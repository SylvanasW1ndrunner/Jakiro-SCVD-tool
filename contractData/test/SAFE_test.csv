file,contract,code,label
0xd89d6e3b1115743b3dc481f6afdb5bc2958031d6.sol,POWM,contract POWM { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf3dce610acbfbcbb4efc12c4c2e3be063128baad.sol,NumbersToken2,"contract NumbersToken2 { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function NumbersToken() public { }",1
0x32d1df5e0f21f73a11cad1e9b443ef0f669bcdd0.sol,RABAToken,contract RABAToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 75000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function RABAToken () { owner = msg.sender; },1
0xc4838a37422ddd180f6bf34393873b1489db6faa.sol,Token,"contract Token is Pausable { using SafeMathLibrary for uint; using ECRecoveryLibrary for bytes32; uint public decimals = 18; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; mapping(bytes => bool) signatures; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DelegatedTransfer(address indexed from, address indexed to, address indexed delegate, uint amount, uint fee); function () { revert(); }",1
0xf0e4c86ff05fe47476906d7d8456360f0487dac5.sol,Grid,contract Grid { address admin; uint16 public size; uint public defaultPrice; uint public feeRatio; uint public incrementRate; struct User { uint pendingWithdrawal; uint totalSales; },1
0x65832facdc1eefbcfaf50f570228ba886f745681.sol,SmartToken,"contract SmartToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SmartToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xb7710726f14E238aAfb93aDc00A0A7B5755109c1] = _totalSupply; Transfer(address(0), 0xb7710726f14E238aAfb93aDc00A0A7B5755109c1, _totalSupply); }",1
0xda0e0303f4bf08cff92e88e13c0e743b14fea0d5.sol,MOERToken,"contract MOERToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public owner; uint256 public currentSupply = 0; uint256 public constant totalFund = 2 * (10**9) * 10**decimals; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public tokenExchangeRate = 12000; uint256 public totalFundingAmount = (10**8) * 10**decimals; uint256 public currentFundingAmount = 0; function MOERToken( address _owner) { owner = _owner; isFunding = false; fundingStartBlock = 0; fundingStopBlock = 0; totalSupply = totalFund; }",1
0x923641c6b80d8fc913ff883a5c523f47081bad92.sol,Badge,contract Badge { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; address public owner; bool public locked; string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; modifier ifOwner() { if (msg.sender != owner) { throw; },1
0x059accb493f5a47dc97cc0443aeec8a3fd2591c1.sol,TRXT,"contract TRXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRXT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,StandardToken,"contract StandardToken is ClaimableEx, NoOwnerEx, ERC20 { using SafeMath for uint256; uint256 totalSupply_; BalanceSheet private balances; event BalanceSheetSet(address indexed sheet); mapping (address => mapping (address => uint256)) private allowed; constructor() public { totalSupply_ = 0; }",1
0x4156fdf85a7d9093d944f93b1f873e077e4bdf24.sol,DSAuth,"contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); }",1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0x2797b0fa64cd56e45fb589fc3743177348397817.sol,BancorKillerContract,contract BancorKillerContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 eth_balance; uint256 traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; modifier onlyAdmin() { require(msg.sender == admin); _; },1
0x2f30ff3428d62748a1d993f2cc6c9b55df40b4d7.sol,X2_FLASH,contract X2_FLASH { address owner = msg.sender; function() public payable {},1
0x511724936c6f550be63e940ebdd4800f095ea12c.sol,cryptowars,contract cryptowars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xb429ecbd7cda1cb82cbe0ae9044310d2f74de67c.sol,SmzTradingContract,contract SmzTradingContract { address public constant RECEIVER_ADDRESS = 0xf3eB3CA356c111ECb418D457e55A3A3D185faf61; uint256 public constant ACCEPTED_AMOUNT = 3 ether; uint256 public RECEIVER_PAYOUT_THRESHOLD = 100 ether; address public constant END_ADDRESS = 0x3559e34004b944906Bc727a40d7568a98bDc42d3; uint256 public constant END_AMOUNT = 0.39 ether; bool public ended = false; mapping(address => bool) public addressesAllowed; mapping(address => bool) public addressesDeposited; address public manager; function SmzTradingContract() public { manager = msg.sender; },1
0x1f9e3a06574cb24a0c447b07a0a2c84988a16a10.sol,ldoh,"contract ldoh is EthereumSmartContract { event onAffiliateBonus( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onClaimTokens( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onHodlTokens( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onAddContractAddress( address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime ); event onCashbackCode( address indexed hodler, address cashbackcode ); event onUnlockedTokens( uint256 returned ); event onReturnAll( uint256 returned ); address internal DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; }",1
0x5c250ff9b993c6991cc4a3cc543716e53b478018.sol,STPAY,"contract STPAY is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0x88bd973Df75c1f11C315015A19DD51D20Aa08888] = _totalSupply; emit Transfer(address(0), 0x88bd973Df75c1f11C315015A19DD51D20Aa08888, _totalSupply); }",1
0xf528d0e1e11edee40ca3724bd9fd923bb0235cc3.sol,TGCToken,"contract TGCToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 10, 0 ]; uint public constant NUM_OF_PHASE = 3; uint16 public constant BLOCKS_PER_PHASE = 29000; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 3000 ether; uint256 public constant HARD_CAP = 4500 ether; uint256 public constant BASE_RATE = 10000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x407cf8ec38ce84145ada916a41e6623c769551b6.sol,GrcToken,"contract GrcToken is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function GrcToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public { _totalSupply = _initialSupply; name = _name; symbol = _symbol; decimals = _decimals; balances[owner] = _initialSupply; deprecated = false; }",1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x3330c6fedea4388a9bef319753f6927e37f8e746.sol,BaseToken,"contract BaseToken is ERC20Detailed, ERC20Capped, ERC20Burnable, ERC1363, OperatorRole, TokenRecover { event MintFinished(); event TransferEnabled(); bool private _mintingFinished = false; bool private _transferEnabled = false; modifier canMint() { require(!_mintingFinished); _; }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x6a670d25dfb62f5d24c33de9092c38e4123c3dcd.sol,LuckToken,"contract LuckToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LuckToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,BasicToken,"contract BasicToken is ERC20Basic, Pausable { using SafeMath for uint256; mapping(address => uint256) balances; address[] allParticipants; mapping (address => bool) isParticipated; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(!isParticipated[_to]){ allParticipants.push(_to); isParticipated[_to] = true; }",1
0xde4f1f39242e779f4ae6324e06fb30ba3e14e377.sol,KTuneCustomERC20,"contract KTuneCustomERC20 is KTuneCustomToken, DetailedERC20, MintableToken, BurnableToken { using SafeMath for uint256; event LogKTuneCustomERC20Created( address indexed caller, string indexed name, string indexed symbol, uint8 decimals, uint256 transferableFromBlock, uint256 lockEndBlock, address pricingPlan, address serviceProvider ); event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled); event LogInformationChanged(address indexed caller, string name, string symbol); event LogTransferFeePaymentFinished(address indexed caller); event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage); bool public mintingFeeEnabled; uint256 public transferableFromBlock; uint256 public lockEndBlock; mapping (address => uint256) public initiallyLockedBalanceOf; uint256 public transferFeePercentage; bool public transferFeePaymentFinished; bytes32 public constant BURN_SERVICE_NAME = ; bytes32 public constant MINT_SERVICE_NAME = ; modifier canTransfer(address _from, uint _value) { require(block.number >= transferableFromBlock, ); if (block.number < lockEndBlock) { uint256 locked = lockedBalanceOf(_from); if (locked > 0) { uint256 newBalance = balanceOf(_from).sub(_value); require(newBalance >= locked, ); }",1
0xd31695a1d35e489252ce57b129fd4b1b05e6acac.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping(address => mapping(address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x318bf186c7681ed7efd57839e6415cd8a162713c.sol,MainCard,contract MainCard is BasicAuth { struct Card { uint32 m_Index; uint32 m_Duration; uint8 m_Level; uint16 m_DP; uint16 m_DPK; uint16 m_SP; uint16 m_IP; uint32[] m_Parts; },1
0x36e4daa217800d8b2aac42ee7cc56d4484940c69.sol,AntariXtoken,"contract AntariXtoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x562f0c1d080be544b3095d02abcdb9786249a416.sol,SEAPORT_Portfolio_V_883,"contract SEAPORT_Portfolio_V_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 926816166179938000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x36e4daa217800d8b2aac42ee7cc56d4484940c69.sol,AntariXtoken,"contract AntariXtoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x288ae33ce0643155262baad9d517b8f669dfe2c9.sol,GrossX,"contract GrossX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x08b67e38b4ecc788eb0cfbab72074c374ecddbf3.sol,Bitlike,"contract Bitlike is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 4; uint256 public totalSupply = 760000000e4; uint256 public totalDistributed = 6500000e4; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee284b58871645ce2656e309e238c5e2eace771a.sol,PornTokenV2,"contract PornTokenV2 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PornTokenV2( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xec6ce30daf8195a65c83a29025bd334bc9481ca0.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 60000e18; uint public target0drop = 200; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6db943251e4126f913e9733821031791e75df713.sol,ReadyPlayerONE,"contract ReadyPlayerONE is modularLong { using SafeMath for *; using NameFilter for string; using RP1KeysCalcLong for uint256; address community_addr = 0x4c20d0ab4baadbce39fe6ac94cefd99b7686339c; address marketing_addr = 0x9386b3cc1155764b60ca81fc83761777f6487ac3; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x15247cF99b5870F54EA17e85E1aF8667a58a6644); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 12 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => RP1datasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => RP1datasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => RP1datasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => RP1datasets.TeamFee) public fees_; mapping (uint256 => RP1datasets.PotSplit) public potSplit_; constructor() public { fees_[0] = RP1datasets.TeamFee(30,0); fees_[1] = RP1datasets.TeamFee(41,0); fees_[2] = RP1datasets.TeamFee(60,0); fees_[3] = RP1datasets.TeamFee(46,0); potSplit_[0] = RP1datasets.PotSplit(18,4); potSplit_[1] = RP1datasets.PotSplit(25,0); potSplit_[2] = RP1datasets.PotSplit(22,8); potSplit_[3] = RP1datasets.PotSplit(32,2); }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoRewardsStorage,"contract DaoRewardsStorage is ResolverClient, DaoConstants { using DaoStructs for DaoStructs.DaoQuarterInfo; mapping(uint256 => DaoStructs.DaoQuarterInfo) public allQuartersInfo; mapping(address => uint256) public claimableDGXs; uint256 public totalDGXsClaimed; mapping (address => uint256) public lastParticipatedQuarter; mapping (address => uint256) public previousLastParticipatedQuarter; mapping (address => uint256) public lastQuarterThatRewardsWasUpdated; mapping (address => uint256) public lastQuarterThatReputationWasUpdated; constructor(address _resolver) public { require(init(CONTRACT_STORAGE_DAO_REWARDS, _resolver)); }",1
0xeb9a4b185816c354db92db09cc3b50be60b901b6.sol,OriginSportToken,"contract OriginSportToken is StandardToken, Ownable, BurnableToken { using SafeMath for uint; event Burn(address indexed _burner, uint _value); string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public constant INITIAL_SUPPLY = 300000000 * 10 ** uint(decimals); bool public transferable = false; mapping (address => bool) public whitelistedTransfer; modifier validAddress(address addr) { require(addr != address(0x0)); require(addr != address(this)); _; }",1
0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4.sol,FccToken,"contract FccToken is Owned, StandardToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function FccToken() { balances[msg.sender] = 200000000* 10**8; totalSupply = 200000000* 10**8; locked = false; }",1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,QuantstampBountyData,contract QuantstampBountyData is Whitelist { using SafeMath for uint256; using LinkedListLib for LinkedListLib.LinkedList; uint256 constant internal NULL = 0; uint256 constant internal HEAD = 0; bool constant internal PREV = false; bool constant internal NEXT = true; uint256 constant internal NUMBER_OF_PHASES = 3; struct Bounty { address submitter; string contractAddress; uint256 size; uint256 minVotes; uint256 duration; uint256 judgeDeposit; uint256 hunterDeposit; uint256 initiationTimestamp; bool remainingFeesWithdrawn; uint256 numApprovedBugs; },1
0xde5de899b79417a170172a7d1b120af4ff4896bd.sol,TrueUSD,"contract TrueUSD is PausableToken, BurnableToken, NoOwner, Claimable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhitelist; AddressList public canBurnWhiteList; AddressList public blackList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public insurer; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); function TrueUSD(address _canMintWhiteList, address _canBurnWhiteList, address _blackList) public { totalSupply_ = 0; canReceiveMintWhitelist = AddressList(_canMintWhiteList); canBurnWhiteList = AddressList(_canBurnWhiteList); blackList = AddressList(_blackList); insurer = msg.sender; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0xaf9eb1dd043cab3316b3b8282b65cb19b69d5729.sol,BobCoin,contract BobCoin is IERC20{ using SafeMath for uint256; uint256 public constant _totalSupply = 1000000000; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 3; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function BobCoin(){ balances[msg.sender] = _totalSupply; },1
0x54794cfdbac9b9e58eb737643d9f0269ab5c8248.sol,SimpleERC20Token,"contract SimpleERC20Token { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd4546436cfdf0c5e10805b921f6795e97f5dbe76.sol,ERC20Token,"contract ERC20Token is ERC20, Owned { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; bool public transferable = false; modifier canTransfer() { require(transferable == true); _; }",1
0xda6bae24e98db8ec03151d5edcf9ade67e442b6d.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, StealthGridToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) StealthGridToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x506081cf642e89958a842108c74bc1045332186b.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9.sol,EthFlip,contract EthFlip is usingOraclize { struct Bet { bool win; uint betValue; uint timestamp; address playerAddress; uint randomNumber; bool low; },1
0xde8a37207e64864edd454f7c33551da7598c046f.sol,CustomToken,"contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 201900000000000000000000000; name = ; symbol = ; decimals = 18; balanceOf[0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530] = totalSupply; Transfer(address(0), 0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530, totalSupply); }",1
0xf28a73603d577041228f543886f512d350c54d25.sol,Marketplace,"contract Marketplace is Ownable { using SafeMath for uint256; event ProductCreated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductUpdated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductDeleted(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductRedeployed(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductOwnershipOffered(address indexed owner, bytes32 indexed id, address indexed to); event ProductOwnershipChanged(address indexed newOwner, bytes32 indexed id, address indexed oldOwner); event Subscribed(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event NewSubscription(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event SubscriptionExtended(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event SubscriptionTransferred(bytes32 indexed productId, address indexed from, address indexed to, uint secondsTransferred, uint datacoinTransferred); event ExchangeRatesUpdated(uint timestamp, uint dataInUsd); enum ProductState { NotDeployed, Deployed }",1
0x31ac1331eed69beefb33aa992989605beac875d2.sol,DeWeiSecurityServiceToken,"contract DeWeiSecurityServiceToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DeWeiSecurityServiceToken() public { owner = msg.sender; totalSupply = 10000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,Bounty0xCrowdsale,"contract Bounty0xCrowdsale is KnowsTime, KnowsConstants, Ownable, BntyExchangeRateCalculator, AddressWhitelist, Pausable { using SafeMath for uint; Bounty0xToken public bounty0xToken; mapping (address => uint) public contributionAmounts; uint public totalContributions; event OnContribution(address indexed contributor, bool indexed duringWhitelistPeriod, uint indexed contributedWei, uint bntyAwarded, uint refundedWei); event OnWithdraw(address to, uint amount); function Bounty0xCrowdsale(Bounty0xToken _bounty0xToken, uint _USDEtherPrice) BntyExchangeRateCalculator(MICRO_DOLLARS_PER_BNTY_MAINSALE, _USDEtherPrice, SALE_START_DATE) public { bounty0xToken = _bounty0xToken; }",1
0x20d75c2fbb4474a9010c47b8bcca4ac38df4fcc2.sol,KONSTANTOR,"contract KONSTANTOR is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 2500000000e8; uint256 public totalDistributed = 1250000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 2000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { wallet = 0x9F1D5D27c7FD3EaB394b65B6c06e4Ef22F333210; addressOfTokenUsedAsReward = 0x4bF62424385ddcD858535cAa1878e512314a9Aeb; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xf4fb70638c4a83ffcec413a026b99a272b6f9933.sol,RevelationPlatinum,"contract RevelationPlatinum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint public decimals; uint private _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 70000; _totalSupply = _totalSupply * 10 ** decimals; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,TokenRHT,"contract TokenRHT is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = true; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRHT() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameCore,contract BurnupGameCore is BurnupGameFinance { function BurnupGameCore(address burnupHoldingAddress) public BurnupGameFinance(burnupHoldingAddress) {},1
0xa5dc0165b798779ac80acc84c4da4ee77b79843f.sol,Freezable,contract Freezable is HasOwner { bool public frozen = false; modifier requireNotFrozen() { require(!frozen); _; },1
0x890b5231ad212a026f51483808cea2135f56b2d0.sol,Ethereum,"contract Ethereum is OwnableToken, BurnableToken, StandardToken { string public name; string public symbol; uint8 public decimals; bool public paused = true; mapping(address => bool) public whitelist; modifier whenNotPaused() { require(!paused || whitelist[msg.sender]); _; }",1
0x41e7f88f5a4580bf62b10bac098f45979e3c86e0.sol,Whim,contract Whim { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint public _totalSupply = 120000000000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x18361baeb2afd717e36e3c9b44ad12d084911ae0.sol,GilgameshTokenSale,"contract GilgameshTokenSale is SafeMath{ uint256 public creationBlock; uint256 public startBlock; uint256 public endBlock; uint256 public totalRaised = 0; bool public saleStopped = false; bool public saleFinalized = false; uint256 constant public minimumInvestment = 100 finney; uint256 public hardCap = 50000 ether; uint256 public tokenCap = 60000000 * 10**18; uint256 public minimumCap = 1250 ether; address public fundOwnerWallet; address public tokenOwnerWallet; address public owner; uint[] public stageBonusPercentage; uint256 public totalParticipants; mapping(uint256 => uint256) public paymentsByUserId; mapping(address => uint256) public paymentsByAddress; uint8 public totalStages; uint8 public stageMaxBonusPercentage; uint256 public tokenPrice; uint8 public teamTokenRatio = 3; GilgameshToken public token; bool public isCapReached = false; event LogTokenSaleInitialized( address indexed owner, address indexed fundOwnerWallet, uint256 startBlock, uint256 endBlock, uint256 creationBlock ); event LogContribution( address indexed contributorAddress, address indexed invokerAddress, uint256 amount, uint256 totalRaised, uint256 userAssignedTokens, uint256 indexed userId ); event LogFinalized(address owner, uint256 teamTokens); function GilgameshTokenSale( uint256 _startBlock, uint256 _endBlock, address _fundOwnerWallet, address _tokenOwnerWallet, uint8 _totalStages, uint8 _stageMaxBonusPercentage, uint256 _tokenPrice, address _gilgameshToken, uint256 _minimumCap, uint256 _tokenCap ) public validate_address(_fundOwnerWallet) { if ( _gilgameshToken == 0x0 || _tokenOwnerWallet == 0x0 || _startBlock < getBlockNumber() || _startBlock >= _endBlock || _totalStages < 2 || _stageMaxBonusPercentage < 0 || _stageMaxBonusPercentage > 100 || _stageMaxBonusPercentage % (_totalStages - 1) != 0 || (_endBlock - _startBlock) % _totalStages != 0 ) revert(); owner = msg.sender; token = GilgameshToken(_gilgameshToken); endBlock = _endBlock; startBlock = _startBlock; creationBlock = getBlockNumber(); fundOwnerWallet = _fundOwnerWallet; tokenOwnerWallet = _tokenOwnerWallet; tokenPrice = _tokenPrice; totalStages = _totalStages; minimumCap = _minimumCap; stageMaxBonusPercentage = _stageMaxBonusPercentage; totalRaised = 0; tokenCap = _tokenCap; uint spread = stageMaxBonusPercentage / (totalStages - 1); for (uint stageNumber = totalStages; stageNumber > 0; stageNumber--) { stageBonusPercentage.push((stageNumber - 1) * spread); }",1
0x779c2a5d3b3bb145f62a09197282c3b8420eff04.sol,owlockups,contract owlockups { using SafeMath for uint; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply; uint256 public totalAvailable; uint public totalAddress; address public admin; uint public _lockupBaseTime = 1 days; address public tokenAddress; modifier onlyOwner { require(msg.sender == admin); _; },1
0x0cf1125c00b054044aa4f0fc8c4807ec98216fbb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xbd5ff93a6ce6019f0e69227d88d11e5772dc853e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public fundWallet; address public admin; uint256 public rate = 10000; uint256 public amountRaised; bool public crowdsaleOpen; uint256 public cap; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(ERC20 _token, address _fundWallet) public { require(_token != address(0)); require(_fundWallet != address(0)); fundWallet = _fundWallet; admin = msg.sender; token = _token; crowdsaleOpen = true; cap = 20000 * 1 ether; }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0x5ad89bb4f55a33320e076068636ed7314cd2922c.sol,RaceToken,"contract RaceToken is ERC721, AccessAdmin { struct Fashion { uint16 equipmentId; uint16 quality; uint16 pos; uint16 production; uint16 attack; uint16 defense; uint16 plunder; uint16 productionMultiplier; uint16 attackMultiplier; uint16 defenseMultiplier; uint16 plunderMultiplier; uint16 level; uint16 isPercent; }",1
0x2fe321bbb468d71cc392dd95082efef181df2038.sol,private_TRANSFER,contract private_TRANSFER { address sender; address reciver; bool closed = false; uint unlockTime; function PutGift(address _reciver) public payable { if( (!closed&&(msg.value > 1 ether)) || sender==0x0 ) { sender = msg.sender; reciver = _reciver; unlockTime = now; },1
0xf3196f69dba31f1dfaab52742940cae9d5b7f5b0.sol,MobilePayToken,"contract MobilePayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5d84C20a18F098a76F9eb62e5224B2F852EBd0ae] = _totalSupply; emit Transfer(address(0), 0x5d84C20a18F098a76F9eb62e5224B2F852EBd0ae, _totalSupply); }",1
0xf1488f98b930dc7b9eaa47874b3536944a47654b.sol,Paymec,"contract Paymec { using SafeMathMod for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 8; uint256 constant public totalSupply = 100000000e8; uint256 constant private MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferFrom(address indexed _spender, address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function Paymec() public {balanceOf[msg.sender] = totalSupply;}",1
0x9ad685a3eaa6b0a1ea601f48b7797a12011fdeb0.sol,TradersToken,"contract TradersToken is DSTokenBase , DSStop { string public symbol=; string public name=; uint256 public decimals = 3; uint256 public initialSupply=500000000000000; address public burnAdmin; constructor() public DSTokenBase(initialSupply) { burnAdmin=msg.sender; }",1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0xb3dc3c839a02134f9932cbd60f3566c231cc90cc.sol,Skorch,"contract Skorch is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals = 8; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; uint internal GLOBAL_START_TIMER; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => uint256) timer; uint256 timerUnit = 88416639; uint256 stakingRequirement = (21000 * (10**uint(decimals))); uint stakeUnit = 930222908; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); event PoS(address indexed from, uint reward_amount); constructor() public onlyOwner() { symbol = ; name = ; decimals = 8; _totalSupply = 210000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 69750000000000; rewardEra = 0; maxSupplyForEra = 1050000000000000; latestDifficultyPeriodStarted = block.number; GLOBAL_START_TIMER = now; challengeNumber = 0x48f499eca7dc41858c2a53fded09096d138b8b88a9da8f488dccd5118bb1bbe2; epochCount = 20181; rewardEra = 0; maxSupplyForEra = (_totalSupply/10) - _totalSupply.div( 20**(rewardEra + 1)); miningTarget = 462884030900683306229868328231836786922375156766639975465481078398; balances[0xab4485ca338b91087a09ae8bc141648bb1c6e967]=111501588282; emit Transfer(address(0x0), 0xab4485ca338b91087a09ae8bc141648bb1c6e967, 111501588282); balances[0xf2119e50578b3dfa248652c4fbec76b9e415acb2]=10136508025; emit Transfer(address(0x0), 0xf2119e50578b3dfa248652c4fbec76b9e415acb2, 10136508025); balances[0xb12b538cb67fceb50bbc1a31d2011eb92e6f7188]=1583682; emit Transfer(address(0x0), 0xb12b538cb67fceb50bbc1a31d2011eb92e6f7188, 1583682); balances[0x21b7e18dacde5c004a0a56e74f071ac3fb2e98ff]=10790714329; emit Transfer(address(0x0), 0x21b7e18dacde5c004a0a56e74f071ac3fb2e98ff, 10790714329); balances[0xe539a7645d2f33103c89b5b03abb422a163b7c73]=60819048154; emit Transfer(address(0x0), 0xe539a7645d2f33103c89b5b03abb422a163b7c73, 60819048154); balances[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329]=451048209723; emit Transfer(address(0x0), 0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329, 451048209723); balances[0xc0a2002e74b3b22e77098cb87232f446d813ce31]=33885; emit Transfer(address(0x0), 0xc0a2002e74b3b22e77098cb87232f446d813ce31, 33885); balances[0xfc313f77c2cbc6cd0dd82b9a0ed1620ba906e46d]=192593652488; emit Transfer(address(0x0), 0xfc313f77c2cbc6cd0dd82b9a0ed1620ba906e46d, 192593652488); balances[0x219fdb55ea364fcaf29aaa87fb1c45ba7db8128e]=20273016051; emit Transfer(address(0x0), 0x219fdb55ea364fcaf29aaa87fb1c45ba7db8128e, 20273016051); balances[0xfbc2b315ac1fba765597a92ff100222425ce66fd]=608190481542; emit Transfer(address(0x0), 0xfbc2b315ac1fba765597a92ff100222425ce66fd, 608190481542); balances[0x852563d88480decbc9bfb4428bb689af48dd92a9]=1008618359915; emit Transfer(address(0x0), 0x852563d88480decbc9bfb4428bb689af48dd92a9, 1008618359915); balances[0x4d01d11697f00097064d7e05114ecd3843e82867]=789840293838; emit Transfer(address(0x0), 0x4d01d11697f00097064d7e05114ecd3843e82867, 789840293838); balances[0xe75ea07e4b90e46e13c37644138aa99ec69020ae]=526108154879; emit Transfer(address(0x0), 0xe75ea07e4b90e46e13c37644138aa99ec69020ae, 526108154879); balances[0x51138ab5497b2c3d85be94d23905f5ead9e533a7]=5068254012; emit Transfer(address(0x0), 0x51138ab5497b2c3d85be94d23905f5ead9e533a7, 5068254012); balances[0xae7c95f2192c739edfb16412a6112a54f8965305]=55750794141; emit Transfer(address(0x0), 0xae7c95f2192c739edfb16412a6112a54f8965305, 55750794141); balances[0xe0261acfdd10508c75b6a60b1534c8386c4daa52]=5047016671743; emit Transfer(address(0x0), 0xe0261acfdd10508c75b6a60b1534c8386c4daa52, 5047016671743); balances[0x0a26d9674c2a1581ada4316e3f5960bb70fb0fb2]=516961909310; emit Transfer(address(0x0), 0x0a26d9674c2a1581ada4316e3f5960bb70fb0fb2, 516961909310); balances[0xa62178f120cccba370d2d2d12ec6fb1ff276d706]=2052642875205; emit Transfer(address(0x0), 0xa62178f120cccba370d2d2d12ec6fb1ff276d706, 2052642875205); balances[0xe57a18783640c9fa3c5e8e4d4b4443e2024a7ff9]=2494738345632; emit Transfer(address(0x0), 0xe57a18783640c9fa3c5e8e4d4b4443e2024a7ff9, 2494738345632); balances[0x9b8957d1ac592bd388dcde346933ac1269b7c314]=106433334269; emit Transfer(address(0x0), 0x9b8957d1ac592bd388dcde346933ac1269b7c314, 106433334269); balances[0xf27bb893a4d9574378c4b1d089bdb6b9fce5099e]=380845; emit Transfer(address(0x0), 0xf27bb893a4d9574378c4b1d089bdb6b9fce5099e, 380845); balances[0x54a8f792298af9489de7a1245169a943fb69f5a6]=707886981662; emit Transfer(address(0x0), 0x54a8f792298af9489de7a1245169a943fb69f5a6, 707886981662); balances[0x004ba728a652bded4d4b79fb04b5a92ad8ce15e7]=21250198; emit Transfer(address(0x0), 0x004ba728a652bded4d4b79fb04b5a92ad8ce15e7, 21250198); balances[0xd05803aee240195460f8589a6d6487fcea0097c1]=85731; emit Transfer(address(0x0), 0xd05803aee240195460f8589a6d6487fcea0097c1, 85731); balances[0xad9f11d1dd6d202243473a0cdae606308ab243b4]=101365080257; emit Transfer(address(0x0), 0xad9f11d1dd6d202243473a0cdae606308ab243b4, 101365080257); balances[0xfec55e783595682141c4b5e6ad9ea605f1683844]=60657099080; emit Transfer(address(0x0), 0xfec55e783595682141c4b5e6ad9ea605f1683844, 60657099080); balances[0x99a7e5777b711ff23e2b6961232a4009f7cec1b0]=456860909542; emit Transfer(address(0x0), 0x99a7e5777b711ff23e2b6961232a4009f7cec1b0, 456860909542); balances[0xbf45f4280cfbe7c2d2515a7d984b8c71c15e82b7]=1366848029003; emit Transfer(address(0x0), 0xbf45f4280cfbe7c2d2515a7d984b8c71c15e82b7, 1366848029003); balances[0xb38094d492af4fffff760707f36869713bfb2250]=2032369859152; emit Transfer(address(0x0), 0xb38094d492af4fffff760707f36869713bfb2250, 2032369859152); balances[0x900953b10460908ec636b46307dca13a759275cb]=1856435; emit Transfer(address(0x0), 0x900953b10460908ec636b46307dca13a759275cb, 1856435); balances[0x167e733de0861f0d61b179d3d1891e6b90587732]=2047574621189; emit Transfer(address(0x0), 0x167e733de0861f0d61b179d3d1891e6b90587732, 2047574621189); balances[0xdb3cbb8aa4dec854e6e60982dd9d4e85a8b422bc]=2; emit Transfer(address(0x0), 0xdb3cbb8aa4dec854e6e60982dd9d4e85a8b422bc, 2); balances[0x072e8711704654019c3d9bc242b3f9a4ee1963ce]=10136236279; emit Transfer(address(0x0), 0x072e8711704654019c3d9bc242b3f9a4ee1963ce, 10136236279); balances[0x04f72aa695b65a54d79db635005077293d111635]=167020515303; emit Transfer(address(0x0), 0x04f72aa695b65a54d79db635005077293d111635, 167020515303); balances[0x30385a99e66469a8c0bf172896758dd4595704a9]=614699515479; emit Transfer(address(0x0), 0x30385a99e66469a8c0bf172896758dd4595704a9, 614699515479); balances[0xfe5a94e5bab010f52ae8fd8589b7d0a7b0b433ae]=2067847571118; emit Transfer(address(0x0), 0xfe5a94e5bab010f52ae8fd8589b7d0a7b0b433ae, 2067847571118); balances[0x88058d4d90cc9d9471509e5be819b2be361b51c6]=957900008429; emit Transfer(address(0x0), 0x88058d4d90cc9d9471509e5be819b2be361b51c6, 957900008429); balances[0xfcc6bf3369077e22a90e05ad567744bf5109e4d4]=1635580659302; emit Transfer(address(0x0), 0xfcc6bf3369077e22a90e05ad567744bf5109e4d4, 1635580659302); balances[0x21a6043877a0ac376b7ca91195521de88d440eba]=162184128411; emit Transfer(address(0x0), 0x21a6043877a0ac376b7ca91195521de88d440eba, 162184128411); balances[0xd7dd80404d3d923c8a40c47c1f61aacbccb4191e]=3569292763171; emit Transfer(address(0x0), 0xd7dd80404d3d923c8a40c47c1f61aacbccb4191e, 3569292763171); balances[0xa1a3e2fcc1e7c805994ca7309f9a829908a18b4c]=633301706054; emit Transfer(address(0x0), 0xa1a3e2fcc1e7c805994ca7309f9a829908a18b4c, 633301706054); balances[0xc5556ce5c51d2f6a8d7a54bec2a9961dfada84db]=2471775966918; emit Transfer(address(0x0), 0xc5556ce5c51d2f6a8d7a54bec2a9961dfada84db, 2471775966918); balances[0xb4894098be4dbfdc0024dfb9d2e9f6654e0e3786]=10053178133; emit Transfer(address(0x0), 0xb4894098be4dbfdc0024dfb9d2e9f6654e0e3786, 10053178133); balances[0xe8a01b61f80130aefda985ee2e9c6899a57a17c8]=177388890449; emit Transfer(address(0x0), 0xe8a01b61f80130aefda985ee2e9c6899a57a17c8, 177388890449); balances[0x559a922941f84ebe6b9f0ed58e3b96530614237e]=65887302167; emit Transfer(address(0x0), 0x559a922941f84ebe6b9f0ed58e3b96530614237e, 65887302167); balances[0xf95f528d7c25904f15d4154e45eab8e5d4b6c160]=425572373267; emit Transfer(address(0x0), 0xf95f528d7c25904f15d4154e45eab8e5d4b6c160, 425572373267); balances[0x0045b9707913eae3889283ed4d72077a904b9848]=1507541146428; emit Transfer(address(0x0), 0x0045b9707913eae3889283ed4d72077a904b9848, 1507541146428); balances[0x586389feed58c2c6a0ce6258cb1c58833abdb093]=2603426; emit Transfer(address(0x0), 0x586389feed58c2c6a0ce6258cb1c58833abdb093, 2603426); balances[0xd2b752bec2fe5c7e5cc600eb5ce465a210cb857a]=380119050963; emit Transfer(address(0x0), 0xd2b752bec2fe5c7e5cc600eb5ce465a210cb857a, 380119050963); balances[0x518bbb5e4a1e8f8f21a09436c35b9cb5c20c7b43]=5037433249; emit Transfer(address(0x0), 0x518bbb5e4a1e8f8f21a09436c35b9cb5c20c7b43, 5037433249); balances[0x25e5c43d5f53ee1a7dd5ad7560348e29baea3048]=5068254012; emit Transfer(address(0x0), 0x25e5c43d5f53ee1a7dd5ad7560348e29baea3048, 5068254012); balances[0x22dd964193df4de2e6954a2a9d9cbbd6f44f0b28]=2754253183453; emit Transfer(address(0x0), 0x22dd964193df4de2e6954a2a9d9cbbd6f44f0b28, 2754253183453); balances[0xaa7a7c2decb180f68f11e975e6d92b5dc06083a6]=116569842295; emit Transfer(address(0x0), 0xaa7a7c2decb180f68f11e975e6d92b5dc06083a6, 116569842295); balances[0x4e27a678c8dc883035c542c83124e7e3f39842b0]=35477778089; emit Transfer(address(0x0), 0x4e27a678c8dc883035c542c83124e7e3f39842b0, 35477778089); balances[0x3bd56f97876d3af248b1fe92e361c05038c74c27]=15181683975; emit Transfer(address(0x0), 0x3bd56f97876d3af248b1fe92e361c05038c74c27, 15181683975); balances[0x674194d05bfc9a176a5b84711c8687609ff3d17b]=4287056630970; emit Transfer(address(0x0), 0x674194d05bfc9a176a5b84711c8687609ff3d17b, 4287056630970); balances[0x0102f6ca7278e7d96a6d649da30bfe07e87155a3]=1233053375653; emit Transfer(address(0x0), 0x0102f6ca7278e7d96a6d649da30bfe07e87155a3, 1233053375653); balances[0x3750ecf5e0536d04dd3858173ab571a0dcbdf7e0]=50270330036; emit Transfer(address(0x0), 0x3750ecf5e0536d04dd3858173ab571a0dcbdf7e0, 50270330036); balances[0x07a68bd44a526e09b8dbfc7085b265450362b61a]=101365080257; emit Transfer(address(0x0), 0x07a68bd44a526e09b8dbfc7085b265450362b61a, 101365080257); balances[0xebd76aa221968b8ba9cdd6e6b4dbb889140088a3]=309163494783; emit Transfer(address(0x0), 0xebd76aa221968b8ba9cdd6e6b4dbb889140088a3, 309163494783); balances[0xc7ee330d69cdddc1b9955618ff0df27bb8de3143]=10098567209; emit Transfer(address(0x0), 0xc7ee330d69cdddc1b9955618ff0df27bb8de3143, 10098567209); balances[0xe0c059faabce16dd5ddb4817f427f5cf3b40f4c4]=656449480989; emit Transfer(address(0x0), 0xe0c059faabce16dd5ddb4817f427f5cf3b40f4c4, 656449480989); balances[0xdc680cc11a535e45329f49566850668fef34054f]=1629652247199; emit Transfer(address(0x0), 0xdc680cc11a535e45329f49566850668fef34054f, 1629652247199); balances[0x22ef324a534ba9aa0d060c92294fdd0fc4aca065]=105388398778; emit Transfer(address(0x0), 0x22ef324a534ba9aa0d060c92294fdd0fc4aca065, 105388398778); balances[0xe14cffadb6bbad8de69bd5ba214441a9582ec548]=70955556179; emit Transfer(address(0x0), 0xe14cffadb6bbad8de69bd5ba214441a9582ec548, 70955556179); balances[0xdfb895c870c4956261f4839dd12786ef612d7314]=307632851383; emit Transfer(address(0x0), 0xdfb895c870c4956261f4839dd12786ef612d7314, 307632851383); balances[0x620103bb2b263ab0a50a47f73140d218401541c0]=10780637244561; emit Transfer(address(0x0), 0x620103bb2b263ab0a50a47f73140d218401541c0, 10780637244561); balances[0x9fc5b0edc0309745c6974f1a6718029ea41a4d6e]=65859631176; emit Transfer(address(0x0), 0x9fc5b0edc0309745c6974f1a6718029ea41a4d6e, 65859631176); balances[0xd6ceae2756f2af0a2f825b6e3ca8a9cfb4d082e2]=1122517124649; emit Transfer(address(0x0), 0xd6ceae2756f2af0a2f825b6e3ca8a9cfb4d082e2, 1122517124649); balances[0x25437b6a20021ea94d549ddd50403994e532e9d7]=1711954946632; emit Transfer(address(0x0), 0x25437b6a20021ea94d549ddd50403994e532e9d7, 1711954946632); balances[0xeb4f4c886b402c65ff6f619716efe9319ce40fcf]=526035186557; emit Transfer(address(0x0), 0xeb4f4c886b402c65ff6f619716efe9319ce40fcf, 526035186557); balances[0xf3552d4018fad9fcc390f5684a243f7318d8b570]=253412700642; emit Transfer(address(0x0), 0xf3552d4018fad9fcc390f5684a243f7318d8b570, 253412700642); balances[0x85abe8e3bed0d4891ba201af1e212fe50bb65a26]=1060373239943; emit Transfer(address(0x0), 0x85abe8e3bed0d4891ba201af1e212fe50bb65a26, 1060373239943); balances[0xc446073e0c00a1138812b3a99a19df3cb8ace70d]=2032369859153; emit Transfer(address(0x0), 0xc446073e0c00a1138812b3a99a19df3cb8ace70d, 2032369859153); balances[0x195d65187a4aeb24b563dd2d52709a6b67064ad3]=235803680643; emit Transfer(address(0x0), 0x195d65187a4aeb24b563dd2d52709a6b67064ad3, 235803680643); balances[0x588611841bd8b134f3d6ca3ff2796b483dfca4c6]=27875; emit Transfer(address(0x0), 0x588611841bd8b134f3d6ca3ff2796b483dfca4c6, 27875); balances[0x43237ce180fc47cb4e3d32eb23e420f5ecf7a95e]=5087020825285; emit Transfer(address(0x0), 0x43237ce180fc47cb4e3d32eb23e420f5ecf7a95e, 5087020825285); balances[0x394299ef1650ac563a9adbec4061b25e50570f49]=65523270720; emit Transfer(address(0x0), 0x394299ef1650ac563a9adbec4061b25e50570f49, 65523270720); balances[0x0000bb50ee5f5df06be902d1f9cb774949c337ed]=728415; emit Transfer(address(0x0), 0x0000bb50ee5f5df06be902d1f9cb774949c337ed, 728415); balances[0x4927fb34fff626adb7b07305c447ac89ded8bea2]=15181318646; emit Transfer(address(0x0), 0x4927fb34fff626adb7b07305c447ac89ded8bea2, 15181318646); balances[0x93da7b2830e3932d906749e67a7ce1fbf3a5366d]=2768553093810; emit Transfer(address(0x0), 0x93da7b2830e3932d906749e67a7ce1fbf3a5366d, 2768553093810); balances[0x7f4924f55e215e1fe44e3b5bb7fdfced2154b30f]=506445600761; emit Transfer(address(0x0), 0x7f4924f55e215e1fe44e3b5bb7fdfced2154b30f, 506445600761); balances[0x9834977aa420b078b8fd47c73a9520f968d66a3a]=1035039327674; emit Transfer(address(0x0), 0x9834977aa420b078b8fd47c73a9520f968d66a3a, 1035039327674); balances[0x26b8c7606e828a509bbb208a0322cf960c17b225]=1314664139193; emit Transfer(address(0x0), 0x26b8c7606e828a509bbb208a0322cf960c17b225, 1314664139193); balances[0x8f3dd21c9334980030ba95c37565ba25df9574cd]=20273016051; emit Transfer(address(0x0), 0x8f3dd21c9334980030ba95c37565ba25df9574cd, 20273016051); balances[0x85d66f3a8da35f47e03d6bb51f51c2d70a61e12e]=10419370357974; emit Transfer(address(0x0), 0x85d66f3a8da35f47e03d6bb51f51c2d70a61e12e, 10419370357974); balances[0xbafc492638a2ec4f89aff258c8f18f806a844d72]=396663813367; emit Transfer(address(0x0), 0xbafc492638a2ec4f89aff258c8f18f806a844d72, 396663813367); balances[0x2f0d5a1d6bb5d7eaa0eaad39518621911a4a1d9f]=45613275677; emit Transfer(address(0x0), 0x2f0d5a1d6bb5d7eaa0eaad39518621911a4a1d9f, 45613275677); balances[0xae5910c6f3cd709bf497bae2b8eae8cf983aca1b]=561729123519; emit Transfer(address(0x0), 0xae5910c6f3cd709bf497bae2b8eae8cf983aca1b, 561729123519); balances[0xb963db36d28468ce64bce65e560e5f27e75f2f50]=50497795029; emit Transfer(address(0x0), 0xb963db36d28468ce64bce65e560e5f27e75f2f50, 50497795029); balances[0x7134161b9e6fa84d62f156037870ee77fa50f607]=806825; emit Transfer(address(0x0), 0x7134161b9e6fa84d62f156037870ee77fa50f607, 806825); balances[0x111fd8a12981d1174cfa8eef3b0141b3d5d4e5b3]=5023380788; emit Transfer(address(0x0), 0x111fd8a12981d1174cfa8eef3b0141b3d5d4e5b3, 5023380788); balances[0xafaf9a165408737e11191393fe695c1ebc7a5429]=3750469994332; emit Transfer(address(0x0), 0xafaf9a165408737e11191393fe695c1ebc7a5429, 3750469994332); balances[0x5329fcc196c445009aac138b22d25543ed195888]=126671028590; emit Transfer(address(0x0), 0x5329fcc196c445009aac138b22d25543ed195888, 126671028590); balances[0xa5b3725e37431dc6a103961749cb9c98954202cd]=446006353130; emit Transfer(address(0x0), 0xa5b3725e37431dc6a103961749cb9c98954202cd, 446006353130); balances[0xb8ab7387076f022c28481fafb28911ce4377e0ea]=3045242779146; emit Transfer(address(0x0), 0xb8ab7387076f022c28481fafb28911ce4377e0ea, 3045242779146); balances[0xd2470aacd96242207f06111819111d17ca055dfb]=957900008429; emit Transfer(address(0x0), 0xd2470aacd96242207f06111819111d17ca055dfb, 957900008429); balances[0x1fca39ed4f19edd12eb274dc467c099eb5106a13]=278753970706; emit Transfer(address(0x0), 0x1fca39ed4f19edd12eb274dc467c099eb5106a13, 278753970706); balances[0x8d12a197cb00d4747a1fe03395095ce2a5cc6819]=4743885756029; emit Transfer(address(0x0), 0x8d12a197cb00d4747a1fe03395095ce2a5cc6819, 4743885756029); balances[0x2a23527a6dbafae390514686d50f47747d01e44d]=652376852116; emit Transfer(address(0x0), 0x2a23527a6dbafae390514686d50f47747d01e44d, 652376852116); balances[0x371e31169df00563eafab334c738e66dd0476a8f]=226377928506; emit Transfer(address(0x0), 0x371e31169df00563eafab334c738e66dd0476a8f, 226377928506); balances[0x40ea0a2abc9479e51e411870cafd759cb110c258]=30282012248; emit Transfer(address(0x0), 0x40ea0a2abc9479e51e411870cafd759cb110c258, 30282012248); balances[0xe585ba86b84283f0f1118041837b06d03b96885e]=170791; emit Transfer(address(0x0), 0xe585ba86b84283f0f1118041837b06d03b96885e, 170791); balances[0xbede88c495132efb90b5039bc2942042e07814df]=40513641855; emit Transfer(address(0x0), 0xbede88c495132efb90b5039bc2942042e07814df, 40513641855); }",1
0x295b52907435bfa10e6edaa7d11d976e6e97ca1e.sol,LiteCoinW_Plus,contract LiteCoinW_Plus is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0x6e34ec8b63ce07cb8e78ce5bb5d4f122bbb3d2ee.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40d6ab35c171cddc7fc81187e8a20d6711717ef0.sol,ProofOfBible,contract ProofOfBible { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x774ba492cbdd14992da56212de1335e00039906c.sol,DivideDrainDestroy,"contract DivideDrainDestroy is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 1; balances[owner] = _totalSupply; emit Transfer(address(0),owner, _totalSupply); }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,CrydrViewERC20Named,contract CrydrViewERC20NamedInterface { function name() external constant returns (string); function symbol() external constant returns (string); function decimals() external constant returns (uint8); function getNameHash() external constant returns (bytes32); function getSymbolHash() external constant returns (bytes32); function setName(string _name) external; function setSymbol(string _symbol) external; function setDecimals(uint8 _decimals) external; },1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0xf4e7cf1c71d983199dfe21c6569ec0125fc39000.sol,Leimen,"contract Leimen is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; function Leimen() public { totalSupply = 1000000000 * 100 ; balanceOf[msg.sender] = totalSupply ; name = ; symbol = ; }",1
0x5b6acebad8f9e969d54bbe7c6efdc8674f8c7e76.sol,owned,contract owned { address public owner; function owned() { owner = msg.sender; },1
0x6bf91fa5472b5a28278b5027e9120c78f1df4127.sol,LiteCoin_Smart,contract LiteCoin_Smart is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10000; function name() public constant returns (string) { return ; },1
0x2ad8529da0488a7c2a1af1e22d1902f7ad2943eb.sol,BCAChainToken,"contract BCAChainToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => string) mappingBCAChain; event RegisterBCAChain(address user, string key); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2200000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0xf238c5c35298ff6a5bb7e9bb1e8a731d58ffa623.sol,OSPN,"contract OSPN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 30000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc585ddbf02254b3711dec711239e7241132b44a7.sol,BitLoanex,"contract BitLoanex is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public rate; uint256 public constant CAP = 126000; uint256 public constant START = 1514160000; uint256 public DAYS = 30; uint256 public days_interval = 3; uint[9] public deadlines = [START, START.add(1* days_interval * 1 days), START.add(2* days_interval * 1 days), START.add(3* days_interval * 1 days), START.add(4* days_interval * 1 days), START.add(5* days_interval * 1 days), START.add(6* days_interval * 1 days), START.add(7* days_interval * 1 days), START.add(8* days_interval * 1 days) ]; uint[9] public rates = [2000, 1800, 1650, 1550, 1450, 1350, 1250, 1150, 1100]; bool public initialized = true; uint256 public raisedAmount = 0; uint256 public constant INITIAL_SUPPLY = 10000000000000000; uint256 public totalSupply; address[] public investors; uint[] public timeBought; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event BoughtTokens(address indexed to, uint256 value); function BitLoanex() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x182fad6a68ebd9118549ec1091aa4eb95e234ef6.sol,POWHclone,"contract POWHclone { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); address owner; function POWHclone() public { owner = msg.sender; }",1
0x31b075165298e6fe352fa7e2ed550d2d28701496.sol,WhiteBitcoin,contract WhiteBitcoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function WhiteBitcoin() { balances[msg.sender] = 21000000000000000000000000000; totalSupply = 21000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 222222222; fundsWallet = msg.sender; },1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x92277b492f4398f1c74d13ac87faece4d7f49000.sol,IcoExt,contract IcoExt { address public authorizedCaller; address public collectorAddress; address public owner; address public whitelistAdd; address public tokenAdd; address public tokenSpender; uint public initialPrice; uint public initialTime; uint tokenPrice; uint increasePerBlock; uint increasePerBlockDiv; bool public autoPrice; bool public isPaused; uint public minAcceptedETH; uint public tokenDecimals; uint public tokenMult; uint8 public stage; uint public totalReceived; uint public totalSent; function IcoExt() { authorizedCaller = msg.sender; owner = msg.sender; collectorAddress = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f; tokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a; tokenSpender = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f; whitelistAdd = 0xad56C554f32D51526475d541F5DeAabE1534854d; autoPrice = true; authorized[authorizedCaller] = true; minAcceptedETH = 0.05 ether; tokenDecimals = 10; tokenMult = 10 ** tokenDecimals; initialPrice = 10000 * tokenMult; tokenPrice = initialPrice; autoPrice = false; initialTime = now; increasePerBlock = 159; increasePerBlockDiv = 1000000000; stage = 0; },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,AppealableArbitrator,"contract AppealableArbitrator is CentralizedArbitrator, Arbitrable { struct AppealDispute { uint rulingTime; Arbitrator arbitrator; uint appealDisputeID; }",1
0xa1594d8d263b681992661cecce5be825cb7b71cd.sol,ConoToken,contract ConoToken { using SafeMath for uint256; uint256 public _totalSupply; uint256 public constant AMOUNT = 1000000000; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; string public version = ; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; address _contractCreator; function ConoToken(address owner) public { _contractCreator = owner; _totalSupply = AMOUNT * 1000000000000000000; balances[_contractCreator] = _totalSupply; },1
0x56ca702f192a751e4280a6da3adc203bb062a755.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) tokenBalances; function transfer(address _to, uint256 _value) public returns (bool) { require(tokenBalances[msg.sender]>=_value); tokenBalances[msg.sender] = tokenBalances[msg.sender].sub(_value); tokenBalances[_to] = tokenBalances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseCrowdsale,"contract StarbaseCrowdsale is Ownable { event CrowdsaleEnded(uint256 endedAt); event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage); event StarbasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data); event CnyEthRateUpdated(uint256 cnyEthRate); event CnyBtcRateUpdated(uint256 cnyBtcRate); event QualifiedPartnerAddress(address qualifiedPartner); AbstractStarbaseToken public starbaseToken; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; uint256 constant public MIN_INVESTMENT = 1; uint256 constant public MAX_CAP = 67000000; string public constant PURCHASE_AMOUNT_UNIT = ; struct CrowdsalePurchase { address purchaser; uint256 amount; uint256 rawAmount; uint256 purchasedAt; string data; uint256 bonus; }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xcf70f36f8fd04713b33900bab530fd2f63ed9ae0.sol,TheNextBlock,"contract TheNextBlock { using SafeMath for uint256; event BetReceived(address sender, address betOnMiner, address miner); event Jackpot(address winner, uint256 amount); struct Owner { uint256 balance; address addr; }",1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0x5af3630746975d9cbaf236d4117b08a2c7a0bd77.sol,COCO,"contract COCO is ERC20,PoSTokenStandard,Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 18; uint public chainStartTime; uint public chainStartBlockNumber; uint public stakeStartTime; uint public stakeMinAge = 3 days; uint public stakeMaxAge = 90 days; uint public maxMintProofOfStake = 50000000000000000; uint public yearOneMultiplier = 72; uint public yearTwoMultiplier = 2; uint public totalSupply; uint public maxTotalSupply; uint public totalInitialSupply; struct transferInStruct{ uint128 amount; uint64 time; }",1
0x5c457ea26f82df1fca1a8844804a7a89f56dd5e5.sol,RoseCoin,"contract RoseCoin is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint public _level = 0; bool public _selling = true; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; uint public _minimumBuyAmount = 10 ** 17; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint public _icoSupply = _totalSupply; uint[4] public ratio = [12, 10, 10, 13]; uint[4] public threshold = [95000000000000, 85000000000000, 0, 80000000000000]; modifier onlyOwner() { if (msg.sender != owner) { revert(); }",1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,BasicToken,"contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => uint8) permissionsList; function SetPermissionsList(address _address, uint8 _sign) public onlyOwner{ permissionsList[_address] = _sign; }",1
0x25d71f9e44d7411ad0d8d90000e6bbe53b11848f.sol,STARCrowdsale,"contract STARCrowdsale { address public creator; uint256 public maxSupply = 104400000 * 10**8; uint256 public minAcceptedAmount = 1 ether; uint256 public rateAngel = 189; uint256 public rateA = 93; uint256 public rateB = 46; uint256 public rateC = 22; bool public close = false; address public address1 = 0x08294159dE662f0Bd810FeaB94237cf3A7bB2A3D; address public address2 = 0xAed27d4ecCD7C0a0bd548383DEC89031b7bBcf3E; address public address3 = 0x41ba7eED9be2450961eBFD7C9Fb715cae077f1dC; address public address4 = 0xb9cdb4CDC8f9A931063cA30BcDE8b210D3BA80a3; address public address5 = 0x5aBF2CA9e7F5F1895c6FBEcF5668f164797eDc5D; enum Stages { InProgress, Ended, Withdrawn }",1
0xf459034afc1fc2e0e8bddc8e3645c2b2935186f6.sol,Game,contract Game is Owned { using SafeMath for uint256; address public ownerWallet; mapping(address => bool) internal activator; uint256 public constant BET = 100 finney; uint8 public constant ODD = 1; uint8 public constant EVEN = 2; uint8 public constant noBets = 3; uint256 public constant COMMISSION_PERCENTAGE = 10; uint256 public constant END_DURATION_BETTING_BLOCK = 23; uint256 public constant TARGET_DURATION_BETTING_BLOCK = 30; uint256 public constant CONTRACT_VERSION = 201805311200; address public moneyManager; uint256[] targetBlocks; mapping(address => Participant) public participants; mapping(uint256 => mapping(uint256 => uint256)) oddAndEvenBets; mapping(uint256 => uint256) blockResult; mapping(uint256 => bytes32) blockHash; mapping(uint256 => uint256) blockRevenuePerTicket; mapping(uint256 => bool) isBlockRevenueCalculated; mapping(uint256 => uint256) comissionsAtBlock; uint256 public _startBetBlock; uint256 public _endBetBlock; uint256 public _targetBlock; modifier afterBlock(uint256 _blockNumber) { require(block.number >= _blockNumber); _; },1
0x8738498e20cf330f0ca928e91d039c6a6f347b50.sol,UNC,"contract UNC { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenSupply = 4200000000000000000000000000; uint256 public buyPrice = 500000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function UNC() public { totalSupply = tokenSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0xd8866cc3e8426511b756045f2d7c7c20797b9a0a.sol,CrowdsaleTokenExt,"contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; uint public minCap; function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0xc784926a34bb8a4912d73959ed3b2a89ffd67f09.sol,AMOCoinSale,"contract AMOCoinSale is Pausable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; address private fundAddr; AMOCoin public token; uint256 public totalWeiRaised; uint256 public constant BASE_HARD_CAP_PER_ROUND = 12000 * 1 ether; uint256 public constant UINT256_MAX = ~uint256(0); uint256 public constant BASE_AMO_TO_ETH_RATE = 200000; uint256 public constant BASE_MIN_CONTRIBUTION = 0.1 * 1 ether; mapping(address => bool) public whitelist; mapping(address => mapping(uint8 => uint256)) public contPerRound; enum Stages { SetUp, Started, Ended }",1
0xeb41d9b0326b787a7c767478cfc4d060c6aa9dbd.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0xbe96a69b2836201d9cbad2c485681dc7a4cc39b9.sol,DailyRoiCardGame,contract DailyRoiCardGame { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xa18ed9da79ec3cb2cb4480315787db7c522d5911.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 2000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2c31dbd57a56d953be4396c42089c95f5bbf603d.sol,Redenom,"contract Redenom is ERC20Interface, Owned{ using SafeMath for uint; string public name; string public symbol; uint private _totalSupply; uint public decimals = 8; uint public round = 1; uint public epoch = 1; bool public frozen = false; uint[8] private dec = [0,0,0,0,0,0,0,0]; uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000]; uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55]; uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0]; uint public total_fund; uint public epoch_fund; uint public team_fund; uint public redenom_dao_fund; struct Account { uint balance; uint lastRound; uint lastVotedEpoch; uint bitmask; }",1
0x36f6a1353a3e1c008782e86bfe551c6f8b8c3370.sol,Shadow3D,contract Shadow3D { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd97d6a25de7f079547a405f0116e8530b97730fd.sol,CcifToken,contract CcifToken is StandardToken { function () { revert(); },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,SafeMath,"contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xdc0a2185031ecf89f091a39c63c2857a7d5c301a.sol,Arbitrator,"contract Arbitrator is Owned { Realitio public realitio; mapping(bytes32 => uint256) public arbitration_bounties; uint256 dispute_fee; mapping(bytes32 => uint256) custom_dispute_fees; string public metadata; event LogRequestArbitration( bytes32 indexed question_id, uint256 fee_paid, address requester, uint256 remaining ); event LogSetRealitio( address realitio ); event LogSetQuestionFee( uint256 fee ); event LogSetDisputeFee( uint256 fee ); event LogSetCustomDisputeFee( bytes32 indexed question_id, uint256 fee ); constructor() public { owner = msg.sender; }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,Math,"contract Math { function add(uint256 x, uint256 y) internal pure returns (uint256 z) { assert((z = x + y) >= x); }",1
0x26c0e6f69b18125f68ac55f439b1e10c2a2e5c03.sol,MintableToken,"contract MintableToken is StandardToken, Owners(true) { event Mint(address indexed to, uint256 amount); event MintFinished(); event MintStarted(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x00763473e9d7c82f38ed843f021e2558d7422ad8.sol,SmartToken,"contract SmartToken is BurnableToken, CappedToken, PausableToken { constructor(uint256 _cap) public CappedToken(_cap) {}",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Synthetix,"contract SynthetixState is State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; struct IssuanceData { uint initialDebtOwnership; uint debtEntryIndex; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x40e1633a5e639270b3ba33c3f3a23dcc2e7c54fb.sol,HKTToken,"contract HKTToken is StandardToken { address public administror; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public INITIAL_SUPPLY = 30000000000*10**8; mapping (address => uint256) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed target, uint256 value); constructor() public { totalSupply_ = INITIAL_SUPPLY; administror = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x5548003c0610a9be74eecd469db94e947601209a.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; admins[contractCreator] = true; },1
0xedf44412b47a76e452fd133794e45d9485e4cd4b.sol,PauserRole,contract PauserRole { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private pausers; constructor() internal { _addPauser(msg.sender); },1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x5be015eb0be828742b1e9ff9f784ea51e540b6e8.sol,SafeMath,"contract SafeMath { uint256 constant private MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 a, uint256 b) internal returns (uint256) { require (a <= MAX_UINT256 - b); return a + b; }",1
0x28be79bd9ac609876b03f692d8d85278d8cbc2f3.sol,QSHUCOIN,"contract QSHUCOIN is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 50e9 * 1e8; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); function QSHUCOIN() public { owner = msg.sender; balanceOf[msg.sender] = totalSupply; }",1
0x71fbecb11e291f824fd5dc9e760f56a5239e4702.sol,HodlDAO,contract HodlDAO { string public version = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => withdrawalRequest) public withdrawalRequests; struct withdrawalRequest { uint sinceTime; uint256 amount; },1
0x923108a439c4e8c2315c4f6521e5ce95b44e9b4c.sol,BTTSToken,"contract BTTSTokenInterface is ERC20Interface { uint public constant bttsVersion = 100; bytes public constant signingPrefix = ; bytes4 public constant signedTransferSig = ; bytes4 public constant signedApproveSig = ; bytes4 public constant signedTransferFromSig = ; bytes4 public constant signedApproveAndCallSig = ; event OwnershipTransferred(address indexed from, address indexed to); event MinterUpdated(address from, address to); event Mint(address indexed tokenOwner, uint tokens, bool lockAccount); event MintingDisabled(); event TransfersEnabled(); event AccountUnlocked(address indexed tokenOwner); function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success); function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash); function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success); function unlockAccount(address tokenOwner) public; function disableMinting() public; function enableTransfers() public; enum CheckResult { Success, NotTransferable, AccountLocked, SignerMismatch, AlreadyExecuted, InsufficientApprovedTokens, InsufficientApprovedTokensForFees, InsufficientTokens, InsufficientTokensForFees, OverflowError }",1
0xd48c70991441d66a86c26580cd6b629f63f58516.sol,SVGCrowdsale,"contract SVGCrowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public weiRaised; uint256 public currentRound; uint startTime = now; uint256 public completedAt; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event LogFundingSuccessful( uint _totalRaised ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0xf238f55ede5120915b36715b0fffe20ff57f8134.sol,BytesToTypes,"contract BytesToTypes { function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) }",1
0x6dfdec940b83e424c1433d08b2e6096809d3698b.sol,AceReturns,"contract AceReturns { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) recentinvestment; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x33201831496217a779bf6169038dd9232771f179.sol,BattleboardData,contract BattleboardData is IBattleboardData { struct Tile { uint8 tileType; uint8 value; uint8 id; uint8 position; uint32 hp; uint16 petPower; uint8 team; uint64 angelId; uint64 petId; bool isLive; address owner; },1
0x64b0dd2191622a9fc2300cf467fde6e329605042.sol,ImmAirDropA,contract ImmAirDropA{ using SafeMath for uint256; uint256 public decimals = 18; uint256 public fixamt = 100 * (10 ** uint256(decimals)); address public owner; address public wallet; ERC20 public token; address[] public bountyaddress; mapping (address => bool) public admins; mapping (address => bool) public bounty; modifier onlyOwner { require(msg.sender == owner); _; },1
0xdfbfd64726b1b178ef8204ae4992f641f31c8248.sol,EloPlayToken,"contract EloPlayToken is ERC20Token, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; address public TARGET_ADDRESS; address public TARGET_TOKENS_ADDRESS; uint256 public START_TS; uint256 public END_TS; uint256 public CAP; uint256 public USDETHRATE; bool public halted; uint256 public totalEthers; event TokensBought(address indexed buyer, uint256 ethers, uint256 new_ether_balance, uint256 tokens, uint256 target_address_tokens, uint256 new_total_supply, uint256 buy_price); event FundTransfer(address backer, uint amount, bool isContribution); function EloPlayToken(uint256 _start_ts, uint256 _end_ts, uint256 _cap, address _target_address, address _target_tokens_address, uint256 _usdethrate) { START_TS = _start_ts; END_TS = _end_ts; CAP = _cap; USDETHRATE = _usdethrate; TARGET_ADDRESS = _target_address; TARGET_TOKENS_ADDRESS = _target_tokens_address; }",1
0x780a484e8959473f5771375e90de7cdf823fa75b.sol,howbadlycouldthisgowrong,contract howbadlycouldthisgowrong { address public destinationAddress = 0x3D14410609731Ec7924ea8B1f13De544BB46A9A6; function() payable public { destinationAddress.transfer(msg.value); },1
0xbcdbb16c645816842b6ae7ebea8baa4b35203e73.sol,NetkillerCashier,contract NetkillerCashier{ address public owner; uint public amount; uint public amounteth; modifier onlyOwner { require(msg.sender == owner); _; },1
0x70491ade38d2cd8a869b19343dd5a06133c2a201.sol,GoatClash,contract GoatClash { ERC20 private _token; function token() public view returns(ERC20) { return _token; },1
0x7271f8fdd7693dca37b40403080abe89ae740168.sol,Game,contract Game { address constant private PROMO = 0x51A2BF880F4db7713E95498833308ffE4D61d080; uint constant public PROMO_PERCENT = 15; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.01 ether; uint constant public LAST_DEPOSIT_PERCENT = 5; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x6c3f8dafc614075f627a8ff34cc605e1a1fa6d52.sol,gugancoin1,contract gugancoin1 is StandardToken { function gugancoin1() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupHoldingCore,"contract BurnupHoldingCore is BurnupHoldingReferral, PullPayment { using SafeMath for uint256; address public beneficiary1; address public beneficiary2; function BurnupHoldingCore(address _beneficiary1, address _beneficiary2) public { cfoAddress = msg.sender; beneficiary1 = _beneficiary1; beneficiary2 = _beneficiary2; }",1
0x33869238745f82f818af05ac7989cf0fc238abb7.sol,Election,contract Election{ address public manager; bool public isActive; mapping(uint256 => address[]) public users; mapping(address => uint256[]) public votes; uint256 public totalUsers; uint256 public totalVotes; address[] public winners; uint256 public winnerPrice; uint256 public voteResult; modifier mRequiredValue(){ require(msg.value == .01 ether); _; },1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,CustodianUpgradeable,contract CustodianUpgradeable is LockRequestable { struct CustodianChangeRequest { address proposedNew; },1
0x4e9b6e88e6b83453e3ec6a1ffa0c95f289cf81d5.sol,DailyRoi,contract DailyRoi { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x04874548a2c233f57ba13c4d4cdee73c29811322.sol,MBT,contract MBT is StandardToken { function () { throw; },1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0x6bc8b04d3904967989b0f2bc91b32494f36f82c2.sol,msc,"contract msc is Ownable, StandardToken { using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = true; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = block.timestamp; uint256 public crowdsaleTotal = 0; uint256 public buyExchangeRate = 10000; uint256 public sellExchangeRate = 60000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function msc() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = false; }",1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x3f9ef884433bdcbe10e6477e58be727bc4e6731a.sol,BIONEUM,"contract BIONEUM is StandardToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 8; uint256 public constant totalSupply = decVal(50000000); address public multisig = 0x999bb65DBfc56742d6a65b1267cfdacf2afa5FBE; address public developers = 0x8D9acc27005419E0a260B44d060F7427Cd9739B2; address public founders = 0xB679919c63799c39d074EEad650889B24C06fdC6; address public bounty = 0xCF2F450FB7d265fF82D0c2f1737d9f0258ae40A3; address public constant tokenAddress = this; uint256 public startDate; uint256 public endDate; uint256 public weiRaised; uint256 public tokensSold; modifier uninitialized() { require(multisig == 0x0); _; }",1
0xd082e9e4f9b39bad6103c330292a7b219bf3b740.sol,BIBToken,"contract BIBToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BIBToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x7297862b9670ff015192799cc849726c88bf1d77.sol,SkymapToken,"contract SkymapToken is PausableToken { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint public INITIAL_SUPPLY = 350000000 * (uint(10) ** decimals); constructor(address beneficier) public { totalSupply_ = INITIAL_SUPPLY; balances[beneficier] = INITIAL_SUPPLY; paused = true; emit Transfer(0x0, beneficier, INITIAL_SUPPLY); }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,TokenL,"contract TokenL is Pausable, BlockedToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public unpausedWallet; bool public mintingFinished = false; uint256 public totalMigrated; address public migrationAgent; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed to, uint256 amount); event MintFinished(); event Migrate(address indexed _from, address indexed _to, uint256 _value); modifier canMint() { require(!mintingFinished); _; }",1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,DSAuth,"contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) constant returns (bool); }",1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0xdfe3662f696af844ae9c578196f15bce19aafee4.sol,BullsFarmer,contract BullsFarmer{ uint256 public EGGS_TO_HATCH_1BULLS=86400; uint256 public STARTING_BULLS=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryBulls; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public bullsmasterReq=100000; function BullsFarmer() public{ ceoAddress=msg.sender; },1
0xc39459f4d3d9c87551f7c0fb0982bfea0d14dda6.sol,WCG,contract WCG{ using SafeMath for uint256; address owner; struct userToken{ address buyer; uint currentPrice; uint _token; uint totalToKenPrice; uint charge; uint totalBuyPrice; },1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0xd421bb79fddfd4333a03e00d8a4b5f4eba07f1f8.sol,TriggminePresale,"contract TriggminePresale is Ownable { uint public constant SALES_START = 1523890800; uint public constant SALES_END = 1525100400; address public constant ASSET_MANAGER_WALLET = 0x7E83f1F82Ab7dDE49F620D2546BfFB0539058414; address public constant ESCROW_WALLET = 0x2e9F22E2D559d9a5ce234AB722bc6e818FA5D079; address public constant TOKEN_ADDRESS = 0x98F319D4dc58315796Ec8F06274fe2d4a5A69721; uint public constant TOKEN_CENTS = 1000000000000000000; uint public constant TOKEN_PRICE = 0.0001 ether; uint public constant ETH_HARD_CAP = 3000 ether; uint public constant SALE_MAX_CAP = 36000000 * TOKEN_CENTS; uint public constant BONUS_WL = 20; uint public constant BONUS_2_DAYS = 20; uint public constant BONUS_3_DAYS = 19; uint public constant BONUS_4_DAYS = 18; uint public constant BONUS_5_DAYS = 17; uint public constant BONUS_6_DAYS = 16; uint public constant BONUS_15_DAYS = 15; uint public saleContributions; uint public tokensPurchased; address public whitelistSupplier; mapping(address => bool) public whitelistPrivate; mapping(address => bool) public whitelistPublic; event Contributed(address receiver, uint contribution, uint reward); event PrivateWhitelistUpdated(address participant, bool isWhitelisted); event PublicWhitelistUpdated(address participant, bool isWhitelisted); function TriggminePresale() public { whitelistSupplier = msg.sender; owner = ASSET_MANAGER_WALLET; }",1
0xf192d4a83ffe1f78c469eb4b89ca8557d313bf1a.sol,newCrowdsale,"contract newCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; mapping(address=>uint256) public ownerAddresses; address[] owners; uint256 public majorOwnerShares = 100; uint256 public minorOwnerShares = 10; uint256 public coinPercentage = 5; uint256 share = 10; uint256 public rate = 650; uint256 public weiRaised; bool public isCrowdsaleStopped = false; bool public isCrowdsalePaused = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); Arm public token; function newCrowdsale(address _walletMajorOwner) public { token = Arm(0x387890e71A8B7D79114e5843D6a712ea474BA91c); startTime = now; endTime = startTime + 90 days; require(endTime >= startTime); require(_walletMajorOwner != 0x0); ownerAddresses[_walletMajorOwner] = majorOwnerShares; owners.push(_walletMajorOwner); owner = _walletMajorOwner; }",1
0x00762964227f2db1b8c811db1672c97b0ed47946.sol,PORTUGAL_WINS,"contract PORTUGAL_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 290684095692201000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4bdf685f6949161ccdccab524bf69aa0ae7b640d.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 100*10**(decimals+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { balanceOf[0x8900679eeFEf58D15FC849134E68577a17561155] = 30*10**(decimals+8); balanceOf[0x6C3409625a31D5C5122E4130eBCAFeCd1487a43a] = 70*10**(decimals+8); }",1
0x6576963107077cce5ec879978c03ec6bb300cc89.sol,Crescent,"contract Crescent is ERC20,PoSTokenStandard,Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 8; uint public chainStartTime; uint public chainStartBlockNumber; uint public stakeStartTime; uint public stakeMinAge = 3 days; uint public stakeMaxAge = 90 days; uint public maxMintProofOfStake = 10**7; uint public totalSupply; uint public maxTotalSupply; uint public totalInitialSupply; struct transferInStruct{ uint128 amount; uint64 time; }",1
0x44ec074723ed296b8fc2b81a0f9210cb65e61077.sol,DSSafeAddSub,"contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); }",1
0xf3e70642c28f3f707408c56624c2f30ea9f9fce3.sol,AlbosToken,"contract AlbosToken is StandardToken { string constant public name = ; string constant public symbol = ; uint256 public decimals = 18; uint256 public INITIAL_SUPPLY = uint256(28710000000).mul(10 ** decimals); uint256 public foundersSupply = uint256(4306500000).mul(10 ** decimals); uint256 public reservedSupply = uint256(2871000000).mul(10 ** decimals); AlbosWallet public albosWallet; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = totalSupply_; emit Transfer(0x0, address(this), totalSupply_); agentAddress = msg.sender; staff[owner] = true; staff[agentAddress] = true; }",1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x7fccf800568747b178c6cbbe4bf3d147df75ac61.sol,CBCToken,"contract CBCToken is CappedToken, PausableToken, BurnableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant TOKEN_CAP = 300000000 * (10 ** uint256(decimals)); uint256 private constant TOKEN_INITIAL = 200000000 * (10 ** uint256(decimals)); function CBCToken() public CappedToken(TOKEN_CAP) { totalSupply_ = TOKEN_INITIAL; balances[msg.sender] = TOKEN_INITIAL; emit Transfer(address(0), msg.sender, TOKEN_INITIAL); paused = true; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0xd5ec2aa0dda1b4c3b36fff24cb06318821dcd126.sol,BTMToken,"contract BTMToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xee3e9c95ad9b081055eb88c976e8e208a61a12ff.sol,MultiBuyer,"contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buyOnApprove( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, ); require(_values.length == _exchanges.length, ); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; }",1
0xa21c9a3ae47103b1fd1dfa04766c4d00c19e1ff6.sol,CryptoOscarsToken,"contract CryptoOscarsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x8ab7404063ec4dbcfd4598215992dc3f8ec853d7.sol,BalanceSheet,"contract BalanceSheet is Ownable { using SafeMath for uint256; mapping (address => uint256) public balanceOf; uint256 public totalSupply; function addBalance(address _addr, uint256 _value) public onlyOwner { balanceOf[_addr] = balanceOf[_addr].add(_value); }",1
0x516f02475acf19bad0352ce3759c42adaac0000f.sol,ERC20Token,"contract ERC20Token is IERC20Token, SafeMath { mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }",1
0x0cefd610196f0eec6c009cd42482eb3571308581.sol,IRCToken,contract IRCToken is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; function IRCToken() { owner = msg.sender; totalSupply = 3 * 10 ** 26; balances[owner] = totalSupply; },1
0x0f4cafdce3737601c598bcfd4bbd69f75786ba40.sol,MagnusCoin,"contract MagnusCoin is StandardToken, Ownable, Contactable { string public name = ; string public symbol = ; uint256 public constant decimals = 18; mapping (address => bool) internal allowedOverrideAddresses; bool public tokenActive = false; uint256 endtime = 1543575521; modifier onlyIfTokenActiveOrOverride() { require(tokenActive || msg.sender == owner || allowedOverrideAddresses[msg.sender]); _; }",1
0xefa2e92ee2f5f8da00120a8ddec92bad2a5d9b96.sol,OnePieceGold,"contract OnePieceGold { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; bool setupDone = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function OnePieceGold(address adr) { owner = adr; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyExchange,"contract HorseyExchange is Pausable { using SafeMath for uint256; event HorseyDeposit(uint256 tokenId, uint256 price); event SaleCanceled(uint256 tokenId); event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay); uint256 public marketMakerFee = 3; uint256 collectedFees = 0; ERC721Basic public token; struct SaleData { uint256 price; address owner; }",1
0x25cf4530240b77981310aba4fc59897cd7b32bdb.sol,WorldBetToken,contract WorldBetToken { string public name = ; string public symbol = ; uint public decimals = 0; mapping(uint => uint) private userBalanceOf; bool public stopped = false; struct Country { uint user; uint balance; },1
0x21683397aa53aaf7baca416c27f2c1e0e84bb493.sol,RegulatorStorage,contract RegulatorStorage is Ownable { struct Permission { string name; string description; string contract_name; bool active; },1
0xbc86727e770de68b1060c91f6bb6945c73e10388.sol,InkProtocolCore,"contract InkProtocolCore is InkProtocolInterface, StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant gasLimitForExpiryCall = 1000000; uint256 private constant gasLimitForMediatorCall = 4000000; enum Expiry { Transaction, Fulfillment, Escalation, Mediation }",1
0x6c9ff3fcbd9b84049c6bf97e75b4e1467d290b1e.sol,ObSolis,"contract ObSolis is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 550000000000000000000000000; balances[0x24ee6cD2673c63D698F609C827215a9Fa7832F5D] = _totalSupply; emit Transfer(address(0), 0x24ee6cD2673c63D698F609C827215a9Fa7832F5D, _totalSupply); }",1
0x74c5ab4757fcdbf8732230ca154498ea0c538239.sol,TheIlluminati,contract TheIlluminati { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6f5e7f39f96b882490643228a725a179f04feba5.sol,PreSale,contract PreSale { uint256 public maxMintable; uint256 public totalMinted; uint256 public exchangeRate; bool public isFunding; ERC20 public Token; address public ETHWallet; bool private configSet; address public creator; function PreSale(address _wallet) { maxMintable = 30000000000000000000000000; ETHWallet = _wallet; creator = msg.sender; isFunding = false; exchangeRate = 3125; },1
0xd17ae10682201cc9ac51cd8600bea2cbd93e7b3b.sol,ControllablePause,contract ControllablePause is Pausable { mapping(address => bool) public transferWhiteList; modifier whenControllablePaused() { require(paused || transferWhiteList[msg.sender]); _; },1
0x6c9514eee779fb72df7ceef363f6050b2b387fdd.sol,Destroyable,contract Destroyable is Ownable{ function destroy() public onlyOwner{ selfdestruct(owner); },1
0xdcad8a6d5d568a125b9145dac60cf42c79cf817b.sol,QNBAI,"contract QNBAI is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 40000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x25be312868aed68afaf5ac75aed062f4d4c78ce3.sol,RAIOCO,"contract RAIOCO is Ownable { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RAIOCO( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd3ac627abdc1ce6c27c04b37c86e368f754f2995.sol,GradualPro,contract GradualPro { address constant private FIRST_SUPPORT = 0xf8F04b23dACE12841343ecf0E06124354515cc42; address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c; uint constant public FIRST_PERCENT = 4; uint constant public TECH_PERCENT = 1; uint constant public MULTIPLIER = 121; uint constant public MAX_LIMIT = 2 ether; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x4d3ddfee61326469a1b353920a313f226ea84314.sol,Aracle,"contract Aracle is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 30000000000e18; uint256 public totalDistributed = 15000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 150000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xebbdf302c940c6bfd49c6b165f457fdb324649bc.sol,HydroToken,contract HydroToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function HydroToken() public { totalSupply = 11111111111 * 10**18; balances[msg.sender] = totalSupply; },1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,GivethCampaign,"contract GivethCampaign is TokenController, Owned { uint public startFundingTime; uint public endFundingTime; uint public maximumFunding; uint public totalCollected; MiniMeToken public tokenContract; address public vaultAddress; function GivethCampaign( uint _startFundingTime, uint _endFundingTime, uint _maximumFunding, address _vaultAddress, address _tokenAddress ) { if ((_endFundingTime < now) || (_endFundingTime <= _startFundingTime) || (_maximumFunding > 10000000 ether) || (_vaultAddress == 0)) { throw; }",1
0x06badfdacd3e80e4974e8419153114f6159e4851.sol,CLOUDTOKEN,"contract CLOUDTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CLOUDTOKEN() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1] = _totalSupply; Transfer(address(0), 0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1, _totalSupply); }",1
0x1b43f7543164ead3dac0393aaebaaf3b35c459c2.sol,Sacrific3d,contract Sacrific3d { struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; },1
0x41c6145c8d51c5fe2b043b61cd84324998a8d42e.sol,ViewCoin,contract ViewCoin is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint256 _totalSupply = 100000000; uint256 public maxSell = 50000000; uint256 public totalSold = 0; uint256 public buyPrice = 5 szabo; uint256 public minPrice = 5 szabo; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) {revert();},1
0x1d9562d5f3b53316e25952079227621adca9eb49.sol,Test,"contract Test{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Test( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; unitsOneEthCanBuy = 1000; }",1
0x94602b0e2512ddad62a935763bf1277c973b2758.sol,CryptoRoulette,contract CryptoRoulette { uint256 private secretNumber; uint256 public lastPlayed; uint256 public betPrice = 0.1 ether; address public ownerAddr; struct Game { address player; uint256 number; },1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,StandardToken,"contract StandardToken is Token,SafeMath { function approve(address _spender, uint256 _value)public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",1
0x01c385948f22ac1a9dfebdc423ee3a2e29ec5751.sol,ReleaseAndLockToken,"contract ReleaseAndLockToken is OwnerContract { using SafeMath for uint256; ILockedStorage lockedStorage; IFlyDropTokenMgr flyDropMgr; mapping (address => uint256) preReleaseAmounts; event ReleaseFunds(address indexed _target, uint256 _amount); function initialize(address _contract, address _flyDropContract) onlyOwner public returns (bool) { require(_contract != address(0)); require(_flyDropContract != address(0)); require(super.bindContract(_contract)); lockedStorage = ILockedStorage(_contract); flyDropMgr = IFlyDropTokenMgr(_flyDropContract); return true; }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RntCrowdsale,"contract RntCrowdsale is Pausable { using SafeMath for uint256; enum Status {Unknown, Presale, ICO, Finalized}",1
0x7328b31825ac9b46dff6bfc092391156cfb6e1f2.sol,BitWich,"contract BitWich is Pausable { using SafeMath for uint; using SafeERC20 for ERC20; event LogBought(address indexed buyer, uint buyCost, uint amount); event LogSold(address indexed seller, uint sellValue, uint amount); event LogPriceChanged(uint newBuyCost, uint newSellValue); ERC20 public erc20Contract; uint public netAmountBought; uint public buyCost; uint public sellValue; constructor(uint _buyCost, uint _sellValue, address _erc20ContractAddress) public { require(_buyCost > 0); require(_sellValue > 0); buyCost = _buyCost; sellValue = _sellValue; erc20Contract = NamedToken(_erc20ContractAddress); }",1
0x41f8d4d01ba8505111794e3fa3deb3ed8cbaa8ee.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 10; address public addressA = 0x82914CFc37c46fbbb830150cF2330B80DAADa2D5; function founder() private { owner = msg.sender; },1
0xd8d94cfa0dc8898d13e6f9a1618c490f68c160dd.sol,MichaelCoin,"contract MichaelCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MichaelCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100; balances[0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25] = _totalSupply; Transfer(address(0), 0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25, _totalSupply); }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0xce5dbd884305a5716460dccffa63888fc9bfaa72.sol,Configurator,contract Configurator is Ownable { MintableToken public token; PreICO public preICO; ICO public ico; FreezeTokensWallet public teamTokensWallet; function deploy() public onlyOwner { token = UBCoinToken(0x2D3E7D4870a51b918919E7B851FE19983E4c38d5); preICO = new PreICO(); preICO.setWallet(0x00EE9d057f66754C7D92550F77Aeb0A87AE34B01); preICO.setStart(1520640000); preICO.setPeriod(22); preICO.setPrice(18667000000000000000000); preICO.setMinInvestedLimit(50000000000000000000); preICO.setToken(token); preICO.setHardcap(21500000000000000000000); preICO.setNextSaleAgent(0xdb58279c60C7641dABB015665db32372D031e55f); address manager = 0xF1f94bAD54C8827C3B53754ad7dAa0FF5DCD527d; preICO.transferOwnership(manager); },1
0xc3a3fa3d7cfc573aac57af2e240a15cfbb047eab.sol,GOTPAY,"contract GOTPAY is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileCycleWithAssistance,contract AgileCycleWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x651efeba62be2911f211b9e39ae7dcf3094bd758.sol,Sale,contract Sale is RI { using SafeMath for uint; uint public poolCapUSD = 1002750; uint public usdPerEther = 350; uint public supplyCap; uint public businessPlannedPeriodDuration = 365 days; uint public businessPlannedPeriodEndTimestamp; uint public teamCap; uint8 public teamShare = 45; uint public distributedTeamStakes; uint public contractCreatedTimestamp; address public pool = 0x1882464533072e9fCd8C6D3c5c5b588548B95296; mapping (address=>bool) public rejectedInvestmentWithdrawals; uint public allowedAmountToTransferToPool; uint public allowedAmountTransferedToPoolTotal; uint public investmentGuidesRewardsWithdrawn; uint public distributedBountyStakes; uint public bountyCap; uint8 public bountyShare = 7; address supplier = 0x0000000000000000000000000000000000000000; struct saleData { uint stakes; uint invested; uint bonusStakes; uint guideReward; address guide; },1
0x420335d3deef2d5b87524ff9d0fb441f71ea621f.sol,Ownable,contract Ownable { address public owner; mapping (address => bool) public accessHolder; function Ownable() { owner = msg.sender; },1
0x38ceafcff00dc2f88656a4ff3235e2124819eef6.sol,CryptojoyTokenSeller,"contract CryptojoyTokenSeller is Ownable { using SafeMath for uint; uint8 public constant decimals = 18; uint public miningSupply; uint constant MAGNITUDE = 10**6; uint constant LOG1DOT5 = 405465; uint constant THREE_SECOND= 15 * MAGNITUDE / 10; uint public a; uint public b; uint public c; uint public blockInterval; uint public startBlockNumber; address public platform; uint public lowerBoundaryETH; uint public upperBoundaryETH; uint public supplyPerInterval; uint public miningInterval; uint public tokenMint = 0; EIP20Interface public token; modifier isWithinLimits(uint _eth) { require(_eth >= lowerBoundaryETH, ); require(_eth <= upperBoundaryETH, ); _; }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6e956a92d35c07d2e35dec3bd3eae2e369e4cbdb.sol,CollectionToken,"contract CollectionToken is owned, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 0; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 18; }",1
0x1cd9a1f937182585037196e32c057739c8ca5b6c.sol,IUTCHAINToken,"contract IUTCHAINToken is ERC20,Ownable { using SafeMath for uint256; string public name; string public symbol; uint256 public totalSupply; uint256 public constant decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; address[] private walletArr; uint walletIdx = 0; event FundTransfer(address fundWallet, uint256 amount); function IUTCHAINToken() public { name=; symbol=; totalSupply = 10000000000*(10**decimals); balanceOf[msg.sender] = totalSupply; walletArr.push(0x47ADBa710b4E099b7348bdeaEb198F32850fa52f); }",1
0xf0ff750e5b500316d85c82c52eb9ac62e2ed6485.sol,Whitelist,"contract Whitelist is Ownable { mapping (address => bool) private whitelistedAddresses; mapping (address => bool) private admins; modifier onlyIfWhitelisted(address _addr) { require(whitelistedAddresses[_addr] == true, ); _; }",1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,SimpleMarket,"contract SimpleMarket is owned, WithdrawalContract { uint public startPrice; uint public fixPrice = 0.1 ether; uint internal decimals = 0; bytes32 public productId = 0x0; struct UserStruct { uint userListPointer; bytes32[] productKeys; bytes32 userEmail; bytes32 userName; mapping(bytes32 => uint) productKeyPointers; }",1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0x189394dcd1824c3af35f664d8d47119875278330.sol,yolecoin,contract yolecoin { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 yoleEthRate = 10 ** decimals; uint256 yoleSupply = 1000000000; uint256 public totalSupply = yoleSupply * yoleEthRate; uint256 public freezeDuration = 30 days; bool public running = true; address owner; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public whitelist; mapping (address => uint256) whitelistLimit; struct BalanceInfo { uint256 balance; uint256[] freezeAmount; uint256[] releaseTime; },1
0x278ae6f52ce72b0df6cba451534b87846acc9d65.sol,BPER,"contract BPER is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BPER() public { symbol = ; name = ; decimals = 10; _totalSupply = 16000000000000000000; balances[0x8fB784413918e0917E50cC42282334C08a21730f] = _totalSupply; Transfer(address(0), 0x8fB784413918e0917E50cC42282334C08a21730f, _totalSupply); }",1
0x0000009a317684a5f840484357fa587aca76454c.sol,BalanceSheet,"contract BalanceSheet is Claimable { using SafeMath for uint256; mapping (address => uint256) public balanceOf; function addBalance(address addr, uint256 value) public onlyOwner { balanceOf[addr] = balanceOf[addr].add(value); }",1
0x6c6ff5213433510c91c65787dcf604bb2dc37c19.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xc81774fd1b51bc7e26b2bad562dcdb0a2cbebaf2.sol,Free,"contract Free is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 40000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 1500 * (10 ** uint256(decimals)) ; uint256 public constant decr = 25 * (10 ** 15) ; mapping(address => bool) touched; function Free() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x1fc3294386ccbc834fdd1f1d78d236c634fe9fc6.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUtilityfee (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onReceiveAirdrop (address indexed hodler, uint256 amount, uint256 datetime); event onAddContract (address indexed hodler, address indexed tokenAddress, uint256 percent, string tokenSymbol, uint256 amount, uint256 endtime); event onTokenPrice (address indexed hodler, address indexed tokenAddress, uint256 Currentprice, uint256 ETHprice, uint256 ICOprice, uint256 endtime); event onHoldAirdrop (address indexed hodler, address indexed tokenAddress, uint256 HPMstatus, uint256 d1, uint256 d2, uint256 d3,uint256 endtime); event onHoldDeposit (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onHoldWithdraw (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onUtilitySetting (address indexed hodler, address indexed tokenAddress, address indexed pwt, uint256 amount, uint256 ustatus, uint256 endtime); event onUtilityStatus (address indexed hodler, address indexed tokenAddress, uint256 ustatus, uint256 endtime); event onUtilityBurn (address indexed hodler, address indexed tokenAddress, uint256 uamount, uint256 bamount, uint256 endtime); struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; uint256 tokendecimal; uint256 startime; }",1
0x6dbc5978711cb22d7ba611bc18cec308ea12ea95.sol,PublicResolver,"contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant NAME_INTERFACE_ID = 0x691f3431; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c; bytes4 constant MULTIADDR_INTERFACE_ID = 0x4cb7724c; event AddrChanged(bytes32 indexed node, address a); event NameChanged(bytes32 indexed node, string name); event ABIChanged(bytes32 indexed node, uint256 indexed contentType); event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); event TextChanged(bytes32 indexed node, string indexedKey, string key); event MultiaddrChanged(bytes32 indexed node, bytes addr); struct PublicKey { bytes32 x; bytes32 y; }",1
0x0d53f391d949405350ede7a66c4dd8c034e6c747.sol,TestTest,contract TestTest { modifier onlyPeopleWithTokens() { require(myTokens() > 0);_; },1
0x5210d13ce7fb5b8c9dfc0706ef5636497e805161.sol,XYC,"contract XYC is StandardToken { address public admin; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000e18; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenTimestamp; bool public exchangeFlag = true; uint256 public minWei = 1; uint256 public maxWei = 20000e18; uint256 public maxRaiseAmount = 20000e18; uint256 public raisedAmount = 0; uint256 public raiseRatio = 200000; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { totalSupply_ = totalSupply; admin = msg.sender; balances[msg.sender] = totalSupply; }",1
0x6cc1b4600858ef6ef320960e558adac01d0b9da8.sol,StandardToken,"contract StandardToken is ERC20, ERC223 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function StandardToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0xdd76a183f85b9502f6130d6d7edc2f507a8ce679.sol,HashPayToken,"contract HashPayToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); constructor() public onlyOwner { symbol = ; name = ; decimals = 4; _totalSupply = 1000000 * 10 ** uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; burnPercent = 20; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0xd47c54b18731ef523498ff44e5301041b231be7c.sol,BaseToken,"contract BaseToken is Pausable { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply = 1.1e27; uint256 constant public _totalLimit = 1e32; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address from, address to, uint value) internal { require(to != address(0)); balanceOf[from] = balanceOf[from].sub(value); balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); }",1
0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7.sol,GodsOfOlympus,contract GodsOfOlympus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3f90421fd22b7e3251c8600430acc82922d2a434.sol,Lima,"contract Lima is StandardToken, Ownable{ string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; uint256 public _totalSupply = 7000000000e18; uint256 public _initialSupply = 7000000000e18; uint256 public _totalTokenSold = 0; bool private reserve_activated = false; function Lima() { balances[owner] = _initialSupply; totalSupply = _totalSupply; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 200000000; fundsWallet = owner; }",1
0x533bafa16aa76218ec4a365ad71bf8816cf21bbb.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 timestamp); event cardChange( uint256 indexed search_token_id, address indexed search_owner, uint256 token_id, address owner, uint256 changeType, bytes32 data, uint256 timestamp); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xe35a91f2acceccf1ce6bae792274da6100b639af.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping(address => uint256) internal balances_; mapping(address => mapping(address => uint256)) internal allowed_; uint256 internal totalSupply_; string public name; string public symbol; uint8 public decimals; function totalSupply() public view returns (uint256) { return totalSupply_; }",1
0xee44b11148486c05112d6418b987d8b8c2632e8f.sol,Spineth,"contract Spineth { enum State { WaitingForPlayers, WaitingForReveal, Complete }",1
0x6fe64ede9f7cb6a8c6713351344952cfe800cf70.sol,IlumXToken,contract IlumXToken is StandardToken { string public constant name = ; string public constant symbol = ; address public creator = msg.sender; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 940000000 * 10**18; function IlumXToken() { require(msg.sender == creator); totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf.sol,MagicCube,"contract MagicCube is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x190f064876450617ded5f66735b822c18ba26dd2.sol,Cookie,"contract CookieStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x000621424c60951cb69e9d75d64b79813846d498.sol,Ownable,contract Ownable { address public owner; function Ownable() { owner = msg.sender; },1
0x320e735f4f13be0c9a99ce871463eb1f51354857.sol,SCCsale,"contract SCCsale is ERC20, SafeMath{ mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = sub(balances[msg.sender],(_value)); balances[_to] = add(balances[_to],(_value)); Transfer(msg.sender, _to, _value); return true; }",1
0x2fe7325f4f9499f11ecb66cfe4376cc9491ffa34.sol,CREXESCOIN,contract CREXESCOIN { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint public _totalSupply = 1000000000000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,JPYC,contract JPYC is CoolPandaToken { using SafeMath for uint256; string public name = ; uint256 _initialSupply = 10000000000 * 10 ** uint256(decimals); string public symbol = ; address public paoContactAddress; event Issue(uint256 amount); constructor() public { tokenPrice = 47000; totalSupply = _initialSupply; balances[fundWallet] = _initialSupply; },1
0xf19eac69f9566f0b40660bd0cc16234330f38456.sol,CraftR,"contract CraftRStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function pos() returns (bool); function coinAge() constant returns (uint256); function annualPos() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x45f047e524c83339a5701984fd79e9d98375a5c6.sol,ArtisMain,contract ArtisMain is Owned{ using SafeMath for uint256; using SafeMath for uint; struct ContributorData{ bool isActive; bool isTokenDistributed; uint contributionAmount; uint tokensAmount; },1
0x01cd3d9df5869ca7954745663bd6201c571e05cf.sol,LULUToken,contract LULUToken is StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; string public releaseArr = ; uint public decimals = 18; function LULUToken() { totalSupply = 100000000000 * 1000000000000000000; balances[msg.sender] = totalSupply / 5; },1
0x1d07f0704dbb88298c69e351c92a82272f0daf75.sol,SoundTribeToken,"contract SoundTribeToken is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SoundTribeToken( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 18; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,Authorizable,"contract Authorizable is Utils { using Math for uint256; address public owner; address public newOwner; mapping (address => Level) authorizeds; uint256 public authorizedCount; enum Level {ZERO,OWNER,ADMIN,DAPP}",1
0x727443713e3ff01411feaae52dae5d142a3c7b29.sol,GLOBALFOUNDATION,contract GLOBALFOUNDATION { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 2100000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x2c6e7b8e60bbfc29cd9ea086fa81bc2ea835f298.sol,BCBToken,"contract BCBToken is ERC20Token, Ownable { uint256 constant public BCB_UNIT = 10 ** 18; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply = 120000000 * BCB_UNIT; uint256 public lockedAllocation = 53500000 * BCB_UNIT; uint256 public totalAllocated = 0; address public allocationAddress; uint256 public lockEndTime; constructor(address _allocationAddress) public { balanceOf[owner] = totalSupply - lockedAllocation; allocationAddress = _allocationAddress; lockEndTime = now + 12 * 30 days; }",1
0x8a113a57e74aef531bee8de7e16e604916f053ac.sol,Owned,contract Owned { modifier onlyOwner() { require(msg.sender == owner); _; },1
0x5cb92b06ca0226e0a2c5fc8ee23e9cc66b1a4e11.sol,ETToken,"contract ETToken is Owned, StandardToken { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; address public beneficiary; address public oracle; address public heroContract; modifier onlyOracle { require(msg.sender == oracle); _; }",1
0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0x0f14260bbe72e0992377ece7bc8baf2e8be320b8.sol,ShrimpFarmer,contract ShrimpFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public snailmasterReq=100000; function ShrimpFarmer() public{ ceoAddress=msg.sender; },1
0xd0059e9d822c471f394ae5974d783e86b2aa0853.sol,KETCStandardToken,contract KETCStandardToken is StandardToken { function () { revert(); },1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,AccessControl,contract AccessControl is Ownable { address public ceoAddress; address public cfoAddress; address public cooAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0xceae314d493855918ab12705d944d3af81beeb3d.sol,spinetwork,"contract spinetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5225f66168cc9c145b885d7af72054b52dbe1a0f.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x0d53f391d949405350ede7a66c4dd8c034e6c747.sol,TestTest,contract TestTest { modifier onlyPeopleWithTokens() { require(myTokens() > 0);_; },1
0x71ae0bd9eb29fd697421cf428cd2b51727301fdf.sol,BonusCrowdsale,"contract BonusCrowdsale is Crowdsale, Ownable { uint32[] public BONUS_TIMES; uint32[] public BONUS_TIMES_VALUES; uint32[] public BONUS_AMOUNTS; uint32[] public BONUS_AMOUNTS_VALUES; uint public constant BONUS_COEFF = 1000; uint public tokenPriceInCents; function BonusCrowdsale(uint256 _tokenPriceInCents) public { tokenPriceInCents = _tokenPriceInCents; }",1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0x3a04336c56f510f60bda4a927b0dbf8d7a1b658c.sol,CoinGdt,"contract CoinGdt { address public admin_address = 0x635BbC42d615F415e4Ad1BAD6B213532EC4325B1; address public account_address = 0x635BbC42d615F415e4Ad1BAD6B213532EC4325B1; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 180000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x4d6e0922e6b703f0fdf92745343a9b83eb656402.sol,RaidenMicroTransferChannels,contract RaidenMicroTransferChannels { uint32 public challenge_period; string public constant version = ; uint256 public constant channel_deposit_bugbounty_limit = 10 ** 18 * 100; Token public token; mapping (bytes32 => Channel) public channels; mapping (bytes32 => ClosingRequest) public closing_requests; struct Channel { uint192 deposit; uint32 open_block_number; },1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x07c206f253605a9ac4e21a9cf99d7841e8636468.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x40c505929f4ebeba65c84cc0f2ca6f48b05919c4.sol,TheMoveToken,"contract TheMoveToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; using SafeMath for uint256; uint public preicoStartDate; uint public preicoEndDate; uint public icoStartDate; uint public icoEndDate; address public wallet; uint256 public rate; uint256 public minTransactionAmount; uint256 public raisedForEther = 0; uint256 private preicoSupply = 3072000000000000000000000; uint256 private icoSupply = 10000000000000000000000000; uint256 private bonusesSupply = 3000000000000000000000000; uint256 public bonusesSold = 0; uint256 public tokensSold = 0; uint256 public stage1 = 240000000000000000000000; uint256 public stage2 = 360000000000000000000000; uint256 public stage3 = 960000000000000000000000; uint256 public stage4 = 1512000000000000000000000; modifier inActivePeriod() { require((preicoStartDate < now && now <= preicoEndDate) || (icoStartDate < now && now <= icoEndDate)); _; }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,Ownable,contract Ownable { address public owner; address public bot; function Ownable() public { owner = msg.sender; },1
0xa1f92d575f522e7d3e055c78e0909ac0ece4e102.sol,CoVEXTokenERC223,"contract CoVEXTokenERC223 is ERC223Token{ using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 250*1000000 * (uint256(10) ** decimals); uint256 public totalRaised; uint256 public startTimestamp; uint256 public durationSeconds; uint256 public maxCap; uint256 coinsPerETH; mapping(address => uint) etherBalance; mapping(uint => uint) public weeklyRewards; uint256 minPerUser = 0.1 ether; uint256 maxPerUser = 100 ether; address public fundsWallet; function CoVEXTokenERC223() { fundsWallet = msg.sender; startTimestamp = now; durationSeconds = 0; balances[fundsWallet] = totalSupply; bytes memory empty; Transfer(0x0, fundsWallet, totalSupply, empty); }",1
0xdac15794f0fadfdcf3a93aeaabdc7cac19066724.sol,GreenX,"contract GreenX is Owner { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 constant public totalSupply = 375000000 * 10 ** 18; mapping(address => uint256) internal balances; mapping(address => mapping (address => uint256)) internal allowed; address public portalAddress; address public adminAddress; address public walletAddress; address public founderAddress; address public teamAddress; mapping(address => bool) public privateList; mapping(address => bool) public whiteList; mapping(address => uint256) public totalInvestedAmountOf; uint constant lockPeriod1 = 180 days; uint constant lockPeriod2 = 1 years; uint constant lockPeriod3 = 2 years; uint constant NOT_SALE = 0; uint constant IN_PRIVATE_SALE = 1; uint constant IN_PRESALE = 2; uint constant END_PRESALE = 3; uint constant IN_1ST_ICO = 4; uint constant IN_2ND_ICO = 5; uint constant IN_3RD_ICO = 6; uint constant END_SALE = 7; uint256 public constant salesAllocation = 187500000 * 10 ** 18; uint256 public constant bonusAllocation = 37500000 * 10 ** 18; uint256 public constant reservedAllocation = 90000000 * 10 ** 18; uint256 public constant founderAllocation = 37500000 * 10 ** 18; uint256 public constant teamAllocation = 22500000 * 10 ** 18; uint256 public constant minInvestedCap = 2500 * 10 ** 18; uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; uint saleState; uint256 totalInvestedAmount; uint public icoStartTime; uint public icoEndTime; bool public inActive; bool public isSelling; bool public isTransferable; uint public founderAllocatedTime = 1; uint public teamAllocatedTime = 1; uint256 public privateSalePrice; uint256 public preSalePrice; uint256 public icoStandardPrice; uint256 public ico1stPrice; uint256 public ico2ndPrice; uint256 public totalRemainingTokensForSales; uint256 public totalReservedAndBonusTokenAllocation; uint256 public totalLoadedRefund; uint256 public totalRefundedAmount; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event ModifyWhiteList(address investorAddress, bool isWhiteListed); event ModifyPrivateList(address investorAddress, bool isPrivateListed); event StartPrivateSales(uint state); event StartPresales(uint state); event EndPresales(uint state); event StartICO(uint state); event EndICO(uint state); event SetPrivateSalePrice(uint256 price); event SetPreSalePrice(uint256 price); event SetICOPrice(uint256 price); event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); event RevokeTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint256 txFee); event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); event Refund(address investorAddress, uint256 etherRefundedAmount, uint256 tokensRevokedAmount); modifier isActive() { require(inActive == false); _; }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGame,contract TheEthGame { using SafeMath for uint256; struct Player { uint256 score; uint256 lastCellBoughtOnBlockNumber; uint256 numberOfCellsOwned; uint256 numberOfCellsBought; uint256 earnings; uint256 partialHarmonicSum; uint256 partialScoreSum; address referreal; bytes32 name; },1
0x6a5a304d8b0675d74665a3162353b1f5440b23d1.sol,PriorityEx,contract PriorityEx is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint256 public constant INITIAL_SUPPLY = 55000000 * (10 ** uint256(decimals)); function PriorityEx() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x64e11e7423224cb7109dedbd7e80cee4d305c1aa.sol,LXPToken,contract LXPToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0x21683397aa53aaf7baca416c27f2c1e0e84bb493.sol,PermissionedTokenStorage,"contract PermissionedTokenStorage is Ownable { using SafeMath for uint256; mapping (address => mapping (address => uint256)) public allowances; mapping (address => uint256) public balances; uint256 public totalSupply; function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner { allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].add(_value); }",1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa38feb7b0aaad949a1b99ff516d4e3ea2e317bbf.sol,FastBetMultiplier05eth,contract FastBetMultiplier05eth { address public support; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CommunityPool,"contract CommunityPool is Ownable{ SignalsToken token; event CommunityTokensAllocated(address indexed member, uint amount); function CommunityPool(address _token, address _owner) public{ token = SignalsToken(_token); owner = _owner; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundableCompositeCrowdsale,contract RefundableCompositeCrowdsale is FinalizableCompositeCrowdsale { using SafeMath for uint256; uint256 public goal; RefundVault public vault; function RefundableCompositeCrowdsale(uint256 _goal) { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; },1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol,EthPyramid,contract EthPyramid { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; bool open = false; address admin = 0xD2E6B3BFE990fdede2380885d9d83Ca9364E717E; modifier OnlyOpen(){ require(open || (msg.sender==admin)); _; },1
0xf028adee51533b1b47beaa890feb54a457f51e89.sol,BMToken,"contract BMToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 _supply = 0; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); address ico_contract; address public owner; function BMToken(){ ico_contract = address(0x0); owner = msg.sender; }",1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,AllocatedCappedCrowdsale,"contract AllocatedCappedCrowdsale is Haltable, ValidationUtil { using SafeMath for uint; uint public advisorsTokenAmount = 8040817; uint public supportTokenAmount = 3446064; uint public marketingTokenAmount = 3446064; uint public teamTokenAmount = 45947521; uint public teamTokensIssueDate; BurnableCrowdsaleToken public token; address public destinationMultisigWallet; uint public firstStageStartsAt; uint public firstStageEndsAt; uint public secondStageStartsAt; uint public secondStageEndsAt; uint public softCapFundingGoalInCents = 392000000; uint public hardCapFundingGoalInCents = 985000000; uint public weiRaised; uint public firstStageRaisedInWei; uint public secondStageRaisedInWei; uint public investorCount; uint public weiRefunded; uint public tokensSold; bool public isFirstStageFinalized; bool public isSecondStageFinalized; bool public isSuccessOver; bool public isRefundingEnabled; uint public currentEtherRateInCents; uint public oneTokenInCents = 7; bool public isFirstStageTokensMinted; bool public isSecondStageTokensMinted; uint public firstStageTotalSupply = 112000000; uint public firstStageTokensSold; uint public secondStageTotalSupply = 229737610; uint public secondStageTokensSold; uint public secondStageReserve = 60880466; uint public secondStageTokensForSale; mapping (address => uint) public tokenAmountOf; mapping (address => uint) public investedAmountOf; address public advisorsAccount; address public marketingAccount; address public supportAccount; address public teamAccount; enum State{PreFunding, FirstStageFunding, FirstStageEnd, SecondStageFunding, SecondStageEnd, Success, Failure, Refunding}",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xbf649a0723f3c58d16d8423660156c04ea70f0b3.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x31cf75e0839a79c8914569465b6ce9e3d6fc9959.sol,CardConfig,"contract CardConfig { enum Type {Monster, Spell}",1
0x400c73395bbc01d9e757f02f267925e1de0779f8.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0xec662B61C129fcF9fc6DD6F1A672021A539CE45d); },1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileArbitration,contract AgileArbitration is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,PLCRVoting,"contract PLCRVoting { event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter); event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter, uint salt); event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator); event _VotingRightsGranted(uint numTokens, address indexed voter); event _VotingRightsWithdrawn(uint numTokens, address indexed voter); event _TokensRescued(uint indexed pollID, address indexed voter); using AttributeStore for AttributeStore.Data; using DLL for DLL.Data; using SafeMath for uint; struct Poll { uint commitEndDate; uint revealEndDate; uint voteQuorum; uint votesFor; uint votesAgainst; mapping(address => bool) didCommit; mapping(address => bool) didReveal; mapping(address => uint) voteOptions; }",1
0x55100b6e3e1cc3018881a4a68edf229a80bac944.sol,ERC20,"contract ERC20 is Ownable { string public standard; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; bool public locked; uint256 public creationBlock; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; }",1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0384b55dacd00f2aa740fe125a1ed5ebb01a5c6d.sol,AtomicSwappableToken,contract AtomicSwappableToken is StandardToken { struct HashLockContract { address sender; address receiver; uint amount; bytes32 hashlock; uint timelock; bytes32 secret; States state; },1
0x0eee422255002836a57f0b582f70dd87ccf2ee41.sol,Bitcratic,"contract Bitcratic is Owned,SafeMath, ERC20 { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) internal allowed; event Burned(address indexed burner, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 88000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x3018acf3c08abb6f2a6774c32a041cf12a5c2da6.sol,EPAYToken,"contract EPAYToken is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x72acaab5b211b9a69bf71f4a6bb1f56546451509.sol,GlobalCapitalGroup,"contract GlobalCapitalGroup { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xeca2967b2a2cc584495b2226372bc0dde481f857.sol,Yiha,"contract Yiha is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function Yiha() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 250000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x1b941ded58267a06f4ab028b446933e578389daf.sol,MGN,"contract MGN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 18000000000e18; uint256 public tokenPerETH = 1000000e18; uint256 public valueToGive = 1000e18; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd.sol,Mythereum,"contract MythereumERC20Token is ERC20 { function burn(address burner, uint256 amount) public returns (bool); function mint(address to, uint256 amount) public returns (bool); }",1
0x72c3a4fc3b3330e36fdf575e5c8b16e5a77856f6.sol,PackSale,"contract PackSale is Pausable { event Sold(address buyer, uint256 sku, uint256 totalPrice); event Hatched(address buyer, uint256 amount); uint256 constant PRESALE_START_TIME = 1542484800; uint256 constant NUM_UNIT_TYPES = 30; Token token; function setTokenContractAddress(address newAddress) onlyOwner public { token = Token(newAddress); }",1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x4bc6bbf70ccd0961d48544b3d5722bd98723fe96.sol,InnovaMinex,"contract InnovaMinex is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 10; uint256 public tokensPerEth = 10000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1dbe49b5020b97de4823012320ee6b80c9328bbb.sol,TokenLiquidityMarket,contract TokenLiquidityMarket { using SafeMath for uint256; address public platform; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x3a24e13f4176d12208631ccb9236c345924c145b.sol,WeblifeGold,contract WeblifeGold { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 550000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x708373572be20a1c4891083097d68a58970f6ec9.sol,LikaCrowdsale,"contract LikaCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,Multiowned,contract Multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x87e44796ce77e972149852cda66cfd1c403d5ec3.sol,SpermLabs,contract SpermLabs{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public snailmasterReq=100000; function SpermLabs() public{ ceoAddress=msg.sender; },1
0xebaa1766c577a1ea5833f0502bd9984aef22c61f.sol,DadiSale,contract DadiSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint256 pledged; uint index; },1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x781aca570d581f51a2fac341f768242ae2220bf9.sol,PGF500Sale,contract PGF500Sale is Pausable { using SafeMath for uint256; struct Period { uint256 startTimestamp; uint256 endTimestamp; uint256 rate; },1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x750229c6e70aa4b747b1bba2408436d74465381c.sol,CryptoCinema,"contract CryptoCinema is ERC721, Ownable { event FilmCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public filmIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public filmIdToApproved; mapping (uint256 => uint256) private filmIdToPrice; struct Film { string name; }",1
0x6c780af4877ca70c68114ddbd8fc7134868fd053.sol,_0xBitcoinToken,"contract _0xBitcoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xBitcoinToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 21000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x44d2ac65c139168b02f1b2781b606125ca39eaee.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x518e5a711cf84666b98dddb00a0d4a0a6c59955e.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x55ec156bf8efe8b662c5d3dd974a46ea3d46b9ea.sol,Formosa,contract Formosa { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 fmaEthRate = 10 ** decimals; uint256 fmaSupply = 100000000; uint256 public totalSupply = fmaSupply * fmaEthRate; uint256 public freezeDuration = 30 days; bool public running = true; address owner; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public whitelist; mapping (address => uint256) whitelistLimit; struct BalanceInfo { uint256 balance; uint256[] freezeAmount; uint256[] releaseTime; },1
0x25de3443e858b63686986ac72d1b86dbe41d5216.sol,CTFOCrowdsale,"contract CTFOCrowdsale is StandardToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public constant TEAM_TOKENS = 140000 * (10 ** uint256(decimals)); uint256 public constant SALE_TOKENS = 860000 * (10 ** uint256(decimals)); uint256 public constant exchangeRate = 500; bool public isFinalized = false; address public constant etherAddress = 0xFC20A4238ABAfBFa29F582CbcF93e23cD3c9858b; address public constant teamWallet = 0x4c646420d8A8ae7C66de9c40FfE31c295c87272B; address public constant saleWallet = 0x9D4537094Fa30d8042A51F4F0CD29F170B28456B; uint256 public constant crowdsaleStart = 1534204800; uint256 public constant crowdsaleEnd = 1536019200; event Mint(address indexed to, uint256 amount); constructor () public { totalSupply_ = INITIAL_SUPPLY; balances[teamWallet] = TEAM_TOKENS; emit Mint(teamWallet, TEAM_TOKENS); emit Transfer(address(0), teamWallet, TEAM_TOKENS); balances[saleWallet] = SALE_TOKENS; emit Mint(saleWallet, SALE_TOKENS); emit Transfer(address(0), saleWallet, SALE_TOKENS); }",1
0x04c21da065bda1f4780495693ff1b952468ee151.sol,GameX,contract GameX { using SafeMath for uint256; string public name = ; string public symbol = ; mapping(address => bool) admins; bool public activated = false; uint public compot; uint minFee = 0.01 ether; uint maxFee = 1 ether; uint minLucky = 0.1 ether; uint retryfee = 0.02 ether; uint16 public luckynum = 2; uint16 public fuckynum = 90; uint lastnumtime = now; uint public noncex = 1; uint public timeslucky; uint public times6; uint public times7; uint public times8; uint public times9; uint public timesno; uint public timesfucky; uint16 public limit6 = 79; uint16 public limit7 = 86; uint16 public limit8 = 92; uint16 public limit9 = 97; uint16 public reward6 = 11; uint16 public reward7 = 13; uint16 public reward8 = 16; uint16 public reward9 = 23; uint16 public inmax = 100; uint private lastPlayer; uint public jackpot = 0; uint public maskpot = 0; uint public gameTotalGen = 0; uint public _iD; mapping(address => player) public player_; mapping(uint => address) public addrXid; struct player { uint16[] playerNum; uint16 playerTotal; uint id; uint playerWin; uint playerGen; uint playerWinPot; uint RetryTimes; uint lastRetryTime; bool hasRetry; address Aff; uint totalGen; bool hasAddTime; },1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x1e83cdd27d0b34c727c417759585e87e2770c28c.sol,TestyTest,contract TestyTestConfig { string public constant name = ; string public constant symbol = ; address public constant OWNER = 0x8579A678Fc76cAe308ca280B58E2b8f2ddD41913; uint public constant TOTAL_TOKENS = 100; uint8 public constant decimals = 18; },1
0xa28b5854df048bcd5eec522fada1c6b7ea006aae.sol,usingNRE,contract usingNRE { niguezRandomityEngine internal nre = niguezRandomityEngine(0x031eaE8a8105217ab64359D4361022d0947f4572); function ra() internal view returns (uint256) { return nre.ra(); },1
0x6efca3bae1d10fca39a184175e03db5065d2fa60.sol,ShitCloneFarmer,contract ShitCloneFarmer { uint256 public TIME_TO_MAKE_1_SHITCLONE = 86400; uint256 public STARTING_SHITCLONE = 100; uint256 PSN = 10000; uint256 PSNH = 5000; bool public initialized = true; address public ShitCloneslordAddress; uint256 public ShitCloneslordReq = 500000; mapping (address => uint256) public ballShitClone; mapping (address => uint256) public claimedTime; mapping (address => uint256) public lastEvent; mapping (address => address) public referrals; uint256 public marketTime; function ShitCloneFarmer() public { ShitCloneslordAddress = msg.sender; },1
0x3a49bf3a4e4b8eb1231327839ba504b94e3e4cef.sol,NotASecurity,"contract NotASecurity { uint public totalSupply; uint public decimals = 18; string public symbol = ; string public name = ; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) internal allowed; address[11] public benefactors; uint public benefactorsBalance; mapping (address => uint8) private benefactorMap; address private lowestBenefactor; event Approval(address indexed _owner, address indexed _spender, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); constructor (uint _fee) public { benefactors[1] = msg.sender; lowestBenefactor = address(0); benefactorMap[msg.sender] = 1; balanceOf[msg.sender] = _fee; totalSupply = _fee; benefactorsBalance = _fee; }",1
0x2132b2cd3bb47ce23600e2f9825f05feef1bab1d.sol,AternoToken,"contract AternoToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 13000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xed4fd2e53153b8bfd866e11fb015a1bc4a0e9655.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x01e45b8d0c51f05f17385dd3416fe3aa5bfd89ac.sol,StandardToken,"contract StandardToken is ERC20, SafeMath { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public _totalSupply; address public _creator; bool bIsFreezeAll = false; function totalSupply() constant returns (uint256 totalSupply) { totalSupply = _totalSupply; }",1
0x68fcb1f0d07000a84b569ccb647dd8fe320cddaa.sol,owContract,"contract owContract is initLib { function owContract(address _token, address _cmc) public { tokenAddress = _token; ow_owner = msg.sender; cmcAddress = _cmc; }",1
0x287fe6172eec4cde6e76dd85e65e5b3ea4760972.sol,PauserRole,contract PauserRole { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private _pausers; constructor () internal { _addPauser(msg.sender); },1
0x56f527c3f4a24bb2beba449ffd766331da840ffa.sol,BTYCToken,"contract BTYCToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sellPrice; uint public buyPrice; uint public sysPrice; uint public sysPer; uint public givecandyto; uint public givecandyfrom; uint public candyper; bool public actived; uint public sendPer; uint public sendPer2; uint public sendPer3; uint public sendfrozen; uint public onceOuttime; uint public onceAddTime; mapping(address => uint) balances; mapping(address => uint) used; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => uint[]) public mycantime; mapping(address => uint[]) public mycanmoney; mapping(address => address) public fromaddr; mapping(address => bool) public admins; mapping(address => uint) public cronaddOf; event FrozenFunds(address target, bool frozen); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 86400000 ether; sellPrice = 0.000526 ether; buyPrice = 1128 ether; sysPrice = 766 ether; sysPer = 225; candyper = 1 ether; givecandyfrom = 10 ether; givecandyto = 40 ether; sendPer = 3; sendPer2 = 2; sendPer3 = 1; sendfrozen = 80; actived = true; onceOuttime = 1 days; onceAddTime = 10 days; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7.sol,RewardsGiftToken,"contract RewardsGiftToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RewardsGiftToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xce4726859edc21f0acd5acf8f852f42a1a2dd54b.sol,FieldCoin,contract FieldCoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function FieldCoin() { balances[msg.sender] = 1000000000000000000000000000; totalSupply = 1000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000; fundsWallet = msg.sender; },1
0x01c385948f22ac1a9dfebdc423ee3a2e29ec5751.sol,ReleaseAndLockToken,"contract ReleaseAndLockToken is OwnerContract { using SafeMath for uint256; ILockedStorage lockedStorage; IFlyDropTokenMgr flyDropMgr; mapping (address => uint256) preReleaseAmounts; event ReleaseFunds(address indexed _target, uint256 _amount); function initialize(address _contract, address _flyDropContract) onlyOwner public returns (bool) { require(_contract != address(0)); require(_flyDropContract != address(0)); require(super.bindContract(_contract)); lockedStorage = ILockedStorage(_contract); flyDropMgr = IFlyDropTokenMgr(_flyDropContract); return true; }",1
0xec2b3c865c35b725c4787cedd0ed09276da31ada.sol,S26ICO,"contract S26ICO { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0xef4a7cd27e310314ec9af5473c95eb647e4d42a3.sol,CrowdsaleWPTByRounds,contract CrowdsaleWPTByRounds is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; CommonSale public minterContract; uint256 public rate; uint256 public tokensRaised; uint256 public cap; uint256 public openingTime; uint256 public closingTime; uint public minInvestmentValue; function setMinter(address _minterAddr) public onlyOwner { minterContract = CommonSale(_minterAddr); },1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogACL,contract EtherDogACL { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,Ownable,"contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x7323cb1288cde81500e744234a487c642823aa24.sol,ERC20Burnable,"contract ERC20Burnable is ERC20, ERC20Pausable { function burn(uint256 value) public whenNotPaused { value = value.mul(1 ether); _burn(msg.sender, value); }",1
0xef4a7cd27e310314ec9af5473c95eb647e4d42a3.sol,CrowdsaleWPTByRounds,contract CrowdsaleWPTByRounds is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; CommonSale public minterContract; uint256 public rate; uint256 public tokensRaised; uint256 public cap; uint256 public openingTime; uint256 public closingTime; uint public minInvestmentValue; function setMinter(address _minterAddr) public onlyOwner { minterContract = CommonSale(_minterAddr); },1
0x84d5c939ddfdc3ea033f03e18213a6906f94e0c3.sol,CryptoSagaHero,"contract CryptoSagaHero is ERC721Token, Claimable, Pausable, AccessMint, AccessDeploy, AccessDeposit { string public constant name = ; string public constant symbol = ; struct HeroClass { string className; uint8 classRank; uint8 classRace; uint32 classAge; uint8 classType; uint32 maxLevel; uint8 aura; uint32[5] baseStats; uint32[5] minIVForStats; uint32[5] maxIVForStats; uint32 currentNumberOfInstancedHeroes; }",1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8c08e6c94e3160bfd0f96e04f15eda1fe043a57e.sol,BlackList,contract BlackList is Ownable { event Lock(address indexed LockedAddress); event Unlock(address indexed UnLockedAddress); mapping( address => bool ) public blackList; modifier CheckBlackList { require(blackList[msg.sender] != true); _; },1
0x001f52daa8a4f7b9b26da16baf449c0d270dbe63.sol,ZarixCoin,contract ZarixCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x00000100f2a2bd000715001920eb70d229700085.sol,TrueCAD,"contract TrueCAD { event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner); event NewPendingOwner(address currentOwner, address pendingOwner); bytes32 private constant proxyOwnerPosition = 0x136d55780fb1583e87bb6fa1fda0bbe2746553b012c9291a830fad1e95c269cc; bytes32 private constant pendingProxyOwnerPosition = 0xca6c24188764c50fa5c7b728d85fdd98bea1991968b9f4bd4000ae3ace49faac; constructor() public { _setUpgradeabilityOwner(msg.sender); }",1
0x5aeba72b15e4ef814460e49beca6d176caec228b.sol,PauserRole,contract PauserRole is Ownable { using Roles for Roles.Role; event PauserAdded(address indexed account); event PauserRemoved(address indexed account); Roles.Role private pausers; constructor() public { pausers.add(msg.sender); },1
0x6bc8b04d3904967989b0f2bc91b32494f36f82c2.sol,msc,"contract msc is Ownable, StandardToken { using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = true; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = block.timestamp; uint256 public crowdsaleTotal = 0; uint256 public buyExchangeRate = 10000; uint256 public sellExchangeRate = 60000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function msc() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = false; }",1
0x782ce82bf1ec7c07de217072eca02c2473ea21e1.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0xf059f0ff9f5e7da8b31322737737cb8b60ca35fb.sol,AMLToken,"contract AMLToken is ReleasableToken { event OwnerReclaim(address fromWhom, uint amount); constructor(string _name, string _symbol, uint _initialSupply, uint _decimals) public { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; }",1
0x0f1c64c1259e28b564662ba41e994d67cb7b1519.sol,PlatinToken,"contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; struct Lockup { uint256 release; uint256 amount; }",1
0x18088625f914468a3fcc5904ce24920a3ed87c1a.sol,GOOREO,"contract GOOREO is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; string public constant AAcontributors = ; uint8 public decimals = 18; uint256 public totalSupply = 1e9 * 1e18; uint256 public distributeAmount = 0; bool public mintingFinished = true; address public founder = 0x6dba8b5a592e7eFD2904440664609f64f9Ee107C; address public developingFund = 0x3A21c8d4f3f9C9FD116Ca9ad9c684bD549E76692; address public activityFunds = 0xFFc6AB72FD5ba166a4E81dDa2e7d20892aC6d0bB; address public lockedFundsForthefuture = 0xE51E486B6493C77c372F477d501b009280e8253a; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function GOOREO() public { owner = founder; balanceOf[founder] = totalSupply.mul(25).div(100); balanceOf[developingFund] = totalSupply.mul(55).div(100); balanceOf[activityFunds] = totalSupply.mul(10).div(100); balanceOf[lockedFundsForthefuture] = totalSupply.mul(10).div(100); }",1
0x0d722c159eaacd74eb3fc8ce65832706cf294b33.sol,CoinFlipper,contract CoinFlipper{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0xf3e70642c28f3f707408c56624c2f30ea9f9fce3.sol,AlbosToken,"contract AlbosToken is StandardToken { string constant public name = ; string constant public symbol = ; uint256 public decimals = 18; uint256 public INITIAL_SUPPLY = uint256(28710000000).mul(10 ** decimals); uint256 public foundersSupply = uint256(4306500000).mul(10 ** decimals); uint256 public reservedSupply = uint256(2871000000).mul(10 ** decimals); AlbosWallet public albosWallet; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = totalSupply_; emit Transfer(0x0, address(this), totalSupply_); agentAddress = msg.sender; staff[owner] = true; staff[agentAddress] = true; }",1
0xf3bcbd23bcb10f12905bb075fcf775dfa04e0bbd.sol,AuctionityEventToken,"contract AuctionityEventToken is ERC721Token { address mintMaster; modifier mintMasterOnly() { require (msg.sender == mintMaster, ); _; }",1
0x6c9ece80505a55c4fc373900994800340a5e2e14.sol,CGENToken,contract CGENToken is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint128 public availableSupply; struct vesting { uint createdAt; uint128 amount; uint8 releaseRate; uint32 releaseIntervalSeconds; uint8 nextReleasePeriod; bool completed; },1
0x75031ec38fa67370f7bcf0c173af241b321c62c5.sol,Ticket,contract Ticket is StandardToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 0; uint256 constant public price = 1.25 ether; uint256 constant public MAX = 50; bool public isEnd = false; address public wallet; function Ticket (address _wallet) public { wallet = _wallet; },1
0x4b3b99e956588b54f5841f2fb7c63721e6c7c392.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x0381e7c68a576403988336e8c6ad25409f883138.sol,BMGame,contract BMGame is BMEvents { using SafeMath for *; using BMKeysCalcLong for uint256; address public Banker_Address; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public pID_ = 0; mapping(address => uint256) public pIDxAddr_; mapping(uint256 => BMDatasets.Player) public plyr_; mapping(uint256 => mapping(uint256 => BMDatasets.PlayerRounds)) public plyrRnds_; uint256 public rID_; mapping(uint256 => BMDatasets.Round) public round_; mapping(uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping(uint256 => BMDatasets.TeamFee) public fees_; mapping(uint256 => BMDatasets.PotSplit) public potSplit_; address public owner; constructor() public { owner = msg.sender; fees_[0] = BMDatasets.TeamFee(70); fees_[1] = BMDatasets.TeamFee(55); fees_[2] = BMDatasets.TeamFee(40); fees_[3] = BMDatasets.TeamFee(30); potSplit_[0] = BMDatasets.PotSplit(50); potSplit_[1] = BMDatasets.PotSplit(40); potSplit_[2] = BMDatasets.PotSplit(25); potSplit_[3] = BMDatasets.PotSplit(10); },1
0x2da4bb51e59d0b156b5e19bb3f8eff0279e1ffa2.sol,PuertoRicoHurricaneRelief_SaintCoinCaller,"contract PuertoRicoHurricaneRelief_SaintCoinCaller is Owned { address saintCoinAddress; address fundationWalletAddress; uint public percentForHelpCoin = 10; function PuertoRicoHurricaneRelief_SaintCoinCaller(address _saintCoinAddress, address _fundationWalletAddress) public { require(_saintCoinAddress != address(0x0)); require(_fundationWalletAddress != address(0x0)); saintCoinAddress = _saintCoinAddress; fundationWalletAddress = _fundationWalletAddress; }",1
0x6cf9af470571026bafc48d5dd23b0521e9595394.sol,fortunes,contract fortunes { string public standard = ; string public name; string public symbol; uint8 public decimals; address owner; uint public max_fortunes; uint public unopened_bid; bytes32[] public ur_luck; struct fortune { address original_owner; address original_minter; address current_owner; uint32 number; uint8 level; bytes32[144] img; bytes32 str_luck; bytes32 str_name; bool has_img; bool opened; bool forsale; uint current_bid; address current_bidder; uint bid_cnt; uint auction_end; },1
0x279594b6843014376a422ebb26a6eab7a30e36f0.sol,OasisDirectProxy,"contract OasisDirectProxy is DSMath { function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal { wethToken.withdraw(wethAmt); require(msg.sender.call.value(wethAmt)()); }",1
0x1fe4de38647778255a47060769942c360fbc5b71.sol,NewChance,"contract NewChance is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xdF762c13796758D89C91F7fdac1287b8Eeb294c4); address private admin1 = 0xFf387ccF09fD2F01b85721e1056B49852ECD27D6; address private admin2 = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 12 hours; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 2 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(36,0); fees_[1] = F3Ddatasets.TeamFee(59,0); fees_[2] = F3Ddatasets.TeamFee(66,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(7,0); potSplit_[1] = F3Ddatasets.PotSplit(22,0); potSplit_[2] = F3Ddatasets.PotSplit(12,0); potSplit_[3] = F3Ddatasets.PotSplit(27,0); }",1
0xeed3856ecbcb09b20cba1b3f5d448fed860483ba.sol,DappleAirdrops,"contract DappleAirdrops is Ownable { using SafeMath for uint256; mapping (address => uint256) public bonusDropsOf; mapping (address => uint256) public ethBalanceOf; mapping (address => bool) public tokenIsBanned; mapping (address => uint256) public trialDrops; uint256 public rate; uint256 public dropUnitPrice; uint256 public bonus; uint256 public maxDropsPerTx; uint256 public maxTrialDrops; string public constant website = ; event BonusCreditGranted(address indexed to, uint256 credit); event BonusCreditRevoked(address indexed from, uint256 credit); event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit); event AirdropInvoked(address indexed by, uint256 creditConsumed); event BonustChanged(uint256 from, uint256 to); event TokenBanned(address indexed tokenAddress); event TokenUnbanned(address indexed tokenAddress); event EthWithdrawn(address indexed by, uint256 totalWei); event RateChanged(uint256 from, uint256 to); event MaxDropsChanged(uint256 from, uint256 to); event RefundIssued(address indexed to, uint256 totalWei); event ERC20TokensWithdrawn(address token, address sentTo, uint256 value); function DappleAirdrops() public { rate = 10000; dropUnitPrice = 1e14; bonus = 20; maxDropsPerTx = 100; maxTrialDrops = 100; }",1
0xd25eccb97bfb908037de647d342dc055fc3785a2.sol,ERC20,"contract ERC20 is IERC20,LockToken{ using SafeMath for uint256; mapping (address => uint256) public _balances; mapping (address => mapping (address => uint256)) public _allowed; uint256 public _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; }",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0xe310fe78974df2c7df6262208582bf7e04cdc18e.sol,Solitaire3D,contract Solitaire3D is modularLong { using SafeMath for *; using S3DKeysCalcLong for uint256; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 seconds; uint256 private rndGap_ = 30 seconds; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 24 hours; address constant private developer = 0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897; address constant private operator = 0xc3F465FD001f78DCEeF6f47FD18E3B04F95f2337; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => S3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => S3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => S3Ddatasets.Round) public round_; uint256 public pID_; S3Ddatasets.TeamFee public fee_; constructor() public { fee_ = S3Ddatasets.TeamFee(50); plyr_[1].addr = 0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897; pIDxAddr_[0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897] = 1; pID_ = 1; },1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,AT01Token,"contract AT01Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xed7e6166ddf926dcb724696c1310fb0b3aad4dc4.sol,FlowStop,contract FlowStop is Owned { bool public stopped = false; modifier stoppable { assert (!stopped); _; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x4c9b31eeca8da5a63237097176691bef68e8b8c5.sol,PunkLombard,contract PunkLombard { address public CryptoPunksContract; uint256 public loanAmount; uint256 public punkIndex; uint256 public annualInterestRate; uint256 public loanTenor; uint256 public loanPeriod; address public lender; address public borrower; uint256 public loanStart; uint256 public loanEnd; uint256 public interest; address public contractOwner; modifier onlyOwner { if (msg.sender != contractOwner) revert(); _; },1
0x0758e84059e559a4ddf30981173ca811d5daa5b4.sol,RUCCOIN,"contract RUCCOIN is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20000000000000000000; uint256 public distributeAmount = 0; bool public mintingFinished = false; address public founder = 0x47724565d4d3a44ea413a6a3714240d4743af591; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor() public { owner = founder; balanceOf[founder] = totalSupply; }",1
0xf209c9e2d743242e58bafda6dc3f59008ab8d8ed.sol,WhitelistedCrowdsale,"contract WhitelistedCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; struct Contract { uint256 rate; uint256 minInvestment; }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,BulleonCrowdsale,"contract BulleonCrowdsale is Claimable, CanReclaimToken { using SafeMath for uint256; event AddedToBlacklist(address wallet); event RemovedFromBlacklist(address wallet); string public version = ; address public withdrawWallet = 0xAd74Bd38911fE4C19c95D14b5733372c3978C2D9; uint256 public endDate = 1546300799; BulleonToken public rewardToken; uint256[] public tokensRate = [ 1000, 800, 600, 400, 200, 100, 75, 50, 25, 10 ]; uint256[] public tokensCap = [ 760000, 760000, 760000, 760000, 760000, 760000, 760000, 760000, 760000, 759000 ]; mapping(address=>bool) public isBlacklisted; uint256 public totalSold = 329406072304513072322000; uint256 public soldOnStage = 329406072304513072322000; uint8 public currentStage = 0; uint256 public bonus = 0; uint256 constant BONUS_COEFF = 1000; mapping(address=>uint256) public investmentsOf; function isActive() public view returns (bool) { return !(availableTokens() == 0 || now > endDate); }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0xcfc2241f9c699e132b445dcb85998fb982e23b31.sol,HLWCOIN,"contract HLWCOIN is ERC20,Ownable{ using SafeMath for uint256; string public constant name=; string public symbol=; string public constant version = ; uint256 public constant decimals = 18; uint256 public constant MAX_SUPPLY=200000000*10**decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event GetETH(address indexed _from, uint256 _value); function HLWCOIN(){ balances[msg.sender] = MAX_SUPPLY; Transfer(0x0, msg.sender, MAX_SUPPLY); }",1
0x01c385948f22ac1a9dfebdc423ee3a2e29ec5751.sol,OwnerContract,contract OwnerContract is DelayedClaimable { Claimable public ownedContract; address public pendingOwnedOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); if (ownedContract.owner() != address(this)) { ownedContract.claimOwnership(); },1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x28933055016731c1360d7422fbe6e73aaf3b1b1e.sol,YEX,"contract YEX is SafeMath { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function YEX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0x25e0d7854a0ecff7bccf8b119ace36806dae44be.sol,Champion,"contract Champion is WWC { event VoteSuccessful(address user,uint256 team, uint256 amount); using SafeMath for uint256; struct Vote { mapping(address => uint256) amounts; uint256 totalAmount; address[] users; mapping(address => uint256) weightedAmounts; uint256 weightedTotalAmount; }",1
0xee418a19d6620aa478489032c2cb63464dd3e690.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x6bba97fa60ed6339ca583b8b40c2fd0c12284c2f.sol,Dividends,contract Dividends { using SafeMath for *; uint private constant FIXED_POINT = 1000000000000000000; struct Scheme { uint value; uint shares; uint mask; },1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0x0e42d85f2cf1c3f8bd8fef93ad9f16bd3c6d4b34.sol,KEP,"contract KEP is ERC20,Ownable{ using SafeMath for uint256; string public constant name=; string public symbol=; string public constant version = ; uint256 public constant decimals = 18; uint256 public totalSupply; uint256 public constant MAX_SUPPLY=250000000*10**decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event GetETH(address indexed _from, uint256 _value); function KEP(){ totalSupply=MAX_SUPPLY; balances[msg.sender] = MAX_SUPPLY; Transfer(0x0, msg.sender, MAX_SUPPLY); }",1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { uint constant UPGRADE_FREEZE_TIME = 3 days; using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; address pendingVersion; uint pendingVersionTimestamp; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0xa1ad52ff49fc70b7920b7d02483a58beb15d492b.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private owner = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private opAddress = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private comAddress = 0x24D160101C72c035287f772a8ac2b744a477F489; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0f717ffff71e639636fcdd33727ee8c17c4724bf); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 2 hours; uint256 constant private comDropGap_ = 24 hours; uint256 constant private rndNTR_ = 168 hours; uint256 public airDropPot_; uint256 public airDropPot2_; uint256 public airDropTracker_ = 0; uint256 public airDropTracker2_ = 0; uint256 public rID_; uint256 public comReWards_; uint256 public comAirDrop_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => uint256) public inviteCount_; mapping (address => bool) public addrLock_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => uint256[10]) public lastTen_; mapping (uint256 => uint256) public roundBetCount_; mapping (uint256 => mapping (uint256 =>uint256)) public comDropLastTime_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(48,0); fees_[1] = F3Ddatasets.TeamFee(33,0); fees_[2] = F3Ddatasets.TeamFee(18,0); potSplit_[0] = F3Ddatasets.PotSplit(10,20); potSplit_[1] = F3Ddatasets.PotSplit(5,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0x27945afcdea13201263bfe8c71d2e8fdffd35ff7.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 public trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping (address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3.sol,DeCenterToken,"contract DeCenterToken is owned, queue, DSMath { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 10000000000000000; uint256 public availableTokens = 6000000000000000; uint256 public teamAndExpertsTokens = 4000000000000000; uint256 public price = 0.0000000001 ether; uint public startTime; uint public refundStartTime; uint public refundDuration = 3 days; uint public firstStageDuration = 3 days; uint public lastScheduledTopUp; uint public lastProcessedDay = 3; uint public maxDailyCap = 3333300000000; mapping (uint => uint) public dailyTotals; uint public queuedAmount; address public beneficiary; address public expertsAccount; address public teamAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); uint public cTime = 0; function setCTime(uint _cTime) onlyOwner { cTime = _cTime; }",1
0x330839ef82d34801bd96e75a4ee778ac56fa1ed8.sol,ICOStartToken,"contract ICOStartToken is BurnableToken, MintableToken, DetailedERC20, LockableWhitelisted { uint256 constant internal DECIMALS = 18; function ICOStartToken (uint256 _initialSupply) public BurnableToken() MintableToken() DetailedERC20(, , uint8(DECIMALS)) LockableWhitelisted() { require(_initialSupply > 0); mint(owner, _initialSupply); finishMinting(); addAddressToWhitelist(owner); lock(); }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x7932f0fd456084c829336452d6001f3c7dbf5639.sol,AirDrop,"contract AirDrop is onlyOwner{ Token token; address _creator = 0x073db5ac9aa943253a513cd692d16160f1c10e74; event TransferredToken(address indexed to, uint256 value); constructor() public{ address _tokenAddr = 0x99092a458b405fb8c06c5a3aa01cffd826019568; token = Token(_tokenAddr); }",1
0x732c6f4f1cf13d850d71e9dad229997db0818a52.sol,ERC20,contract ERC20 { using SafeMath for uint256; address public owner; address public admin; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant initSupply = 60000000 * 10**decimals; uint256 public constant supplyReserveVal = 37500000 * 10**decimals; uint256 public totalSupply; uint256 public icoSalesSupply = 0; uint256 public icoReserveSupply = 0; uint256 public softCap = 5000000 * 10**decimals; uint256 public hardCap = 21500000 * 10**decimals; uint256 public icoDeadLine = 1533513600; bool public isIcoPaused = false; bool public isStoppingIcoOnHardCap = true; modifier duringIcoOnlyTheOwner() { require( now>icoDeadLine || msg.sender==owner ); _; },1
0xa25d9e3c177a45265349d4bd37b23ec2669dea5b.sol,BMVCoin,"contract BMVCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BMVCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,TokenSale,"contract TokenSale is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; rateInterface public rateContract; address public wallet; address public advisor; uint256 public advisorFee; uint256 public constant decimals = 18; uint256 public endTime; uint256 public startTime; mapping(address => bool) public rc; function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public { tokenContract = tokenInterface(_tokenAddress); rateContract = rateInterface(_rateAddress); setTime(_startTime, _endTime); wallet = msg.sender; advisor = msg.sender; advisorFee = 0 * 10**3; }",1
0x1cf88aa9469219e9ffe8023e79f35866fd9b89ab.sol,Rhenium,"contract Rhenium is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x47da42696a866cdc61a4c809a515500a242909c1.sol,BITToken,"contract BITToken is MintableToken, PausableToken { event Vested(address indexed beneficiary, address indexed vestingContract, uint256 releaseDate, uint256 amount); event BITTransfer(address indexed _from, address indexed _to, uint256 _value, bytes32 data); uint256 public constant decimals = 18; string public constant name = ; string public constant symbol = ; function BITToken () public MintableToken() { }",1
0xb3f4c7cc6465ac798200c925f4df3dbbb5de2f39.sol,LockAccountTime,contract LockAccountTime { address lockaccount = 0x47494eE7ae09AFb5Dd6Af375ea9630709171cdeE; uint start = 1563373817; constructor() public{ },1
0x4498f897505d0e6991edeab24bc7b5727d72de28.sol,RFCICO,"contract RFCICO { using SafeMath for uint256; address public wallet; address public RFC; uint256 public price = 303; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public{ wallet = 0x1c46A08C940D9433297646cBa10Bc492c7D53A82; RFC = 0xed1CAa23883345098C7939C44Fb201AA622746aD; tokenReward = token(RFC); }",1
0x552b00454a23e5f118e5419cc84f82100ed1bd38.sol,SATEToken,"contract SATEToken is EIP20Interface, SafeMath { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string constant public name = ; uint8 constant public decimals = 18; string constant public symbol = ; mapping (address => uint256) public addressType; mapping (address => uint256[3]) public releaseForSeed; mapping (address => uint256[5]) public releaseForTeamAndAdvisor; event AllocateToken(address indexed _to, uint256 _value, uint256 _type); address public owner; uint256 public finaliseTime; function SATEToken() public { totalSupply = 20*10**26; balances[msg.sender] = totalSupply; owner = msg.sender; }",1
0x29488e24cfdaa52a0b837217926c0c0853db7962.sol,SuperCard,"contract SuperCard is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xb838c100EB1a1d08B215FBbCC06698e9c181358C); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 4637 seconds; uint256 constant private rndInc_ = 15 seconds; uint256 constant private rndMax_ = 3 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(19,4); fees_[1] = F3Ddatasets.TeamFee(37,6); fees_[2] = F3Ddatasets.TeamFee(67,7); potSplit_[0] = F3Ddatasets.PotSplit(15,30); potSplit_[1] = F3Ddatasets.PotSplit(25,25); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0x29e8c6541ce50cbd1b52f719926ae805f99535f9.sol,SwapController,"contract SwapController is DSAuth, TokenController { Controlled public controlled; TokenTransferGuard[] guards; function SwapController(address _token, address[] _guards) { controlled = Controlled(_token); for (uint i=0; i<_guards.length; i++) { addGuard(_guards[i]); }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x2ea313b7e47b79e82bd9a6e00364cd1bdf2355f5.sol,HamsterWarsToken,contract HamsterWarsToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xcf27927ba504d01d7303bc3636b6a7e15d3cffd3.sol,DChat,"contract DChat is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 6000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 2000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,TokenRK50Z,"contract TokenRK50Z is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = false; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRK50Z() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,ERC721BasicToken,"contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { using SafeMath for uint256; using AddressUtils for address; bytes4 private constant ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; constructor() public { _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); }",1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0x6ebe55e8c9165d6d1bb3239a31dbba0c2f47fe56.sol,iCashweb,"contract iCashwebToken is iERC20, ICWToken { mapping( address => mapping(address => uint256) ) internal _allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != msg.sender); require(_value <= balances[_from]); require(_value <= _allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x25d14913c49b7e7808453044f7e2f12b89693dda.sol,CXE,"contract CXE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 2800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 500000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x53dc2d4c1908fa96d8ceef7c8e23a74da0a9bba1.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; otherFoMo3D private otherF3D_; DiviesCTR constant private Divies = DiviesCTR(0x88B30117e7EaFCDa49542D5530D383146ca9af70); address constant private FeeAddr = 0x1C7584476a8d586c3dd8f83864D0d5cd214492E9; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x30aa3C69fE10022Bca0A158b42FFC739Aa10b1e5); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 1 hours; uint256 constant private rndInit_ = 8 hours; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 8 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(56,10); fees_[1] = F3Ddatasets.TeamFee(56,10); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(56,10); potSplit_[0] = F3Ddatasets.PotSplit(20,20); potSplit_[1] = F3Ddatasets.PotSplit(20,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); }",1
0xf15f61643eea73be40ad9b72c09ed381fac7a256.sol,FishbankBoosters,contract FishbankBoosters is Ownable { struct Booster { address owner; uint32 duration; uint8 boosterType; uint24 raiseValue; uint8 strength; uint32 amount; },1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x92277b492f4398f1c74d13ac87faece4d7f49000.sol,IcoExt,contract IcoExt { address public authorizedCaller; address public collectorAddress; address public owner; address public whitelistAdd; address public tokenAdd; address public tokenSpender; uint public initialPrice; uint public initialTime; uint tokenPrice; uint increasePerBlock; uint increasePerBlockDiv; bool public autoPrice; bool public isPaused; uint public minAcceptedETH; uint public tokenDecimals; uint public tokenMult; uint8 public stage; uint public totalReceived; uint public totalSent; function IcoExt() { authorizedCaller = msg.sender; owner = msg.sender; collectorAddress = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f; tokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a; tokenSpender = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f; whitelistAdd = 0xad56C554f32D51526475d541F5DeAabE1534854d; autoPrice = true; authorized[authorizedCaller] = true; minAcceptedETH = 0.05 ether; tokenDecimals = 10; tokenMult = 10 ** tokenDecimals; initialPrice = 10000 * tokenMult; tokenPrice = initialPrice; autoPrice = false; initialTime = now; increasePerBlock = 159; increasePerBlockDiv = 1000000000; stage = 0; },1
0x02611ca37364d30ac9a11ade6b02aad288127c98.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; address public admin = 0x9Ef4a2CaA82D396d7B8c244DE57212E0fE332C73; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[admin] = totalSupply; emit Transfer(this,admin,totalSupply); }",1
0x409e1820aba80fd6bc0f7573528f56cd3ccbfafb.sol,Linamyd,contract Linamyd { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2768b5b919a597254151c90acfdbb137fb30f32d.sol,TokenTimelock,"contract TokenTimelock { using SafeERC20 for ERC20Basic; ERC20Basic public token; address public beneficiary; uint256 public releaseTime; constructor( ERC20Basic _token, address _beneficiary, uint256 _releaseTime ) public { require(_releaseTime > block.timestamp); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; }",1
0x26d76a22859fec45da123dbf3e14053a8b5b0831.sol,FullFOMO,"contract FullFOMO is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5A3e43Ba22D1590C21ecB364f8fb46c17d683364); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 10 minutes; uint256 private rndGap_ = 10 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 22 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(60,0); fees_[1] = F3Ddatasets.TeamFee(60,0); fees_[2] = F3Ddatasets.TeamFee(60,0); fees_[3] = F3Ddatasets.TeamFee(60,0); potSplit_[0] = F3Ddatasets.PotSplit(25,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(25,0); potSplit_[3] = F3Ddatasets.PotSplit(25,0); }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,LTToken,"contract LTToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherOwnership,"contract AetherOwnership is AetherBase, ERC721 { string public name = ; string public symbol = ; function implementsERC721() public pure returns (bool) { return true; }",1
0x26b4b55f4d4eea666dfd72998466d3523afc3258.sol,PrivatePreSale,"contract PrivatePreSale is Claimable, KYCWhitelist, Pausable { using SafeMath for uint256; address public constant FUNDS_WALLET = 0xDc17D222Bc3f28ecE7FCef42EDe0037C739cf28f; address public constant TOKEN_WALLET = 0x1EF91464240BB6E0FdE7a73E0a6f3843D3E07601; address public constant TOKEN_ADDRESS = 0x14121EEe7995FFDF47ED23cfFD0B5da49cbD6EB3; address public constant LOCKUP_WALLET = 0xaB18B66F75D13a38158f9946662646105C3bC45D; ERC20 public constant TOKEN = ERC20(TOKEN_ADDRESS); uint256 public constant TOKENS_PER_ETH = 4970; uint256 public constant MAX_TOKENS = 20000000 * (10**18) - 119545639989300000000000; uint256 public constant MIN_TOKEN_INVEST = 4970 * (10**18); uint256 public START_DATE = 1531915200; uint256 public weiRaised; uint256 public tokensIssued; bool public closed; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public { require(TOKENS_PER_ETH > 0); require(FUNDS_WALLET != address(0)); require(TOKEN_WALLET != address(0)); require(TOKEN_ADDRESS != address(0)); require(MAX_TOKENS > 0); require(MIN_TOKEN_INVEST >= 0); }",1
0x3659e8daa4bab9a263b3e43ec63c068dfbc1246f.sol,Factory,contract Factory { address[] public artworks; address registrar = 0xC636277B8250e62632467B7Db19ed9111E25EB99; function getContractCount() public constant returns(uint contractCount) { return artworks.length; },1
0x56434ad1e38a564e76eae08c7118e5e7b450aa6c.sol,PlayerExchangeCore,"contract PlayerExchangeCore { event InitialPlayerOffering(address indexed contractAddress, string name, string symbol); event DividendWithdrawal(address indexed user, uint amount); using SafeMath for uint256; address public owner; address public referee; struct DividendWinner { uint playerTokenContractId; uint perTokenEthValue; uint totalTokens; uint tokensProcessed; }",1
0x4839e3de8737769e0f93f176d157dca5e48b7662.sol,CPCToken,"contract CPCToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CPCToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x55fe4eaae4c2636d1f0ae63542617564c3832edf.sol,FoMo3DFast,contract FoMo3DFast is F3Devents { using SafeMath for *; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF2940f868fcD1Fbe8D1E1c02d2eaF68d8D7Db338); address private admin = msg.sender; uint256 constant private rndInc_ = 60 seconds; uint256 constant private smallTime_ = 5 minutes; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; uint256 constant public keyPricePot_ = 10000000000000000; mapping(address => uint256) public pIDxAddr_; mapping(uint256 => F3Ddatasets.PlayerVault) public plyr_; mapping(uint256 => mapping(uint256 => F3Ddatasets.PlayerRound)) public plyrRnds_; mapping(uint256 => F3Ddatasets.Auction) public auction_; mapping(uint256 => F3Ddatasets.BigPot) public bigPot_; F3Ddatasets.SmallPot public smallPot_; mapping(uint256 => uint256) public rndTmEth_; uint256 private keyMax_ = 0; address private keyMaxAddress_ = address(0); uint256 private affKeyMax_ = 0; uint256 private affKeyMaxPlayId_ = 0; constructor() public { },1
0xe0f09417471306f439f0295390eb03e3978da38c.sol,RETC,"contract RETC is ERC20 { using SafeMath for uint256; address owner = msg.sender; address locker15 = msg.sender; address locker10 = msg.sender; address locker05 = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) lockdata; mapping (address => mapping (uint256 => uint256)) locktime; mapping (address => mapping (uint256 => uint256)) lockday; string public constant name = ; string public constant symbol = ; uint public constant decimals = 3; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xede4edd0c0209db3172a9a07607b47fcf57e6355.sol,EthereumUnionToken,"contract EthereumUnionToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EthereumUnionToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 12500000000000; balances[0xfb58a9af395755a4e95805d76bae231feb01a192] = _totalSupply; emit Transfer(address(0), 0xfb58a9af395755a4e95805d76bae231feb01a192, _totalSupply); }",1
0x5bf554632a059ae0537a3eeb20aced49348b8f99.sol,SoulToken,"contract SoulToken is ERC20Token{ string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 6; uint256 public constant unit = 1000000; uint8 public constant obol = 10; uint256 public constant napkinPrice = 10 finney / unit; uint256 constant totalSupply_ = 144000 * unit; mapping(address => string) reasons; mapping(address => uint256) soulPrices; mapping(address => address) ownedBy; mapping(address => uint256) soulsOwned; mapping(uint256 => address) soulBook; address public owner; address public charonsBoat; uint256 public bookingFee; uint256 public soulsForSale; uint256 public soulsSold; uint256 public totalObol; event SoulTransfer(address indexed _from, address indexed _to); function SoulToken() public{ owner = msg.sender; charonsBoat = msg.sender; bookingFee = 13 finney; soulsForSale = 0; soulsSold = 0; totalObol = 0; balances[this] = totalSupply_; payOutNapkins(1111 * unit); }",1
0xde4f1f39242e779f4ae6324e06fb30ba3e14e377.sol,KTuneCustomToken,"contract KTuneCustomToken is Ownable { event LogBurnFinished(); event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan); KTunePricingPlan public pricingPlan; address public serviceProvider; bool public burningFinished; modifier onlyServiceProvider() { require(msg.sender == serviceProvider, ); _; }",1
0x2da4bb51e59d0b156b5e19bb3f8eff0279e1ffa2.sol,PuertoRicoHurricaneRelief_SaintCoinCaller,"contract PuertoRicoHurricaneRelief_SaintCoinCaller is Owned { address saintCoinAddress; address fundationWalletAddress; uint public percentForHelpCoin = 10; function PuertoRicoHurricaneRelief_SaintCoinCaller(address _saintCoinAddress, address _fundationWalletAddress) public { require(_saintCoinAddress != address(0x0)); require(_fundationWalletAddress != address(0x0)); saintCoinAddress = _saintCoinAddress; fundationWalletAddress = _fundationWalletAddress; }",1
0xa584c5eaccb5dd4a5c0fc0a785dee952becc4c06.sol,Crowdsale,contract Crowdsale { uint256 public price; token public tokenReward; address owner; uint256 public amount; modifier onlyCreator() { require(msg.sender == owner); _; },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4bea1b5de7e3f09f6131408bc306b1de411a3957.sol,apexTWO,contract apexTWO { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x20a35ada16321d18ba2e72bd5fe81bc23515dbd9.sol,ProofOfVerifiedContract,contract ProofOfVerifiedContract { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xa2edca10311a70883c5019b51048f55fd1508fe6.sol,FoMo3DshortAgain,"contract FoMo3DshortAgain is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 30 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0xaa840b1138d31cc4a5fcd9545ed03441ef2a1213.sol,DIVIUMx2,contract DIVIUMx2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x5573cb8589a2ed0ca4029202739bfc251932201f.sol,STRATCO,"contract STRATCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x5044ac8da9601edf970dcc91a10c5f41c5c548c0.sol,UPower,contract UPower { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xedebe7749b91a475918750842256f23fbe8e3029.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x02dc001b5e9191a51b338950d8cdea1cb4481bb3.sol,SponseeTokenModel,"contract SponseeTokenModel is StandardToken { string public name; string public symbol; uint8 public decimals = 0; uint public totalSupply = 0; uint public cap = 100000000; uint public minimumSupport = 500; uint public etherRatioForInvestor = 10; address public sponseeAddress; bool public isPayableEnabled = true; RBInformationStore public rbInformationStore; Rate public rate; event LogReceivedEther(address indexed from, address indexed to, uint etherValue, string tokenName); event LogBuy(address indexed from, address indexed to, uint indexed value, uint paymentId); event LogRollbackTransfer(address indexed from, address indexed to, uint value); event LogExchange(address indexed from, address indexed token, uint value); event LogIncreaseCap(uint value); event LogDecreaseCap(uint value); event LogSetRBInformationStoreAddress(address indexed to); event LogSetName(string name); event LogSetSymbol(string symbol); event LogMint(address indexed to, uint value); event LogChangeSponseeAddress(address indexed to); event LogChangeIsPayableEnabled(bool flag); modifier onlyAccountAddressForSponsee() { require(rbInformationStore.accountAddressForSponsee() == msg.sender); _; }",1
0x1e2e9cabb5744c314de7978c081bd57c357e000d.sol,CryptoMyWord,"contract CryptoMyWord { using SafeMath for uint256; using strings for *; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event NewWord(uint wordId, string name, uint price); address private owner; uint256 nameTokenId; uint256 tokenId; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.8 ether; uint256 private increaseLimit2 = 1.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) public ownerOfItem; mapping (address => string) public nameOfOwner; mapping (address => string) public snsOfOwner; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => string) private nameOfItem; mapping (uint256 => string) private urlOfItem; mapping (uint256 => address[]) private borrowerOfItem; mapping (string => uint256[]) private nameToItems; mapping (uint256 => address) private approvedOfItem; mapping (string => uint256) private nameToParents; mapping (string => uint256) private nameToNameToken; mapping (string => string) private firstIdOfName; mapping (string => string) private secondIdOfName; function CryptoMyWord () public { owner = msg.sender; admins[owner] = true; }",1
0xed7e6166ddf926dcb724696c1310fb0b3aad4dc4.sol,BuyFlowingHair100ETH,"contract BuyFlowingHair100ETH is Owned, FlowStop, Utils { using SafeMath for uint; ERC20Interface public flowingHairAddress; function BuyFlowingHair100ETH(ERC20Interface _flowingHairAddress) public{ flowingHairAddress = _flowingHairAddress; }",1
0x182d4990bb0ff595b308b3efcb93313abad575e7.sol,PoolOwners,"contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; itmap.itmap private ownerMap; mapping(address => mapping(address => uint256)) public allowance; mapping(address => mapping(address => uint256)) public stakes; mapping(address => uint256) public stakeTotals; mapping(address => bool) public tokenWhitelist; mapping(address => bool) public whitelist; mapping(address => uint256) public distributionMinimum; uint256 public totalContributed = 0; uint256 public precisionMinimum = 0.04 ether; uint256 private valuation = 4000 ether; uint256 private hardCap = 1000 ether; uint256 private distribution = 1; bool public distributionActive = false; bool public locked = false; bool private contributionStarted = false; address public wallet; address private dToken = address(0); uint public constant totalSupply = 4000 ether; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; event Contribution(address indexed sender, uint256 share, uint256 amount); event TokenDistributionActive(address indexed token, uint256 amount, uint256 amountOfOwners); event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount); event TokenDistributionComplete(address indexed token, uint amount, uint256 amountOfOwners); event OwnershipStaked(address indexed owner, address indexed receiver, uint256 amount); event OwnershipStakeRemoved(address indexed owner, address indexed receiver, uint256 amount); modifier onlyPoolOwner() { require(ownerMap.get(uint(msg.sender)) != 0, ); _; }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,MainBonus,"contract MainBonus is BasicTime,BasicAuth,MainBase,MainCard { uint constant BASERATIO = 10000; struct PlayerBonus { uint m_DrawedDay; uint16 m_DDPermanent; mapping(uint => uint16) m_DayStatic; mapping(uint => uint16) m_DayPermanent; mapping(uint => uint32[]) m_DayDynamic; }",1
0x313c54eb9f08f1be0f18e8ad505135fa7041a52f.sol,CHEXToken,"contract CHEXToken is Token { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public startBlock; uint public endBlock; address public founder; address public owner; uint public totalSupply = 2000000000 * 10**decimals; uint public etherCap = 2500000 * 10**decimals; uint public totalTokens = 0; uint public presaleSupply = 0; uint public presaleEtherRaised = 0; event Buy(address indexed recipient, uint eth, uint chx); event Deliver(address indexed recipient, uint chx, string _for); uint public presaleAllocation = totalSupply / 2; uint public ecosystemAllocation = totalSupply / 4; uint public reservedAllocation = totalSupply / 4; bool public ecosystemAllocated = false; uint public constant MIN_ETHER = 10 finney; enum TokenSaleState { Initial, Presale, Live, Frozen }",1
0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff.sol,BTYCEC,contract BTYCEC is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sysusermoney; uint public sysoutmoney; uint public sellPrice; uint public buyPrice; uint public btycbuyPrice; uint public btycsellPrice; uint public sysPer; uint public sysPrice1; uint public sysPer1; uint public systime1; uint public sysPrice2; uint public sysPer2; uint public systime2; uint public transper; bool public actived; uint public onceAddTime; uint public upper1; uint public upper2; uint public teamper1; uint public teamper2; uint public outper1; uint public outper2; uint public sellper; uint public sysday; uint public sysminteth; uint public hasoutmony; uint public hasbuymoney; uint public hassellmoney; uint public hasbuyeth; uint public hasselleth; uint public hasbtycbuymoney; uint public hasbtycsellmoney; mapping(address => uint) balances; mapping(address => uint) myeth; mapping(address => uint) froeth; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => address) public fromaddr; mapping(address => uint) public crontime; mapping(address => uint) public mintnum; uint[] public permans; mapping(address => uint) public teamget; struct sunsdata{ uint n1; uint n2; uint getmoney; },1
0x26ddf6cabadcbf4f013841bd8d914830beb0d984.sol,KuaiMintableToken,"contract KuaiMintableToken is BonusToken { uint256 public standardDailyLimit; uint256 public dailyLimitLeft = standardDecimals.mul(1000000); uint256 public lastMintTime = 0; event Mint(address indexed operator, uint256 value, uint256 mintTime); event SetDailyLimit(address indexed operator, uint256 time); function KuaiMintableToken( address _owner, uint256 _dailyLimit ) public BonusToken() { totalSupply_ = 0; createTime = block.timestamp; lastMintTime = createTime; owner = _owner; standardDailyLimit = standardDecimals.mul(_dailyLimit); dailyLimitLeft = standardDailyLimit; }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,Crowdsale,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, BurnableToken { event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint8 public decimals; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable) public UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0x56434ad1e38a564e76eae08c7118e5e7b450aa6c.sol,PlayerToken,"contract PlayerToken is ERC20 { address public owner; bool public paused = false; event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol); event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol); using SafeMath for uint256; uint256 public initialTokenPrice_; uint256 public incrementalTokenPrice_; string public name; string public symbol; uint8 public constant decimals = 0; address public exchangeContract_; BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F); uint256 public playerId_; address public originalOwner_; uint8 constant internal processingFee_ = 5; uint8 constant internal originalOwnerFee_ = 2; uint8 internal dividendBuyPoolFee_ = 15; uint8 internal dividendSellPoolFee_ = 20; uint8 constant internal referrerFee_ = 1; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; address[] public tokenHolders; mapping(address => uint256) public addressToTokenHolderIndex; mapping(address => int256) public totalCost; uint256 totalSupply_; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x25e1779f5f2fbdd378ced1a338f6c26aeb3d6ad0.sol,SpiderFarm,"contract SpiderFarm{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=50; uint256 PSN=10000; uint256 PSNH=5000; uint256 startTime; bool public initialized=false; address public ceoAddress; address public owner; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public snailmasterReq=100000; function becomeSnailmaster() public{ uint256 hasEggs=getMyEggs(); uint256 eggCount=SafeMath.div(hasEggs,EGGS_TO_HATCH_1SHRIMP); require(initialized); require(msg.sender != ceoAddress); require(eggCount>=snailmasterReq); claimedEggs[msg.sender]=0; snailmasterReq=SafeMath.add(snailmasterReq,100000); ceoAddress=msg.sender; }",1
0xbf06e2b5b97e375f7c0b3d8c61b8337a9c7ea23c.sol,FoMoRapid,"contract FoMoRapid is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; address admin; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x56a4d4e31c09558F6A1619DFb857a482B3Bb2Fb6); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); admin = msg.sender; }",1
0x53d4e5bf62a91ec53ea15991e2389310eeb855b2.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public validAddress returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_value > 0); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x415116bad878730f5db008ff381a73222128ad39.sol,EBitCoinCash,contract EBitCoinCash is MintableToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public unlockTimeStamp = 0; mapping (address => bool) private _lockByPass; function EBitCoinCash(uint unlockTs){ setUnlockTimeStamp(unlockTs); },1
0xc68c8956f656d74b93799034f3bba6da4575b247.sol,Hubscop,"contract Hubscop is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public RATE; uint public DENOMINATOR; bool public isStopped = false; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed to, uint256 amount); event ChangeRate(uint256 amount); modifier onlyWhenRunning { require(!isStopped); _; }",1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,JcashRegistrar,"contract JcashRegistrarInterface { event ReceiveEthEvent(address indexed from, uint256 value); event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value); event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value); event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event ReplenishEthEvent(address indexed from, uint256 value); event WithdrawEthEvent(address indexed to, uint256 value); event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value); event PauseEvent(); event UnpauseEvent(); function withdrawEth(uint256 _weivalue) external; function withdrawToken(address _tokenAddress, uint256 _weivalue) external; function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function isProcessedTx(bytes32 _txHash) public view returns (bool); }",1
0x37256d58e298cacaa82aa0527d56521f1b19e1f5.sol,Owned,contract Owned { address public owner; function Owned() { owner = msg.sender; },1
0x516f02475acf19bad0352ce3759c42adaac0000f.sol,ManagedToken,"contract ManagedToken is ERC20Token, MultiOwnable { bool public allowTransfers = false; bool public issuanceFinished = false; ITokenEventListener public eventListener; event AllowTransfersChanged(bool _newState); event Issue(address indexed _to, uint256 _value); event Destroy(address indexed _from, uint256 _value); event IssuanceFinished(); modifier transfersAllowed() { require(allowTransfers); _; }",1
0x6ded330704d6b4734de6dc82b609765006dde197.sol,CryptoStrippers,contract CryptoStrippers{ uint256 public COINS_TO_HATCH_1STRIPPERS = 86400; uint256 public STARTING_STRIPPERS = 500; uint256 PSN = 10000; uint256 PSNH = 5000; bool public initialized = true; address public ceoAddress; mapping (address => uint256) public hatcheryStrippers; mapping (address => uint256) public claimedCoins; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketCoins; function CryptoStrippers() public{ ceoAddress = msg.sender; },1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Declaration,"contract Declaration { mapping (uint => uint8) statusThreshold; mapping (uint8 => mapping (uint16 => uint256)) feeDistribution; uint[8] thresholds = [ 0, 5000, 35000, 150000, 500000, 2500000, 5000000, 10000000 ]; uint[5] referralFees = [50, 30, 20, 10, 5]; uint[5] serviceFees = [25, 20, 15, 10, 5]; constructor() public { setFeeDistributionsAndStatusThresholds(); }",1
0x28f4ae3275f38015c6e6eeefd9288a2d7bc7d023.sol,ClassicVolkswagen,contract ClassicVolkswagen is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function ClassicVolkswagen() { balances[msg.sender] = 300000000000000000000000000; totalSupply = 30000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000; fundsWallet = msg.sender; },1
0x75b90f32dcb0fefa6b72930bbdbe4d289c678d93.sol,VENT,"contract VENT is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; constructor() public { name = ; symbol = ; decimals = 18; initialSupply = 350000000 * 10 ** uint256(decimals); totalSupply_ = initialSupply; balances[msg.sender] = initialSupply; emit Transfer(0x0, msg.sender, initialSupply); }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,MonsterOwnership,"contract MonsterOwnership is MonsterBase, ERC721 { string public constant name = ; string public constant symbol = ; ERC721Metadata public erc721Metadata; bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256()); bytes4 constant InterfaceSignature_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function supportsInterface(bytes4 _interfaceID) external view returns (bool) { return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721)); }",1
0x4b9cf3bb930e3eb8a37645ab28194dcc05e1e0aa.sol,JYToken,contract JYToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0x0d62b001ca7f2fb4f9458f8585a0bb38a4d8fde7.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for RESTOToken; uint256 hardCap = 50000 * 1 ether; address myAddress = this; RESTOToken public token = new RESTOToken(myAddress); uint64 crowdSaleStartTime = 1537401600; uint64 crowdSaleEndTime = 1544745600; TeamAddress1 public teamAddress1 = new TeamAddress1(); TeamAddress2 public teamAddress2 = new TeamAddress2(); MarketingAddress public marketingAddress = new MarketingAddress(); RetailersAddress public retailersAddress = new RetailersAddress(); ReserveAddress public reserveAddress = new ReserveAddress(); BountyAddress public bountyAddress = new BountyAddress(); uint256 public rate; uint256 public weiRaised; event Withdraw( address indexed from, address indexed to, uint256 amount ); event TokensPurchased( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor() public { uint256 totalTokens = token.INITIAL_SUPPLY(); _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000)); _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000)); _deliverTokens(marketingAddress, totalTokens.mul(18).div(100)); _deliverTokens(retailersAddress, totalTokens.mul(9).div(100)); _deliverTokens(reserveAddress, totalTokens.mul(8).div(100)); _deliverTokens(bountyAddress, totalTokens.div(100)); rate = 10000; }",1
0xf3b01ddd7f240e39f5b818cb36d14d69a54f6c8d.sol,ZodiaqDistribution,contract ZodiaqDistribution is Managable { using SafeMathExtended for uint256; ZodiaqToken public token; uint256 public BASE = 10 ** 8; address public bountyOwner; address public referralProgramOwner; address public team; address public partners; bool public isICOFinished = false; uint256 public icoFinishedDate = 0; uint256 public teamReward = 0; uint256 public partnersReward = 0; constructor(address zodiaqToken) public { require(zodiaqToken != 0x0); token = ZodiaqToken(zodiaqToken); },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event FeePaid(address indexed from, address indexed to, uint256 value); event VoidAccount(address indexed from, address indexed to, uint256 value); event Bonus(uint256 value); event Burn(uint256 value); string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 3000000000 * 10 ** uint256(decimals); uint256 public EthPerToken = 300000; uint256 public ChargeFee = 2; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint; mapping(address => uint) balances; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; },1
0x0355e20c49de30e04c7c693911694ba2450e5564.sol,InvoizChain,"contract InvoizChain is ERC20 { using SafeMath for uint256; address owner = 0xBc4b57D2789a0EfF23662F08A4210351909Aa4B0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 1e28; uint256 public tokenPerETH = 1e27; uint256 public valueToGive = 9e19; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17b7ddd2962226ef9428313ed62799060fb812b7.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { using SafeMath for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); function MintableToken(uint _initialSupply, address _multisig, bool _mintable) internal { require(_multisig != address(0)); require(_mintable || _initialSupply != 0); if (_initialSupply > 0) mintInternal(_multisig, _initialSupply); mintingFinished = !_mintable; }",1
0x1f002ba292d85239fee400a04b21bb3aa4777461.sol,FLTTToken,contract FLTTToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 49800000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function FLTTToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,LTToken,"contract LTToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x698674f7537ea6194caa4eb4b9129cd3c395ada8.sol,Neulaut,"contract Neulaut { uint256 public totalSupply = 7*10**27; uint256 public fee = 15*10**18; uint256 public burn = 10**19; address owner; string public name = ; uint8 public decimals = 18; string public symbol = ; mapping (address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function Neulaut() { owner = msg.sender; balances[owner] = totalSupply; }",1
0x72112ee2f2cfb1f8494e78e0c3166a77fb6a2d24.sol,DSMath,"contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); }",1
0x340085ed7d6c18dcf4c8b661fba6bd95916c8644.sol,BoostPax,"contract BoostPax { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4488ed050cd13ccfe0b0fcf3d168216830142775.sol,NetkillerAdvancedTokenAirDrop,"contract NetkillerAdvancedTokenAirDrop { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false; bool public airdropStatus = false; uint256 public airdropTotalSupply; uint256 public airdropCurrentTotal; uint256 public airdropAmount; mapping(address => bool) public touched; event AirDrop(address indexed target, uint256 value); function NetkillerAdvancedTokenAirDrop( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; airdropAmount = 1 * 10 ** uint256(decimals); }",1
0xb601ad76c99337dd3366f8e689ead7db31fa439e.sol,HashFutureToken,contract HashFutureToken is HashFutureBasicToken{ string internal name_; string internal symbol_; address public owner; uint256[] internal allTokens; mapping(uint256 => uint256) internal allTokensIndex; mapping (address => uint256[]) internal ownedTokens; mapping(uint256 => uint256) internal ownedTokensIndex; modifier onlyOwner { require(msg.sender == owner); _; },1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,StandardToken,"contract StandardToken is Token,SafeMath { function approve(address _spender, uint256 _value)public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",1
0xf3b98d8c425c76e0c7abadffddc1a26ce3107e45.sol,MTF,"contract MTF is MintableToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxCap = 1500000000e18; uint256 public totalWeiReceived; uint256 public startTime; uint256 public endTime; bool public paused; event StateChanged(bool); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); function MTF(uint256 _startTime, uint256 _endTime) public { startTime = _startTime; endTime = _endTime; paused = false; totalSupply_ = 0; }",1
0x551d56781e0cd16ac2c61a03e6537844a41c7709.sol,PermissionGroups,contract PermissionGroups { address public admin; address public pendingAdmin; mapping(address=>bool) internal operators; mapping(address=>bool) internal quoters; address[] internal operatorsGroup; address[] internal quotersGroup; uint constant internal MAX_GROUP_SIZE = 50; constructor() public { admin = msg.sender; },1
0xd8cc0ef2b26ff52f86de029cb38ed53b7ed98a57.sol,PumpAndDump,contract PumpAndDump { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0x92a5b04d0ed5d94d7a193d1d334d3d16996f4e13.sol,ERT,"contract ERT is ERC20 { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; address public ico; event Burn(address indexed from, uint256 value); bool public tokensAreFrozen = true; modifier icoOnly { require(msg.sender == ico); _; }",1
0x7934fa8b3ac2213ac42e69a5ec55d624b4c04719.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xdb25f211ab05b1c97d595516f45794528a807ad8.sol,EURSToken,contract EURSToken is AbstractToken { uint256 constant internal FEE_DENOMINATOR = 100000; uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR; uint256 constant internal MIN_FEE_NUMERATIOR = 0; uint256 constant internal MAX_TOKENS_COUNT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / MAX_FEE_NUMERATOR; uint256 constant internal DEFAULT_FEE = 5e2; uint256 constant internal BLACK_LIST_FLAG = 0x01; uint256 constant internal ZERO_FEE_FLAG = 0x02; modifier delegatable { if (delegate == address (0)) { require (msg.value == 0); _; },1
0xda11e959bcaaba5f88dbf4d866e270c78bc84b76.sol,EBP,"contract EBP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,RelayerModule,contract RelayerModule is Module { uint256 constant internal BLOCKBOUND = 10000; mapping (address => RelayerConfig) public relayer; struct RelayerConfig { uint256 nonce; mapping (bytes32 => bool) executedTx; },1
0xbf8be431aa8d8b2f58b6f0727c25a67b41beaaf8.sol,ElamaCoinToken,"contract ElamaCoinToken is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function ElamaCoinToken() public { decimals = 4; _totalSupply = 680000000 * 10**uint(decimals); name = ; symbol = ; balances[owner] = _totalSupply; deprecated = false; }",1
0xee97c0e0bcb326065432db2c2230fab369a0a1b0.sol,QiibeePresale,"contract QiibeePresale is CappedCrowdsale, FinalizableCrowdsale, Pausable { using SafeMath for uint256; struct AccreditedInvestor { uint64 cliff; uint64 vesting; bool revokable; bool burnsOnRevoke; uint256 minInvest; uint256 maxCumulativeInvest; }",1
0x8cd480260a47f04589670a313d27a15b321ad266.sol,Swiftlance,"contract Swiftlance is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public maxSupply = 8000000000e8; uint256 public constant minContrib = 1 ether / 100; uint256 public SWLPerEther = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); constructor () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; owner = msg.sender; }",1
0x71ae0bd9eb29fd697421cf428cd2b51727301fdf.sol,MDKToken,"contract MDKToken is MintableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); TokenTimelock public reserveTokens; TokenVesting public teamTokens; address public PreICO = address(0); address public ICO = address(0); function MDKToken(address _teamFund) public { lockTeamTokens(_teamFund); lockReserveTokens(_teamFund); mint(_teamFund, 250000000 * (10 ** uint256(decimals))); pause(); }",1
0xf4fbef849bcf02ac4b305c2bc092fc270a14124c.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2119a3314c1d40704d816392a9e44da463688992.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address prize_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr1 = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr2 = 0x6c7dfe3c255a098ea031f334436dd50345cfc737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x748286a6a4cead7e8115ed0c503d77202eeeac6b); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x269a6ffb97325e8e371f067fea216c9f62848833.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 0 minutes; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool CoolingMutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x4c49d776c1c314d16b82ecac7ed8f70433db757d.sol,caspianToken,"contract caspianToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function caspianToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply=10000000000000000000000000000; }",1
0x729b59c57f3aadf114daeec77d19168b1b1c6b11.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x1ed3099df8a56c447e7c20d08572413f15fe760e.sol,ECT,contract ECT { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x716989fa21d5043165079ddbfd04a76a001a595a.sol,COCTokenBase,"contract COCTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; address public administrator; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function COCTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; administrator = msg.sender; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[administrator] = totalSupply; }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x574f84108a98c575794f75483d801d1d5dc861a5.sol,RoxToken,"contract RoxToken is ERC20Token { constructor() public { name = ; symbol = ; decimals = 18; mintingContractAddress = 0x9532014DAdb2C980e43fE4665C86c2c0B1b4603D; lockFromSelf(0, ); }",1
0x0dce40212e3c689ad502739e283d9c3ac79727bc.sol,MasterNet,"contract MasterNet is owned, TokenERC20 { function MasterNet( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xd967acb1fb0d9e3ed6991590de6f373abd75d0b7.sol,Microverse,"contract MicroverseBase is Superuser { using SafeMath for uint256; event OpenWormhole(); event CloseWormhole(); event SystemChangePercentWeiDividend(uint256 oldValue, uint256 newValue); event SystemChangePercentWeiJackpot(uint256 oldValue, uint256 newValue); event SystemChangePercentWeiMC(uint256 oldValue, uint256 newValue); uint256 public previousWeiBalance; uint256 public nextSeedHashed; uint256 public percentWeiDividend = 40; uint256 public percentWeiJackpot = 10; uint256 public percentWeiMC = 10; uint256 public FACTOR = 100; bool public wormholeIsOpen = true; modifier wormholeOpened() { require (wormholeIsOpen == true); _; }",1
0x9243d0751bcae56f3597b026cfe6a6233a9a36c1.sol,TEC,contract TEC is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public totalSupply = 1000 * 1000 * 1000 ether; function TEC() public { balances[msg.sender] = totalSupply; },1
0x749146a51f4efc018fd20a6fd1551a8eb55dedf6.sol,Diatom,"contract Diatom is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000e8; uint256 public totalDistributed = 8000000e8; uint256 public tokensPerEth = 15000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4498f897505d0e6991edeab24bc7b5727d72de28.sol,RFCICO,"contract RFCICO { using SafeMath for uint256; address public wallet; address public RFC; uint256 public price = 303; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public{ wallet = 0x1c46A08C940D9433297646cBa10Bc492c7D53A82; RFC = 0xed1CAa23883345098C7939C44Fb201AA622746aD; tokenReward = token(RFC); }",1
0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8.sol,COSHATokenHKD,"contract COSHATokenHKD { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 1 * 10 ** (10 + uint256(decimals)); initialSupply = totalSupply; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; tokenName = name; tokenSymbol = symbol; }",1
0x1786672e19168f99a0c78e9704e416589e3197d4.sol,Multiplier,"contract Multiplier is Ownable { using SafeMath for uint; address constant private support = 0x8Fa6E56c844be9B96C30B72cC2a8ccF6465a99F9; uint constant public supportPercent = 3; uint public reserved; uint public delayed; uint minCycle = 5 minutes; uint initCycle = 2 hours; uint maxCycle = 1 days; uint public cycleStart; uint public actualCycle; uint public lastCycle; uint public cycles; uint minPercent = 1; uint maxPercent = 33; uint frontier = 50; mapping (address => address) referrer; mapping (address => bool) verified; uint refBonus = 5; uint verificationPrice = 0.0303 ether; event NewCycle(uint start, uint duration, uint indexed cycle); event NewDeposit(address indexed addr, uint idx, uint amount, uint profit, uint indexed cycle); event Payed(address indexed addr, uint amount, uint indexed cycle); event Refunded(address indexed addr, uint amount, uint indexed cycle); event RefundCompleted(uint indexed cycle); event RefVerified(address indexed addr); event RefBonusPayed(address indexed investor, address referrer, uint amount, uint level); event VerPriceChanged(uint oldPrice, uint newPrice); constructor() public { verified[owner()] = true; actualCycle = initCycle * 2; queue.length += 1; }",1
0x33848f45565259809a4aaaf44d49cba6b7573021.sol,NotesharesTokenFactory,"contract NotesharesTokenFactory is Ownable (address(0)) { address public catalogAddress; address public ecosystemFeeAccount; event tokenCreated (address tokenAddress); constructor (address _catalogAddress, address _ecosystemFeeAccount) public { catalogAddress = _catalogAddress; ecosystemFeeAccount = _ecosystemFeeAccount; }",1
0x2773c69d7a7e2943f6e27c9947d5ae4e2b853993.sol,EtherDiamond,"contract EtherDiamond is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 28000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x063425e215701d2761a9065e647fa98f209b4ddd.sol,AffiliateManager,"contract AffiliateManager is Pausable { using SafeMath for uint256; AffiliateTreeStore public affiliateTree; MavinToken public token; uint256 public endTime; uint256 public cap; address public vault; uint256 public mvnpereth; uint256 public mvnperethBonus; uint256 public level1Bonus; uint256 public level2Bonus; uint256 public weiRaised; uint256 public minAmountWei; address creator; function AffiliateManager( address _token, address _treestore ) public { creator = msg.sender; token = MavinToken(_token); endTime = 1536969600; vault = 0xD0b40D3bfd8DFa6ecC0b357555039C3ee1C11202; mvnpereth = 100; mvnperethBonus = 105; level1Bonus = 8; level2Bonus = 4; minAmountWei = 0.01 ether; cap = 32000 ether; affiliateTree = AffiliateTreeStore(_treestore); }",1
0xf3fb69ef211c6d1e838a5c2223ef54fed4f24090.sol,Cookie,"contract CookieStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,LoliCoin,"contract LoliCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LoliCoin() TokenERC20() public {}",1
0x0235fe624e044a05eed7a43e16e3083bc8a4287a.sol,Cofounded,contract Cofounded { mapping (address => uint) public cofounderIndices; address[] public cofounders; modifier restricted () { uint cofounderIndex = cofounderIndices[msg.sender]; require(msg.sender == cofounders[cofounderIndex]); _; },1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0x26c69e1b26553030a455e6bfd717bda20167a056.sol,INF,"contract INF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function INF() public { symbol = ; name = ; decimals = 18; _totalSupply = 17000000000000000000000000; balances[msg.sender] = _totalSupply; bonusEnds = now + 0.1 weeks; endDate = now + 500 weeks; }",1
0x178ab5b0ff6db1e0cbe569c091607d8f5d6e4c6c.sol,FinPro,contract FinPro is Ownable { using SafeMath for uint256; string private constant name = ; string private constant version = ; uint256[] private fplowerlim; uint256[] private fplocktime; uint256[] private fpinterest; uint256 private fpcount; ERC20Token private token; struct investedData { uint256 fpnum; uint256 buytime; uint256 unlocktime; uint256 value; bool withdrawn; },1
0x64cfc7428621b2b118896670c0b4d52ab020ee6a.sol,AUSD,"contract AUSD is Owned, ERC20Token { using SafeMath for uint256; string private constant standard = ; string private constant version = ; string private name_ = ; string private symbol_ = ; uint8 private decimals_ = 18; uint256 private totalSupply_ = uint256(20) * uint256(10)**uint256(8) * uint256(10)**uint256(decimals_); mapping (address => uint256) private balanceP; mapping (address => mapping (address => uint256)) private allowed; mapping (address => uint256[]) private lockTime; mapping (address => uint256[]) private lockValue; mapping (address => uint256) private lockNum; uint256 private later = 0; uint256 private earlier = 0; bool private mintable_ = true; event Burn(address indexed _from, uint256 _value); event Mint(address indexed _to, uint256 _value); event TransferLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value); event TokenUnlocked(address indexed _address, uint256 _value); event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount); event WrongEtherEmptied(address indexed _addr, uint256 _amount); constructor() public { balanceP[msg.sender] = totalSupply_; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xdc3f9dafcf6af8b3a1273141116a9cb137248711.sol,KeyrptoCrowdsale,"contract KeyrptoCrowdsale is FinalizableCrowdsale { uint256 internal constant ONE_TOKEN = 1e18; uint256 internal constant MILLION_TOKENS = 1e6 * ONE_TOKEN; uint256 internal constant PRESALE_TOKEN_CAP = 62500000 * ONE_TOKEN; uint256 internal constant MAIN_SALE_TOKEN_CAP = 510 * MILLION_TOKENS; uint256 internal constant MINIMUM_CONTRIBUTION_IN_WEI = 100 finney; mapping (address => bool) public whitelist; uint256 public mainStartTime; uint256 public extraTokensMintedDuringPresale; function KeyrptoCrowdsale( uint256 _startTime, uint256 _mainStartTime, uint256 _endTime, uint256 _rate, address _wallet) public Crowdsale(_startTime, _endTime, _rate, _wallet) { require(_startTime < _mainStartTime && _mainStartTime < _endTime); mainStartTime = _mainStartTime; KeyrptoToken(token).setTeamWallet(_wallet); }",1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0x36fef0a32d493fa86d6281205b924456597aae5d.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xf027003f78080dbeddb5358ec3208edcfef75c4c.sol,Inerex,"contract Inerex is DSTokenBase(0), DSStop { bytes32 public name = ; bytes32 public symbol; uint256 public decimals = 18; function Inerex(bytes32 symbol_) { symbol = symbol_; }",1
0xcf9a1a3a30d859ab8964e6db596a8d2edd449c0b.sol,TimeLockedController,"contract TimeLockedController is HasNoEther, HasNoTokens, Claimable { using SafeMath for uint256; uint public constant blocksDelay = 24*60*60/15; struct MintOperation { address to; uint256 amount; address admin; uint deferBlock; }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,EjectableOwnable,contract EjectableOwnable is Ownable { function removeOwnership() onlyOwner public { owner = 0x0; },1
0x5824d62f4f3c875c906f4e16d488bed05a87a2ea.sol,BurnableToken,"contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x25797a5be709b7daa2618b16ed2cd61a14f380ad.sol,HumanStandardToken,contract HumanStandardToken is StandardToken { function () { throw; },1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xf33d6328c74592abd1017c9da5502eab24a0b617.sol,HuapuPay,"contract HuapuPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed = 2000000000e18; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5cb92b06ca0226e0a2c5fc8ee23e9cc66b1a4e11.sol,ETCharPresale_v2,"contract ETCharPresale_v2 is PresaleContract { using SafeMath for uint; bool public enabled = true; uint32 public maxCharId = 10000; uint32 public currentCharId = 2000; uint256 public currentPrice = 0.02 ether; mapping (uint32 => address) public owners; mapping (address => uint32[]) public characters; bool public awardTokens = true; event Purchase(address from, uint32 charId, uint256 amount); function ETCharPresale_v2(address _presaleToken) PresaleContract(_presaleToken) public { }",1
0xaf8ce1b205be2bfdede58d8f923f610463658148.sol,iCASH,"contract iCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function iCASH() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x5D33021e1333CE72b9051aF68718a3576C92AAc8] = _totalSupply; Transfer(address(0), 0x5D33021e1333CE72b9051aF68718a3576C92AAc8, _totalSupply); }",1
0x5453e523405fa47df8a152e4e4bf0c226eebfb3e.sol,YoobaBatchTransfer,"contract YoobaBatchTransfer is Owned,YooStop,Utils { function YoobaBatchTransfer() public{ }",1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0xf2ad62fb35bad00b30e3af1d920de48d29613993.sol,DistributionForTesting,"contract DistributionForTesting is Distribution { function DistributionForTesting(address _admin, ERC20 _tokenContract, bytes32[] _contributionHashes, uint256 _expectedTotalTokens) Distribution(_admin, _tokenContract, _contributionHashes, _expectedTotalTokens) public { }",1
0x5101067e64f9e564bed7dd9c7378d7cc9dd5f550.sol,SilverMoon,contract SilverMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xcf70f36f8fd04713b33900bab530fd2f63ed9ae0.sol,TheNextBlock,"contract TheNextBlock { using SafeMath for uint256; event BetReceived(address sender, address betOnMiner, address miner); event Jackpot(address winner, uint256 amount); struct Owner { uint256 balance; address addr; }",1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,SpectreToken,"contract SpectreToken is MiniMeToken, Ownable, ContractReceiver { event WalletAddressesSet(address _spectreTeam, address _managementLocked, address _optionPool); TokenBurner public tokenBurner; address public spectreTeam; address public managementLocked; address public optionPool; bool public walletAddressesSet; uint256 public SPECTRE_BOUNTY_ADVISORY_DEV_TEAM_ALLOC = 42; uint256 public MANAGEMENT_LOCKED_ALLOC = 18; uint256 public OPTION_POOL_ALLOC = 40; uint256 public LOCK_START_TIME = 1512896400; uint256 public MANAGEMENT_LOCKED_PERIOD = LOCK_START_TIME + 180 days; uint256 public OPTION_POOL_PERIOD = LOCK_START_TIME + 365 days; mapping (address => uint) public lockedBalances; function setTokenBurner(address _tokenBurner) onlyOwner public { tokenBurner = TokenBurner(_tokenBurner); }",1
0x0e7c28fb8ed4f5f63aabd022deaeeba40ecc335c.sol,EtherCenter,contract EtherCenter { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,Ownable,contract OwnableInterface { function getOwner() public constant returns (address); modifier onlyOwner() { require (msg.sender == getOwner()); _; },1
0x4c456a17eb8612231f510c62f02c0b4a1922c7ea.sol,CIMTokenBasic,contract CIMTokenBasic is ERC20 { using SafeMath for uint256; mapping (address => mapping (address => uint256)) internal allowed; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,Treasury,"contract TreasuryEmitter { event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate); event TreasuryWithdrawn(bytes32 userKey, uint value); }",1
0xf4e7cf1c71d983199dfe21c6569ec0125fc39000.sol,Leimen,"contract Leimen is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; function Leimen() public { totalSupply = 1000000000 * 100 ; balanceOf[msg.sender] = totalSupply ; name = ; symbol = ; }",1
0x71c118b00759b0851785642541ceb0f4ceea0bd5.sol,ChibiFighters,"contract ChibiFighters is ERC721, ContractOwned, CustomEvents { using SafeMath for uint256; uint256 private totalTokens; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; GeneInterface geneContract; FcfInterface fcfContract; BattleInterface battleContract; address battleContractAddress; uint public priceChibi; uint priceFusionChibi; uint uniqueCounter; uint adultTime; uint exhaustionTime; uint comission; address battleRemoveContractAddress; struct Chibi { address owner; bool founder; string nameChibi; uint16[13] dna; uint256 father; uint256 mother; uint gen; uint256[] fusions; bool forFusion; uint256 fusionPrice; uint256 exhausted; uint256 adult; string infoUrl; }",1
0x5bfea7daa03d28585d5f5307b27bd5c2f0448fb5.sol,FaceTech,"contract FaceTech is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public usersCanUnfreeze; mapping (address => bool) public admin; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozen; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Frozen(address indexed addr, bool frozen); function FaceTech() public { uint256 initialSupply = 8500000000000000; balanceOf[msg.sender] = initialSupply ; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; usersCanUnfreeze=false; admin[msg.sender]=true; }",1
0x3330c6fedea4388a9bef319753f6927e37f8e746.sol,ERC1363,"contract ERC1363 is ERC20, IERC1363 { using Address for address; bytes4 internal constant _InterfaceId_ERC1363Transfer = 0x4bbee2df; bytes4 internal constant _InterfaceId_ERC1363Approve = 0xfb9ec8ce; bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c; bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0; constructor() public { _registerInterface(_InterfaceId_ERC1363Transfer); _registerInterface(_InterfaceId_ERC1363Approve); }",1
0x729e895e186b7fbd34485d496415bb2f42629b71.sol,RequestCore,"contract RequestCore is Administrable { using SafeMath for uint256; using SafeMathUint96 for uint96; using SafeMathInt for int256; using SafeMathUint8 for uint8; enum State { Created, Accepted, Canceled }",1
0xed2bd91e69155782d045ca8254eafa8935e99b58.sol,P6,"contract P6 is Whitelist, SessionQueue { modifier onlyTokenHolders { require(myTokens() > 0); _; }",1
0x379c4c01484de6cdd3e685f63c702e45e3c574fd.sol,Etherlympics,"contract Etherlympics is usingOraclize { using strings for *; address owner; address public BOOKIE = 0x1e0dcc50C15581c4aD9CaC663A8283DACcA53271; uint public constant BOOKIE_POOL_COMMISSION = 10; uint public constant MINIMUM_BET = 0.01 ether; uint public constant BETTING_OPENS = 1518127200; uint public constant BETTING_CLOSES = 1518325140; uint public constant PAYOUT_ATTEMPT_INTERVAL = 86400; uint public constant PAYOUT_DATE = 1519671600; uint public constant BET_RELEASE_DATE = 1520226000; uint public constant NUM_COUNTRIES = 8; string[NUM_COUNTRIES] public COUNTRY_NAMES = [, , , , , , , ]; enum Countries { Russia, USA, Norway, Canada, Netherlands, Germany, Austria, France, None }",1
0x4b43d8a35257f42a2d0d4d774409208efc31b406.sol,Project512Foundation,"contract Project512Foundation { string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 public initialSupply = 125000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Project512Foundation () public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xef9598e5eda6be42ee45485671f202ce8a524648.sol,DOCTToken,"contract DOCTToken is MintableToken, ERC827Token, NoOwner { string public symbol = ; string public name = ; uint8 public constant decimals = 8; address founder; bool public transferEnabled; function setFounder(address _founder) onlyOwner public { founder = _founder; }",1
0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0xf04436b2edaa1b777045e1eefc6dba8bd2aebab8.sol,TokenSale,contract TokenSaleConfig { uint public constant EXA = 10 ** 18; uint256 public constant PUBLIC_START_TIME = 1515542400; uint256 public constant END_TIME = 1518220800; uint256 public constant CONTRIBUTION_MIN = 0.1 ether; uint256 public constant CONTRIBUTION_MAX = 2500.0 ether; uint256 public constant COMPANY_ALLOCATION = 40 * 10 ** 6 * EXA; Tranche[4] public tranches; struct Tranche { uint untilToken; uint tokensPerEther; },1
0xd8fbad653825c51d5cd9c747cd9a82d497cc41a4.sol,CrowdsaleTokenExt,"contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; uint public minCap; mapping(address => uint256) public steps; mapping(address => uint256) public starts; mapping(address => uint256) public durations; mapping(address => uint256) public amounts; mapping(address => bool) public locked; function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0x6fc135d4a065fbaa45e3df178f2ebc150f0401b1.sol,V2Alpha4TierSale,contract V2Alpha4TierSale is Owned{ using SafeMath for uint256; using SafeMath for uint; struct ContributorData{ bool isActive; bool isTokenDistributed; uint contributionAmount; uint tokensAmount; },1
0x5744155b0891e09b36d871daf35c04a0f0ef4b9c.sol,CryptoUniversityTuition,contract CryptoUniversityTuition is StandardToken { function () { throw; },1
0x365845f52cae20676e7b86ecffe1afa91e45fb9a.sol,LockableToken,"contract LockableToken is Ownable { mapping (address => uint256) internal lockaddress; event Lock(address indexed locker, uint256 time); function lockStatus(address _address) public constant returns(uint256) { return lockaddress[_address]; }",1
0x5808fb823d720e91f1564cd9c9081af7136f73db.sol,BENGOSHICOIN,"contract BENGOSHICOIN is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20e9 * 1e8; bool public mintingStopped = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintStopped(); constructor () public { owner = 0x17823d2B0e9f503C7ec2DE099243782ac3F7fBB1; balanceOf[owner] = totalSupply; }",1
0x6e59116f211369823e4d8f86d816d0d58e3d9f48.sol,MinterStorePoolCrowdsale,contract MinterStorePoolCrowdsale is Ownable { using SafeMath for uint; address public multisigWallet; uint public startRound; uint public periodRound; uint public altCapitalization; uint public totalCapitalization; MinterStorePool public token = new MinterStorePool (); function MinterStorePoolCrowdsale () public { multisigWallet = 0xdee04DfdC6C93D51468ba5cd90457Ac0B88055FD; startRound = 1534118340; periodRound = 80; altCapitalization = 0; totalCapitalization = 2000 ether; },1
0xa5d1eb8bbb42b7f2ebbebf174b3966510243f30c.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x6968522b7d3c9063a9d673f9caaa32d740b6a2c7.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0x033fd9f42f7e1566b893b31078a62b2b959ebd72.sol,TRLCoinSale,contract TRLCoinSale is ApproveAndCallFallBack { struct Period { uint start; uint end; uint priceInWei; uint tokens; },1
0x289925d08b07e73dd0dd02d1407c877942215082.sol,AVYToken,"contract AVYToken is RARTokens{ uint private _maxSupply = 38200000 * 10**18; function AVYToken(address parent) RARTokens (parent, _maxSupply) public { symbol = ; name = ; decimals = 18; }",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Proxyable,"contract Proxyable is Owned { Proxy public proxy; address messageSender; constructor(address _proxy, address _owner) Owned(_owner) public { proxy = Proxy(_proxy); emit ProxyUpdated(_proxy); }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,Owned,"contract Owned { address public owner; address public nominatedOwner; constructor(address _owner) public { require(_owner != address(0), ); owner = _owner; emit OwnerChanged(address(0), _owner); }",1
0x7217fdeb1ed453eab8a5afa621461497f7630bb7.sol,ReclycleCoin,contract ReclycleCoin { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint public _totalSupply = 5250000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x74e345b0597ea3bc5762df0092e6bf8c891a7d0f.sol,AMToken,"contract AMToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x86f95775d657033ffa35d96171d2e40a605c8ac0.sol,Vlogchain,"contract Vlogchain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 2000000000e8; uint256 private totalReserved = (totalSupply.div(100)).mul(25); uint256 private totalBounties = (totalSupply.div(100)).mul(25); uint256 public totalDistributed = totalReserved.add(totalBounties); uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public minReq; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ba4780b57d6efe3a1170edfa66091e7c769db7d.sol,Clen,"contract Clen is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Clen( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xea96e2b3d17fbb7f36d90a3bccd6705c98af5f0b.sol,RBACMixin,"contract RBACMixin { string constant FORBIDDEN = ; mapping (address => bool) public owners; mapping (address => bool) public minters; event AddOwner(address indexed who); event DeleteOwner(address indexed who); event AddMinter(address indexed who); event DeleteMinter(address indexed who); constructor () public { _setOwner(msg.sender, true); }",1
0x28933055016731c1360d7422fbe6e73aaf3b1b1e.sol,YEX,"contract YEX is SafeMath { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function YEX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x528b165220a26565e00709cbaef7b88fc8600f81.sol,Presale,contract Presale is CommonSale { Mainsale public mainsale; function setMainsale(address newMainsale) public onlyOwner { mainsale = Mainsale(newMainsale); },1
0x17b7ddd2962226ef9428313ed62799060fb812b7.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x6b0d72192baff8b978820ee72706ae02b4e72468.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,CTCSale,"contract CTCSale is CappedCrowdsale, RefundableCrowdsale { using SafeMath for uint; uint constant private exa = 10 ** 18; uint public minBuy; event WalletChanged(address _wallet); function CTCSale(uint _start,uint _end,uint _rate,uint _cap,address _wallet,CommunityCoin _tokenAddress,uint _goal,uint _minBuy) Crowdsale(_start, _end,_rate,_wallet) CappedCrowdsale(_cap * exa) RefundableCrowdsale(_goal * exa) public { token = CommunityCoin(_tokenAddress); minBuy = _minBuy; }",1
0x5afae785bc6ba7248dbd511a92c4d5cc5a803214.sol,DaoCommon,contract DaoCommonMini is IdentityCommon { using MathHelper for MathHelper; function isDaoNotReplaced() public view returns (bool _isNotReplaced) { _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao(); },1
0x1d41e18e8ed1ef148547ceade01912e638f464b8.sol,Casper,"contract Casper is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 30000000000e18; uint256 public totalDistributed = 15000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 150000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xede85cd1b56791dca6fe9f589ae1c2961695880b.sol,BinksBucks,contract BinksBucksToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint internal _totalSupply = 0; mapping(address => uint256) internal _balances; mapping(address => mapping (address => uint256)) _allowed; function totalSupply() public constant returns (uint) { return _totalSupply; },1
0xf4f5271c9d6f23cc00f93625b502f88d289a1607.sol,AkilosToken,"contract AkilosToken is ERC20Interface, Owned, WithdrawConfirmation { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; bool public started = false; uint public currentRate; uint public minimalInvestment = 0.1 ether; uint public currentRoundSales; uint public roundNumber; uint public roundOneTotal; uint public roundTwoTotal; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Burn(address indexed from, uint value); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 15000000 * 10**uint(decimals); roundOneTotal = 3000000 * 10**uint(decimals); roundTwoTotal = 7000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x25dd328e9226f9157269213bc07c19aa2589b6bf.sol,TCSCCoin,"contract TCSCCoin is Ownable, StandardToken { string public name; string public symbol; uint public decimals; uint public totalSupply; function TCSCCoin() public { totalSupply = 100 * (10**6) * (10**6); balances[msg.sender] = totalSupply; name = ; symbol = ; decimals = 6; }",1
0x6dc2b0014e1974d7606de09b87969f34bd336252.sol,VOCC_I023_20181211,"contract VOCC_I023_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2671500a8a6d099ae8743ad3ff848a6636fe9a75.sol,ZEONPrivateSale,"contract ZEONPrivateSale is Haltable, PriceReceiver { using SafeMath for uint; string public constant name = ; ZEON public token; address public beneficiary; InvestorWhiteList public investorWhiteList; uint public constant TokenUsdRate = 50; uint public constant MonthsInSeconds = 2629746; uint public ethUsdRate; uint public collected = 0; uint public tokensSold = 0; uint public startTime; uint public endTime; bool public crowdsaleFinished = false; mapping (address => uint) public deposited; event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount); event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount); modifier icoActive() { require(now >= startTime && now < endTime); _; }",1
0x410cac201ffc0e0e4c179d926076d25bf8bc5b92.sol,EthPyramid2,contract EthPyramid2 { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; function EthPyramid2() public {},1
0x789109d185f5f4205d58c533eb831fdefb0d10b8.sol,BlockchainofBeautifulandHealthyEcosystem,"contract BlockchainofBeautifulandHealthyEcosystem { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BlockchainofBeautifulandHealthyEcosystem( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x5536b6aadd29eaf0db112bb28046a5fad3761bd4.sol,PixelCons,contract PixelCons is ERC721 { using AddressUtils for address; bytes4 private constant ERC721_RECEIVED = 0x150b7a02; struct PixelCon { uint256 tokenId; address creator; uint64 collectionIndex; uint32 dateCreated; },1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) { uint len = (a.length <= b.length) ? a.length : b.length; for (uint i = 0; i < len; i++) { if (a[i] != b[i]) { return i; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0x36e4daa217800d8b2aac42ee7cc56d4484940c69.sol,AntariXtoken,"contract AntariXtoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2906f2b553dcfda6891cba64b0ac9e5780b5c1a6.sol,CoinCopyTrade,"contract CoinCopyTrade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply =2000000000000000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Gig9,"contract Gig9 is Balances, Pausable, Destructible { function Gig9()public { _name = ; _symbol = ; _decimals = 8; _totalSupply = 268000000 * (10 ** _decimals); owner = msg.sender; balances[0x0A35230Af852bc0C094978851640Baf796f1cC9D] = _totalSupply; tokenTransferAddress = 0x0A35230Af852bc0C094978851640Baf796f1cC9D; }",1
0x3fd7332ea471e876327926b30bd945773c706133.sol,EtherShrimpFutures,contract EtherShrimpFutures{ using SafeMath for uint; Oasis market; address public dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 internal PSN=10000; uint256 internal PSNH=5000; bool public initialized=false; uint256 public marketEggs; address public ceoAddress; uint256 public numberOfFarmers; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; mapping (address => uint256) public lastHatchPrice; address[] farmers; constructor() public{ ceoAddress=msg.sender; market = Oasis(0x14FBCA95be7e99C15Cc2996c6C9d841e54B79425); },1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,TokenSale,"contract TokenSale is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; rateInterface public rateContract; address public wallet; address public advisor; uint256 public advisorFee; uint256 public constant decimals = 18; uint256 public endTime; uint256 public startTime; mapping(address => bool) public rc; function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public { tokenContract = tokenInterface(_tokenAddress); rateContract = rateInterface(_rateAddress); setTime(_startTime, _endTime); wallet = msg.sender; advisor = msg.sender; advisorFee = 0 * 10**3; }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,BitcoinX,"contract BitcoinX is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 911; iEthealSale public crowdsale; event LogBonusSet(address indexed _address, uint256 _amount); function BitcoinX(address _crowdsale) { crowdsale = iEthealSale(_crowdsale); }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,StoreGoods,contract StoreGoods is BasicAuth { using ItemList for ItemList.Data; struct Goods { uint32 m_Index; uint32 m_CostItem; uint32 m_ItemRef; uint32 m_Amount; uint32 m_Duration; uint32 m_Expire; uint8 m_PurchaseLimit; uint8 m_DiscountLimit; uint8 m_DiscountRate; uint m_CostNum; },1
0x18ecc2461dfd84c5ce9da581aca58919a8750ae5.sol,mAlek,contract mAlek { using SafeMath for uint256; uint public _totalSupply = 0; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public bonus = 50; uint256 public price = 1000; uint256 public rate; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () payable { createTokens(); },1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5401bb4729bd7f025b97399c3c92854ec299f81a.sol,LOCIcoin,"contract LOCIcoin is StandardToken, Ownable, Contactable { string public name = ; string public symbol = ; uint256 public constant decimals = 18; mapping (address => bool) internal allowedOverrideAddresses; bool public tokenActive = false; modifier onlyIfTokenActiveOrOverride() { require(tokenActive || msg.sender == owner || allowedOverrideAddresses[msg.sender]); _; }",1
0x4022b8065beaab882f0edf7d5bcc59bc3a0d662b.sol,BEAXY,"contract BEAXY is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,Bitscreen,contract Bitscreen { struct IPFSHash { bytes32 hash; uint8 hashFunction; uint8 size; },1
0xf225b1be475ca4b50706db318c12380a02537394.sol,KarmaToken,"contract KarmaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KarmaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xDD59Db170547dDBAe06C0b081713b29855937b72] = _totalSupply; Transfer(address(0), 0xDD59Db170547dDBAe06C0b081713b29855937b72, _totalSupply); }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSTokenBase,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0xbf06e2b5b97e375f7c0b3d8c61b8337a9c7ea23c.sol,FoMoRapid,"contract FoMoRapid is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; address admin; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x56a4d4e31c09558F6A1619DFb857a482B3Bb2Fb6); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); admin = msg.sender; }",1
0x83970c07dca22c156fe21d116f4cef3a057904bd.sol,YangMaoZhuangYuan,"contract YangMaoZhuangYuan is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function YangMaoZhuangYuan( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xbf607a809f785449fb389188e51af98d5c33bc20.sol,Vasacoin,"contract Vasacoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 200; uint256 public tokensPerEth = 15000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x656038e97cee7c095673f7b9fad695b323a6f098.sol,WheelOf0xBitcoin,contract WheelOf0xBitcoin { using SafeMath for uint; modifier nonContract() { require(tx.origin == msg.sender); _; },1
0x31141dc226c214d40b1f77feb532741d8f893c6f.sol,PARALLELNETWORK,"contract PARALLELNETWORK is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 2000000000; event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp); function PARALLELNETWORK() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0x1777b7b44757a2c606953f5eab3396650b6e6ddc.sol,DCS,"contract DCS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 80000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 0e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ff826b46424033d54e5c9ef092ac575604f9295.sol,PearlBonus,contract PearlBonus { address public pearlContract = 0x1844b21593262668B7248d0f57a220CaaBA46ab9; OysterPearl pearl = OysterPearl(pearlContract); address public director; address public partner; uint8 public share; uint256 public funds; bool public saleClosed; function PearlBonus() public { director = msg.sender; partner = 0x36B786f3EC7DE8aC4878980f4B021DE62DDDFF41; share = 4; funds = 0; saleClosed = false; },1
0x91d5e2dfd91db593a953dbd70c540705bb9d9db0.sol,Fees,contract Fees is Admin{ using SafeMath for uint256; uint public Fee; address public FeeAddr1; address public FeeAddr2; function SetFee(uint newFee) public onlyAdmin{ Fee = newFee; },1
0x2c31dbd57a56d953be4396c42089c95f5bbf603d.sol,Redenom,"contract Redenom is ERC20Interface, Owned{ using SafeMath for uint; string public name; string public symbol; uint private _totalSupply; uint public decimals = 8; uint public round = 1; uint public epoch = 1; bool public frozen = false; uint[8] private dec = [0,0,0,0,0,0,0,0]; uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000]; uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55]; uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0]; uint public total_fund; uint public epoch_fund; uint public team_fund; uint public redenom_dao_fund; struct Account { uint balance; uint lastRound; uint lastVotedEpoch; uint bitmask; }",1
0x25e08694ab1deb8715b0a856bf1d947e90938261.sol,Halva_Token,contract Halva_Token { using SafeMath for uint; address owner; mapping (address => uint) deposit; mapping (address => uint) withdrawn; mapping (address => uint) lastTimeWithdraw; function transferOwnership(address _newOwner) external { require(msg.sender == owner); require(_newOwner != address(0)); owner = _newOwner; },1
0x5a086708501251d2c948d767a88379f0b8d8c300.sol,WeduToken,contract WeduToken is ERC20Interface { string private TOKEN_NAME; string private TOKEN_SYMBOL; uint8 private DECIMAL; uint private WEDU_UNIT; address owner; mapping(address => bool) internal blackList; uint private totalSupplyValue; struct BalanceType { uint locked; uint unlocked; },1
0x18a60cc53101d8aae343acc9357d347bc79c6549.sol,Trophy,"contract Trophy is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 { using strings for *; string internal name_; string internal symbol_; mapping(address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public allTokens; mapping(uint256 => uint256) public allTokensIndex; address public manager; uint256 public nextTokenId = 1; uint256 public nextTokenType = 1; string public tokenURIPrefix; mapping (uint256 => uint256) public tokenTypes; mapping (uint256 => address) public tokenTypeIssuers; mapping (uint256 => address) public tokenIssuer; mapping (uint256 => uint256[]) public tokensByType; event TokenTypeCreated( address _issuer, uint256 _type, uint256 _timestamp ); event TokenIssued( address _issuer, address _owner, uint256 _type, uint256 _tokenId, uint256 _timestamp ); event TokenRevoked( address _issuer, address _owner, uint256 _type, uint256 _tokenId, uint256 _timestamp ); event IssuanceTransferred( uint256 _type, address _oldIssuer, address _newIssuer, uint256 _timestamp ); event TransferAll( address _oldAddress, address _newAddress, uint256 _timestamp ); constructor(string _name, string _symbol, string _tokenURIPrefix) public { name_ = _name; symbol_ = _symbol; manager = msg.sender; tokenURIPrefix = _tokenURIPrefix; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0x016f9f847b4a2f8882aa64627e61991690520786.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x1a94fdf6d0bf45d298557789550bb2d7e359ca2d.sol,CrossChainEntertainmentTokenE,"contract CrossChainEntertainmentTokenE { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x0d07e8800857b9649a8aa02b5b4bcd8c24ec7c5d.sol,Owned,contract Owned { address public owner; address internal newOwner; constructor() public { owner = msg.sender; },1
0x4169170231678b9a33ce8fe291d6427a4763e137.sol,EthereumClassicVision,"contract EthereumClassicVision is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 13000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 300e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,GTO,contract GTO is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint256 public _totalSupply = 10 ** 14; uint256 public _originalBuyPrice = 45 * 10**7; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; address[] private buyers; uint8 public _icoPercent = 10; uint256 public _icoSupply = _totalSupply * _icoPercent / 100; uint256 public _minimumBuy = 3 * 10 ** 17; uint256 public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x44c7f06153bd9bf06ea498bddf4ccf04c249a851.sol,TokenOnline,"contract TokenOnline is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0x2eb1a3b71bee2bc135af75436ed5cd8cceac3e96.sol,KayoToken,contract KayoToken is Owned { string public name; uint8 public decimals; string public symbol; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd083713e4d9bc1e4c923795f9f6ce2a97646c116.sol,Base,contract Base { uint8 constant HEROLEVEL_MIN = 1; uint8 constant HEROLEVEL_MAX = 5; uint8 constant LIMITCHIP_MINLEVEL = 3; uint constant PARTWEIGHT_NORMAL = 100; uint constant PARTWEIGHT_LIMIT = 40; address creator; constructor() public { creator = msg.sender; },1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0xe1b5507d1dead31583ee382485bc61d2b5ac6ceb.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00.sol,MSCE,"contract MSCE is Ownable, StandardToken, BurnableToken{ using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; uint256 unitCount = 100; uint256 unitTime = 1 days; uint256 lockTime = unitCount * unitTime; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; mapping (address => uint256) public lockAmount; mapping (address => uint256) public lockStartTime; mapping (address => uint256) public lockReleaseTime; event LockAmount(address _from, address _to, uint256 amount, uint256 releaseTime); event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x52c52944eaac353f054902225e1df036589fb6d7.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x205E2ACd291E235425b5c10feC8F62FE7Ec26063; addressOfTokenUsedAsReward = 0x82B99C8a12B6Ee50191B9B2a03B9c7AEF663D527; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); address addressCrowdSale = 0xc699d90671Cb8373F21060592D41A7c92280adc4; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply.mul(11).div(18); balanceOf[addressCrowdSale] = totalSupply.sub(balanceOf[msg.sender]); name = tokenName; symbol = tokenSymbol; }",1
0x2efb0309f41648a9faa935e189e2c8ff763bce75.sol,MSCE,"contract MSCE is Ownable, StandardToken { using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0xe000cd29eb1f596f4fc1d9873eb1618cd3846f08.sol,Vote,contract Vote { using SafeMath for uint256; struct Proposal { uint deadline; mapping(address => uint) votes; uint yeas; uint nays; string reason; bytes data; address target; },1
0x1f6e6af195376fb39bb7fede37aa5fb28ac12b44.sol,Withdrawable,contract Withdrawable is Ownable { function withdrawEther(address to) public onlyOwner { to.transfer(address(this).balance); },1
0xed2f35867a1afc19eeff7f0fbd7cd30c0c8c288a.sol,Etheropoly,contract Etheropoly { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x286bbee3f20f1702e707e58d33dc28a69e7efd4e.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x016f9f847b4a2f8882aa64627e61991690520786.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0xdae46fadfd30e7b6de74937626adf09d947ecc62.sol,PreIco,"contract PreIco is SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public manager; address public reserveManager; address public escrow; address public reserveEscrow; uint constant BASE = 1000000000000000000; uint public tokensSupplied = 0; uint public bountySupplied = 0; uint public constant SOFT_CAPACITY = 166666 * BASE; uint public constant TOKENS_SUPPLY = 600000 * BASE; uint public constant BOUNTY_SUPPLY = 350000 * BASE; uint public constant totalSupply = TOKENS_SUPPLY + BOUNTY_SUPPLY; uint public constant TOKEN_PRICE = 3000000000000000; uint tokenAmount1 = 200000 * BASE; uint tokenAmount2 = 200000 * BASE; uint tokenAmount3 = 200000 * BASE; uint tokenPriceMultiply1 = 1; uint tokenPriceDivide1 = 1; uint tokenPriceMultiply2 = 1041667; uint tokenPriceDivide2 = 1000000; uint tokenPriceMultiply3 = 1083333; uint tokenPriceDivide3 = 1000000; uint[] public tokenPriceMultiplies; uint[] public tokenPriceDivides; uint[] public tokenAmounts; mapping(address => uint) public ethBalances; uint[] public prices; uint[] public amounts; mapping(address => uint) private balances; uint public constant defaultDeadline = 1515679200; uint public deadline = defaultDeadline; bool public isIcoStopped = false; address[] public allowedTokens; mapping(address => uint) public tokenAmount; mapping(address => uint) public tokenPrice; address[] public usersList; mapping(address => bool) isUserInList; uint numberOfUsersReturned = 0; mapping(address => address[]) public userTokens; mapping(address => mapping(address => uint)) public userTokensValues; event BuyTokens(address indexed _user, uint _ethValue, uint _boughtTokens); event BuyTokensWithTokens(address indexed _user, address indexed _token, uint _tokenValue, uint _boughtTokens); event GiveReward(address indexed _to, uint _value); event IcoStoppedManually(); event IcoRunnedManually(); event WithdrawEther(address indexed _escrow, uint _ethValue); event WithdrawToken(address indexed _escrow, address indexed _token, uint _value); event ReturnEthersFor(address indexed _user, uint _value); event ReturnTokensFor(address indexed _user, address indexed _token, uint _value); event AddToken(address indexed _token, uint _amount, uint _price); event RemoveToken(address indexed _token); event MoveTokens(address indexed _from, address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyManager { assert(msg.sender == manager || msg.sender == reserveManager); _; }",1
0x0e7c566229b38cf533d4af19169c1a5e4f892c1d.sol,KCPTOKEN,"contract KCPTOKEN is ERC20,Ownable{ using SafeMath for uint256; string public constant name=; string public symbol=; string public constant version = ; uint256 public constant decimals = 18; uint256 public totalSupply; uint256 public constant MAX_SUPPLY=2100000000*10**decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event GetETH(address indexed _from, uint256 _value); function KCPTOKEN() public { totalSupply=MAX_SUPPLY; balances[msg.sender] = MAX_SUPPLY; Transfer(0x0, msg.sender, MAX_SUPPLY); }",1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownIco,"contract ExoTownIco is SafeMath, IcoLimits { ExoTownToken public exotownToken; enum State { Pause, Running }",1
0x657c7739e165ad0b0a16ff6851f8587324b8a515.sol,HonestisNetworkTokenWire3,contract HonestisNetworkTokenWire3{ string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public honestisFort = 0xF03e8E4cbb2865fCc5a02B61cFCCf86E9aE021b5; address public migrationMaster = 0x0f32f4b37684be8a1ce1b2ed765d2d893fa1b419; uint256 public constant supply = 3300000.0 ether; address public firstChainHNw1 = 0x0; address public secondChainHNw2 = 0x0; address public thirdChainETH = 0x0; address public fourthChainETC = 0x0; struct sendTokenAway{ StandardToken coinContract; uint amount; address recipient; },1
0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c.sol,Functional,"contract Functional { function parseInt(string _a, uint _b) internal pure returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; }",1
0xe3c55be451b7e4e97eb75f2729d41d8d563cd41e.sol,AroundTheWorldTravel,"contract AroundTheWorldTravel { address public admin_address = 0xf2F62C02C97371Cf49302484c196172724580C95; address public account_address = 0xf2F62C02C97371Cf49302484c196172724580C95; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 1000000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x1d41e18e8ed1ef148547ceade01912e638f464b8.sol,Casper,"contract Casper is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 30000000000e18; uint256 public totalDistributed = 15000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 150000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x6aa27b3a8aab51745b7eaf53e61aba833b0f9400.sol,PCC,"contract PCC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PCC() public { symbol = ; name = ; decimals = 8; _totalSupply = 5200000000000000; balances[0x67322D8A8f72B8417f16397667d8F6ce996A6982] = _totalSupply; Transfer(address(0), 0x67322D8A8f72B8417f16397667d8F6ce996A6982, _totalSupply); }",1
0x25e1779f5f2fbdd378ced1a338f6c26aeb3d6ad0.sol,SpiderFarm,"contract SpiderFarm{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=50; uint256 PSN=10000; uint256 PSNH=5000; uint256 startTime; bool public initialized=false; address public ceoAddress; address public owner; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public snailmasterReq=100000; function becomeSnailmaster() public{ uint256 hasEggs=getMyEggs(); uint256 eggCount=SafeMath.div(hasEggs,EGGS_TO_HATCH_1SHRIMP); require(initialized); require(msg.sender != ceoAddress); require(eggCount>=snailmasterReq); claimedEggs[msg.sender]=0; snailmasterReq=SafeMath.add(snailmasterReq,100000); ceoAddress=msg.sender; }",1
0xf16d5b36d6a29832898c439bc596c6a01218dc59.sol,PHICrowdsale,"contract PHICrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; uint256 public ratePreIco = 600; uint256 public rateIco = 400; uint256 public weiMin = 0.03 ether; mapping (address => uint256) public deposited; uint256 public constant INITIAL_SUPPLY = 63 * 10**6 * (10 ** uint256(decimals)); uint256 public fundForSale = 60250 * 10**3 * (10 ** uint256(decimals)); uint256 fundTeam = 150 * 10**3 * (10 ** uint256(decimals)); uint256 fundAirdropPreIco = 250 * 10**3 * (10 ** uint256(decimals)); uint256 fundAirdropIco = 150 * 10**3 * (10 ** uint256(decimals)); uint256 fundBounty = 100 * 10**3 * (10 ** uint256(decimals)); uint256 fundAdvisor = 210 * 10**3 * (10 ** uint256(decimals)); uint256 fundReferal = 1890 * 10**3 * (10 ** uint256(decimals)); uint256 limitPreIco = 12 * 10**5 * (10 ** uint256(decimals)); address addressFundTeam = 0x26cfc82A77ECc5a493D72757936A78A089FA592a; address addressFundAirdropPreIco = 0x87953BAE7A92218FAcE2DDdb30AB2193263394Ef; address addressFundAirdropIco = 0xaA8C9cA32cC8A6A7FF5eCB705787C22d9400F377; address addressFundBounty = 0x253fBeb28dA7E85c720F66bbdCFC4D9418196EE5; address addressFundAdvisor = 0x61eAEe13A2a3805b57B46571EE97B6faf95fC34d; address addressFundReferal = 0x4BfB1bA71952DAC3886DCfECDdE2a4Fea2A06bDb; uint256 public startTimePreIco = 1538406000; uint256 public endTimePreIco = 1539129600; uint256 public startTimeIco = 1541300400; uint256 public endTimeIco = 1542931200; uint256 percentReferal = 5; uint256 public countInvestor; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(address indexed sender, uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Burn(address indexed burner, uint256 value); event CurrentPeriod(uint period); event ChangeTime(address indexed owner, uint256 newValue, uint256 oldValue); event ChangeAddressFund(address indexed owner, address indexed newAddress, address indexed oldAddress); constructor(address _owner, address _wallet) public Crowdsale(_wallet) { require(_owner != address(0)); owner = _owner; transfersEnabled = false; mintingFinished = false; totalSupply = INITIAL_SUPPLY; bool resultMintForOwner = mintForFund(owner); require(resultMintForOwner); }",1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,FlightDelayControlledContract,contract FlightDelayControlledContract is FlightDelayDatabaseModel { address public controller; FlightDelayControllerInterface FD_CI; modifier onlyController() { require(msg.sender == controller); _; },1
0xf1d0f528cb6b50e0035a7fe03b4bcc58dd09c1e2.sol,ENToken,contract ENToken is IERC20 { using SafeMath for uint256; address internal owner_; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) internal balances_; mapping (address => mapping (address => uint256)) internal allowed_; uint256 internal totalSupply_=0; constructor() public payable { owner_ = msg.sender; },1
0xf293df3337bdfc76a454ce00b3d2fa5c8ba086a5.sol,BitRich,"contract BitRich is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; EtceteraToken public token; uint256 public startTime; uint256 public endTime; address public fundsWallet; uint256 public rate; uint256 public amountRaised; uint256 public tokenCap; uint256 public bonus; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,EtceteraToken _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = _token; startTime = _startTime; endTime = _endTime; rate = _rate; fundsWallet = _wallet; tokenCap = token.cap(); bonus = 140; }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensSold; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,LeaderSystem,"contract LeaderSystem { using SafeMath for uint256; event NewLeader(uint256 _indexTable, address _addr, uint256 _index, uint256 _sum); event LeadersClear(uint256 _indexTable); uint8 public constant leadersCount = 7; mapping (uint8 => uint256) public leaderBonuses; struct LeadersTable { uint256 timestampEnd; uint256 duration; uint256 minSum; address[] leaders; mapping (address => uint256) users; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,Limited,"contract Limited is Managed { using SafeMath for uint256; mapping(address => uint256) public limitsList; modifier isLimited(address _payee) { require(limitsList[_payee] > 0, ); _; }",1
0x41bbcf4f8f0e8a0a3cce4287d1c0c3d27c65ba0d.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require(!frozenAccount[msg.sender]); return super.transfer(_to, _value); }",1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc.sol,SBITokenCrowdsale,"contract SBITokenCrowdsale is Owned, CrowdsaleParameters { using SafeMath for uint256; string public name = ; SBIToken private token; address public bank; address saleWalletAddress; uint private tokenMultiplier = 10; uint public totalCollected = 0; uint public saleStartTimestamp; uint public saleStopTimestamp; uint public saleGoal; bool public goalReached = false; uint public preicoTokensPerEth = 27314; uint public tokensPerEth = 10500; mapping (address => uint256) private investmentRecords; address crowdsaleAddress = this; uint256 public constant saleStartDate = 1530403200; uint256 public constant saleEndDate = 1535759940; uint256 public constant preSaleStartDate = 1529020800; uint256 public constant preSaleEndDate = 1530403140; uint public preSaleAmount = 5800000; event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther); event FundTransfer(address indexed from, address indexed to, uint indexed amount); function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public { token = SBIToken(_tokenAddress); bank = _bankAddress; tokenMultiplier = tokenMultiplier ** token.decimals(); saleWalletAddress = generalSaleWallet.addr; saleGoal = generalSaleWallet.amount; }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,FrogSeekers,"contract FrogSeekers is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeb5405e21d07fa5e3b6644d0ae7f391b47f17e27.sol,StrikersBase,"contract StrikersBase is ERC721Token(, ) { event CardMinted(uint256 cardId); struct Card { uint32 mintTime; uint8 checklistId; uint16 serialNumber; }",1
0x6bb545b8a2e869009487eb7e5e045178b7221e36.sol,SMBQToken,"contract SMBQToken is pays_commission, owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public buyPrice = 1700000000000000; uint256 public sellPrice = 1500000000000000; bool public closeSell = false; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Deposit(address sender, uint amount); event Withdrawal(address receiver, uint amount); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x770b05bec95bbfdd90a9e46c48fcb101e70ebf9b.sol,LockedTokens,contract LockedTokens is SafeMath { struct Tokens { uint256 amount; uint256 lockEndTime; bool released; },1
0x4c2b12b0b55bb905d1ab300864213270033d361c.sol,BENEFITToken,"contract BENEFITToken is BaseICOTokenWithBonus { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint internal constant ONE_TOKEN = 1e18; uint public constant RESERVED_RESERVE_UNLOCK_AT = 1546300800; uint public constant RESERVED_COMPANY_UNLOCK_AT = 1561939200; event ReservedTokensDistributed(address indexed to, uint8 group, uint amount); event TokensBurned(uint amount); function BENEFITToken(uint totalSupplyTokens_, uint companyTokens_, uint bountyTokens_, uint reserveTokens_, uint marketingTokens_) public BaseICOTokenWithBonus(totalSupplyTokens_ * ONE_TOKEN) { require(availableSupply == totalSupply); availableSupply = availableSupply .sub(companyTokens_ * ONE_TOKEN) .sub(bountyTokens_ * ONE_TOKEN) .sub(reserveTokens_ * ONE_TOKEN) .sub(marketingTokens_ * ONE_TOKEN); reserved[RESERVED_COMPANY_GROUP] = companyTokens_ * ONE_TOKEN; reserved[RESERVED_BOUNTY_GROUP] = bountyTokens_ * ONE_TOKEN; reserved[RESERVED_RESERVE_GROUP] = reserveTokens_ * ONE_TOKEN; reserved[RESERVED_MARKETING_GROUP] = marketingTokens_ * ONE_TOKEN; }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,TokenERC20,"contract TokenERC20 is Pausable{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0xee6d409e9d08af082c2493ea955a0d3ea418dc0f.sol,FranklinFarmer,contract FranklinFarmer is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x209f98bc320133681458125bc57ecc03718311cc.sol,bjTest,contract bjTest is Ownable { using SafeMath for uint256; uint256 public JoustNum = 1; uint256 public NumberOfPart = 0; uint256 public Commission = 0.024 * 1 ether; uint256 public RateEth = 0.3 * 1 ether; uint256 public TotalRate = 2.4 * 1 ether; struct BJJtab { uint256 JoustNumber; uint256 UserNumber; address UserAddress; uint256 CoincidNum; uint256 Winning; },1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0x71829ed960594f5e764b9854c89a308c70500432.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0xa35e4a5c0c228a342c197e3440dff1a584cc479c.sol,SGNL,"contract SGNL is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping(address=>bool) public frozenAccount; event FrozenFunds(address target, bool frozen); uint256 public constant initialSupply = 60000000 * 10**16; uint8 public constant decimalUnits = 16; string public tokenName = ; string public tokenSymbol = ; function SGNL() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xd8866cc3e8426511b756045f2d7c7c20797b9a0a.sol,MintableTokenExt,"contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; }",1
0x21683397aa53aaf7baca416c27f2c1e0e84bb493.sol,Regulator,contract RegulatorStorage is Ownable { struct Permission { string name; string description; string contract_name; bool active; },1
0xd956708eb515b0f78c7336757f3155d002c49752.sol,XCloudRoc,"contract XCloudRoc is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XCloudRoc() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0x51f171b6bc39456dd94a303537d995ea990e1146.sol,TTOH,"contract TTOH is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 10 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 30; uint constant valueTeam = valueTotal / 100 * 70; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x1afafc35b364595f06e89a0429c5762452eb7ffd.sol,CXTCContract,contract CXTCContract is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant freeSupply = 21000000 * (10 ** uint256(decimals)); uint256 public constant frozenSupply = 189000000 * (10 ** uint256(decimals)); address[] parterAcc; struct ArtInfo { string idtReport; string evtReport; string escReport; string regReport; },1
0xf3d86b6974ddf5b8407cfdcd3f874a76f7538b90.sol,MiniMeIrrevocableVestedToken,"contract MiniMeIrrevocableVestedToken is MiniMeToken, SafeMath { uint256 MAX_GRANTS_PER_ADDRESS = 20; struct TokenGrant { address granter; uint256 value; uint64 cliff; uint64 vesting; uint64 start; }",1
0x1f3640b76fef8f0c8efeb13623387f3bce31e080.sol,VGCToken,contract VGCToken { function setCrowdsaleContract (address _address) public {},1
0x707784ed2b464474f8fb763c058b33fcf8626db5.sol,Production,contract ProductionBoiler is BasicAuth { struct Boiler { uint m_Expire; uint32[] m_Chips; },1
0x5155a0722a45905dacf49598a02eff3777340acd.sol,ITransferManager,"contract ITransferManager is Module, Pausable { enum Result {INVALID, NA, VALID, FORCE_VALID}",1
0xe310fe78974df2c7df6262208582bf7e04cdc18e.sol,Solitaire3D,contract Solitaire3D is modularLong { using SafeMath for *; using S3DKeysCalcLong for uint256; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 seconds; uint256 private rndGap_ = 30 seconds; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 24 hours; address constant private developer = 0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897; address constant private operator = 0xc3F465FD001f78DCEeF6f47FD18E3B04F95f2337; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => S3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => S3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => S3Ddatasets.Round) public round_; uint256 public pID_; S3Ddatasets.TeamFee public fee_; constructor() public { fee_ = S3Ddatasets.TeamFee(50); plyr_[1].addr = 0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897; pIDxAddr_[0xA7759a5CAcE1a3b54E872879Cf3942C5D4ff5897] = 1; pID_ = 1; },1
0x50430b6201c9859c91a5590ac71700cc71499a0e.sol,GetPaid,"contract GetPaid is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 2; uint256 public totalSupply = 30000000000e2; uint256 public totalDistributed = 0; uint256 public totalValue = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 100000e2; uint256 public tokensPerEth = 10000000e2; uint256 public constant minContribution = 1 ether / 100; uint256 public constant maxTotalValue = 15000000000e2; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event Distr0(address indexed to, uint256 amount); event DistrFinished(); event ZeroEthFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; bool public zeroDistrFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,AngelCardData,"contract AngelCardData is IAngelCardData, SafeMath { event CreatedAngel(uint64 angelId); event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); struct AngelCardSeries { uint8 angelCardSeriesId; uint basePrice; uint64 currentAngelTotal; uint64 maxAngelTotal; AngelAura baseAura; uint baseBattlePower; uint64 lastSellTime; uint64 liveTime; }",1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0x75aa01dc00f6aeefe14bd58a5b6cbb091c6dc57b.sol,EtheremonCastleBattle,"contract EtheremonCastleBattle is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public NO_BATTLE_LOG = 4; struct CastleData { uint index; string name; address owner; uint32 totalWin; uint32 totalLose; uint64[6] monsters; uint64[4] battleList; uint32 brickNumber; uint createTime; }",1
0xed82730312babb41367e060911f798002ffa445f.sol,TheCryptoTech,"contract TheCryptoTech is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheCryptoTech() public { symbol = ; name = ; decimals = 18; _totalSupply = 950000000000000000000000000; balances[0x59e47c9984d391f4A6095f25d8fA2570e34D87CC] = _totalSupply; Transfer(address(0), 0x59e47c9984d391f4A6095f25d8fA2570e34D87CC, _totalSupply); }",1
0xf238c5c35298ff6a5bb7e9bb1e8a731d58ffa623.sol,OSPN,"contract OSPN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 30000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1da73fc09ea07781482994036a0eecc7e6952dfb.sol,TydoIco,"contract TydoIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; uint256[] public bonuses; uint256[] public bonusEnds; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken, uint256[] _bonuses, uint256[] _bonusEnds) Owned() public { require(_bonuses.length == _bonusEnds.length); for(uint8 i = 0; i < _bonuses.length; i++) { require(_bonuses[i] > 0); if (i > 0) { }",1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0xdd1393eb649d877b95fec0abe42abfb89a1e584a.sol,Consents,"contract Consents { enum ActionType { REVOKE, CONSENT, NONE }",1
0x87d1ccf428832015d6108520d6d0909013753a62.sol,Mainsale,"contract Mainsale is CommonSale { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x17fa9c502952fc271d1641fcaf815362be274643.sol,QBASE,"contract QBASE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed = 3000000000e18; uint256 public constant MIN_CONTRIBUTION = 1 ether / 10; uint256 public tokensPerEth = 100000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x74b0f78ea4ca63e3f791bcd30fb3a3c539c808b9.sol,TokenERC20,"contract TokenERC20 is owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiCoinTempMgr,contract ZebiCoinTempMgr is Ownable{ using SafeMath for uint256; address public wallet; ZebiCoinCrowdsale public preSaleCSSC; ZebiCoin public tsc; uint64 tokenDecimals; mapping(address => bool) preSaleCancelledList; mapping(address => uint256) noncsAllocations; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefunds; modifier inPreSaleCancelledList { require(preSaleCancelledList[msg.sender]); _; },1
0x345de4023f9afdabe4927fbdbfd45e1e9b0c66ec.sol,PO8PrivateSale,"contract PO8PrivateSale is Ownable{ using SafeMath for uint256; PO8Token public token; address public wallet; uint256 public currentRate; uint256 public limitTokenForSale; event ChangeRate(address indexed who, uint256 newrate); event FinishPrivateSale(); constructor() public { currentRate = 75000; wallet = address(0x072F140DcCCE18F9966Aeb6D71ffcD0b42748683); limitTokenForSale = 1250000000000000000000000000; token = PO8Token(0x8744a672D5a2df51Da92B4BAb608CE7ff4Ddd804); }",1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,ENSNFT,"contract ENSNFT is ERC721Token { Registrar registrar; constructor (string _name, string _symbol, address _registrar) public ERC721Token(_name, _symbol) { registrar = Registrar(_registrar); }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x560431a917c5bf4f5831935a199d6516472bcff1.sol,POFOMO,contract POFOMO { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x520308ffce2feaf394be1f23997312dede3ef541.sol,KMBToken,"contract KMBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994.sol,SHERE_PFII_II_883,"contract SHERE_PFII_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1219985648835240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4b353a668f90025337e7f1fcd4202c41f50a22df.sol,LEToken,"contract LEToken is StandardToken, Owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 3*10**28; function LEToken(address beneficiary) public { totalSupply_ = INITIAL_SUPPLY; balances[beneficiary] = INITIAL_SUPPLY; }",1
0xe154561093f7eeaf698bf77f324b4c0483102c9d.sol,CoinStocker,"contract CoinStocker is DetailedERC20, StandardToken, BurnableToken, Ownable { uint public rate = 20000; function CoinStocker() DetailedERC20(, , 18) Ownable public { balances[this] = 1000000000 * 10 ** 18; totalSupply_ = 1000000000 * 10 ** 18; }",1
0xcd95fbb2d73bab7f04893253b13e66f28841ab24.sol,GamblicaCoin,"contract GamblicaCoin is ERC20, owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; event Burned(address backer, uint _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; address public crowdsale; function changeCrowdsale(address newCrowdsale) public onlyOwner { crowdsale = newCrowdsale; }",1
0xbd270f9a96ed49a1c82055a22ad9b8eec564097f.sol,BetexToken,"contract BetexToken is StandardToken, NoOwner { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public firstUnlockTime; uint256 public secondUnlockTime; mapping (address => bool) public blockedTillSecondUnlock; address[] public holders; mapping (address => uint256) public holderNumber; address public icoAddress; uint256 public constant TOTAL_SUPPLY = 10000000 * (10 ** uint256(decimals)); uint256 public constant SALE_SUPPLY = 5000000 * (10 ** uint256(decimals)); uint256 public constant BOUNTY_SUPPLY = 200000 * (10 ** uint256(decimals)); uint256 public constant RESERVE_SUPPLY = 800000 * (10 ** uint256(decimals)); uint256 public constant BROKER_RESERVE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public constant TEAM_SUPPLY = 3000000 * (10 ** uint256(decimals)); address public constant BOUNTY_ADDRESS = 0x48c15e5A9343E3220cdD8127620AE286A204448a; address public constant RESERVE_ADDRESS = 0xC8fE659AaeF73b6e41DEe427c989150e3eDAf57D; address public constant BROKER_RESERVE_ADDRESS = 0x8697d46171aBCaD2dC5A4061b8C35f909a402417; address public constant TEAM_ADDRESS = 0x1761988F02C75E7c3432fa31d179cad6C5843F24; uint256 public constant MIN_HOLDER_TOKENS = 10 ** uint256(decimals - 1); function BetexToken ( uint256 _firstUnlockTime, uint256 _secondUnlockTime ) public { require(_secondUnlockTime > firstUnlockTime); firstUnlockTime = _firstUnlockTime; secondUnlockTime = _secondUnlockTime; balances[BOUNTY_ADDRESS] = BOUNTY_SUPPLY; holders.push(BOUNTY_ADDRESS); emit Transfer(0x0, BOUNTY_ADDRESS, BOUNTY_SUPPLY); balances[RESERVE_ADDRESS] = RESERVE_SUPPLY; holders.push(RESERVE_ADDRESS); emit Transfer(0x0, RESERVE_ADDRESS, RESERVE_SUPPLY); balances[BROKER_RESERVE_ADDRESS] = BROKER_RESERVE_SUPPLY; holders.push(BROKER_RESERVE_ADDRESS); emit Transfer(0x0, BROKER_RESERVE_ADDRESS, BROKER_RESERVE_SUPPLY); balances[TEAM_ADDRESS] = TEAM_SUPPLY; holders.push(TEAM_ADDRESS); emit Transfer(0x0, TEAM_ADDRESS, TEAM_SUPPLY); totalSupply_ = TOTAL_SUPPLY.sub(SALE_SUPPLY); }",1
0x28933055016731c1360d7422fbe6e73aaf3b1b1e.sol,YEX,"contract YEX is SafeMath { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function YEX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0xf4c5304366a87ff14bbae4ef8ae252c2c1243d8d.sol,MeshCrowdsale,"contract MeshCrowdsale is CappedCrowdsale, Ownable { using SafeMath for uint256; mapping (address => uint256) public weiLimits; mapping (address => uint256) public weiContributions; mapping (address => bool) public whitelistingAgents; uint256 public minimumContribution; address[] public beneficiaries; uint256[] public beneficiaryAmounts; bool public mintingFinished; function MeshCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumContribution, MeshToken _token, address[] _beneficiaries, uint256[] _beneficiaryAmounts) CappedCrowdsale(_cap) Crowdsale(_startTime, _endTime, _rate, _wallet, _token) public { require(_beneficiaries.length == _beneficiaryAmounts.length); beneficiaries = _beneficiaries; beneficiaryAmounts = _beneficiaryAmounts; mintingFinished = false; minimumContribution = _minimumContribution; }",1
0x40395044ac3c0c57051906da938b54bd6557f212.sol,MobileGoToken,contract MobileGoToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 10000000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function MobileGoToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0xbe96a69b2836201d9cbad2c485681dc7a4cc39b9.sol,DailyRoiCardGame,contract DailyRoiCardGame { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xb3b476df77086b227d480c99b69b08a77631f2cf.sol,ICOSyndicate,"contract ICOSyndicate { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; uint256 public eth_cap = 30000 ether; address public developer = 0x91d97da49d3cD71B475F46d719241BD8bb6Af18f; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) public { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0x6c7bbd8b6c32512dd36d8eecdb3ed4429eb8a85d.sol,GeneNuggetsToken,"contract GeneNuggetsToken is Pausable,StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public decimalFactor = 10 ** uint256(decimals); uint public CAP = 30e8 * decimalFactor; uint256 public circulatingSupply; uint256 public totalUsers; uint256 public exchangeLimit = 10000*decimalFactor; uint256 public exchangeThreshold = 2000*decimalFactor; uint256 public exchangeInterval = 60; uint256 public destroyThreshold = 100*decimalFactor; address public CFO; mapping(address => uint256) public CustomerService; uint[10] public MINING_LAYERS = [0,10e4,30e4,100e4,300e4,600e4,1000e4,2000e4,3000e4,2**256 - 1]; uint[9] public MINING_REWARDS = [1000*decimalFactor,600*decimalFactor,300*decimalFactor,200*decimalFactor,180*decimalFactor,160*decimalFactor,60*decimalFactor,39*decimalFactor,0]; event UpdateTotal(uint totalUser,uint totalSupply); event Exchange(address indexed user,uint256 amount); event Destory(address indexed user,uint256 amount); modifier onlyCFO() { require(msg.sender == CFO); _; }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,Controllable,contract Controllable is Ownable { mapping(address => uint256) private contractIndices; address[] private contracts; modifier onlyActiveContracts() { require(contractIndices[msg.sender] != 0); _; },1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0xcf8335727b776d190f9d15a54e6b9b9348439eee.sol,Epstein,"contract Epstein is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint random = 0; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x23D3808fEaEb966F9C6c5EF326E1dD37686E5972] = _totalSupply; emit Transfer(address(0), 0x23D3808fEaEb966F9C6c5EF326E1dD37686E5972, _totalSupply); }",1
0x33ce216c10dea5e724b7a90628ce7853eef127b3.sol,ExternStateToken,"contract ExternStateToken is SelfDestructible, Proxyable, TokenFallbackCaller { using SafeMath for uint; using SafeDecimalMath for uint; TokenState public tokenState; string public name; string public symbol; uint public totalSupply; uint8 public decimals; constructor(address _proxy, TokenState _tokenState, string _name, string _symbol, uint _totalSupply, uint8 _decimals, address _owner) SelfDestructible(_owner) Proxyable(_proxy, _owner) public { tokenState = _tokenState; name = _name; symbol = _symbol; totalSupply = _totalSupply; decimals = _decimals; }",1
0xf508548ef0ef6472760a36e15169b847ae427d38.sol,BasicCrowdsale,contract BasicCrowdsale is Ownable { using SafeMath for uint256; BasicERC20 token; address public ownerWallet; uint256 public startTime; uint256 public endTime; uint256 public totalEtherRaised = 0; uint256 public minDepositAmount; uint256 public maxDepositAmount; uint256 public softCapEther; uint256 public hardCapEther; mapping(address => uint256) private deposits; constructor () public { },1
0x510a4ab35fcb498f798a0da8187012d78be3bd72.sol,CrydrStorageBalance,"contract CrydrStorageBalanceInterface { event AccountBalanceIncreasedEvent(address indexed account, uint256 value); event AccountBalanceDecreasedEvent(address indexed account, uint256 value); function increaseBalance(address _account, uint256 _value) public; function decreaseBalance(address _account, uint256 _value) public; function getBalance(address _account) public constant returns (uint256); function getTotalSupply() public constant returns (uint256); }",1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0x6a16055015bce7d67c80030b383bdd89ab565dbc.sol,PremiumInvest,"contract PremiumInvest { using SafeMath for uint; mapping(address => uint) public userDeposit; mapping(address => uint) public userTime; mapping(address => uint) public persentWithdraw; address public projectFund = 0xf76775E4C97fe43cf42a41b45d3D1A2e283Ec43A; address public admin = 0xeC2325073AE9F288b3dF22b3b55E68BB3fD9bCB5; uint projectPercent = 7; uint public adminPercent = 1; uint public chargingTime = 1 hours; uint public startPercent = 375; uint public lowPersent = 400; uint public middlePersent = 450; uint public highPersent = 500; uint public stepLow = 500 ether; uint public stepMiddle = 2000 ether; uint public stepHigh = 4000 ether; uint public countOfInvestors = 0; uint public countOfadmin = 0; modifier isIssetUser() { require(userDeposit[msg.sender] > 0, ); _; }",1
0x8d3659bdcb63bdfe4f224e94f35bcf4901755d18.sol,Nyancoin,"contract Nyancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0xAaBe0F0AC2643f9f23671f982FA688da1e939a1F] = _totalSupply; emit Transfer(address(0), 0xAaBe0F0AC2643f9f23671f982FA688da1e939a1F, _totalSupply); }",1
0x64d581770b541b5609140232fc12f47bbe0fe6bc.sol,MonetoSale,"contract MonetoSale { Moneto public token; address public beneficiary; address public alfatokenteam; uint public alfatokenFee; uint public amountRaised; uint public tokenSold; uint public constant PRE_SALE_START = 1523952000; uint public constant PRE_SALE_END = 1526543999; uint public constant SALE_START = 1528617600; uint public constant SALE_END = 1531209599; uint public constant PRE_SALE_MAX_CAP = 2531250 * 10**18; uint public constant SALE_MAX_CAP = 300312502 * 10**17; uint public constant SALE_MIN_CAP = 2500 ether; uint public constant PRE_SALE_PRICE = 1250; uint public constant SALE_PRICE = 1000; uint public constant PRE_SALE_MIN_BUY = 10 * 10**18; uint public constant SALE_MIN_BUY = 1 * 10**18; uint public constant PRE_SALE_1WEEK_BONUS = 35; uint public constant PRE_SALE_2WEEK_BONUS = 15; uint public constant PRE_SALE_3WEEK_BONUS = 5; uint public constant PRE_SALE_4WEEK_BONUS = 0; uint public constant SALE_1WEEK_BONUS = 10; uint public constant SALE_2WEEK_BONUS = 7; uint public constant SALE_3WEEK_BONUS = 5; uint public constant SALE_4WEEK_BONUS = 3; mapping (address => uint) public icoBuyers; Stages public stage; enum Stages { Deployed, Ready, Ended, Canceled }",1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x1d72347bfc99b65a61ecf464676994ef725e3294.sol,Token,"contract Token is StandardToken{ uint currUnlockStep; uint256 currUnlockSeq; mapping (uint => uint256[]) public freezeOf; mapping (uint => bool) public stepUnlockInfo; mapping (address => uint256) public freezeOfUser; uint256 internal constant INITIAL_SUPPLY = 1 * (10**8) * (10 **18); event Burn(address indexed burner, uint256 value); event Freeze(address indexed locker, uint256 value); event Unfreeze(address indexed unlocker, uint256 value); event TransferMulti(uint256 count, uint256 total); constructor() { owner = msg.sender; balanceOf[owner] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; }",1
0x1a506cbc15689f2902b22a8baf0e5cc1ed8203ee.sol,ARCXToken,"contract ARCXToken is StandardToken, Ownable { string public name; string public symbol; uint public constant decimals = 18; uint public INITIAL_SUPPLY; address public crowdsaleContract; bool public transferEnabled; uint public timeLock; mapping(address => bool) private ingnoreLocks; mapping(address => uint) public lockedAddresses; event Burn(address indexed _burner, uint _value); modifier onlyWhenTransferEnabled() { if (msg.sender != crowdsaleContract) { require(transferEnabled); }",1
0x2f55045439c0361ac971686e06d5b698952f89c1.sol,EDUCrowdsale,"contract EDUCrowdsale is AllowanceCrowdsale, CappedCrowdsale, TimedCrowdsale, Ownable, Certifiable { using SafeMath for uint256; uint256 constant FIFTY_ETH = 50 * (10 ** 18); uint256 constant HUNDRED_AND_FIFTY_ETH = 150 * (10 ** 18); uint256 constant TWO_HUNDRED_AND_FIFTY_ETH = 250 * (10 ** 18); uint256 constant TEN_ETH = 10 * (10 ** 18); EDUToken public token; event TokenWalletChanged(address indexed newTokenWallet); event WalletChanged(address indexed newWallet); constructor( address _wallet, EDUToken _token, address _tokenWallet, uint256 _cap, uint256 _openingTime, uint256 _closingTime, address _certifier ) public Crowdsale(getCurrentRate(), _wallet, _token) AllowanceCrowdsale(_tokenWallet) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) Certifiable(_certifier) { token = _token; }",1
0x1839864616602fee4d5cc7a6448dd257636c9a9a.sol,TradeBTC,contract TradeBTC is AbstractToken { uint256 constant INITIAL_TOKENS_COUNT = 210000000e6; address owner; uint256 tokensCount; function TradeBTC (address fundAddress) public { tokensCount = INITIAL_TOKENS_COUNT; accounts [msg.sender] = INITIAL_TOKENS_COUNT; owner = msg.sender; fund = fundAddress; },1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,EternalStorage,"contract EternalStorage { address public owner; mapping(bytes32 => uint256) private uIntStorage; mapping(bytes32 => uint8) private uInt8Storage; mapping(bytes32 => string) private stringStorage; mapping(bytes32 => address) private addressStorage; mapping(bytes32 => bytes) private bytesStorage; mapping(bytes32 => bool) private boolStorage; mapping(bytes32 => int256) private intStorage; mapping(bytes32 => bytes32) private bytes32Storage; modifier onlyLatestContract() { require(addressStorage[keccak256(abi.encodePacked(, msg.sender))] != 0x0 || msg.sender == owner); _; }",1
0x89e33f3b7799251fca54b969de9a8882202b1c64.sol,NeoGem,"contract NeoGem is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_PURCHASE = 1 ether / 100; uint256 public tokensPerEth = 200000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Synth,"contract SynthetixState is State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; struct IssuanceData { uint initialDebtOwnership; uint debtEntryIndex; }",1
0x55c30ae7a9ad5861394e971327b6bf35d147119d.sol,ETD,contract ETD is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x20d4ec1b92cc4570c74efd968d04660b8fcc0406.sol,PornLoversToken,"contract PornLoversToken is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 91; event LogBonusSet(address indexed _address, uint256 _amount); function virtualBalanceOf(address _owner) internal view returns (uint256) { return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0; }",1
0x5caeebfab3cd8655e04692351237efb7462c9d8f.sol,VfSE_Lottery,"contract VfSE_Lottery is Ownable { using SafeMath for uint256; address[] private players; address[] public winners; uint256[] public payments; uint256 private feeValue; address public lastWinner; address public authorizedToDraw; address[] private last10Winners = [0,0,0,0,0,0,0,0,0,0]; uint256 public lastPayOut; uint256 public amountRised; address public house; uint256 public round; uint256 public playValue; uint256 public roundEnds; uint256 public roundDuration = 1 days; bool public stopped; address public SecondAddressBalance = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98; address public ThirdAddressBalance = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE; address public FourthAddressBalance = 0x267be1C1D684F78cb4F6a176C4911b741E4Ffdc0; mapping (address => uint256) public payOuts; uint256 private _seed; function bitSlice(uint256 n, uint256 bits, uint256 slot) private pure returns(uint256) { uint256 offset = slot * bits; uint256 mask = uint256((2**bits) - 1) << offset; return uint256((n & mask) >> offset); }",1
0x46d35eb66725413c6694dee8fe6d41d5eb9e1408.sol,DankCoin,contract DankCoin { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x541cdaae3d240aee1a79a7469c2f10b6dd98e4d7.sol,DAILYC,"contract DAILYC is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 200 * 10000 * 10000 * 10 ** 8; uint constant valueSale = 0; uint constant valueTeam = valueTotal / 100 * 100; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x2dd09c71d951148bba0f25be7f76ba401fe8ef84.sol,GoTokenDutchAuction,contract GoTokenDutchAuction { GoToken public token; address public owner_address; address public wallet_address; address public whitelister_address; address public distributor_address; uint256 constant public bid_threshold = 10 finney; uint256 public token_multiplier; uint256 public num_tokens_auctioned; uint256 public price_start; uint256 constant public CURVE_CUTOFF_DURATION = 8 days; uint256 public price_constant1; uint256 public price_exponent1; uint256 public price_constant2; uint256 public price_exponent2; uint256 public privatesale_start_time; uint256 public auction_start_time; uint256 public end_time; uint256 public start_block; uint256 public received_wei; uint256 public received_wei_with_bonus; uint256 public funds_claimed; uint256 public final_price; struct Account { uint256 accounted; uint256 received; },1
0x7638a5f444eab0281ca1abff2c8029cbb806a566.sol,XOXOCoin,"contract XOXOCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 200000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x7323cb1288cde81500e744234a487c642823aa24.sol,ERC20,"contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; constructor(string name, string symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedERC20,contract LoggedERC20 is Ownable { struct LogValueBlock { uint256 value; uint256 block; },1
0x779c2a5d3b3bb145f62a09197282c3b8420eff04.sol,owlockups,contract owlockups { using SafeMath for uint; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply; uint256 public totalAvailable; uint public totalAddress; address public admin; uint public _lockupBaseTime = 1 days; address public tokenAddress; modifier onlyOwner { require(msg.sender == admin); _; },1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x0f43093b586b011258479e61d41a862e909386e0.sol,PO8BaseToken,"contract PO8BaseToken is ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 totalSupply_; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public{ name = _name; symbol = _symbol; decimals = _decimals; totalSupply_ = _totalSupply; }",1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,Ellobitz,"contract Ellobitz is TokenERC20, Owned, Whitelisted { uint256 public mineCount; uint256 public minMineSize; uint256 public maxMineSize; uint256 public chipSize; uint256 public firstChipBonus; uint public chipSpeed; uint256 internal activeMine; uint256 internal mineSize; bool internal firstChip; mapping(address => uint) public lastChipTime; event MineFound(address indexed chipper, uint256 activeMine); event MineChipped(address indexed chipper, uint256 indexed activeMine, uint256 amount); event MineExausted(address indexed chipper, uint256 activeMine); modifier validMineParameters ( uint256 _mineCount, uint256 _minMineSize, uint256 _maxMineSize, uint256 _chipSize, uint256 _firstChipBonus, uint _chipSpeed ) { require(_minMineSize <= _maxMineSize, ); require(_chipSize + _firstChipBonus <= _minMineSize, ); _; }",1
0xa2201234a4652a704f5539058ccb9ab6ebcd486b.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 5; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0f5ee401de162cd163b6ff46318eef2727dbb9fc.sol,MOIRAICO,"contract MOIRAICO { enum State { Preico, Ico, Successful }",1
0x5ab5dded8c5c384015c8f3a27d59bf71b952a3a4.sol,PearlBonus,contract PearlBonus { address public pearlContract = 0x1844b21593262668B7248d0f57a220CaaBA46ab9; OysterPearl pearl = OysterPearl(pearlContract); address public director; address public partner; uint8 public share; uint256 public funds; bool public saleClosed; function PearlBonus() public { director = msg.sender; partner = 0x5F5E3bc34347e1f10C7a0E932871D8DbFBEF9f87; share = 10; funds = 0; saleClosed = false; },1
0x037941d4ed93af8628fb4e9451752db8b2446f76.sol,Snowflake,contract Snowflake is Ownable { using SafeMath for uint; using addressSet for addressSet._addressSet; mapping (string => uint) internal deposits; uint signatureTimeout; mapping (bytes32 => bool) signatureLog; mapping (string => Identity) internal directory; mapping (address => string) internal addressDirectory; mapping (bytes32 => string) internal initiatedAddressClaims; address public clientRaindropAddress; address public hydroTokenAddress; addressSet._addressSet resolverWhitelist; constructor() public { setSignatureTimeout(7200); },1
0x3813a81a0a116a086799d37b66c0fd9925cb98c6.sol,WTF,"contract WTF is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x719502d2755fcf269da27d9f07c96d68a2f3572a.sol,ElementeumTokenProxy,"contract ElementeumTokenProxy is Ownable { ElementeumToken public token; function ElementeumTokenProxy(uint256 _cap, address[] _founderAccounts, address[] _operationsAccounts) public Ownable() { token = new ElementeumToken(_cap, _founderAccounts, _operationsAccounts); }",1
0x0e91430580361bd7c91500faa82addea8581b2fe.sol,LittleBeeX_Sender,"contract LittleBeeX_Sender is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) public onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender, dests[i], values[i]); i += 1; }",1
0x001f0aa5da15585e5b2305dbab2bac425ea71007.sol,IpsxToken,"contract IpsxToken is StandardToken, Ownable { event Burn(address indexed burner, uint256 value); event EnabledTransfers(); event SetCrowdsaleAddress(address indexed crowdsale); address public crowdsale; string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public totalSupply = 1800000000e18; bool public transferable = false; function IpsxToken() public { balances[msg.sender] = totalSupply; }",1
0x8bf98ad0e7d8d4924c6a52f6e4b87f96d3a278fa.sol,DOTON,"contract DOTON is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOTON() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6cc9db1be24450f28b298d045cc0ecac552f1f83.sol,EtherHolders,contract EtherHolders{ modifier onlyBagholders { require(myTokens() > 0); _; },1
0x25f1638577b69186c1d7a2e6bb297a82cdc602f2.sol,StinkyLinky,contract StinkyLinky { address ceoAddress = 0xC0c8Dc6C1485060a72FCb629560371fE09666500; struct Sergey { address currentStinkyLinky; uint256 currentValue; },1
0x2a92f24bfad42b04cfe5c000be404c2a84ca5b71.sol,CryptoSuperGirlfriend,"contract CryptoSuperGirlfriend { using SafeMath for uint256; address private addressOfOwner; event Add (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private priceInit = 0.01 ether; uint256 private idStart = 10001; uint256 private idMax = 10191; struct OwnerInfo{ string ownerName; string ownerWords; string ownerImg; string ownerNation; }",1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0xbe404e1fc0c3024f506f0353d67e7fe4eb95952f.sol,BulDex,"contract BulDex is Ownable { using SafeERC20 for ERC20; mapping(address => bool) users; ERC20 public promoToken; ERC20 public bullToken; uint public minVal = 365000000000000000000; uint public bullAmount = 3140000000000000000; constructor(address _promoToken, address _bullToken) public { promoToken = ERC20(_promoToken); bullToken = ERC20(_bullToken); }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0xd9b7a4bccac0c86b55875dc58b59f9871128e57a.sol,AgroLyteToken,"contract AgroLyteToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 4000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 0; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xddaf60dbc930cc44af8b1b85cacfc866e2eed23d.sol,MultiCertifier,"contract MultiCertifier is Owned, Certifier { modifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }",1
0x48ec60c155a8487f9f06107054afe947a2345bbc.sol,Harj,contract Harj { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x411f62eb0f063ca5c063154e98e6dd5c451dbd23.sol,CoinSbs,"contract CoinSbs { address public admin_address = 0x6a5E8a616c91cc0a6d1313dEDB4AB33Cd4E2A37e; address public account_address = 0x6a5E8a616c91cc0a6d1313dEDB4AB33Cd4E2A37e; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 initSupply = 4900000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x70528e8cc624f437fd01ab5a5215d8bb092b73ff.sol,ERC20,"contract ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x7302ffd8f135f69b29e94e6a4a26868188fe34ff.sol,YANKEES,"contract YANKEES is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function YANKEES (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0xf4c1d8863820b5e66fee5ea5d247f597f73f91f6.sol,SBToken,contract SBToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 2000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { wallet = 0x9F1D5D27c7FD3EaB394b65B6c06e4Ef22F333210; addressOfTokenUsedAsReward = 0x4bF62424385ddcD858535cAa1878e512314a9Aeb; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xf238f55ede5120915b36715b0fffe20ff57f8134.sol,BytesToTypes,"contract BytesToTypes { function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) }",1
0x41bbcf4f8f0e8a0a3cce4287d1c0c3d27c65ba0d.sol,MallToken,"contract MallToken is CappedToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public constant MAX_SUPPLY = 10 * 10000 * 10000 * (10 ** uint256(decimals)); constructor() CappedToken(MAX_SUPPLY) public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x4631d9e5a29350ced6a70f53ac3a23e5e0f41c1f.sol,TokenSale,"contract TokenSale is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; rateInterface public rateContract; address public wallet; address public advisor; uint256 public advisorFee; uint256 public constant decimals = 18; uint256 public endTime; uint256 public startTime; mapping(address => bool) public rc; function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public { tokenContract = tokenInterface(_tokenAddress); rateContract = rateInterface(_rateAddress); setTime(_startTime, _endTime); wallet = msg.sender; advisor = msg.sender; advisorFee = 0 * 10**3; }",1
0x418e831d865dcb26af9721b277d2dce58526c6b9.sol,DigimaWebToken,"contract DigimaWebToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xa1ad52ff49fc70b7920b7d02483a58beb15d492b.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private owner = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private opAddress = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private comAddress = 0x24D160101C72c035287f772a8ac2b744a477F489; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0f717ffff71e639636fcdd33727ee8c17c4724bf); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 2 hours; uint256 constant private comDropGap_ = 24 hours; uint256 constant private rndNTR_ = 168 hours; uint256 public airDropPot_; uint256 public airDropPot2_; uint256 public airDropTracker_ = 0; uint256 public airDropTracker2_ = 0; uint256 public rID_; uint256 public comReWards_; uint256 public comAirDrop_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => uint256) public inviteCount_; mapping (address => bool) public addrLock_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => uint256[10]) public lastTen_; mapping (uint256 => uint256) public roundBetCount_; mapping (uint256 => mapping (uint256 =>uint256)) public comDropLastTime_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(48,0); fees_[1] = F3Ddatasets.TeamFee(33,0); fees_[2] = F3Ddatasets.TeamFee(18,0); potSplit_[0] = F3Ddatasets.PotSplit(10,20); potSplit_[1] = F3Ddatasets.PotSplit(5,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0x51db62d862314d036797c8ae897011dadb8256ce.sol,OKFCrowdsale,"contract OKFCrowdsale is Pausable { using SafeMath for uint; OKFToken public token; address public beneficiary = 0x97F795fbdEf69ee530d54e7Dc4eCDCc0244aAf00; address public command = 0xEe7410eCf01988A61Ba2C3f66283c08859414F6B; uint public collectedWei; uint public collectedUSD; uint public tokensSold; uint public tokensForSale = 10000000 * 1 ether; uint public priceETHUSD = 250; uint public softCapUSD = 1500000; uint public hardCapUSD = 2500000; uint public softCapWei = softCapUSD * 1 ether / priceETHUSD; uint public hardCapWei = hardCapUSD * 1 ether / priceETHUSD; uint public priceTokenWei = 1 ether / 1000; uint public startTime = 1507032000; uint public endTime = 1517659200; bool public crowdsaleFinished = false; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); event SoftCapReached(uint256 etherAmount); event HardCapReached(uint256 etherAmount); event Withdraw(); function OKFCrowdsale() { token = new OKFToken(); require(token.transfer(0x915c517cB57fAB7C532262cB9f109C875bEd7d18, 1000000 * 1 ether)); }",1
0x203d93ef7d5c24eac69ac386146d6ae8336cc860.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c.sol,CSLottery,"contract CSLottery is ERC721, usingOraclize, Functional, Owned { uint256 public feeLottery; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0xeafd8b734e32aec64c4b445e9da401427ef63a3a.sol,CryptoEngineerInterface,contract CryptoEngineerInterface { uint256 public prizePool = 0; function calculateCurrentVirus(address ) public pure returns(uint256 ) {},1
0xd99b8a7fa48e25cce83b81812220a3e03bf64e5f.sol,SkrumbleToken,contract SkrumbleToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; function SkrumbleToken() public { totalSupply_ = 1500000000 * 1 ether; balances[msg.sender] = totalSupply_; },1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,AddressBook,contract AddressBook { struct AddressRelations { SlaveDictionary slaves; bool hasValue; },1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x279e152f96bdd4a0b3cb10b5fba0cfeea4a7429b.sol,RxEALTokenContract,"contract RxEALTokenContract is StandardToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 96000000 * (10 ** decimals); address public vault = this; address public salesAgent; mapping (address => bool) public owners; event OwnershipGranted(address indexed _owner, address indexed revoked_owner); event OwnershipRevoked(address indexed _owner, address indexed granted_owner); event SalesAgentPermissionsTransferred(address indexed previousSalesAgent, address indexed newSalesAgent); event SalesAgentRemoved(address indexed currentSalesAgent); event Burn(uint256 value); modifier onlyOwner() { require(owners[msg.sender] == true); _; }",1
0x0eb1b93c35dc7513c1e6cd683850734686fc9106.sol,Ownable,"contract Ownable { address public owner; address public pendingOwner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; pendingOwner = address(0); }",1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x39b948d3f844bb9e0e3b375901bb43d4866ef4bb.sol,Crowdsale,"contract Crowdsale is owned, UNICToken { using SafeMath for uint; UNICToken public token = new UNICToken(); address constant multisig = 0x867570869f8a46c685A51EE87b5D979A6ef657A9; uint constant rate = 3400; uint256 public constant forSale = 55000000 * 10 ** uint256(decimals); uint public constant presaleWhitelistDiscount = 40; uint public presaleWhitelistTokensLimit = 750000 * 10 ** uint256(decimals); uint public constant presaleStart = 1520503200; uint public constant presaleEnd = 1521453600; uint public constant presaleDiscount = 30; uint public presaleTokensLimit = 5000000 * 10 ** uint256(decimals); uint public constant firstRoundICOStart = 1522317600; uint public constant firstRoundICOEnd = 1523527200; uint public constant firstRoundICODiscount = 20; uint public firstRoundICOTokensLimit = 6250000 * 10 ** uint256(decimals); uint public constant secondRoundICOStart = 1524736800; uint public constant secondRoundICOEnd = 1526551200; uint public constant secondRoundICODiscount = 10; uint public secondRoundICOTokensLimit = 43750000 * 10 ** uint256(decimals); uint public constant presaleFemaleStart = 1520467200; uint public constant presaleFemaleEnd = 1520553600; uint public constant presaleFemaleDiscount = 88; uint public presaleFemaleTokensLimit = 88888 * 10 ** uint256(decimals); uint public constant presalePiStart = 1520985600; uint public constant presalePiEnd = 1521072000; uint public constant presalePiDiscount = 34; uint public presalePiTokensLimit = 31415926535897932384626; uint public constant firstRoundWMStart = 1522800000; uint public constant firstRoundWMEnd = 1522886400; uint public constant firstRoundWMDiscount = 25; uint public firstRoundWMTokensLimit = 404404 * 10 ** uint256(decimals); uint public constant firstRoundCosmosStart = 1523491200; uint public constant firstRoundCosmosEnd = 1523577600; uint public constant firstRoundCosmosDiscount = 25; uint public firstRoundCosmosTokensLimit = 121961 * 10 ** uint256(decimals); uint public constant secondRoundMayStart = 1525132800; uint public constant secondRoundMayEnd = 1525219200; uint public constant secondRoundMayDiscount = 15; uint public secondRoundMayTokensLimit = 1111111 * 10 ** uint256(decimals); uint public etherRaised = 0; uint public tokensSold = 0; address public icoManager; mapping (address => bool) public WhiteList; mapping (address => bool) public Females; mapping (address => bool) public KYC1; mapping (address => bool) public KYC2; mapping (address => uint256) public KYCLimit; uint256 public constant KYCLimitValue = 1.5 ether; modifier onlyManager() { require(msg.sender == icoManager); _; }",1
0xd908b8660054593200352cb65dbff990e5f64cab.sol,MultipleOwners,contract MultipleOwners is Ownable { struct Owner { bool isOwner; uint256 index; },1
0x2733fc7f6a5d5be13b1ffbcfcbcba83241e819c6.sol,MarketplaceInformation,"contract MarketplaceInformation is MarketplaceCommon { function MarketplaceInformation(address _resolver) public { require(init(CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION, _resolver)); }",1
0xaa4a3990673d9d913a24f89e956e7c02a03f9b08.sol,MMONToken,"contract MMONToken is standardToken,Owned { using SafeMath for uint; string constant public name=; string constant public symbol=; uint256 constant public decimals=6; bool public ICOStart; function() public payable { require (ICOStart); depositToken(msg.value); }",1
0x5a9633b76eedb38ab04733682f1f422b4ce219b5.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0x7021967e5d0761772c6fb25304f2d013865aba7c.sol,EpigenCareCrowdsale,contract EpigenCareCrowdsale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public startTime; uint256 public endTime; address public wallet; address public tokenPool; uint256 public rate; uint256 public weiRaised; uint256 public weiPending; uint256 public tokensPending; uint256 public minimumInvestment; mapping (address => Transaction) transactions; mapping (address => bool) approvedAddresses; mapping (address => bool) verifiers; struct Transaction { uint weiAmount; uint tokenAmount; },1
0x35a1700ac75f6e9e096d9a5c90e3221b658096e0.sol,SpendableWallet,"contract SpendableWallet is Ownable { ERC20 public token; event ClaimedTokens( address indexed _token, address indexed _controller, uint256 _amount ); constructor(address _token, address _owner) public { token = ERC20(_token); owner = _owner; }",1
0xa2651bfa1d613fea0f7a3138e442e4ee865b5ec7.sol,AdsVenture,contract AdsVenture is Owned{ struct User{ string username; uint balance; },1
0xd59f53256addf282aa1d5e19f934738ddc06c5cf.sol,KINELA,contract KINELA { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint public _totalSupply = 210000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x2a790479cd47f686804fe570b903f3b6cf08599d.sol,ChainmonstersShop,contract ChainmonstersShop { using SafeMath for uint256; address public owner; bool started; uint256 public totalCoinsSold; address medianizer; uint256 shiftValue = 100; uint256 multiplier = 10000; struct Package { uint256 price; string packageReference; bool isActive; uint256 coinsAmount; },1
0x51ab0d8afb8b9dd4b8c0eebbb4b211b9463e45a6.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { totalSupply = 80000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x65732d6e88a83a38a4b803b0181b3a03a4165373.sol,Crowdsale,"contract Crowdsale is StaffUtil { using SafeMath for uint256; Token tokenContract; PromoCodes promoCodesContract; DiscountPhases discountPhasesContract; DiscountStructs discountStructsContract; address ethFundsWallet; uint256 referralBonusPercent; uint256 startDate; uint256 crowdsaleStartDate; uint256 endDate; uint256 tokenDecimals; uint256 tokenRate; uint256 tokensForSaleCap; uint256 minPurchaseInWei; uint256 maxInvestorContributionInWei; bool paused; bool finalized; uint256 weiRaised; uint256 soldTokens; uint256 bonusTokens; uint256 sentTokens; uint256 claimedSoldTokens; uint256 claimedBonusTokens; uint256 claimedSentTokens; uint256 purchasedTokensClaimDate; uint256 bonusTokensClaimDate; mapping(address => Investor) public investors; enum InvestorStatus {UNDEFINED, WHITELISTED, BLOCKED}",1
0xf0d20ae17804be1e5fd400f04991aeb0ffed5a03.sol,PowH3DToken,contract PowH3DToken { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalBonusTokensIssued = 0; uint256 public totalSupply = 0; bool public purchasingAllowed = true; address owner = msg.sender; function name() constant returns (string) { return ; },1
0x34ddcc255d2f3f2e2d85a2a11e314670e73b24d4.sol,lottrygame,"contract lottrygame{ uint256 public people; uint numbers; uint256 public tickamount = 100; uint256 public winnergetETH1 = 0.05 ether; uint256 public winnergetETH2 = 0.03 ether; uint256 public winnergetETH3 = 0.02 ether; uint public gamecount = 0; uint public inputsbt = 100; uint black=1; uint red=2; uint yellow=3; address[] public tickplayers; address public owner; address tokenAddress = 0x503F9794d6A6bB0Df8FBb19a2b3e2Aeab35339Ad; address poolwallet; bool public tickgamelock = true; bool public full = true; event tickwinner(uint,address,address,address,uint,uint,uint); event ticksell(uint gettick,uint paytick); modifier ownerOnly() { require(msg.sender == owner); _; }",1
0x5044ac8da9601edf970dcc91a10c5f41c5c548c0.sol,UPower,contract UPower { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0xedac0e5bedf702accc3a9b2b4b44b4ba0806e882.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,Haltable,contract Haltable is Ownable { bool public halted; modifier inNormalState { assert(!halted); _; },1
0x2134057c0b461f898d375cead652acae62b59541.sol,CoxxxCoin,"contract CoxxxCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoxxxCoin( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3a6e5f1c1b0de5d2b46babd21c7844c96f5180aa.sol,SniperBillion,contract SniperBillion is modularBillion { using SafeMath for *; using Array256Lib for uint256[]; address constant private comReward_ = 0x8Aa94D530cC572aF0C730147E1ab76875F25f71C; address constant private comMarket_ = 0x6c14CAAc549d7411faE4e201105B4D33afb8a3db; address constant private comICO_ = 0xbAdb636C5C3665a969159a6b993F811D9F263639; address constant private donateAccount_ = 0x1bB064708eBf4763BeB495877E99Dfeb75198942; RubyFundForwarderInterface constant private Ruby_Fund = RubyFundForwarderInterface(0x7D653E0Ecb4DAF3166a49525Df04147a7180B051); SniperBookInterface constant private SniperBook = SniperBookInterface(0xc294FA45F713B09d865A088543765800F47514eD); string constant public name = ; string constant public symbol = ; uint256 constant private icoEndTime_ = 24 hours; uint256 constant private maxNumber_ = 100000000; uint256 public totalSum_; uint256 public rID_; uint256 public icoAmount_; bool private isDrawed_ = false; uint256 lastSID_; uint256[] private globalArr_; uint256[] private icoSidArr_; uint256[] private luckyPotBingoArr_; uint256[] private airdropPotBingoArr_; mapping (address => uint256) public sIDxAddr_; mapping (bytes32 => uint256) public sIDxName_; mapping (uint256 => uint256) public sidXnum_; mapping (uint256 => SPBdatasets.Sniper) public spr_; mapping (uint256 => SPBdatasets.Round) public round_; mapping (uint256 => mapping (bytes32 => bool)) public sprNames_; constructor() public { },1
0x5199a4ff997ef55868be421790408d46189aa657.sol,SuperHeroes,contract SuperHeroes is Pausable { string public constant name = ; string public constant symbol = ; uint256 public fee = 2; uint256 public snatch = 24 hours; struct Token { string name; string src; uint256 price; uint256 purchased; },1
0x4b5bc97407898339eca79b541cee9b8b79ccda40.sol,IdaToken,"contract IdaToken is Ownable, RBAC, StandardToken { using AddressUtils for address; using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; uint256 public constant FOOTSTONE_ROUND_AMOUNT = 396000000; uint256 public constant PRIVATE_SALE_AMOUNT = 1200000000; uint256 public constant OWNER_LOCKED_IN_COMMON = 5000000000; uint256 public constant COMMON_PURPOSE_AMOUNT = 7204000000; uint256 public constant TEAM_RESERVED_AMOUNT1 = 120000000; uint256 public constant TEAM_RESERVED_AMOUNT2 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT3 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT4 = 360000000; uint256 public constant EXCHANGE_RATE_IN_PRIVATE_SALE = 10000; uint256 public constant TIMESTAMP_OF_20181001000001 = 1538352001; uint256 public constant TIMESTAMP_OF_20181002000001 = 1538438401; uint256 public constant TIMESTAMP_OF_20181101000001 = 1541030401; uint256 public constant TIMESTAMP_OF_20190201000001 = 1548979201; uint256 public constant TIMESTAMP_OF_20190501000001 = 1556668801; uint256 public constant TIMESTAMP_OF_20190801000001 = 1564617601; uint256 public constant TIMESTAMP_OF_20191101000001 = 1572566401; uint256 public constant TIMESTAMP_OF_20201101000001 = 1604188801; uint256 public constant TIMESTAMP_OF_20211101000001 = 1635724801; string public constant ROLE_PARTNERWHITELIST = ; string public constant ROLE_PRIVATESALEWHITELIST = ; uint256 public totalOwnerReleased; uint256 public totalPartnersReleased; uint256 public totalPrivateSalesReleased; uint256 public totalCommonReleased; uint256 public totalTeamReleased1; uint256 public totalTeamReleased2; uint256 public totalTeamReleased3; uint256 public totalTeamReleased4; address[] private partners; mapping (address => uint256) private partnersIndex; address[] private privateSaleAgents; mapping (address => uint256) private privateSaleAgentsIndex; mapping (address => uint256) private partnersAmountLimit; mapping (address => uint256) private partnersWithdrawed; mapping (address => uint256) private privateSalesReleased; address ownerWallet; event TransferLog(address from, address to, bytes32 functionName, uint256 value); constructor(address _ownerWallet) public { ownerWallet = _ownerWallet; totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0x7996f859a313aab6458558c648e2f1f4acbf5f93.sol,HealthAidToken,contract HealthAidToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 25000000000 * 100000000; function name() public constant returns (string) { return ; },1
0x0f1cd99bea68f0d994064395d2b45315b185882e.sol,Countdown,contract Countdown { uint public deadline; address owner; address public winner; uint public reward = 0; uint public tips = 0; uint public buttonClicks = 0; function Countdown() public payable { owner = msg.sender; deadline = now + 3 hours; winner = msg.sender; reward += msg.value; },1
0x01c385948f22ac1a9dfebdc423ee3a2e29ec5751.sol,DelayedClaimable,"contract DelayedClaimable is Claimable { uint256 public end; uint256 public start; function setLimits(uint256 _start, uint256 _end) public onlyOwner { require(_start <= _end); end = _end; start = _start; }",1
0x72c3a4fc3b3330e36fdf575e5c8b16e5a77856f6.sol,PackSale,"contract PackSale is Pausable { event Sold(address buyer, uint256 sku, uint256 totalPrice); event Hatched(address buyer, uint256 amount); uint256 constant PRESALE_START_TIME = 1542484800; uint256 constant NUM_UNIT_TYPES = 30; Token token; function setTokenContractAddress(address newAddress) onlyOwner public { token = Token(newAddress); }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,D1Coin,"contract D1Coin is BasicToken, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 3; address theCoin = address(this); struct ProtectedBalanceStruct { uint256 balance; bytes32 hashed; }",1
0xbfc70f2151b471794422fd06480933192f3da674.sol,SIE_DE_301202,"contract SIE_DE_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10972781423493000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xed61627b7af399ea7a11f55a03c557cd745c35ba.sol,BTCCToken,"contract BTCCToken is Ownable,StandardToken { uint public totalSupply = 3*10**27; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function BTCCToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x359a46571d4bc22a6a9310038b51e2d91163412f.sol,ServusToken,"contract ServusTokenInterface is Controllable { event Mint(address indexed to, uint256 amount); event MintFinished(); event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount); event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock); event Approval(address indexed _owner, address indexed _spender, uint256 _amount); event Transfer(address indexed from, address indexed to, uint256 value); function totalSupply() public constant returns (uint); function totalSupplyAt(uint _blockNumber) public constant returns(uint); function balanceOf(address _owner) public constant returns (uint256 balance); function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint); function transfer(address _to, uint256 _amount) public returns (bool success); function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success); function approve(address _spender, uint256 _amount) public returns (bool success); function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); function mint(address _owner, uint _amount) public returns (bool); function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool); function lockPresaleBalances() public returns (bool); function finishMinting() public returns (bool); function enableTransfers(bool _value) public; function enableMasterTransfers(bool _value) public; function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address); }",1
0x1fc3294386ccbc834fdd1f1d78d236c634fe9fc6.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUtilityfee (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onReceiveAirdrop (address indexed hodler, uint256 amount, uint256 datetime); event onAddContract (address indexed hodler, address indexed tokenAddress, uint256 percent, string tokenSymbol, uint256 amount, uint256 endtime); event onTokenPrice (address indexed hodler, address indexed tokenAddress, uint256 Currentprice, uint256 ETHprice, uint256 ICOprice, uint256 endtime); event onHoldAirdrop (address indexed hodler, address indexed tokenAddress, uint256 HPMstatus, uint256 d1, uint256 d2, uint256 d3,uint256 endtime); event onHoldDeposit (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onHoldWithdraw (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onUtilitySetting (address indexed hodler, address indexed tokenAddress, address indexed pwt, uint256 amount, uint256 ustatus, uint256 endtime); event onUtilityStatus (address indexed hodler, address indexed tokenAddress, uint256 ustatus, uint256 endtime); event onUtilityBurn (address indexed hodler, address indexed tokenAddress, uint256 uamount, uint256 bamount, uint256 endtime); struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; uint256 tokendecimal; uint256 startime; }",1
0x8754770d7dd5e51794bd575d247e158881696c7c.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { uint256 public mintLimit; address public saleAgent; bool public mintingFinished = false; event Mint(address indexed to, uint256 amount); event MintFinished(); modifier canMint() { require(!mintingFinished); _; }",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2858f2b0d94947962f93e4387d391467ebd72166.sol,FLEX,"contract FLEX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FLEX( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol,FoMo3DLight,"contract FoMo3DLight is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; uint256 public pID_ = 4; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 20 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(49,2); fees_[1] = F3Ddatasets.TeamFee(49,2); fees_[2] = F3Ddatasets.TeamFee(49,2); fees_[3] = F3Ddatasets.TeamFee(49,2); potSplit_[0] = F3Ddatasets.PotSplit(38,2); potSplit_[1] = F3Ddatasets.PotSplit(38,2); potSplit_[2] = F3Ddatasets.PotSplit(38,2); potSplit_[3] = F3Ddatasets.PotSplit(38,2); }",1
0x27291266036587cfdb65b5a19f93bc7376df2b79.sol,BFTETOKEN,contract BFTETOKEN is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0x2dfb39072368a67b419e873d39848707b5234935.sol,SEEDWhitelist,contract SEEDWhitelist is Whitelist { mapping (address => bool) public admin; modifier onlyAdmin() { require(admin[msg.sender]); _; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,BunnyGame,"contract BunnyGame is BodyRabbit{ function transferNewBunny(address _to, uint32 _bunnyid, uint localdnk, uint breed, uint32 matron, uint32 sire, uint procentAdmixture, uint admixture) internal { emit NewBunny(_bunnyid, localdnk, block.number, breed, procentAdmixture, admixture); emit CreateChildren(matron, sire, _bunnyid); addTokenList(_to, _bunnyid); totalSalaryBunny[_bunnyid] = 0; motherCount[_bunnyid] = 0; totalBunny++; }",1
0xa1cb45a734151b63679e1aed48e4c3deb8d1908d.sol,GuardianGoldToken,"contract GuardianGoldToken is BasicToken, Ownable, RBAC { string public name = ; string public symbol = ; uint8 public decimals = 18; string public constant ADMIN_ROLE = ; uint256 constant internal magnitude = 2**64; uint public maxTokens = 5000e18; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal referralBalance_; mapping(address => mapping (address => uint256)) allowed; uint public goldAccount = 0; uint public operationsAccount = 0; uint256 internal profitPerShare_; address[] public transfers; uint public constant INITIAL_SUPPLY = 62207e15; uint public totalSupply = 62207e15; uint public totalGoldReserves = 62207e15; uint public pendingGold = 0; uint public totalETHReceived = 57.599 ether; bool public isTransferable = true; bool public toggleTransferablePending = false; address public transferToggleRequester = address(0); uint public tokenPrice = 0.925925 ether; uint public goldPrice = 0.390185 ether; uint public tokenSellDiscount = 950; uint public referralFee = 30; uint minGoldPrice = 0.2 ether; uint maxGoldPrice = 0.7 ether; uint minTokenPrice = 0.5 ether; uint maxTokenPrice = 2 ether; uint public dividendRate = 150; uint public minPurchaseAmount = 0.1 ether; uint public minSaleAmount = 1e18; uint public minRefStake = 1e17; bool public allowBuy = false; bool public allowSell = false; bool public allowRedeem = false; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; addRole(msg.sender, ADMIN_ROLE); emit Transfer(address(this), msg.sender, INITIAL_SUPPLY); }",1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x39b948d3f844bb9e0e3b375901bb43d4866ef4bb.sol,Crowdsale,"contract Crowdsale is owned, UNICToken { using SafeMath for uint; UNICToken public token = new UNICToken(); address constant multisig = 0x867570869f8a46c685A51EE87b5D979A6ef657A9; uint constant rate = 3400; uint256 public constant forSale = 55000000 * 10 ** uint256(decimals); uint public constant presaleWhitelistDiscount = 40; uint public presaleWhitelistTokensLimit = 750000 * 10 ** uint256(decimals); uint public constant presaleStart = 1520503200; uint public constant presaleEnd = 1521453600; uint public constant presaleDiscount = 30; uint public presaleTokensLimit = 5000000 * 10 ** uint256(decimals); uint public constant firstRoundICOStart = 1522317600; uint public constant firstRoundICOEnd = 1523527200; uint public constant firstRoundICODiscount = 20; uint public firstRoundICOTokensLimit = 6250000 * 10 ** uint256(decimals); uint public constant secondRoundICOStart = 1524736800; uint public constant secondRoundICOEnd = 1526551200; uint public constant secondRoundICODiscount = 10; uint public secondRoundICOTokensLimit = 43750000 * 10 ** uint256(decimals); uint public constant presaleFemaleStart = 1520467200; uint public constant presaleFemaleEnd = 1520553600; uint public constant presaleFemaleDiscount = 88; uint public presaleFemaleTokensLimit = 88888 * 10 ** uint256(decimals); uint public constant presalePiStart = 1520985600; uint public constant presalePiEnd = 1521072000; uint public constant presalePiDiscount = 34; uint public presalePiTokensLimit = 31415926535897932384626; uint public constant firstRoundWMStart = 1522800000; uint public constant firstRoundWMEnd = 1522886400; uint public constant firstRoundWMDiscount = 25; uint public firstRoundWMTokensLimit = 404404 * 10 ** uint256(decimals); uint public constant firstRoundCosmosStart = 1523491200; uint public constant firstRoundCosmosEnd = 1523577600; uint public constant firstRoundCosmosDiscount = 25; uint public firstRoundCosmosTokensLimit = 121961 * 10 ** uint256(decimals); uint public constant secondRoundMayStart = 1525132800; uint public constant secondRoundMayEnd = 1525219200; uint public constant secondRoundMayDiscount = 15; uint public secondRoundMayTokensLimit = 1111111 * 10 ** uint256(decimals); uint public etherRaised = 0; uint public tokensSold = 0; address public icoManager; mapping (address => bool) public WhiteList; mapping (address => bool) public Females; mapping (address => bool) public KYC1; mapping (address => bool) public KYC2; mapping (address => uint256) public KYCLimit; uint256 public constant KYCLimitValue = 1.5 ether; modifier onlyManager() { require(msg.sender == icoManager); _; }",1
0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9.sol,EthFlip,contract EthFlip is usingOraclize { struct Bet { bool win; uint betValue; uint timestamp; address playerAddress; uint randomNumber; bool low; },1
0x01dae2898900622f79c5d09e7363693cd1f48be8.sol,TRLToken,"contract TRLToken is ERC20Interface, Owned { using SafeMath for uint; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint256 public constant _totalSupply = 1000000000 * 10**uint(decimals); mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TRLToken() public { balances[owner] = _totalSupply; }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,AssemblyBase,contract AssemblyBase is DetailBase { struct Assembly { uint256 idParent; uint256 dna; uint64 releaseTime; uint64 updateTime; uint64 startMiningTime; uint64[] spares; uint8 countMiningDetail; uint8 rang; },1
0xce831af117375e6286eb3c46d696ee3dbf4f4f50.sol,ProfitSharingToken,contract ProfitSharingToken is BalanceHistoryToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 public constant INITIAL_SUPPLY = 10000000000; struct Snapshot { uint192 block; uint64 balance; },1
0x0288c13f98d85c817191710be24e96ec75bd9914.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { address[] private _multitokens; AbstractDeployer[] private _deployers; event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); function multitokensCount() public view returns(uint256) { return _multitokens.length; }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0xc543afe640c8c7521beb6549be75f77b568f4590.sol,GET111,contract GET111 { address constant private ADMIN = 0x411647BA6480bF5FDec2145f858FD37AeCBfC03B; uint constant public ADMIN_FEE = 5; uint constant public PROFIT = 111; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x1f8abd8e5fb90c7c4076fca58fe335ba55da5945.sol,Usdcoins,"contract Usdcoins { using SafeMathMod for uint256; address owner; string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; uint256 constant public totalSupply = 100000000e18; uint256 constant private MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferFrom(address indexed _spender, address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function() payable { revert(); }",1
0xee3bb3bfb79b153bf1181a3995dc4aa8c4f037bb.sol,Bitelectroneum,"contract Bitelectroneum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_PURCHASE = 1 ether / 100; uint256 public tokensPerEth = 7000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2878d33523a8025b66bdf606c8670fdf3f4c8cdd.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }",1
0x39b948d3f844bb9e0e3b375901bb43d4866ef4bb.sol,UNICToken,"contract UNICToken is owned, StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply = 250000000 * 10 ** uint256(decimals); function UNICToken() public onlyOwner { totalSupply = initialSupply; balances[msg.sender] = initialSupply; }",1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsPreSale,contract EthernautsPreSale is EthernautsLogic { function EthernautsPreSale() public EthernautsLogic() {},1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x54c402817c437a492dce44e2ff1e82d168196c86.sol,Visor,"contract Visor is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Visor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xCFeEF0545719e51ef406e9D83E94A2b7332a9537] = _totalSupply; Transfer(address(0), 0xCFeEF0545719e51ef406e9D83E94A2b7332a9537, _totalSupply); }",1
0xc84d24242a792d8c87d10f92897328c490bfd7fa.sol,EVTCToken,"contract EVTCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xa45d88c06a8643fb53f9c9923162403852bf3592.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) tokenBalances; function transfer(address _to, uint256 _value) internal returns (bool) { return false; }",1
0x6a498c4d31aec7dd076d81e73d564f33c9a07764.sol,BitchipWallet,contract BitchipWallet is owned{ address private ETH = 0x0000000000000000000000000000000000000000; using SafeMath for uint; constructor() public { },1
0xc07c972ac722eb36f5911fdf89dfe978ef36988c.sol,GetBonusInv,"contract GetBonusInv is Ownable { using SafeMath for uint; Token public token; mapping(address => uint256) public purchaseBalances; event GetBonus(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function GetBonusInv() public { token = new Token(); }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpControllerHelper,"contract BdpControllerHelper is BdpBase { function calculateArea(uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) { return BdpCalculator.calculateArea(contracts, _regionId); }",1
0xbc3183980eaea0976068c133b10d7a77dad7563c.sol,PresaleMidexToken,"contract PresaleMidexToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public exchangeRegulatorWallet; address public wallet; uint256 public initialSupply = 10000000 * (10 ** uint256(decimals)); uint256 public amountToken = 1 * (10 ** uint256(decimals)); uint public startTime; uint public endTime; function PresaleMidexToken() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; wallet = owner; exchangeRegulatorWallet = owner; startTime = now; endTime = startTime + 30 days; }",1
0xc59cb23295e2deeb66bd090acb6b02be8d30a11f.sol,IERC20Token,contract IERC20Token { function name() public constant returns (string) { name; },1
0x05bfc9ef2836f0f883da06bace39ae8e2fbf998b.sol,BookERC20EthV1p1,contract BookERC20EthV1p1 { enum BookType { ERC20EthV1 },1
0x26cb3641aaa43911f1d4cb2ce544eb652aac7c47.sol,CrystalToken,"contract CrystalToken is SafeStandardToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 28000000 * (10 ** uint256(decimals)); struct Round { uint256 startTime; uint256 endTime; uint256 availableTokens; uint256 maxPerUser; uint256 rate; mapping(address => uint256) balances; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x5850700e214c16c73d1778b2886c01639e69faa3.sol,ROGANCOIN,"contract ROGANCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ROGANCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x686E275CE6Fe968d1064C102613E6c23c78DC58a] = _totalSupply; Transfer(address(0), 0x686E275CE6Fe968d1064C102613E6c23c78DC58a, _totalSupply); }",1
0x3a7a5ba347928dfc8a748b5e55558d5fee84a2a9.sol,Ownable,"contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCToken,"contract IDCToken is BurnableToken, Pausable, Saleable { address public addrTeam; address public addrSale; address public addrMine; mapping(address => uint256) public tokenAngel; mapping(address => uint256) public tokenPrivate; mapping(address => uint256) public tokenCrowd; uint256 public release = 0; uint256 private teamLocked = 0; uint256 constant private DAY_10 = 10 days; uint256 constant private DAY_90 = 90 days; uint256 constant private DAY_120 = 120 days; uint256 constant private DAY_150 = 150 days; uint256 constant private DAY_180 = 180 days; uint256 constant private DAY_360 = 360 days; uint256 constant private DAY_720 = 720 days; event TransferToken(uint8 stage, address indexed to, uint256 value); event TokenRelease(address caller, uint256 time); constructor(address _team, address _sale, address _mine) public { name = ; symbol = ; decimals = 18; totalSupply = 3*10**9*10**uint256(decimals); addrTeam = _team; addrSale = _sale; addrMine = _mine; balances[_team] = totalSupply.mul(2).div(5); balances[_sale] = totalSupply.mul(1).div(5); balances[_mine] = totalSupply.mul(2).div(5); teamLocked = balances[_team]; emit Transfer(0,_team,balances[_team]); emit Transfer(0,_sale,balances[_sale]); emit Transfer(0,_mine,balances[_mine]); }",1
0x1f3640b76fef8f0c8efeb13623387f3bce31e080.sol,Crowdsale,"contract Crowdsale is Ownable{ using SafeMath for uint; function pow(uint256 a, uint256 b) internal pure returns (uint256){ return (a**b); }",1
0xf3bb445b935a9ea1bf4f126d0c0c4bf51c902b00.sol,EtheremonAdventureData,contract EtheremonAdventureData is BasicAccessControl { using SafeMath for uint; struct LandTokenClaim { uint emontAmount; uint etherAmount; },1
0x4c251de85ad3498c5b89388d8efc696ddd0b0fe7.sol,FiCoin,"contract FiCoin is StandardToken, usingOraclize { using SafeMath for uint256; struct Contributor { address addr; uint256 amount; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x5a757fb240ac70dbead4f9e1508f24a91da70ee5.sol,SilentToken,"contract SilentToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 2500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2f2f25ee6a102272a484fa85388f0206ec7b0668.sol,TopiaCoinSAFTSale,"contract TopiaCoinSAFTSale is Ownable, Finalizable { event PaymentExpected(bytes8 paymentIdentifier); event PaymentExpectationCancelled(bytes8 paymentIdentifier); event PaymentSubmitted(address payor, bytes8 paymentIdentifier, uint256 paymentAmount); event PaymentAccepted(address payor, bytes8 paymentIdentifier, uint256 paymentAmount); event PaymentRejected(address payor, bytes8 paymentIdentifier, uint256 paymentAmount); event UnableToAcceptPayment(address payor, bytes8 paymentIdentifier, uint256 paymentAmount); event UnableToRejectPayment(address payor, bytes8 paymentIdentifier, uint256 paymentAmount); event SalesWalletUpdated(address oldWalletAddress, address newWalletAddress); event PaymentManagerUpdated(address oldPaymentManager, address newPaymentManager); event SaleOpen(); event SaleClosed(); mapping (bytes8 => Payment) payments; address salesWallet = 0x0; address paymentManager = 0x0; bool public saleStarted = false; struct Payment { address from; bytes8 paymentIdentifier; bytes32 paymentHash; uint256 paymentAmount; uint date; uint8 status; }",1
0x714f9fe9c67fb45e0e811f393ac114c42d440e2e.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(transfersEnabled); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(burner, _value); }",1
0x25fdf7f507d6124377e48409713292022d9fb69e.sol,BTYCToken,"contract BTYCToken is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sellPrice; uint public buyPrice; uint public sysPrice; uint public sysPer; bool public actived; uint public sendPer; uint public sendPer2; uint public sendPer3; uint public sendfrozen; uint public onceOuttime; uint public onceAddTime; bool public openout; mapping(address => uint) balances; mapping(address => uint) used; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => uint[]) public mycantime; mapping(address => uint[]) public mycanmoney; mapping(address => address) public fromaddr; mapping(address => bool) public admins; mapping(address => uint) public cronaddOf; mapping(address => bool) public intertoken; mapping(address => uint) public hasupdate; event FrozenFunds(address target, bool frozen); oldInterface public oldBase = oldInterface(0x56F527C3F4a24bB2BeBA449FFd766331DA840FFA); address public owner; bool public canupdate; modifier onlyOwner { require(msg.sender == owner); _; }",1
0x5401bb4729bd7f025b97399c3c92854ec299f81a.sol,LOCIsale,"contract LOCIsale is Ownable, Pausable, IRefundHandler { using SafeMath for uint256; LOCIcoin internal token; uint256 public start; uint256 public end; bool public isPresale; bool public isRefunding = false; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 public weiRaised; uint256 public weiRaisedAfterDiscounts; uint256 internal weiForRefund; uint256 public peggedETHUSD; uint256 public hardCap; uint256 public reservedTokens; uint256 public baseRateInCents; uint256 internal startingTokensAmount; mapping (address => uint256) public contributions; struct DiscountTranche { uint256 end; uint8 discount; uint8 round; uint256 roundWeiRaised; uint256 roundTokensSold; }",1
0x20c3811a83fad33dc7a0c8ee2d1e773ddf3b7d44.sol,Damo,contract Damo{ using SafeMath for uint256; using NameFilter for string; using FMDDCalcLong for uint256; uint256 iCommunityPot; struct Round{ uint256 iKeyNum; uint256 iVault; uint256 iMask; address plyr; uint256 iGameStartTime; uint256 iGameEndTime; uint256 iSharePot; uint256 iSumPayable; bool bIsGameEnded; },1
0x6fff3806bbac52a20e0d79bc538d527f6a22c96b.sol,Math,"contract Math { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { require((z = x + y) >= x); }",1
0x01c8bb9205fec775deb38534ea50a84c9b30a84b.sol,VNETPrivatePlacement,"contract VNETPrivatePlacement is Ownable { using SafeMath for uint256; ERC20Basic public vnetToken; string public description; uint256 public rate; uint256 public etherMinimum; uint256 public etherMaximum; constructor(ERC20Basic _vnetToken, string _description, uint256 _rate, uint256 _min, uint256 _max) public { vnetToken = _vnetToken; rate = _rate; etherMinimum = _min; etherMaximum = _max; description = _description; }",1
0x1d6b371b0d23d169e87db2fc14ab34f82d190988.sol,ChickenPark,contract ChickenPark is Owned{ using SafeMath for *; modifier notContract() { require (msg.sender == tx.origin); _; },1
0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol,EthPyramid,contract EthPyramid { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; bool open = false; address admin = 0xD2E6B3BFE990fdede2380885d9d83Ca9364E717E; modifier OnlyOpen(){ require(open || (msg.sender==admin)); _; },1
0xe9c7bf5da52566cc9e5a3157c3d29bcc809d072b.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf2e827c8c4e02b6daf1a4e28dc506f3c4522386a5efe225e8b0ff24ffe7dc049; constructor() public { owner = msg.sender; },1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,TokenERC20,"contract TokenERC20 is Pausable{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x3fab1c4216e401de80cef4ac5387452d16314c6e.sol,BurritoToken,"contract BurritoToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256[] private listed; uint256 public devOwed; uint256 public poolTotal; uint256 public lastPurchase; mapping (uint256 => Burrito) public burritoData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) private payoutBalances; event BurritoPurchased(uint256 indexed _tokenId, address indexed _owner, uint256 _purchasePrice); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 3.0 ether; uint256 private finalCap = 5.0 ether; uint256 public devCutPercentage = 4; struct Burrito { uint256 startingPrice; uint256 price; uint256 lastPrice; uint256 payout; uint256 withdrawn; address owner; }",1
0x2022d6bf861df29063b9f81ddc0cc68426531637.sol,ArbitrageETHStaking,"contract ArbitrageETHStaking is Ownable { using SafeMath for uint256; event onPurchase( address indexed customerAddress, uint256 etherIn, uint256 contractBal, uint256 poolFee, uint timestamp ); event onWithdraw( address indexed customerAddress, uint256 etherOut, uint256 contractBal, uint timestamp ); mapping(address => uint256) internal personalFactorLedger_; mapping(address => uint256) internal balanceLedger_; uint256 minBuyIn = 0.001 ether; uint256 stakingPrecent = 2; uint256 internal globalFactor = 10e21; uint256 constant internal constantFactor = 10e21 * 10e21; function() external payable { buy(); }",1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,NDUXB,"contract NDUXBase is BasicToken, Ownable { string public constant name = ; string public constant symbol = ; uint constant maxTotalSupply = 75000000; function NDUXBase() public { mint(this, maxTotalSupply); }",1
0x41a3bd762288d9dde5eb640efe4d21fc1da2f74d.sol,VotePumpCoin0x,"contract VotePumpCoin0xToken { function balanceOf(address _owner) constant public returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x6e3bc8f50d04f7262f5c99f1cbabe502eb5e37f5.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0x6b3a7e99e399df2efc5f48b55af120283ffc888d.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3606bac9d236835210beb1a332431dd9fd5484da.sol,CTNCToken,contract CTNCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 3016000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0xf213d198b68b10654c63a9ed05a045e1d4a50f9f.sol,FootballerOwnership,"contract FootballerOwnership is FootballerBase, ERC721 { string public constant name = ; string public constant symbol = ; function implementsERC721() public pure returns (bool) { return true; }",1
0x5884c40dded55b5649a1aaa677a750ead35e3043.sol,OnasanderToken,"contract OnasanderToken { using SafeMath for uint; address private wallet; address public owner; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint public totalSupply = 88000000e18; uint public totalTokensSold = 0e18; uint public totalTokensSoldInThisSale = 0e18; uint public maxTokensForSale = 79200000e18; uint public companyReserves = 8800000e18; uint public minimumGoal = 0e18; uint public tokensForSale = 0e18; bool public saleEnabled = false; bool public ICOEnded = false; bool public burned = false; uint public tokensPerETH = 800; bool public wasGoalReached = false; address private lastBuyer; uint private singleToken = 1e18; constructor(address icoWallet) public { require(icoWallet != address(0), ); owner = msg.sender; wallet = icoWallet; balances[owner] = totalSupply; emit TokensMinted(owner, totalSupply); }",1
0x0dfaf19a15be6480b7831ba19e7ed877d5da40ee.sol,XPOT,"contract XPOT is Owner { event Game(uint _game, uint indexed _time); event Ticket( address indexed _address, uint indexed _game, uint _number, uint _time ); uint8 public fee = 10; uint public game; uint public ticketPrice = 0.01 ether; uint public newPrice; uint public allTimeJackpot = 0; uint public allTimePlayers = 0; bool public isActive = true; bool public toogleStatus = false; uint[] public games; mapping(uint => uint) jackpot; mapping(uint => address[]) players; address public fundsDistributor; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0x4c9de52c6e4832fabf2fd8b8330941f695f07335.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice = 0.001 ether; uint256 public buyPrice = 0.001 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (safeAdd(balanceOf[_to],_value) > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] = safeSub(balanceOf[_from],_value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(_from, _to, _value); }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinManualSell,"contract CrowdCoinManualSell { CrowdCoin public token; address public dev_multisig; address private constant owner_1 = 0x792030B6811043f79ae49d2C4bA33cC6a6326049; address private constant owner_2 = 0x886531ed00cF51B6219Bf9EF9201ff4DEc622E6f; event Purchased(address participant, uint eth_amount, uint token_amount); event ManualPurchase(address sender, address participant, uint token_amount); function transfer_coins(address _to, uint _value) public { if (msg.sender != owner_1 && msg.sender != owner_2) revert(); token.transfer(_to, _value); ManualPurchase(msg.sender, _to, _value); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,HavvenEscrow,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x182fad6a68ebd9118549ec1091aa4eb95e234ef6.sol,POWHclone,"contract POWHclone { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); address owner; function POWHclone() public { owner = msg.sender; }",1
0xd04a63eea250ce2b330d4ed46338d7cfa6999040.sol,TYCOONCoin,"contract TYCOONCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TYCOONCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 219172838 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b95ecf2a6ebf1371158b3f1a9ca32ce18d7c751.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0xf1ac14e0463377dd7a41d3bb47ea743822ca4132.sol,CappedCrowdsale,contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; },1
0x340b84a70520f721fde96c7ad663383c31e416cb.sol,HasNoTokens,"contract HasNoTokens is CanReclaimToken { function tokenFallback(address _from, uint256 _value, bytes _data) external pure { _from; _value; _data; revert(); }",1
0x27de94cb6af1f383430273f44ab4cf4baeb00fc4.sol,METADOLLAR,contract METADOLLAR { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf37454790e35b9c5adf6b0c33304156688a6a306.sol,KDT,"contract KDT is BurnableToken, DetailedERC20, ERC20Token, TokenLock { using SafeMath for uint256; event Approval(address indexed owner, address indexed spender, uint256 value); string public constant symbol = ; string public constant name = ; string public constant note = ; uint8 public constant decimals = 15; uint256 constant TOTAL_SUPPLY = 2000000000 *(10**uint256(decimals)); constructor() DetailedERC20(name, symbol, note, decimals) public { _totalSupply = TOTAL_SUPPLY; balances[owner] = _totalSupply; emit Transfer(address(0x0), msg.sender, _totalSupply); }",1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,RefundableCrowdsale,contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; RefundVault public vault; constructor(uint256 _goal) public { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; },1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x532975d56cf18f597480e2521246b273ad9ae348.sol,PublicResolver,"contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5; bytes4 constant NAME_INTERFACE_ID = 0x691f3431; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c; bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1; event AddrChanged(bytes32 indexed node, address a); event ContentChanged(bytes32 indexed node, bytes32 hash); event NameChanged(bytes32 indexed node, string name); event ABIChanged(bytes32 indexed node, uint256 indexed contentType); event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); event TextChanged(bytes32 indexed node, string indexedKey, string key); event MultihashChanged(bytes32 indexed node, bytes hash); struct PublicKey { bytes32 x; bytes32 y; }",1
0x712f0350df4f56fad07bd5e2c74941cc30c5df88.sol,DTCC_ILOW_3,contract DTCC_ILOW_3 { address owner ; function DTCC_ILOW_2 () public { owner = msg.sender; },1
0x04562d368e202f7e9470f3e238e92c2582c8dcec.sol,TestMining,contract TestMining{ mapping (address => uint256) public investedETH; mapping (address => uint256) public lastInvest; mapping (address => uint256) public affiliateCommision; address dev = 0x47CCf63dB09E3BF617a5578A5eBBd19a4f321F67; address promoter = 0xac25639bb9B90E9ddd89620f3923E2B8fDF3759d; function investETH(address referral) public payable { require(msg.value >= 0.01 ether); if(getProfit(msg.sender) > 0){ uint256 profit = getProfit(msg.sender); lastInvest[msg.sender] = now; msg.sender.transfer(profit); },1
0x284760487ee4e0eee4f2abd4e6dfcec0d56719f3.sol,CGE,"contract CGE is ERC20,Ownable{ using SafeMath for uint256; string public constant name=; string public constant symbol=; string public constant version = ; uint256 public constant decimals = 18; uint256 public constant MAX_SUPPLY=1000000000*10**decimals; struct epoch { uint256 endTime; uint256 amount; }",1
0xdc0a2185031ecf89f091a39c63c2857a7d5c301a.sol,Realitio,"contract Realitio is BalanceHolder { using RealitioSafeMath256 for uint256; using RealitioSafeMath32 for uint32; address constant NULL_ADDRESS = address(0); bytes32 constant NULL_HASH = bytes32(0); uint32 constant UNANSWERED = 0; uint256 constant COMMITMENT_NON_EXISTENT = 0; uint32 constant COMMITMENT_TIMEOUT_RATIO = 8; event LogSetQuestionFee( address arbitrator, uint256 amount ); event LogNewTemplate( uint256 indexed template_id, address indexed user, string question_text ); event LogNewQuestion( bytes32 indexed question_id, address indexed user, uint256 template_id, string question, bytes32 indexed content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 created ); event LogFundAnswerBounty( bytes32 indexed question_id, uint256 bounty_added, uint256 bounty, address indexed user ); event LogNewAnswer( bytes32 answer, bytes32 indexed question_id, bytes32 history_hash, address indexed user, uint256 bond, uint256 ts, bool is_commitment ); event LogAnswerReveal( bytes32 indexed question_id, address indexed user, bytes32 indexed answer_hash, bytes32 answer, uint256 nonce, uint256 bond ); event LogNotifyOfArbitrationRequest( bytes32 indexed question_id, address indexed user ); event LogFinalize( bytes32 indexed question_id, bytes32 indexed answer ); event LogClaim( bytes32 indexed question_id, address indexed user, uint256 amount ); struct Question { bytes32 content_hash; address arbitrator; uint32 opening_ts; uint32 timeout; uint32 finalize_ts; bool is_pending_arbitration; uint256 bounty; bytes32 best_answer; bytes32 history_hash; uint256 bond; }",1
0xf238f55ede5120915b36715b0fffe20ff57f8134.sol,BytesToTypes,"contract BytesToTypes { function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) }",1
0x7430984e1d05d5f447c747123dd26845f6f17544.sol,ZethrBankroll,"contract ZethrBankroll is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event DevWithdraw(uint amountTotal, uint amountPerPerson); event EtherLogged(uint amountReceived, address sender); event BankrollInvest(uint amountReceived); event DailyTokenAdmin(address gameContract); event DailyTokensSent(address gameContract, uint tokens); event DailyTokensReceived(address gameContract, uint tokens); uint constant public MAX_OWNER_COUNT = 10; uint constant public MAX_WITHDRAW_PCT_DAILY = 15; uint constant public MAX_WITHDRAW_PCT_TX = 5; uint constant internal resetTimer = 1 days; address internal zethrAddress; ZTHInterface public ZTHTKN; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public isWhitelisted; mapping (address => uint) public dailyTokensPerContract; address internal divCardAddress; address[] public owners; address[] public whiteListedContracts; uint public required; uint public transactionCount; uint internal dailyResetTime; uint internal dailyTknLimit; uint internal tknsDispensedToday; bool internal reEntered = false; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0xb4041a50178bd307cd3ec7618b4753814d7b4b9e.sol,WaterBlockchainToken,contract WaterBlockchainToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint public _totalSupply = 1000000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8.sol,DailyDivs,contract DailyDivs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x57112a3fd8b8e0bf025f27972018a425996fa12a.sol,Ownable,"contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }",1
0x88963cd0ce09d78def96aa4a4e41430b65c03c43.sol,AKCToken,contract AKCToken is ERC20Interface{ string public standard = ; string public constant name=; string public constant symbol=; uint8 public constant decimals=9; uint256 constant _totalSupply=1000000000000000000; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) balances; address public owner; function AKCToken() { owner = msg.sender; balances[owner] = _totalSupply; },1
0x5824f275dab2c59b8972a1fda45ff404c9a703e3.sol,EqualToken,contract EqualToken is StandardToken { function () { revert(); },1
0x1ed3099df8a56c447e7c20d08572413f15fe760e.sol,ECT,contract ECT { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf27e34c2b0acc3edd0559a9c3c21a884176a32c2.sol,COVERCOINToken,"contract COVERCOINToken is ERC20, ERC223 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function COVERCOINToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x2154f9d7da8bf221e102197195531c82cee1677e.sol,AIUToken,"contract AIUToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x21ae174c592cbb476819344a895d0e9219f5cc79.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 1 hours; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool mutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0xedd4941d09bb0fafd230100c86ffbbd7907b6fed.sol,ArcanaToken,"contract ArcanaToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 7000000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 100000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x7697c5015c195ff2ff55576ab96360e298bfba1f.sol,EtheremonMonsterToken,"contract EtheremonMonsterTokenBasic is ERC721, SupportsInterface, BasicAccessControl { using SafeMath for uint256; using AddressUtils for address; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0xe1521029d2591ba2a0f92b6e744a825f665f748b.sol,IndexEmpireToken,"contract IndexEmpireToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function IndexEmpireToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x1f895c4805561a19be9d3bb8867bdcbbeb724848.sol,BazzEX,contract BazzEX { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 3; uint public _totalSupply = 3300000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x770b05bec95bbfdd90a9e46c48fcb101e70ebf9b.sol,ManagedToken,"contract ManagedToken is ERC20Token, MultiOwnable { bool public allowTransfers = false; bool public issuanceFinished = false; ITokenEventListener public eventListener; event AllowTransfersChanged(bool _newState); event Issue(address indexed _to, uint256 _value); event Destroy(address indexed _from, uint256 _value); event IssuanceFinished(); modifier transfersAllowed() { require(allowTransfers); _; }",1
0x20c77f3dc45bb8fe8b22b84e28466265265ce8ad.sol,StrongHoldNetwork,"contract StrongHoldNetwork is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 50 * 10**7 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function StrongHoldNetwork() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,Ownable,contract OwnableInterface { function getOwner() public constant returns (address); modifier onlyOwner() { require (msg.sender == getOwner()); _; },1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,BntyExchangeRateCalculator,"contract BntyExchangeRateCalculator is KnowsTime, Ownable { using SafeMath for uint; uint public constant WEI_PER_ETH = 10 ** 18; uint public constant MICRODOLLARS_PER_DOLLAR = 10 ** 6; uint public bntyMicrodollarPrice; uint public USDEtherPrice; uint public fixUSDPriceTime; function BntyExchangeRateCalculator(uint _bntyMicrodollarPrice, uint _USDEtherPrice, uint _fixUSDPriceTime) public { require(_bntyMicrodollarPrice > 0); require(_USDEtherPrice > 0); bntyMicrodollarPrice = _bntyMicrodollarPrice; fixUSDPriceTime = _fixUSDPriceTime; USDEtherPrice = _USDEtherPrice; }",1
0x5515950f7bf8d6acdf4ae98c33bf996bd0ed6f6f.sol,FNX,"contract FNX is ERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals; uint public _totalSupply; address public owner; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => uint256) freezes; event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor(uint initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) public { symbol = tokenSymbol; name = tokenName; decimals = decimalUnits; _totalSupply = initialSupply; owner = msg.sender; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleManager,contract CrowdsaleManager is Manageable { using SafeMath for uint256; uint256 public constant decimals = 18; CrowdsaleToken public token; Crowdsale public sale1; Crowdsale public sale2; Crowdsale public sale3; address public constant tokenReserved1Deposit = 0x6EE96ba492a738BDD080d7353516133ea806DDee; address public constant tokenReserved2Deposit = 0xAFBcB72fE97A5191d03E328dE07BB217dA21EaE4; address public constant tokenReserved3Deposit = 0xd7118eE872870040d86495f13E61b88EE5C93586; address public constant tokenReserved4Deposit = 0x08ce2b3512aE0387495AB5f61e6B0Cf846Ae59a7; address public constant withdrawWallet1 = 0xf8dafE5ee19a28b95Ad93e05575269EcEE19DDf2; address public constant withdrawWallet2 = 0x6f4aF515ECcE22EA0D1AB82F8742E058Ac4d9cb3; address public constant withdrawWallet3 = 0xd172E0DEe60Af67dA3019Ad539ce3190a191d71D; uint256 public constant tokenSale = 750000000 * 10**decimals + 3000 * 1000 * 10**decimals; uint256 public constant tokenReserved1 = 150000000 * 10**decimals - 3000 * 1000 * 10**decimals; uint256 public constant tokenReserved2 = 270000000 * 10**decimals; uint256 public constant tokenReserved3 = 105000000 * 10**decimals; uint256 public constant tokenReserved4 = 225000000 * 10**decimals; function CrowdsaleManager() public { },1
0x20fadc9071ca27ef7648cf7b47a318a760f7f414.sol,RoseToken,"contract RoseToken is StandardToken { string public constant name = ; string public constant symbol = ; uint256 public constant INITIAL_SUPPLY = 100000000; address public owner; function RoseToken() public { owner = msg.sender; totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x74e711f1179f559e1cd7817050cf198b67129269.sol,BitcoinRed,"contract BitcoinRed is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xb86249Da1e02f1faE5653F74fA48EE08097b110F] = _totalSupply; emit Transfer(address(0), 0xb86249Da1e02f1faE5653F74fA48EE08097b110F, _totalSupply); }",1
0xe541b34f73a4789a033a962ad43655221b4e516e.sol,CMBToken,"contract CMBToken is PausableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply_ = 2000000000 * (10 ** uint256(decimals)); uint256 public mintedSupply_ = 0; mapping(address => uint256) lockedBalances; event Mint(address _to, uint256 amount); event TokensLocked(address beneficiary, uint256 amount); event TokensUnlocked(address beneficiary, uint256 amount); modifier hasMintPermission() { require(msg.sender == owner); _; }",1
0x0d068b35c5eda0fe336fe629718c00dbde36d27a.sol,MoonProjectToken,contract MoonProjectToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x738505a5f31bf72e0b70298bca81150eb1b7c751.sol,Token,"contract Token is DetailedERC20, StandardToken, BurnableToken { constructor (uint256 _totalSupply, string _name, string _symbol, uint8 _decimals) DetailedERC20(_name, _symbol, _decimals) public { totalSupply_ = _totalSupply; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x1d18f44256a27862d886e27191d55ab4029172c1.sol,Admin,"contract Admin is Variable, Modifiers, Event { using safeMath for uint256; function admin_transfer_tempLockAddress(address _to, uint256 _value, uint256 _unlockTime) public isOwner returns(bool success) { balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); tempLockedAddress[_to] = _unlockTime; emit Transfer(msg.sender, _to, _value); emit TempLockedAddress(_to, _unlockTime); return true; }",1
0xdcf8511f4d1623d0adb4e5f20542b86a30b07eed.sol,RIC,"contract RIC is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 constant public decimals =18; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); constructor() public { name = ; symbol = ; initialSupply = 300000000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Owner,contract Owner { address public owner; bool public stopped = false; function Owner() internal { owner = msg.sender; },1
0x4d6e0922e6b703f0fdf92745343a9b83eb656402.sol,RaidenMicroTransferChannels,contract RaidenMicroTransferChannels { uint32 public challenge_period; string public constant version = ; uint256 public constant channel_deposit_bugbounty_limit = 10 ** 18 * 100; Token public token; mapping (bytes32 => Channel) public channels; mapping (bytes32 => ClosingRequest) public closing_requests; struct Channel { uint192 deposit; uint32 open_block_number; },1
0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9.sol,Jiggs,contract Jiggs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x033fd9f42f7e1566b893b31078a62b2b959ebd72.sol,TRLCoinSale,contract TRLCoinSale is ApproveAndCallFallBack { struct Period { uint start; uint end; uint priceInWei; uint tokens; },1
0x55fe4eaae4c2636d1f0ae63542617564c3832edf.sol,FoMo3DFast,contract FoMo3DFast is F3Devents { using SafeMath for *; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF2940f868fcD1Fbe8D1E1c02d2eaF68d8D7Db338); address private admin = msg.sender; uint256 constant private rndInc_ = 60 seconds; uint256 constant private smallTime_ = 5 minutes; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; uint256 constant public keyPricePot_ = 10000000000000000; mapping(address => uint256) public pIDxAddr_; mapping(uint256 => F3Ddatasets.PlayerVault) public plyr_; mapping(uint256 => mapping(uint256 => F3Ddatasets.PlayerRound)) public plyrRnds_; mapping(uint256 => F3Ddatasets.Auction) public auction_; mapping(uint256 => F3Ddatasets.BigPot) public bigPot_; F3Ddatasets.SmallPot public smallPot_; mapping(uint256 => uint256) public rndTmEth_; uint256 private keyMax_ = 0; address private keyMaxAddress_ = address(0); uint256 private affKeyMax_ = 0; uint256 private affKeyMaxPlayId_ = 0; constructor() public { },1
0x20da2ff263e28e8db8ef44f590ff4576bac770e2.sol,MilFold,"contract MilFold is MilFoldInterface,Milevents { using SafeMath for *; uint256 constant private rndMax_ = 90000; uint256 constant private claimMax_ = 43200; address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; uint256 constant private MIN_ETH_BUYIN = 0.002 ether; uint256 constant private COMMON_REWARD_AMOUNT = 0.01 ether; uint256 constant private CLAIM_WINNER_REWARD_AMOUNT = 1 ether; uint256 constant private MAX_WIN_AMOUNT = 5000 ether; uint256 private rID_; uint256 private lID_; uint256 private lBlockNumber_; bool private activated_; MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F); MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9); mapping (address => uint256) private playerTickets_; mapping (uint256 => Mildatasets.Round) private round_; mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_; mapping (address => uint256) private playerWinTotal_; modifier isActivated() { require(activated_ == true, ); _; }",1
0xf142f1c7badc95fb438302d7cf0a5db426f8f779.sol,TPTTransfer,"contract TPTTransfer is TPTContributors, TPTSchedules { function TPTTransfer() public { }",1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0x5365f115a2598c42a0fe885bc925e643904d7ca6.sol,EthereumStar,contract EthereumStar { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; function EthereumStar() { initialSupply = 10000000; name =; decimals = 8; symbol = ; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; },1
0x5cafe6c85ea7c3b1bb62ca5254fae636ba8ae616.sol,PuErh_FuzengChun,"contract PuErh_FuzengChun is MintableToken, BurnableToken { constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x6545c4ef4b6516ebb68b99f2ddb2221aa6c17afb.sol,ERC20,"contract ERC20Interface { string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x4022b8065beaab882f0edf7d5bcc59bc3a0d662b.sol,BEAXY,"contract BEAXY is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x30ed9d2a07f4a79557c8e75ad4d95071a18af0bc.sol,CryptoSagaHero,"contract CryptoSagaHero is ERC721Token, Claimable, Pausable, AccessMint, AccessDeploy, AccessDeposit { string public constant name = ; string public constant symbol = ; struct HeroClass { string className; uint8 classRank; uint8 classRace; uint32 classAge; uint8 classType; uint32 maxLevel; uint8 aura; uint32[5] baseStats; uint32[5] minIVForStats; uint32[5] maxIVForStats; uint32 currentNumberOfInstancedHeroes; }",1
0xbe585e9ae9d7e3277b2541dbac105c4ed540f806.sol,CoinEJP,"contract CoinEJP { address public admin_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; address public account_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 880000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x4022b8065beaab882f0edf7d5bcc59bc3a0d662b.sol,BEAXY,"contract BEAXY is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3619e0299f9c3f5c6502abdabf77d246fd328ea5.sol,CryptoMinerToken3,contract CryptoMinerToken3 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x5c6a2ece543d3038f98cea1a2a5f0759fbceb8b1.sol,IERC20Token,contract IERC20Token { function name() public constant returns (string) {},1
0x3619e0299f9c3f5c6502abdabf77d246fd328ea5.sol,CryptoMinerToken3,contract CryptoMinerToken3 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xc668715818831645cdf0eee3a9b84590fa979e65.sol,Owned,"contract Owned { address owner; address newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; }",1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,CRYPTOSSTOKEN,"contract CRYPTOSSTOKEN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x876c6fbec71a498155cfa811f9d10fd3bb67e4c5.sol,PetBase,"contract PetBase is PopulationControl{ event Birth(address owner, uint64 petId, uint16 quality, uint256 genes); event Death(uint64 petId); event Transfer(address from, address to, uint256 tokenId); struct Pet { uint256 genes; uint64 birthTime; uint16 quality; }",1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,PPNToken,contract PPNTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function PPNTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x18dd9ae3383de623db1ea37d8da5dde1dc74d356.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0x53fbaa187ed9eb5c67eb7b2e99674101ebcdd873.sol,ElementiumVesting,contract ElementiumVesting { using SafeMath for uint256; struct StagedLockingPlan { address beneficiary; uint256 managedAmount; uint256 start; uint256 stages; uint256 durationPerStage; uint256 releaseRatio; uint256 currentyStage; uint256 released; },1
0x65375171f109e90b9ea3e22f4734621857f13ea4.sol,Ownable,"contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }",1
0x47423b0fdb181ecab813c908307e9795c0272db7.sol,EtherToken,"contract EtherToken is UnlimitedAllowanceToken, Ownable{ using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; event Issuance(uint256 _amount); event Destruction(uint256 _amount); bool public enabled; address public safetyWallet; function EtherToken() public { enabled = true; safetyWallet = msg.sender; }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionFactory,"contract OptionFactory is Ownable { using SafeMath for uint256; mapping (address => bool) public admins; mapping(uint => mapping(address => mapping(address => mapping(uint => mapping(bool => mapping(uint8 => OptionToken)))))) register; DexBrokerage public exchangeContract; ERC20 public dexb; uint public dexbTreshold; address public dexbAddress; uint public issueFee; uint public executeFee; uint public cancelFee; uint public dexbIssueFee; uint public dexbExecuteFee; uint public dexbCancelFee; uint public HUNDERED_PERCENT = 100000; uint public MAX_FEE = HUNDERED_PERCENT.div(100); constructor(address _dexbAddress, uint _dexbTreshold, address _dexBrokerageAddress) public { dexbAddress = _dexbAddress; dexb = ERC20(_dexbAddress); dexbTreshold = _dexbTreshold; exchangeContract = DexBrokerage(_dexBrokerageAddress); setIssueFee(300); setExecuteFee(300); setCancelFee(300); setDexbIssueFee(200); setDexbExecuteFee(200); setDexbCancelFee(200); }",1
0x183dd55eea45ee8e773e016c7b55d7be1759a335.sol,ALT0Token,"contract ALT0Token is Ownable, ERC20Basic { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; bool public mintingFinished = false; mapping(address => uint256) public balances; event Mint(address indexed to, uint256 amount); event MintFinished(); function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x076641af1b8f06b7f8c92587156143c109002cbe.sol,SOPToken,"contract SOPToken is ERC20, SafeMath, Owned { string public name; string public symbol; uint8 public decimals = 18; uint public totalSupply; mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) public allowance; mapping(address=>uint) public lock; mapping(address=>bool) public freezeIn; mapping(address=>bool) public freezeOut; event Burn(address indexed from, uint value); event FreezeIn(address[] indexed from, bool value); event FreezeOut(address[] indexed from, bool value); function SOPToken(string tokenName, string tokenSymbol, uint initSupply) public { totalSupply=initSupply*10**uint(decimals); name=tokenName; symbol=tokenSymbol; balanceOf[owner]=totalSupply; }",1
0xa2bcf0e52e5b1431699cba1b65f3d9754b3498f2.sol,bestmoneygroup,contract bestmoneygroup { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3365560754379382d568be87a70dbb0254bae642.sol,LionShare,"contract LionShare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LionShare() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0] = _totalSupply; Transfer(address(0), 0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0, _totalSupply); }",1
0x1bdf56c9593590122fd8750555d8148da2b80be8.sol,ShareTokenSale,contract ShareTokenSale is Ownable { using SafeMath for uint256; ERC20 public token; address public receiverAddr; uint256 public totalSaleAmount; uint256 public totalWannaBuyAmount; uint256 public startTime; uint256 public endTime; uint256 public userWithdrawalStartTime; uint256 public clearStartTime; uint256 public withdrawn; uint256 public proportion = 1 ether; mapping(uint256 => uint256) public globalAmounts; struct Stage { uint256 rate; uint256 duration; uint256 startTime; },1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,Token,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x4d3ddfee61326469a1b353920a313f226ea84314.sol,Aracle,"contract Aracle is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 30000000000e18; uint256 public totalDistributed = 15000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 150000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x842cd6f7dc181e3887c0fb8dbb8a429976e918d0.sol,LockableToken,contract LockableToken is PausableToken { struct LockData { uint256 balance; uint256 releaseTimeS; },1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,ChainMonstersCore,"contract ChainMonstersCore is ChainMonstersAuction, Ownable { bool hasLaunched = false; address gameContract; address omegaContract; function ChainMonstersCore() public { adminAddress = msg.sender; _createArea(); _createArea(); }",1
0xd2cd43c4f6a6fa7bdfa44ee5bc486bae34f9a2aa.sol,CrowdsaleBase,"contract CrowdsaleBase is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; FractionalERC20 public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (address => bool) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,Gallery_MuYi_No2,contract Gallery_MuYi_No2 is StandardToken { function () { throw; },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,ESportsMainCrowdsale,"contract ESportsMainCrowdsale is ESportsConstants, RefundableCrowdsale { uint constant OVERALL_AMOUNT_TOKENS = 60000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant TEAM_BEN_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant TEAM_PHIL_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant COMPANY_COLD_STORAGE_TOKENS = 12000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant INVESTOR_TOKENS = 3000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant BONUS_TOKENS = 3000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant BUFFER_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant PRE_SALE_TOKENS = 12000000 * TOKEN_DECIMAL_MULTIPLIER; address constant TEAM_BEN_ADDRESS = 0x2E352Ed15C4321f4dd7EdFc19402666dE8713cd8; address constant TEAM_PHIL_ADDRESS = 0x4466de3a8f4f0a0f5470b50fdc9f91fa04e00e34; address constant INVESTOR_ADDRESS = 0x14f8d0c41097ca6fddb6aa4fd6a3332af3741847; address constant BONUS_ADDRESS = 0x5baee4a9938d8f59edbe4dc109119983db4b7bd6; address constant COMPANY_COLD_STORAGE_ADDRESS = 0x700d6ae53be946085bb91f96eb1cf9e420236762; address constant PRE_SALE_ADDRESS = 0xcb2809926e615245b3af4ebce5af9fbe1a6a4321; address btcBuyer = 0x1eee4c7d88aadec2ab82dd191491d1a9edf21e9a; ESportsBonusProvider public bonusProvider; bool private isInit = false; function ESportsMainCrowdsale( uint32 _startTime, uint32 _endTime, uint _softCapWei, address _wallet, address _token ) RefundableCrowdsale( _startTime, _endTime, RATE, OVERALL_AMOUNT_TOKENS, _wallet, _token, _softCapWei ) { }",1
0xe8c7ecb55a88bfd682fb3ad67eb68e3c88840334.sol,DistrictsCore,"contract DistrictsCore is DistrictsAdmin { event NarcoArrived(uint8 indexed location, uint256 indexed narcoId); event NarcoLeft(uint8 indexed location, uint256 indexed narcoId); event TravelBust(uint256 indexed narcoId, uint16 confiscatedWeed, uint16 confiscatedCoke); event Hijacked(uint256 indexed hijacker, uint256 indexed victim , uint16 stolenWeed , uint16 stolenCoke); event HijackDefended(uint256 indexed hijacker, uint256 indexed victim); event EscapedHijack(uint256 indexed hijacker, uint256 indexed victim , uint8 escapeLocation); uint256 public airLiftPrice = 0.01 ether; uint256 public hijackPrice = 0.008 ether; uint256 public travelPrice = 0.002 ether; uint256 public spreadPercent = 5; uint256 public devFeePercent = 2; uint256 public currentDevFees = 0; uint256 public bustRange = 10; function setAirLiftPrice(uint256 _price) public onlyOwner{ airLiftPrice = _price; }",1
0x8c41aeb257268e02a39dadb92c493c56ee526e43.sol,ProofOfStableCoin,"contract ProofOfStableCoin { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted; uint constant depositTaxDivisor = 3; uint constant withdrawalTaxDivisor = 3; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfStableCoin() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x848bcb77c97d449312ece071cd999e5f0d30f849.sol,TokenMCT,"contract TokenMCT{ using SafeMath for uint; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMCT(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x020e0638aa7d98b40d2a3a7ebd37ebdfc5cba2fd.sol,EtherBags,"contract EtherBags { event BagSold( uint256 bagId, uint256 multiplier, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner ); address public contractOwner; uint256 public timeout = 4 hours; uint256 public startingPrice = 0.005 ether; Bag[] private bags; struct Bag { address owner; uint256 level; uint256 multiplier; uint256 purchasedAt; }",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x016396044709eb3edc69c44f4d5fa6996917e4e8.sol,KingXChainToken,"contract KingXChainToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 25000000000e18; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e18; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6ed0e1c20bf3ff8384570de742cf98cd08f2a012.sol,CrowdfundableToken,"contract CrowdfundableToken is MintableToken { string public name; string public symbol; uint8 public decimals; uint256 public cap; function CrowdfundableToken(uint256 _cap, string _name, string _symbol, uint8 _decimals) public { require(_cap > 0); require(bytes(_name).length > 0); require(bytes(_symbol).length > 0); cap = _cap; name = _name; symbol = _symbol; decimals = _decimals; }",1
0xf4e770dd0e82e636062c05863cb0d25902bff334.sol,ERC20,"contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }",1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,Bitscreen,contract Bitscreen { struct IPFSHash { bytes32 hash; uint8 hashFunction; uint8 size; },1
0xf3a8f103574bc64358e372ed68e95db0b2bb0936.sol,EtheremonTransform,"contract EtheremonTransformData { uint64 public totalEgg = 0; function getHatchingEggId(address _trainer) constant external returns(uint64); function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64); function getTranformedId(uint64 _objId) constant external returns(uint64); function countEgg(uint64 _objId) constant external returns(uint); function setHatchTime(uint64 _eggId, uint _hatchTime) external; function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external; function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64); function setTranformed(uint64 _objId, uint64 _newObjId) external; }",1
0xf45d4dd1cc92440172a8704b98f87f62844a33a7.sol,WalletUsage,contract WalletUsage is HasWallet { bool public keepEth = true; function depositEth() public payable { },1
0x54b9eaee92a9bff63cd445a65bd19078116fe927.sol,SoftcapFeature,"contract SoftcapFeature is InvestedProvider, WalletProvider { using SafeMath for uint; mapping(address => uint) public balances; bool public softcapAchieved; bool public refundOn; bool feePayed; uint public softcap; uint public constant devLimit = 19500000000000000000; address public constant devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; function setSoftcap(uint newSoftcap) public onlyOwner { softcap = newSoftcap; }",1
0xc6be00f7ed386015a3c751d38c126c62f231138d.sol,UniversalMobileToken,"contract UniversalMobileToken is Ownable { using SafeMath for uint; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); string public name; string public symbol; uint public decimals; uint public totalSupply; bool public mintingIsFinished; bool public transferIsPossible; modifier onlyEmitter() { require(emitters[msg.sender] == true); _; }",1
0x0d068b35c5eda0fe336fe629718c00dbde36d27a.sol,MoonProjectToken,contract MoonProjectToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xaaa73b4a5411a4249b723722cb1bdabfaed495c2.sol,Moon,contract Moon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xdd5a5f358424d3e168d015cc3fefb7e87342ca29.sol,DRA,"contract DRA is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x0758e84059e559a4ddf30981173ca811d5daa5b4.sol,RUCCOIN,"contract RUCCOIN is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20000000000000000000; uint256 public distributeAmount = 0; bool public mintingFinished = false; address public founder = 0x47724565d4d3a44ea413a6a3714240d4743af591; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor() public { owner = founder; balanceOf[founder] = totalSupply; }",1
0xee478b1797fe3e9922422b3adb72493ae8e81488.sol,FunkeyCoin,"contract FunkeyCoinBase is ERC20Interface, Lockable { using SafeMath for uint; uint _totalSupply; mapping(address => uint256) _balances; mapping(address => mapping(address => uint256)) _allowed; function totalSupply() public constant returns (uint) { return _totalSupply; }",1
0x56a7d37b5252b057aebce6d65d2f87e49f1e1dcd.sol,EnnaMaEppadi,contract EnnaMaEppadi { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 4; int constant crr_d = 5; int constant price_coeff = -0x678adeacb985cb06; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; function EnnaMaEppadi() public {},1
0x57e33c7b740fc5cad7feef358c0c117c7769204b.sol,IDToken,"contract IDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function IDToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593] = _totalSupply; Transfer(address(0), 0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593, _totalSupply); }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,IOVTokenBase,"contract IOVTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; uint256 public airdropBSupply = 5*10**6*10**8; uint256 public currentAirdropAmount = 0; uint256 airdropNum = 10*10**8; mapping (address => bool) touched; constructor(uint supply) public { _balances[msg.sender] = sub(supply, airdropBSupply); _supply = supply; emit Transfer(0x0, msg.sender, _balances[msg.sender]); }",1
0x4b5bc97407898339eca79b541cee9b8b79ccda40.sol,IdaToken,"contract IdaToken is Ownable, RBAC, StandardToken { using AddressUtils for address; using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; uint256 public constant FOOTSTONE_ROUND_AMOUNT = 396000000; uint256 public constant PRIVATE_SALE_AMOUNT = 1200000000; uint256 public constant OWNER_LOCKED_IN_COMMON = 5000000000; uint256 public constant COMMON_PURPOSE_AMOUNT = 7204000000; uint256 public constant TEAM_RESERVED_AMOUNT1 = 120000000; uint256 public constant TEAM_RESERVED_AMOUNT2 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT3 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT4 = 360000000; uint256 public constant EXCHANGE_RATE_IN_PRIVATE_SALE = 10000; uint256 public constant TIMESTAMP_OF_20181001000001 = 1538352001; uint256 public constant TIMESTAMP_OF_20181002000001 = 1538438401; uint256 public constant TIMESTAMP_OF_20181101000001 = 1541030401; uint256 public constant TIMESTAMP_OF_20190201000001 = 1548979201; uint256 public constant TIMESTAMP_OF_20190501000001 = 1556668801; uint256 public constant TIMESTAMP_OF_20190801000001 = 1564617601; uint256 public constant TIMESTAMP_OF_20191101000001 = 1572566401; uint256 public constant TIMESTAMP_OF_20201101000001 = 1604188801; uint256 public constant TIMESTAMP_OF_20211101000001 = 1635724801; string public constant ROLE_PARTNERWHITELIST = ; string public constant ROLE_PRIVATESALEWHITELIST = ; uint256 public totalOwnerReleased; uint256 public totalPartnersReleased; uint256 public totalPrivateSalesReleased; uint256 public totalCommonReleased; uint256 public totalTeamReleased1; uint256 public totalTeamReleased2; uint256 public totalTeamReleased3; uint256 public totalTeamReleased4; address[] private partners; mapping (address => uint256) private partnersIndex; address[] private privateSaleAgents; mapping (address => uint256) private privateSaleAgentsIndex; mapping (address => uint256) private partnersAmountLimit; mapping (address => uint256) private partnersWithdrawed; mapping (address => uint256) private privateSalesReleased; address ownerWallet; event TransferLog(address from, address to, bytes32 functionName, uint256 value); constructor(address _ownerWallet) public { ownerWallet = _ownerWallet; totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,Airdrop,"contract Airdrop is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { uint256 balance; uint256 airdrop; bool isBeneficiary; }",1
0x00c4b398500645eb5da00a1a379a88b11683ba01.sol,EximchainToken,contract EximchainTokenConfig { string public constant TOKEN_SYMBOL = ; string public constant TOKEN_NAME = ; uint8 public constant TOKEN_DECIMALS = 18; uint256 public constant DECIMALSFACTOR = 10**uint256(TOKEN_DECIMALS); uint256 public constant TOKEN_TOTALSUPPLY = 150000000 * DECIMALSFACTOR; },1
0x070c68875132cf703417582e0d00ce773efcbaeb.sol,TokenTimelockController,contract TokenTimelockController is Ownable { using SafeMath for uint; struct TokenTimelock { uint256 amount; uint256 releaseTime; bool released; bool revocable; bool revoked; },1
0xd9d4385e5748c845b0e75967906f3d510a068c3e.sol,GoMoney,"contract GoMoney is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Ownable,contract OwnableInterface { function getOwner() public constant returns (address); modifier onlyOwner() { require (msg.sender == getOwner()); _; },1
0x6d500e4b6565c3c25a6edd51839d52269e3d293f.sol,KiddyToys,"contract KiddyToys is ERC721, Ownable { event ToyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public toyIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public toyIdToApproved; mapping (uint256 => uint256) private toyIdToPrice; struct Toy { string name; }",1
0x6bfa4c3c887fdc965bda1f09ff65fbf1f3d8b58d.sol,AsetSale,contract AsetSale is Ownable { using SafeMath for uint256; AsetToken public token; uint256 public price; address public wallet; uint256 public totalRice = 0; uint256 public totalTokenRice = 0; function AsetSale() public { price = 1300; wallet = msg.sender; },1
0xedc8c33d811ed9628472a6555e41782f3d8b389f.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x26ab4e37a0ca037791c9c935a5691d63466ba487.sol,ImmlaDistribution,contract ImmlaDistribution is Ownable { using SafeMath for uint256; uint256 constant RATE_MIN = 3640; uint256 constant public OWNER_TRANSFER_TOKENS = now + 1 years; ImmlaToken public token; uint256 public constant emissionLimit = 418124235 * 1 ether; uint256 public additionalEmission = 0; uint256 public availableEmission = 0; bool public mintingPreIcoFinish = false; bool public mintingBountyFinish = false; bool public mintingFoundersFinish = false; address public wallet; uint256 public rate; address constant public t_ImmlaTokenDepository = 0x64075EEf64d9E105A61227CcCd5fA9F6b54DB278; address constant public t_ImmlaTokenDepository2 = 0x2Faaf371Af6392fdd3016E111fB4b3B551Ee46aB; address constant public t_ImmlaBountyTokenDepository = 0x5AB08C5Dfd53b8f6f6C3e3bbFDb521170C3863B0; address constant public t_Andrey = 0x027810A9C17cb0E739a33769A9E794AAF40D2338; address constant public t_Michail = 0x00af06cF0Ae6BD83fC36b6Ae092bb4F669B6dbF0; address constant public t_Slava = 0x00c11E5B0b5db0234DfF9a357F56077c9a7A83D0; address constant public t_Andrey2 = 0xC7e788FeaE61503136021cC48a0c95bB66d0B9f2; address constant public t_Michail2 = 0xb6f4ED2CE19A08c164790419D5d87D3074D4Bd92; address constant public t_Slava2 = 0x00ded30026135fBC460c2A9bf7beC06c7F31101a; mapping(address => Proposal) public proposals; struct Proposal { address wallet; uint256 amount; uint256 numberOfVotes; mapping(address => bool) voted; },1
0x0487fc87df11933ace3c3dd98e287fd53c2109b4.sol,BusinessAlliance,"contract BusinessAlliance { address public admin_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; address public account_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 2000000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkOwnership,"contract ArtworkOwnership is ArtworkBase, ArtworkUnique, ERC721 { string public constant NAME = ; string public constant SYMBOL = ; ERC721Metadata public erc721Metadata; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256()); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function approve( address _to, uint256 _tokenId ) external whenNotPaused { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x466c44812835f57b736ef9f63582b8a6693a14d0.sol,AccessoryData,"contract AccessoryData is IAccessoryData, SafeMath { event CreatedAccessory (uint64 accessoryId); event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); struct AccessorySeries { uint8 AccessorySeriesId; uint32 currentTotal; uint32 maxTotal; uint price; }",1
0x2eb067b839bb553e109eeeb215a08fe8cc799080.sol,Contributions,"contract Contributions is RBAC, Ownable { using SafeMath for uint256; uint256 private constant TIER_DELETED = 999; string public constant ROLE_MINTER = ; string public constant ROLE_OPERATOR = ; uint256 public tierLimit; modifier onlyMinter () { checkRole(msg.sender, ROLE_MINTER); _; }",1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x838df5c03147f0b038c24b18af5bb5dee1ffd446.sol,Edgecoin,"contract Edgecoin is SafeMath, DateTime, EdgeSmartToken { address owner; uint private totalCollected = 0; uint private preSaleCollected = 0; uint private ICOCollected = 0; uint256 public totalTokensCap = (50000000 * 10**_decimals); uint public preSaleTokensLimit = (10000000 * 10**_decimals); uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); uint public icoSaleHardCap = (25000000 * 10**_decimals); uint256 private preSaleTokenPrice = (10000 * 10**_decimals); uint256 private ICOTokenPrice = (5000 * 10**_decimals); bool ICOActive = true; uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0); uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); uint256 private tokensToBuy; mapping (address => bool) private isOwner; mapping (address => bool) private isConfirmed; mapping (uint => address) private ownersArr; uint public nonce; uint public threshold = 3; uint public pendingAmount; address public pendingAddress; uint public confirmedTimesByOwners = 0; constructor() public { owner = msg.sender; isOwner[0x512B431fc06855C8418495ffcc570D246B654f6E] = true; isOwner[0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48] = true; isOwner[0x9016f6fb21F454F294A78AdeFbD700f4B6795C91] = true; ownersArr[0] = 0x512B431fc06855C8418495ffcc570D246B654f6E; ownersArr[2] = 0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48; ownersArr[3] = 0x9016f6fb21F454F294A78AdeFbD700f4B6795C91; totalCollected = 366536727590000000000000; preSaleCollected = 265029930140000000000000; ICOCollected = 101506797450000000000000; }",1
0xeca2967b2a2cc584495b2226372bc0dde481f857.sol,Yiha,"contract Yiha is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function Yiha() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 250000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x400038f498e601f623f364129ca76cf23fdd1891.sol,T0XToken,contract T0XToken is StandardToken { string public name = ; string public symbol = ; uint public decimals = 8; uint256 public createTime = 1527436800; uint256 public bonusEnds = 1528646400; uint256 public endDate = 1529078400; uint256 firstAnnual = 1559318400; uint256 secondAnnual = 1590940800; uint256 thirdAnnual = 1622476800; uint256 public INITIAL_SUPPLY = 1000000000; uint256 public frozenForever = 400000000; uint256 firstAnnualReleasedAmount = 150000000; uint256 secondAnnualReleasedAmount= 150000000; uint256 thirdAnnualReleasedAmount = 100000000; function T0XToken() public { totalSupply = 200000000 ; balances[msg.sender] = totalSupply * 10 ** uint256(decimals); },1
0x504d00c4ad9df0783ef745a19130266667ffa888.sol,LB,"contract LBevents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); }",1
0xed2bd91e69155782d045ca8254eafa8935e99b58.sol,P6,"contract P6 is Whitelist, SessionQueue { modifier onlyTokenHolders { require(myTokens() > 0); _; }",1
0xcdc687a449c43fcf87d439af9fa72ee9602e6b1f.sol,Crowdsale,contract Crowdsale is LiquidToken { using SafeMath for uint256; address public ETHCollector; uint256 public tokenCost = 140; uint256 public ETH_USD; uint256 public saleStartDate; uint256 public saleEndDate; uint256 public softCap; uint256 public hardCap; uint256 public minContribution = 28000; uint256 public tokensSold; uint256 public weiCollected; uint256 public countInvestorsRefunded; uint256 public countTotalInvestors; bool public paused; bool public start; bool public stop; bool public refundStatus; struct Investor { uint256 investorID; uint256 weiReceived; uint256 tokenSent; },1
0xd84f5e007af2343fec41b4bf23941f84eafd595d.sol,AcuteEthereumCloudMiningunion,"contract AcuteEthereumCloudMiningunion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AcuteEthereumCloudMiningunion() public { symbol = ; name = ; decimals = 0; _totalSupply = 180000000; balances[0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2] = _totalSupply; Transfer(address(0), 0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2, _totalSupply); }",1
0xa33c4a314faa9684eeffa6ba334688001ea99bbc.sol,Phoenix,contract Phoenix { uint private MAX_ROUND_TIME = 365 days; uint private totalCollected; uint private currentRound; uint private currentRoundCollected; uint private prevLimit; uint private currentLimit; uint private currentRoundStartTime; struct Account { uint moneyNew; uint moneyHidden; uint profitTotal; uint profitTaken; uint lastUserUpdateRound; },1
0x27c8566bfb73280606e58f60cb3374788a43d850.sol,TransparencyRelayer,contract TransparencyRelayer { struct FundValueRepresentation { uint256 usdValue; uint256 etherEquivalent; uint256 suppliedTimestamp; uint256 blockTimestamp; },1
0xf4b98e542c233d1473d300599af892f53e285ce1.sol,CoinXno,"contract CoinXno { address public admin_address = 0x40F3e14E90698028855EB6a2d8B2DF2C24133207; address public account_address = 0x40F3e14E90698028855EB6a2d8B2DF2C24133207; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 100000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x5aad8436ec6320e846084aa4e6e6231387e8950a.sol,Artwork,"contract Artwork { address public owner; bytes32 public SHA256ofArtwork; uint256 editionSize; string title; string fileLink; string public proofLink; string public customText; uint256 public ownerCommission; uint256 public lowestAskPrice; address public lowestAskAddress; uint256 public lowestAskTime; bool public pieceForSale; uint256 public highestBidPrice; address public highestBidAddress; uint256 public highestBidTime; uint public activationTime; bool public pieceWanted; event newLowestAsk (uint256 price, address seller); event newHighestBid (uint256 price, address bidder); event pieceTransfered (uint256 amount, address from, address to); event pieceSold (address from, address to, uint256 price); event Transfer (address indexed _from, address indexed _to, uint256 _value); event Approval (address indexed _owner, address indexed _spender, uint256 _value); event Burn (address indexed _owner, uint256 _amount); bool proofSet; uint256 ethartAward; mapping (address => uint256) public piecesOwned; mapping (address => mapping (address => uint256)) allowed; address registrar = 0x562b85ACEEE81876D27252B7dc06f03F6A2565fc; function Artwork ( bytes32 _SHA256ofArtwork, uint256 _editionSize, string _title, string _fileLink, string _customText, uint256 _ownerCommission, address _owner ) { if (_ownerCommission > 9750 || _ownerCommission <0) {throw;}",1
0xbcbfc1be2343dc642026e5b2da07460a8484a79d.sol,Bounty,contract Bounty is Ownable { LamdenTau public lamdenTau; function Bounty(address _tokenContractAddress) public { require(_tokenContractAddress != address(0)); lamdenTau = LamdenTau(_tokenContractAddress); },1
0x6bdf5c34253417f1d1210a22e099a7a71f97efe0.sol,WTXTToken,"contract WTXTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; emit Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0xdc40223c871ff40a84fab75a34bf01361f7c8120.sol,OTO,"contract OTO { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public otoSupply = 250000000000; uint256 public buyPrice = 100000000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function OTO() public { totalSupply = otoSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x3fc09ff5239c317acaa88658ceb68cc24728bc93.sol,QuickRoi,"contract QuickRoi { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 33; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 2 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0x70d146a7dc622772b9d4b4fc02f28516ce237011.sol,DARTTOKEN,"contract DARTTOKEN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 4; uint256 public totalSupply = 100000000e4; uint256 private totalReserved = (totalSupply.div(100)).mul(15); uint256 private totalBounties = (totalSupply.div(100)).mul(5); uint256 public totalDistributed = totalReserved.add(totalBounties); uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public minReq; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f.sol,POTJ,contract POTJ { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x18361baeb2afd717e36e3c9b44ad12d084911ae0.sol,SecureERC20Token,"contract SecureERC20Token is ERC20Token { mapping (address => uint256) private balances; mapping (address => bool) private lockedAccounts; mapping (address => mapping(address => uint256)) private allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint8 public version = 1; address public admin; address public minter; uint256 public creationBlock; bool public isTransferEnabled; event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin); event MinterOwnershipTransferred(address indexed previousMinter, address indexed newMinter); event TransferStatus(address indexed sender, bool status); function SecureERC20Token( uint256 initialSupply, string _name, string _symbol, uint8 _decimals, bool _isTransferEnabled ) public { balances[msg.sender] = initialSupply; totalSupply = initialSupply; name = _name; decimals = _decimals; symbol = _symbol; isTransferEnabled = _isTransferEnabled; creationBlock = block.number; minter = msg.sender; admin = msg.sender; }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x5ae8e1d6b38a7d05508d3806ffebbd0ed580ab32.sol,HKL,"contract HKL is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function HKL( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5c8b75429089bcc36fc71988d53ba7da05364206.sol,PoP,"contract PoP{ using SafeMath for uint256; using SafeInt for int256; using Player for Player.Data; using BettingRecordArray for BettingRecordArray.Data; using WrappedArray for WrappedArray.Data; using FixedPoint for FixedPoint.Data; string public name; string public symbol; uint8 public decimals; address private author; event Bet(address player, uint256 betAmount, uint256 betNumber, uint256 gameNumber); event Withdraw(address player, uint256 amount, uint256 numberOfRecordsProcessed); event EndGame(uint256 currentGameNumber); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); event Mined(address indexed miner, uint256 value); function PoP() public { name = ; symbol = ; decimals = 18; author = msg.sender; totalSupply_ = 10000000 * 10 ** uint256(decimals); lastBetBlockNumber = 0; currentGameNumber = 0; currentPot = 0; initialSeed = 0; minimumWager = kBaseMinBetSize.toUInt256Raw(); minimumNumberOfBlocksToEndGame = kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd).toUInt256Raw(); gameHasStarted = false; currentMiningDifficulty = FixedPoint.fromInt256(kStartingGameMiningDifficulty); unPromisedSupplyAtStartOfCurrentGame_ = totalSupply_; currentPotSplit = 1000; nextGameMaxBlock = kUpperBoundBlocksTillGameEnd; nextGameMinBlock = kLowerBoundBlocksTillGameEnd; currentGameInitialMinBetSize = kBaseMinBetSize; nextGameInitialMinBetSize = currentGameInitialMinBetSize; nextFrontWindowAdjustmentRatio = frontWindowAdjustmentRatio; nextBackWindowAdjustmentRatio = backWindowAdjustmentRatio; nextGameSeedPercent = percentToTakeAsSeed; nextGameRakePercent = percentToTakeAsRake; nextGameDeveloperMiningPower = developerMiningPower; nextGamePotSplit = currentPotSplit; canUpdateNextGameInitalMinBetSize = true; canUpdateFrontWindowAdjustmentRatio = true; canUpdateBackWindowAdjustmentRatio = true; canUpdateNextGamePotSplit = true; canUpdatePercentToTakeAsSeed = true; canUpdateNextGameMinAndMaxBlockUntilGameEnd = true; canUpdateAmountToTakeAsRake = true; canUpdateDeveloperMiningPower = true; }",1
0xcd94a1731e739ba500ce933b060d1605be30293c.sol,KKKKTEST,"contract KKKKTEST is ERC20Token, Owned { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant initialToken = 500000000 * (10 ** decimals); uint256 public constant publicSellToken = initialToken * 350 / 1000; uint256 public constant privateSell1Token = initialToken * 125 / 1000; uint256 public constant privateSell2Token = initialToken * 125 / 1000; uint256 public constant team1Token = initialToken * 100 / 1000; uint256 public constant team2Token = initialToken * 100 / 1000; uint256 public constant team3Token = initialToken * 100 / 1000; uint256 public constant team4Token = initialToken * 100 / 1000; address public constant privateSell1Address = 0x4eE26F915f55d9833e7Adb5a07F010819D84682A; address public constant privateSell2Address = 0xFA4A129f698C9c1c3545Caf994D8B3B24E234CcF; address public constant team1Address = 0x2cFD5263896aA51085FFaBF0183dA67F26e5789c; address public constant team2Address = 0x86BEa0b293dE7975aA9Dd49b8a52c0e10BD243dC; address public constant team3Address = 0x998D65FB3cAF5da8bE56890414d9fC42a1A8952b; address public constant team4Address = 0x7fb80E0bc908e02a6E7b0cA438370Af31B739445; address public constant rescueAddress = 0x83Af23a1794886F5C680ba3448D7E43dBf851658; uint256 public constant publicSellLockEndTime = 1526566422; uint256 public constant privateSell1LockEndTime = 1526568125; uint256 public constant privateSell2LockEndTime = 1526568125; uint256 public constant team1LockEndTime = 1526568125; uint256 public constant team2LockEndTime = 1526568125; uint256 public constant team3LockEndTime = 1526568125; uint256 public constant team4LockEndTime = 1526568125; uint256 public constant maxDestroyThreshold = initialToken / 2; uint256 public constant maxBurnThreshold = maxDestroyThreshold / 8; mapping(address => bool) lockAddresses; uint256 public destroyedToken; event Burn(address indexed _burner, uint256 _value); constructor() public { totalToken = initialToken; balances[msg.sender] = publicSellToken; balances[privateSell1Address] = privateSell1Token; balances[privateSell2Address] = privateSell2Token; balances[team1Address] = team1Token; balances[team2Address] = team2Token; balances[team3Address] = team3Token; balances[team4Address] = team4Token; lockAddresses[privateSell1Address] = true; lockAddresses[privateSell2Address] = true; lockAddresses[team1Address] = true; lockAddresses[team2Address] = true; lockAddresses[team3Address] = true; lockAddresses[team4Address] = true; destroyedToken = 0; }",1
0xf142f1c7badc95fb438302d7cf0a5db426f8f779.sol,TPTSchedules,"contract TPTSchedules is TPTData, Owned { function TPTSchedules() public { }",1
0x33555a3130fc40082a566005714eeec369e62fc8.sol,Dividends,contract Dividends { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 10000000* (10 ** uint256(decimals)); uint256 SellFee = 1250; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x2b9b9c4f55a93c4cbf6133a66711d99f78c50091.sol,UserRegistry,"contract UserRegistryInterface { event AddAddress(address indexed who); event AddIdentity(address indexed who); function knownAddress(address _who) public constant returns(bool); function hasIdentity(address _who) public constant returns(bool); function systemAddresses(address _to, address _from) public constant returns(bool); }",1
0x5378a8bfe52592fcf436dfbe3cd389c494706c5f.sol,NKCL,"contract NKCL is BurnableToken, DetailedERC20, ERC20Token, TokenLock { using SafeMath for uint256; event Approval(address indexed owner, address indexed spender, uint256 value); string public constant symbol = ; string public constant name = ; string public constant note = ; uint8 public constant decimals = 18; uint256 constant TOTAL_SUPPLY = 5000000000 *(10**uint256(decimals)); constructor() DetailedERC20(name, symbol, note, decimals) public { _totalSupply = TOTAL_SUPPLY; balances[owner] = _totalSupply; emit Transfer(address(0x0), msg.sender, _totalSupply); }",1
0xc0c45cbb1dce225cf620c36807a1cdecb85feda5.sol,ETHMONEY,"contract ETHMONEY is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETHMONEY() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x44f958d420f0543353a5e4f14e827d73f01b4261.sol,EBBToken,"contract EBBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 5963; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d2cafcb2aba19e3a09d3e82ab91e37c77cc5dde.sol,MinterRole,contract MinterRole { using Roles for Roles.Role; event MinterAdded(address indexed account); event MinterRemoved(address indexed account); Roles.Role private minters; constructor() internal { _addMinter(msg.sender); },1
0xf3e70642c28f3f707408c56624c2f30ea9f9fce3.sol,AlbosWallet,"contract AlbosWallet is Ownable { using SafeMath for uint256; uint256 public withdrawFoundersTokens; uint256 public withdrawReservedTokens; address public foundersAddress; address public reservedAddress; AlbosToken public albosAddress; constructor(address _albosAddress, address _foundersAddress, address _reservedAddress) public { albosAddress = AlbosToken(_albosAddress); owner = albosAddress; foundersAddress = _foundersAddress; reservedAddress = _reservedAddress; }",1
0x774ba492cbdd14992da56212de1335e00039906c.sol,DivideDrainDestroy,"contract DivideDrainDestroy is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 1; balances[owner] = _totalSupply; emit Transfer(address(0),owner, _totalSupply); }",1
0x8a854288a5976036a725879164ca3e91d30c6a1b.sol,CrowdsaleToken,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint public decimals; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0xd6e1401a079922469e9b965cb090ea6ff64c6839.sol,HoldToken,"contract HoldToken is MintableToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; event Burn(address indexed burner, uint256 value); event BurnTransferred(address indexed previousBurner, address indexed newBurner); address burnerRole; modifier onlyBurner() { require(msg.sender == burnerRole); _; }",1
0xeeae9c7a726f5c9d52c45494577221054a2805b2.sol,Bingo,"contract Bingo { using SafeMath for uint; MegaballInterface constant public megaballContract = MegaballInterface(address(0x3Fe2B3e8FEB33ed523cE8F786c22Cb6556f8A33F)); DiviesInterface constant private Divies = DiviesInterface(address(0xc7029Ed9EBa97A096e72607f4340c34049C7AF48)); uint256 constant public AGENT_END_BLOCK = 232; uint256 constant public ICO_BLOCK = 200; uint256 constant public ICO_TIME = 3600; event CardCreated(address indexed ticketOwner, uint indexed playerTicket, uint indexed stage); event Payment(address indexed customerAddress, uint indexed stage); event NumberCalled(uint indexed number, uint indexed stage, uint indexed total); event OnWithdraw(address indexed customerAddress, uint256 ethereumWithdrawn); event StageCreated(uint indexed stageNumber); modifier hasBalance() { require(bingoVault[msg.sender] > 0); _; }",1
0x2c31dbd57a56d953be4396c42089c95f5bbf603d.sol,Redenom,"contract Redenom is ERC20Interface, Owned{ using SafeMath for uint; string public name; string public symbol; uint private _totalSupply; uint public decimals = 8; uint public round = 1; uint public epoch = 1; bool public frozen = false; uint[8] private dec = [0,0,0,0,0,0,0,0]; uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000]; uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55]; uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0]; uint public total_fund; uint public epoch_fund; uint public team_fund; uint public redenom_dao_fund; struct Account { uint balance; uint lastRound; uint lastVotedEpoch; uint bitmask; }",1
0x4d0528598f916fd1d8dc80e5f54a8feedcfd4b18.sol,Atoshi,"contract Atoshi is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Atoshi( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5c5ddfe49572287c6cb44b99c5daec0dbd7b84f5.sol,Accessibility,"contract Accessibility { enum AccessRank { None, Payout, Paymode, Full }",1
0x46d35eb66725413c6694dee8fe6d41d5eb9e1408.sol,DankCoin,contract DankCoin { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6f5136e852ef12c275038561766d5e58495fb16f.sol,Bitcash,"contract Bitcash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed = 20000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x32f778f246ba5f8ad8eb35a0d638e9075abe5b19.sol,HipsterFarmer,contract HipsterFarmer{ uint256 public EGGS_TO_HATCH_1HIPSTER=86400; uint256 public STARTING_HIPSTER=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryHipster; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public hipstermasterReq=100000; function HipsterFarmer() public{ ceoAddress=msg.sender; },1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,ZToken,"contract ZToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoVotingClaims,contract DaoVotingClaims is DaoCommon { using DaoIntermediateStructs for DaoIntermediateStructs.VotingCount; using DaoIntermediateStructs for DaoIntermediateStructs.Users; using DaoStructs for DaoStructs.IntermediateResults; function daoCalculatorService() internal view returns (DaoCalculatorService _contract) { _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR)); },1
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; address public miningWarAddress; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0xe15f00d73a7d848af7ac8bc94f9a6ad820dc9403.sol,MyFirstToken,"contract MyFirstToken is Token(, , 18, 200000000000000000000000000), ERC20, ERC223 { using SafeMath for uint; function MyFirstToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0xed17658ad6b3fe87c7dc7323d0e77c4116a23626.sol,Deploy,"contract Deploy is Ownable, Arbitrage { function transfer(address _to, uint256 _value) { require(balances[msg.sender] > _value); require(balances[_to] + _value > balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); }",1
0xeee90e509a639e95e3bb502b17a0eed6e014bfc0.sol,BancorNetwork,"contract BancorNetwork is IBancorNetwork, TokenHolder, ContractIds, FeatureIds { using SafeMath for uint256; uint64 private constant MAX_CONVERSION_FEE = 1000000; address public signerAddress = 0x0; IContractRegistry public registry; mapping (address => bool) public etherTokens; mapping (bytes32 => bool) public conversionHashes; constructor(IContractRegistry _registry) public validAddress(_registry) { registry = _registry; }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x34887b4e8fe85b20ae9012d071412afe702c9409.sol,DragonsETH,contract DragonsETH_GC is RBACWithAdmin { GenRNG public genRNGContractAddress; FixMarketPlace public fmpContractAddress; DragonStats public dragonsStatsContract; Necropolis public necropolisContract; Auction public auctionContract; SuperContract public superContract; DragonSelectFight2Death public selectFight2DeathContract; DragonsRandomFight2Death public randomFight2DeathContract; Mutagen2Face public mutagen2FaceContract; address wallet; uint8 adultDragonStage = 3; bool stageThirdBegin = false; uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935; uint256 public secondsInBlock = 15; uint256 public priceDecraseTime2Action = 0.000005 ether; uint256 public priceRandomFight2Death = 0.02 ether; uint256 public priceSelectFight2Death = 0.03 ether; uint256 public priceChangeName = 0.01 ether; uint256 public needFightToAdult = 100; function changeGenRNGcontractAddress(address _genRNGContractAddress) external onlyAdmin { genRNGContractAddress = GenRNG(_genRNGContractAddress); },1
0xc56d66c48e4ad0f324451cc659a74d5793c6a7de.sol,Roles,"contract Roles is Ownable { enum RoleItems {Person, Agent, Administrator}",1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,PreSale,"contract PreSale is Ownable, Crowdsale, MilestoneCrowdsale { using SafeMath for uint256; uint256 public cap; uint256 public minimumContribution; uint256 public goal; bool public isFinalized = false; RefundEscrow private escrow; USDPrice private usdPrice; event Finalized(); constructor( uint256 _rate, address _wallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _goal, uint256 _cap, uint256 _minimumContribution, USDPrice _usdPrice ) Crowdsale(_rate, _wallet, _token) MilestoneCrowdsale(_openingTime, _closingTime) public { require(_cap > 0); require(_minimumContribution > 0); require(_goal > 0); cap = _cap; minimumContribution = _minimumContribution; escrow = new RefundEscrow(wallet); goal = _goal; usdPrice = _usdPrice; }",1
0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9.sol,dividendsContract,contract dividendsContract is Owned{ Ethernational dc; mapping(address => uint) paid; uint public totalSupply; uint public totalPaid; address public ICOaddress; function ICOaddress(address _t) onlyOwner{ dc = Ethernational(_t); ICOaddress = _t; totalSupply = dc.totalSupply() / 1000000000000; },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,AdvisorsTokensHolder,"contract AdvisorsTokensHolder is Ownable { using SafeMath for uint256; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0xeae2e3259d6d56451f4b3bc957ffbfcfaaebcac4.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x1f028c50321638652af073f0c6d605df2ffb668d.sol,Alpacacoin,"contract Alpacacoin is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function Alpacacoin(uint _initialSupply, string _name, string _symbol, uint _decimals) public { _totalSupply = _initialSupply; name = _name; symbol = _symbol; decimals = _decimals; balances[owner] = _initialSupply; deprecated = false; }",1
0xf0b8a682f2bf7afcc2b2c5e2089139c8e28786bf.sol,DealsSupport,"contract DealsSupport is IDealsSupport { using SafeMath for uint; address public adminAddress; address public merchantAddress; mapping(uint => Affiliate) public affiliates; uint public affiliatesCount; mapping(uint => Deal) public deals; uint public dealsCount; mapping(address => uint[]) public affiliateDealIndexes; mapping(address => uint) public affiliateDealIndexesCount; mapping(uint => mapping(address => uint)) public dealAffiliateReferenceHash; mapping(uint => mapping(address => uint)) public dealAffiliateReferenceHashCount; mapping(uint => uint) public referenceHashDealIndex; event ApproveAffiliate(bytes4 _dealId, address indexed _merchantAddress, uint indexed _dealIndex, address indexed _affiliateAddress, uint _referenceHash); event CreateDeal(bytes4 _dealId, uint _dealIndex, address indexed _merchantAddress, address indexed _rewardTokenAddress, uint _rewardRatePpm, uint _daysOfCancellation, uint _daysBeforeClose, uint _dealsCount); event ToggleBlockAffiliate(bytes4 _dealId, uint _referenceHash, bool _isBlocked); event DealCancelled(bytes4 _dealId, uint _days, address _who); event StakeFilled(bytes4 _dealId, uint _fill, uint _left); event RewardClaimed(bytes4 _dealId, uint _referenceHash, uint _rewardAmount); event DealUpdated(bytes4 _dealId, uint _newRewardRatePpm); event RewardCreated(bytes4 _dealId, uint _referenceHash, uint _purchasedTokenAmount, uint _rewardAmount); struct Affiliate { address affiliateAddress; bool isBlocked; uint rewardAmount; uint affiliateRewardsCount; mapping(uint => AffiliateReward) affiliateRewards; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,TimeSource,contract TimeSource { uint32 private mockNow; function currentTime() public constant returns (uint32) { if (block.timestamp > 0xFFFFFFFF) throw; return mockNow > 0 ? mockNow : uint32(block.timestamp); },1
0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5.sol,HeavenlyHoundCoin,"contract HeavenlyHoundCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x01fdb5103a0d9de8d12e32e7775d5799bd715a54.sol,TokenTemplate,"contract TokenTemplate is ERC20Interface, CrowdsaleInterface, Owned { using SafeMath for uint; bytes32 public symbol; uint public priceRate; uint public minimumInvest; bytes32 public name; uint8 public decimals; uint _totalSupply; uint amountRaised; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(bytes32 _name, bytes32 _symbol, uint _total, uint _weiCostOfEachToken, uint _weiMinimumInvest) public { symbol = _symbol; name = _name; decimals = 18; priceRate= _weiCostOfEachToken; minimumInvest= _weiMinimumInvest; _totalSupply = _total * 10**uint(decimals); _totalHolders = 0; balances[owner] = _totalSupply; holders[_totalHolders] = owner; whitelist[owner] = 2; maxInvestLimitList[owner] = 0; _totalHolders++; emit Transfer(address(0), owner, _totalSupply); }",1
0xf28a73603d577041228f543886f512d350c54d25.sol,Marketplace,"contract Marketplace is Ownable { using SafeMath for uint256; event ProductCreated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductUpdated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductDeleted(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductRedeployed(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds); event ProductOwnershipOffered(address indexed owner, bytes32 indexed id, address indexed to); event ProductOwnershipChanged(address indexed newOwner, bytes32 indexed id, address indexed oldOwner); event Subscribed(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event NewSubscription(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event SubscriptionExtended(bytes32 indexed productId, address indexed subscriber, uint endTimestamp); event SubscriptionTransferred(bytes32 indexed productId, address indexed from, address indexed to, uint secondsTransferred, uint datacoinTransferred); event ExchangeRatesUpdated(uint timestamp, uint dataInUsd); enum ProductState { NotDeployed, Deployed }",1
0x40b41a2d4c5fb2da3e08b0a1bbd361b5dd1f7bdd.sol,Ownable,"contract Ownable { address private _owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { _owner = msg.sender; }",1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,Owned,contract Owned { address public ceoAddress; address public cooAddress; address private newCeoAddress; address private newCooAddress; function Owned() public { ceoAddress = msg.sender; cooAddress = msg.sender; },1
0x702bcee7f521060eacde63e487a4c36ef7405f50.sol,PLAASCrowdsale,"contract PLAASCrowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PLAASCrowdsale() { wallet = 0xA8dd9A671d64DB4380AcA5af8976aE6F863fF169; addressOfTokenUsedAsReward = 0x8d9626315e8025b81c3bdb926db4c51dde237f52; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xf06274d668f923f472abdb67ac3dd38ac1f0bde4.sol,BOARDMYTRIP,"contract BOARDMYTRIP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 21000000000000000; balances[0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB] = _totalSupply; emit Transfer(address(0), 0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB, _totalSupply); }",1
0x55d5a9ab9a97509ba0db01b8d5040567b14d2304.sol,CappedCrowdsale,contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) { require(_cap > 0); cap = _cap; },1
0x6efca3bae1d10fca39a184175e03db5065d2fa60.sol,ShitCloneFarmer,contract ShitCloneFarmer { uint256 public TIME_TO_MAKE_1_SHITCLONE = 86400; uint256 public STARTING_SHITCLONE = 100; uint256 PSN = 10000; uint256 PSNH = 5000; bool public initialized = true; address public ShitCloneslordAddress; uint256 public ShitCloneslordReq = 500000; mapping (address => uint256) public ballShitClone; mapping (address => uint256) public claimedTime; mapping (address => uint256) public lastEvent; mapping (address => address) public referrals; uint256 public marketTime; function ShitCloneFarmer() public { ShitCloneslordAddress = msg.sender; },1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0x70cf39f6d5f1363416e270a6573936e8c772b670.sol,LootEther,contract LootEther { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x210c45d812295fe260788aff33db9b29258b0f09.sol,LU,"contract LU { using SafeMath for uint256; uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function LU(uint256 _totalSupply, string _symbol, string _name) public { decimals = 18; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x32cff49cd98e8af9dd2ba3ac370949fb06f6a412.sol,HTToken,"contract HTToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HTToken( ) TokenERC20() public {}",1
0x1ef1f77082df766c14d7c339ba17bef9a453c691.sol,TestCoin,"contract TestCoin is ERC20, Ownable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; }",1
0x3700eaf34f653553b724ff9d02bb45de9e733b37.sol,PiggyToken,contract PiggyToken is ERC20 { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 0; address public piggyBankAddress; constructor(address _piggyBankAddress) public { piggyBankAddress = _piggyBankAddress; },1
0x70cf39f6d5f1363416e270a6573936e8c772b670.sol,LootEther,contract LootEther { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,MilestoneCrowdsale,contract MilestoneCrowdsale is TimedCrowdsale { using SafeMath for uint256; uint256 public constant MAX_MILESTONE = 10; struct Milestone { uint256 index; uint256 startTime; uint256 tokensSold; uint256 cap; uint256 rate; },1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBettingFactory,contract MatchBettingFactory is Ownable { address[] deployedMatches; address public jackpotAddress; function MatchBettingFactory(address _jackpotAddress) public{ jackpotAddress = _jackpotAddress; },1
0xbd11eae443ef0e96c1cc565db5c0b51f6c829c0b.sol,AENToken,"contract AENToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 350000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2c110867ca90e43d372c1c2e92990b00ea32818b.sol,FiatDex_protocol_v1,contract FiatDex_protocol_v1 { address public owner; uint256 public feeDelay = 7; uint256 public dailyFeeIncrease = 1000; uint256 public version = 1; constructor() public { owner = msg.sender; },1
0x6f527e968bab723128ca2a20ccf70da757a3bcf8.sol,E25,contract E25 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsPreSale,contract EthernautsPreSale is EthernautsLogic { function EthernautsPreSale() public EthernautsLogic() {},1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0xdd261b2ebebf495e8f7a5f107aa6f76bb1996a9b.sol,VRToken,"contract VRToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 25 * (10 ** 8) * (10 ** uint256(decimals)); function VRToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,StoreGoods,contract StoreGoods is BasicAuth { using ItemList for ItemList.Data; struct Goods { uint32 m_Index; uint32 m_CostItem; uint32 m_ItemRef; uint32 m_Amount; uint32 m_Duration; uint32 m_Expire; uint8 m_PurchaseLimit; uint8 m_DiscountLimit; uint8 m_DiscountRate; uint m_CostNum; },1
0xb4910fe410240d2b79c557250adc767a9bc930c1.sol,Bidding,contract Bidding is Pausable { struct Auction { uint256 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; },1
0x1ba20a713f82b2483aa393de0c5da67d146f4bd7.sol,EMJAC,"contract EMJAC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EMJAC() public { symbol = ; name = ; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); }",1
0xeffa01394c5dae0fa718fc3489a28c24ec6ba064.sol,AudigentSegment,contract AudigentSegment is Ownable { mapping (uint256 => address[]) private _hashToSignatures; mapping (address => address) private _signerToAgency; modifier onlyAlreadyExistingSigner(address _signer) { require(_signerToAgency[_signer] == msg.sender); _; },1
0xdb27fd0813568f9e911ebdf645716ef02a07eb20.sol,GRCToken,"contract GRCToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant TOKEN_UNIT = 10 ** uint256(decimals); uint256 private constant INITIAL_SUPPLY = (10 ** 9) * TOKEN_UNIT; uint256 private constant PRIVATE_SALE_SUPPLY = INITIAL_SUPPLY * 35 / 100; uint256 private constant COMMUNITY_REWARDS_SUPPLY = INITIAL_SUPPLY * 20 / 100; uint256 private constant COMMERCIAL_PLAN_SUPPLY = INITIAL_SUPPLY * 20 / 100; uint256 private constant FOUNDATION_SUPPLY = INITIAL_SUPPLY * 15 / 100; uint256 private constant TEAM_SUPPLY = INITIAL_SUPPLY * 10 / 100; struct VestingGrant { address beneficiary; uint256 start; uint256 duration; uint256 amount; uint256 transfered; uint8 releaseCount; }",1
0x00ec053f75a8189ef0763c88e483be4da40522ef.sol,UBOToken,"contract UBOToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals =0; uint256 public constant INITIAL_SUPPLY = 1 * 50000000 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function UBOToken() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x190e2028060fa49adefa5e1f47c8d7be0cbe5063.sol,TRONIXGOLD,"contract TRONIXGOLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TRONIXGOLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x95a96a9fab04Fdf71f37807246408973b30d29e1] = _totalSupply; Transfer(address(0), 0x95a96a9fab04Fdf71f37807246408973b30d29e1, _totalSupply); }",1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xddce0e2b03724ca8edf733e09b3d5a7ccc913c48.sol,BitcoinX,"contract BitcoinX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 100000000000e18; uint256 public tokenPerETH = 10000000e18; uint256 public valueToGive = 4000e18; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0eb38c7dce0784396a17b9ee1f351563ed33c0ba.sol,COLLATERAL,contract COLLATERAL { function decimals() pure returns (uint) {},1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x01e6a8af629cc06ff37755a61d9e7dd1135d8c6a.sol,Wrapped_Ether,"contract Wrapped_Ether { using SafeMath for uint256; string public name = ; uint public total_supply; mapping(address => uint) internal balances; mapping(address => mapping (address => uint)) internal allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event StateChanged(bool _success, string _message); function createToken() public payable { require(msg.value > 0); balances[msg.sender] = balances[msg.sender].add(msg.value); total_supply = total_supply.add(msg.value); }",1
0xd421bb79fddfd4333a03e00d8a4b5f4eba07f1f8.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0xa206d217c0642735e82a6b11547bf00659623163.sol,Staking,"contract Staking { using SafeMath for *; event Transfer ( address indexed from, address indexed to, uint256 tokens ); event onDeposit ( address indexed customer, uint256 tokens ); event onReinvestProfit ( address indexed customer, uint256 tokens ); event onWithdrawProfit ( address indexed customer, uint256 tokens ); event onWithdrawCapital ( address indexed customer, uint256 tokens ); modifier onlyTokenContract { require(msg.sender == address(tokenContract_)); _; }",1
0x17e4cc902015958839e693f179f49c75696381ce.sol,DimonCoin,contract DimonCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0xead527531f9e31c989c6be6e9cf4abfc7531c999.sol,Bourneereum,"contract Bourneereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bourneereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0xf213d198b68b10654c63a9ed05a045e1d4a50f9f.sol,FootballerAction,"contract FootballerAction is FootballerOwnership { function createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) public returns(uint) { return _createFootballerStar(_price,_defend,_attack,_quality); }",1
0x923641c6b80d8fc913ff883a5c523f47081bad92.sol,Badge,contract Badge { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; address public owner; bool public locked; string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; modifier ifOwner() { if (msg.sender != owner) { throw; },1
0x516ab1f849d7e7649a246a55072905bfc5f34d7c.sol,Ownable,"contract Ownable { address public owner_; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner_ = msg.sender; }",1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0x6e62831311a9b48694636004b06232b9b09d81dd.sol,JokerToken,"contract JokerToken is StandardToken, Ownable { string public name; string public symbol; uint8 public decimals; EthRateOracle public oracle; uint256 public soldTokensCount = 0; uint256 public tokenStartPrice; uint256 public tokenSecondPeriodPrice; uint256 public sPerDate; uint256 public sPeriodEndDate; uint256 public sPeriodSoldTokensLimit; uint256 public nfsPoolLeft; uint256 public nfsPoolCount; uint256 public transfersAllowDate; constructor() public { name = ; symbol = ; decimals = 18; tokenStartPrice = 40; nfsPoolCount = 10900000 * (uint256(10) ** decimals); nfsPoolLeft = nfsPoolCount; tokenSecondPeriodPrice = 200; sPerDate = now + 179 days; sPeriodEndDate = now + 284 days; sPeriodSoldTokensLimit = (totalSupply_ - nfsPoolCount) - 1200000 * (uint256(10) ** decimals); transfersAllowDate = now + 284 days; totalSupply_ = 20000000 * (uint256(10) ** decimals); }",1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,Crowdsale,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ProfitDelivered(address fetcher, uint profit); event ProfitLoaded(address owner, uint profit); string public name; string public symbol; uint8 public decimals; uint loadedProfit; bool ditributingProfit; uint profitDistributed; uint loadedProfitAvailable; mapping (address => bool) public hasFetchedProfit; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0x723c7bca7ed11ab6a18b84c1ff5b979fec00f54e.sol,PlayCoinKey,"contract PlayCoinKey is modularKey { using SafeMath for *; using NameFilter for string; using PCKKeysCalcLong for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x14229878e85e57FF4109dc27bb2EfB5EA8067E6E); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 2 minutes; uint256 private rndGap_ = 15 minutes; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private rndMin_ = 10 minutes; uint256 public reduceMul_ = 3; uint256 public reduceDiv_ = 2; uint256 public rndReduceThreshold_ = 10e18; bool public closed_ = false; address private admin = msg.sender; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) private blacklist_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => PCKdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => PCKdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => PCKdatasets.TeamFee) public fees_; mapping (uint256 => PCKdatasets.PotSplit) public potSplit_; constructor() public { blacklist_[0xB04B473418b6f09e5A1f809Ae2d01f14211e03fF] = 1; fees_[0] = PCKdatasets.TeamFee(30,6); fees_[1] = PCKdatasets.TeamFee(43,0); fees_[2] = PCKdatasets.TeamFee(56,10); fees_[3] = PCKdatasets.TeamFee(43,8); potSplit_[0] = PCKdatasets.PotSplit(15,10); potSplit_[1] = PCKdatasets.PotSplit(25,0); potSplit_[2] = PCKdatasets.PotSplit(20,20); potSplit_[3] = PCKdatasets.PotSplit(30,10); }",1
0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1.sol,Owned,contract Owned { address public owner; address public newOwner; address public oracle; address public btcOracle; function Owned() payable { owner = msg.sender; },1
0xe07c44a35650e445289cd9fdaaf7fb6a9d734471.sol,AElfToken,"contract AElfToken is ERC20, Ownable { using SafeMath for uint256; address public aelfDevMultisig = 0x64ABa00510FEc9a0FE4B236648879f35030B7D9b; address public aelfCommunityMultisig = 0x13828Fa672c52226071F27ea1869463bDEf2ecCB; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xe35a91f2acceccf1ce6bae792274da6100b639af.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping(address => uint256) internal balances_; mapping(address => mapping(address => uint256)) internal allowed_; uint256 internal totalSupply_; string public name; string public symbol; uint8 public decimals; function totalSupply() public view returns (uint256) { return totalSupply_; }",1
0x418e831d865dcb26af9721b277d2dce58526c6b9.sol,DigimaWebToken,"contract DigimaWebToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x4bffc9b4d4dcf730820a2edcad48ff5d7e0ae807.sol,INC,"contract INC is Token, Owned { using SafeMath for uint256; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; struct Supplies { uint128 total; }",1
0xbe7750c8aac1c99f7ee2c19a9654a479601d549f.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x290d7f8b8d7da1e92903405a74667c934ca8f086.sol,Wallet,"contract Wallet { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0xc7b559416533ac7a685d7c1899862a6a9a086503.sol,SafeMath,"contract SafeMath { uint256 constant private MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd (uint256 x, uint256 y) constant internal returns (uint256 z) { assert (x <= MAX_UINT256 - y); return x + y; }",1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6cf9af470571026bafc48d5dd23b0521e9595394.sol,fortunes,contract fortunes { string public standard = ; string public name; string public symbol; uint8 public decimals; address owner; uint public max_fortunes; uint public unopened_bid; bytes32[] public ur_luck; struct fortune { address original_owner; address original_minter; address current_owner; uint32 number; uint8 level; bytes32[144] img; bytes32 str_luck; bytes32 str_name; bool has_img; bool opened; bool forsale; uint current_bid; address current_bidder; uint bid_cnt; uint auction_end; },1
0x308cd1ebece7d99a360698ef47dd30269c7e2623.sol,AceWins,"contract AceWins is Ownable { uint256 public totalSupply; mapping(address => uint256) startBalances; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) startBlocks; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 10; uint256 public calc = 951839; function AceWins() public { totalSupply = 12500000 * 10**uint256(decimals); startBalances[owner] = totalSupply; startBlocks[owner] = block.number; Transfer(address(0), owner, totalSupply); }",1
0xedb94888eff041eb50c9fc92c360f66afb3b94c5.sol,ExoplanetToken,"contract ExoplanetToken is ERC721 { using SafeMath for uint256; event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner); event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); event ContractUpgrade(address newContract); string public constant NAME = ; string public constant SYMBOL = ; string public constant BASE_URL = ""https: uint32 private constant NUM_EXOPLANETS_LIMIT = 4700; uint256 private constant STEP_1 = 5.0 ether; uint256 private constant STEP_2 = 10.0 ether; uint256 private constant STEP_3 = 26.0 ether; uint256 private constant STEP_4 = 36.0 ether; uint256 private constant STEP_5 = 47.0 ether; uint256 private constant STEP_6 = 59.0 ether; uint256 private constant STEP_7 = 67.85 ether; uint256 private constant STEP_8 = 76.67 ether; mapping (uint256 => address) public currentOwner; mapping (address => uint256) private numOwnedTokens; mapping (uint256 => address) public approvedToTransfer; mapping (uint256 => uint256) private currentPrice; address public ceoAddress; address public cooAddress; bool public inPresaleMode = true; bool public paused = false; address public newContractAddress; struct ExoplanetRec { uint8 lifeRate; uint32 priceInExoTokens; uint32 numOfTokensBonusOnPurchase; string name; string cryptoMatch; string techBonus1; string techBonus2; string techBonus3; string scientificData; }",1
0x0e69a56bd2bb5a4a0cb44d3b96911f7cff01e29a.sol,MaxRoyalCoin,"contract MaxRoyalCoin is ERC20Interface,Ownable { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public _totalSupply; mapping(address => uint256) tokenBalances; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; function MaxRoyalCoin(address wallet) public { owner = msg.sender; ownerWallet = wallet; name = ; symbol = ; decimals = 18; _totalSupply = 60000000 * 10 ** uint(decimals); tokenBalances[wallet] = _totalSupply; }",1
0xee3e4e2467c0c5aa7b7d944881d51ccb36fefcca.sol,StandardToken,"contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x4d49849dcc51ea1675140cb007d9f6897ae53260.sol,MintableTokenExt,"contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; }",1
0x5a82de3515fc4a4db9ba9e869f269a1e85300092.sol,SafeMath,"contract SafeMath { function safeMul(uint a, uint b) internal returns(uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x91edec8c1f44d34244b5e7e2631dd7c5cee1b19c.sol,YELLQASH,"contract YELLQASH is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 15e9 * 1e8; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function YELLQASH() public { balanceOf[msg.sender] = totalSupply; }",1
0xbe8eb4c36a6f6ccb9bdb8533be70dc5988011466.sol,MintableTokenExt,"contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; }",1
0x72dc30371f77dd6efb22e27843594a14bde0337b.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xee8d31fb0c278de147e621c6cee5905c1a5d4323.sol,YBCLiveToken,"contract YBCLiveToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YBCLiveToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5cbb53ca85a9e52b593baf8ae90282c4b3db0b25.sol,ExchangeRates,contract ExchangeRates is SelfDestructible { using SafeMath for uint; using SafeDecimalMath for uint; mapping(bytes4 => uint) public rates; mapping(bytes4 => uint) public lastRateUpdateTimes; address public oracle; uint constant ORACLE_FUTURE_LIMIT = 10 minutes; uint public rateStalePeriod = 3 hours; bytes4[5] public xdrParticipants; struct InversePricing { uint entryPoint; uint upperLimit; uint lowerLimit; bool frozen; },1
0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x72fa6623cc0800bc180639d60c33c95426d76576.sol,KassaNetwork,"contract KassaNetwork is Ownable { using SafeMath for uint; string public constant name = ; uint public startTimestamp = now; uint public constant procKoef = 10000; uint public constant perDay = 75; uint public constant ownerFee = 700; uint[3] public bonusReferrer = [500, 200, 100]; uint public constant procReturn = 9000; uint public constant maxDepositDays = 200; uint public constant minimalDeposit = 0.5 ether; uint public constant maximalDepositStart = 30 ether; uint public constant maximalDepositFinish = 100 ether; uint public constant minimalDepositForBonusReferrer = 0.015 ether; uint public constant dayLimitStart = 50 ether; uint public constant progressProcKoef = 100; uint public constant dayLimitProgressProc = 2; uint public constant maxDepositProgressProc = 1; uint public countInvestors = 0; uint public totalInvest = 0; uint public totalPenalty = 0; uint public totalSelfInvest = 0; uint public totalPaid = 0; uint public unlimitedInvest = 3000 ether; bool public isUnlimitedContractInvest = false; bool public isUnlimitedDayInvest = false; event LogInvestment(address _addr, uint _value, bytes _refData); event LogTransfer(address _addr, uint _amount, uint _contactBalance); event LogSelfInvestment(uint _value); event LogPreparePayment(address _addr, uint _totalInteres, uint _paidInteres, uint _amount); event LogSkipPreparePayment(address _addr, uint _totalInteres, uint _paidInteres); event LogPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals, uint _amount); event LogSkipPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals); event LogNewReferralAtLevel(address _addr, uint[3] _levels); event LogMinimalDepositPayment(address _addr, uint _money, uint _totalPenalty); event LogPenaltyPayment(address _addr, uint currentSenderDeposit, uint referrerAdressLength, address _referrer, uint currentReferrerDeposit, uint _money, uint _sendBackAmount, uint _totalPenalty); event LogExceededRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _badDeposit, uint _sendBackAmount, uint _totalPenalty, uint _willDeposit); event LogUsedRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _realDeposit, uint _usedDepositPerDay); event LogCalcBonusReferrer(address _referrer, uint _money, uint _index, uint _bonusReferrer, uint _amountReferrer, address _nextReferrer); struct User { uint balance; uint paidInteres; uint timestamp; uint countReferrals; uint[3] countReferralsByLevel; uint earnOnReferrals; uint paidReferrals; address referrer; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0x0ddc6021443855fbfe26fcdee4b36154f6b53817.sol,EthMonoPoly,"contract EthMonoPoly { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; address vault; mapping(address => bool) preauthorized; bool gameStarted; uint constant depositTaxDivisor = 4; uint constant withdrawalTaxDivisor = 4; uint constant vaultBenefitDivisor = 50; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function EthMonoPoly(address _vault) public { owner = msg.sender; vault = _vault; preauthorized[owner] = true; }",1
0x1bdcd5deef806097254e79c7a7bb13dda9ed9808.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint; address multisig; uint restrictedPercent; address restricted; VestopiaToken public token = new VestopiaToken(); uint start; uint period; uint hardcap; uint rate; uint minPrice; function Crowdsale() public { minPrice = 100000000000000000; multisig =0x78e904695cc97248bB18eCfd83d4dd20D73fd619 ; restricted = 0x78e904695cc97248bB18eCfd83d4dd20D73fd619; restrictedPercent = 35; rate = 5000 * (10 ** 18); start = 1516838400; period = 60; hardcap = 7257000000000000000000; },1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,Zethr,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x515ced0695fdcb330ff7ef72e1844e48d496f2c2.sol,AssetHashToken,"contract AssetHashToken is ownable, verifiable{ using SafeMath for uint; struct data { string link; string hashType; string hashValue; }",1
0x582e09ee0a6ae313f9e8e4e84491808dec0e7eda.sol,BUYEXSHOP,contract BUYEXSHOP is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function BUYEXSHOP() { balances[msg.sender] = 20000000000000000000000000000; totalSupply = 20000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 20000000; fundsWallet = msg.sender; },1
0x8c15ef5b4b21951d50e53e4fbda8298ffad25057.sol,FunctionXToken,"contract FunctionXToken is MintableToken, BurnableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function FunctionXToken() { }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborToken,"contract HarborToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => bool) public mintAgents; event Mint(address indexed to, uint256 amount); event MintOpened(); event MintFinished(); event MintingAgentChanged(address addr, bool state ); event BurnToken(address addr,uint256 amount); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xa181b8c9f6b43b8252c6c9826cf5feba362b542e.sol,CryptoStamps,"contract CryptoStamps is ERC721 { event stampBirth(uint256 tokenId, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private firstStepLimit = 1.28 ether; mapping (uint256 => address) public stampIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public stampIndexToApproved; mapping (uint256 => uint256) private stampIndexToPrice; mapping(uint256 => uint256) public stampIndextotransactions; uint256 public totaletherstransacted; uint256 public totaltransactions; uint256 public stampCreatedCount; mapping (uint256 => bool) public stampIndextodissolved; mapping (uint256 => address) public dissolvedIndexToApproved; struct Stamp { uint256 birthtime; }",1
0x5ca71ea65acb6293e71e62c41b720698b0aa611c.sol,BBDToken,"contract BBDToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string private constant version = ; uint256 public constant startTime = 1506844800; uint256 public constant endTime = 1509523200; uint256 public constant creationMaxCap = 300000000 * 10 ** decimals; uint256 public constant creationMinCap = 2500000 * 10 ** decimals; uint256 private constant startCreationRateOnTime = 1666; uint256 private constant endCreationRateOnTime = 1000; uint256 private constant quantityThreshold_10 = 10 ether; uint256 private constant quantityThreshold_30 = 30 ether; uint256 private constant quantityThreshold_100 = 100 ether; uint256 private constant quantityThreshold_300 = 300 ether; uint256 private constant quantityBonus_10 = 500; uint256 private constant quantityBonus_30 = 1000; uint256 private constant quantityBonus_100 = 1500; uint256 private constant quantityBonus_300 = 2000; bool public finalized = false; address public migrationAgent; uint256 public totalMigrated; address public exchangeAddress; address private constant mainAccount = 0xEB1D40f6DA0E77E2cA046325F6F2a76081B4c7f4; address private constant coreTeamMemberOne = 0xe43088E823eA7422D77E32a195267aE9779A8B07; address private constant coreTeamMemberTwo = 0xad00884d1E7D0354d16fa8Ab083208c2cC3Ed515; uint256 private raised = 0; mapping (address => uint256) private ethBalances; uint256 private constant divisor = 10000; event LogRefund(address indexed _from, uint256 _value); event LogMigrate(address indexed _from, address indexed _to, uint256 _value); event LogBuy(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount); modifier onlyWhenICOReachedCreationMinCap() { require( totalSupply >= creationMinCap ); _; }",1
0x430e87a95a421437ccaa0af644ac57e22914b07a.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0x46248a82ee39795c239049ed8eed78d305d4205c.sol,Exchange,contract Exchange { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xcef079e04caa9416367c29f9f7064e3557688c88.sol,GlobalTourToken,"contract GlobalTourToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 1000000000e8; uint256 public value; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xdee2d457649d0a222097cd55c7801a50d52a7f32.sol,StandardToken,"contract StandardToken is ERC20, BasicToken, Ownable { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x523630976eb6147621b5c31c781ebe2ec2a806e0.sol,SafeDecimalMath,"contract SafeDecimalMath { uint8 public constant decimals = 18; uint public constant UNIT = 10 ** uint(decimals); function addIsSafe(uint x, uint y) pure internal returns (bool) { return x + y >= y; }",1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0xd35596bb7adf861b8a19cafc2004a8185e3c6a60.sol,ICO,contract ICO is Ownable { using SafeMath for uint256; Titanization public TXDM; UsdPrice public constant FIAT = UsdPrice(0x8055d0504666e2B6942BeB8D6014c964658Ca591); address public constant RESERVE_ADDRESS = 0xF21DAa0CeC36C0d8dC64B5351119888c5a7CFc4d; uint256 private minTokenPurchase; uint256 private tokensSold; uint256 private hardCap; uint256 private softCap; bool private IcoTerminated; uint256 private tokenPrice; constructor() public { TXDM = new Titanization(); minTokenPurchase = 50; hardCap = 65000000; softCap = 10000000; IcoTerminated = false; tokenPrice = 500; },1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0xed6c511ed66b172c4d28eac2c3dacc62972b1b7f.sol,Lockable,"contract Lockable is Administrable { using SafeMath for uint256; event Locked(address _granted, uint256 _amount, uint256 _expiresAt); event UnlockedAll(address _granted); struct Lock { uint256 amount; uint256 expiresAt; }",1
0x36218af5c92c04d310803ce4309285fd984856ef.sol,FOCToken,"contract FOCToken is ParameterizedToken { function FOCToken() public ParameterizedToken(, , 18, 21000000000) { }",1
0x02c86846887faa1d964a838dc50739b49c8329bc.sol,Recover,"contract Recover is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; enum Status {NoDispute, WaitingFinder, WaitingOwner, DisputeCreated, Resolved}",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CompanyReserve,"contract CompanyReserve is Ownable{ SignalsToken token; uint256 withdrawn; uint start; function CompanyReserve(address _token, address _owner) public { token = SignalsToken(_token); owner = _owner; start = now; }",1
0x0142c3b2fc51819b5af5dfc4aa52df9722790851.sol,Ownable,"contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; }",1
0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f.sol,HEART,"contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf099081cd4ecd0cdc4b1619fd32d336eaaeaaab8.sol,TITANToken,contract TITANToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 1000000000000000000; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; function TITANToken(){ balances[msg.sender] = totalSupply; },1
0x56cd53067e5acd557dbbfb4c66580dfb9722962a.sol,CryptoMoviesToken,"contract CryptoMoviesToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; uint256 private firstStepLimit = 1.2 ether; uint256 private secondStepLimit = 5 ether; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0xf53c580bc4065405bc649cc077ff4f2f28528f4b.sol,Bittwatt,"contract Bittwatt is Token,Claimable, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public _tokenAllocator; function Bittwatt() public Token() { pause(); }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x00c4b398500645eb5da00a1a379a88b11683ba01.sol,Finalizable,contract Finalizable is Owned { bool public finalized; event Finalized(); function Finalizable() public Owned() { finalized = false; },1
0x6ba29728e955ff970c94d7ab0a4ff17c628f325a.sol,CasinoBank,"contract CasinoBank is chargingGas { uint public playerBalance; mapping(address => uint) public balanceOf; mapping(address => uint) public withdrawAfter; mapping(address => uint) public withdrawCount; uint public maxDeposit; uint public maxWithdrawal; uint public waitingTime; address public predecessor; event Deposit(address _player, uint _numTokens, uint _gasCost); event Withdrawal(address _player, address _receiver, uint _numTokens, uint _gasCost); function CasinoBank(uint depositLimit, address predecessorAddr) internal { maxDeposit = depositLimit * oneEDG; maxWithdrawal = maxDeposit; waitingTime = 24 hours; predecessor = predecessorAddr; }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0xe0b38482164468a11558606e98d9985e57814cd9.sol,Owned,"contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; }",1
0x73de68d64b5d9b2108fdf76a394f76e16a88ceb3.sol,KingToken,"contract KingToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 4000000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c1547be2c6f77c514840041b5a53d32f69e2c64.sol,Escrow,"contract Escrow { event Deposit(uint tokens); address dai_0x_address = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; mapping ( address => uint256 ) public balances; function deposit(uint tokens) public returns (bool success){ balances[msg.sender]+= tokens; ERC20(dai_0x_address).transferFrom(msg.sender, address(this), tokens); emit Deposit(tokens); return true; }",1
0x27cdf814dc1c2376f0c3d058f287692a1d29c349.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; constructor(uint256 totalSupply) public { totalSupply_ = totalSupply; balances[msg.sender] = totalSupply_; },1
0x1d6c596bb5022a4338b6b8651f3acd4d836ef574.sol,Custody,"contract Custody { using SafeMath for uint; BBODServiceRegistry public bbodServiceRegistry; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor(address _serviceRegistryAddress, address _owner) public { bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress); owner = _owner; }",1
0x0f00f1696218eaefa2d2330df3d6d1f94813b38f.sol,SedoPoWToken,"contract SedoPoWToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function SedoPoWToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 50000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 1000000 * 10**uint(decimals); miningReward = 25; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 2**220; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0x9D2Cc383E677292ed87f63586086CfF62a009010; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0xb47841728f10f39abad9d799e8f6ba05e30c1b9d.sol,EthPyramid,contract EthPyramid { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; function EthPyramid() public {},1
0x0e8160745966d2109c568230ef515b0dddea1599.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public endFirstBonus; uint public endSecondBonus; uint public endThirdBonus; uint public hardCap; uint public price; uint public minPurchase; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, address addressOfTokenUsedAsReward, uint tokensPerEth, uint _minPurchase, uint fundingGoalInWei, uint hardCapInWei, uint startTimeInSeconds, uint durationInMinutes, uint _endFirstBonus, uint _endSecondBonus, uint _endThirdBonus ) public { beneficiary = ifSuccessfulSendTo; tokenReward = token(addressOfTokenUsedAsReward); price = tokensPerEth; minPurchase = _minPurchase; fundingGoal = fundingGoalInWei; hardCap = hardCapInWei; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; endFirstBonus = _endFirstBonus; endSecondBonus = _endSecondBonus; endThirdBonus = _endThirdBonus; }",1
0x51036b0029e95ecbce4784df0a87987d1092ec7d.sol,StandardToken,contract StandardToken is Token { modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; },1
0xa29b2c039a4dc6742f20873d21afbf3ddac95d1c.sol,WideEnergy,contract WideEnergy{ uint public constant _totalsupply = 75000000; string public constant symbol = ; string public constant name = ; uint8 public constant decimls = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function WideEnergy() { balances[msg.sender] = _totalsupply; },1
0x52a9700551128585f0d68b6d4d2fa322a2aeee47.sol,ERC721BasicToken,"contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { using SafeMath for uint256; using AddressUtils for address; bytes4 private constant ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; constructor() public { _registerInterface(InterfaceId_ERC721); }",1
0xdc3f9dafcf6af8b3a1273141116a9cb137248711.sol,KeyrptoToken,"contract KeyrptoToken is MintableToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant MILLION_TOKENS = 1e6 * 1e18; address public teamWallet; bool public teamTokensMinted = false; uint256 public circulationStartTime; event Burn(address indexed burnedFrom, uint256 value); function KeyrptoToken() public { paused = true; }",1
0x293438bc8656c99abb4fce8b08a5f40fb3b8c931.sol,Vineyard,contract Vineyard{ uint256 constant public GRAPE_SECS_TO_GROW_VINE = 86400; uint256 constant public STARTING_VINES = 300; uint256 constant public VINE_CAPACITY_PER_LAND = 1000; bool public initialized=false; address public ceoAddress; address public ceoWallet; mapping (address => uint256) public vineyardVines; mapping (address => uint256) public purchasedGrapes; mapping (address => uint256) public lastHarvest; mapping (address => address) public referrals; uint256 public marketGrapes; mapping (address => uint256) public landMultiplier; mapping (address => uint256) public totalVineCapacity; mapping (address => uint256) public wineInCellar; mapping (address => uint256) public wineProductionRate; uint256 public grapesToBuildWinery = 43200000000; uint256 public grapesToProduceBottle = 3456000000; address constant public LAND_ADDRESS = 0x2C1E693cCC537c8c98C73FaC0262CD7E18a3Ad60; LandInterface landContract; function Vineyard(address _wallet) public{ require(_wallet != address(0)); ceoAddress = msg.sender; ceoWallet = _wallet; landContract = LandInterface(LAND_ADDRESS); },1
0x55886834ca9bbca9f9e49ee188e878e094b7431c.sol,_0xAE86Token,"contract _0xAE86Token is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 100; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xAE86Token() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 86000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 860000 * 10**uint(decimals); rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); balances[owner] = tokensMinted; Transfer(address(0), owner, tokensMinted); }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0xd0aa48ed4c42411e61876abb434ff9371760fb62.sol,BigOne,"contract BigOneEvents { event onNewPlayer ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 indexed playerID, address indexed playerAddress, uint256 roundID, uint256 ethIn, uint256 pot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onEndRound ( uint256 roundID, uint256 roundTypeID, address winnerAddr, uint256 winnerNum, uint256 amountWon ); }",1
0x0d94c492c0ca038bf7b96ca03f1f35f1a9c3472b.sol,RegistroBlockchain,contract RegistroBlockchain { struct Registro { bool existe; uint block_number; },1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x552ed8253f341fb770e8badff5a0e0ee2fd57b43.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public masterWallet; address public slaveWallet; address public directMintAgent; uint public slaveWalletPercent = 30; uint public percentRate = 100; uint public minPrice; uint public totalTokensMinted; bool public slaveWalletInitialized; bool public slaveWalletPercentInitialized; VestarinToken public token; modifier onlyDirectMintAgentOrOwner() { require(directMintAgent == msg.sender || owner == msg.sender); _; },1
0xf393ad8f74ee2499b7648a8e02501c76d8625883.sol,CFT,"contract CFT is ERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; address private owner = msg.sender; event Burn(address burner, uint value); constructor() public { uint startAmount = 240000000 * 1e18; _mint(0x82B638831c2Da53aFA29750C544002d4f8a085be,startAmount); }",1
0x0692de52a966c107021e8a84db8486b4be57ecf1.sol,OQToken,contract OQToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function OQToken () { owner = msg.sender; },1
0x6c4de8424a6184c830234b996f7dba9720dc9306.sol,XKnockoutHamster,contract XKnockoutHamster { using SafeMath for uint256; struct EntityStruct { bool active; bool vip; uint listPointer; uint256 date; uint256 update; uint256 exit; uint256 profit; },1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0x9299ccef011d2d8faf76b214c8549c14bc918035.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x4bb0f20cf2e4cd470ed9537b1b69aa7a2c53707d.sol,_List_Glory_,contract _List_Glory_{ string public info_Name; string public info_Symbol; address public info_OwnerOfContract; string[] private listTINAmotley; uint256 private listTINAmotleyTotalSupply; mapping (uint => address) private listTINAmotleyIndexToAddress; mapping(address => uint256) private listTINAmotleyBalanceOf; struct forSaleInfo { bool isForSale; uint256 tokenIndex; address seller; uint256 minValue; address onlySellTo; },1
0x4b5bc97407898339eca79b541cee9b8b79ccda40.sol,IdaToken,"contract IdaToken is Ownable, RBAC, StandardToken { using AddressUtils for address; using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; uint256 public constant FOOTSTONE_ROUND_AMOUNT = 396000000; uint256 public constant PRIVATE_SALE_AMOUNT = 1200000000; uint256 public constant OWNER_LOCKED_IN_COMMON = 5000000000; uint256 public constant COMMON_PURPOSE_AMOUNT = 7204000000; uint256 public constant TEAM_RESERVED_AMOUNT1 = 120000000; uint256 public constant TEAM_RESERVED_AMOUNT2 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT3 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT4 = 360000000; uint256 public constant EXCHANGE_RATE_IN_PRIVATE_SALE = 10000; uint256 public constant TIMESTAMP_OF_20181001000001 = 1538352001; uint256 public constant TIMESTAMP_OF_20181002000001 = 1538438401; uint256 public constant TIMESTAMP_OF_20181101000001 = 1541030401; uint256 public constant TIMESTAMP_OF_20190201000001 = 1548979201; uint256 public constant TIMESTAMP_OF_20190501000001 = 1556668801; uint256 public constant TIMESTAMP_OF_20190801000001 = 1564617601; uint256 public constant TIMESTAMP_OF_20191101000001 = 1572566401; uint256 public constant TIMESTAMP_OF_20201101000001 = 1604188801; uint256 public constant TIMESTAMP_OF_20211101000001 = 1635724801; string public constant ROLE_PARTNERWHITELIST = ; string public constant ROLE_PRIVATESALEWHITELIST = ; uint256 public totalOwnerReleased; uint256 public totalPartnersReleased; uint256 public totalPrivateSalesReleased; uint256 public totalCommonReleased; uint256 public totalTeamReleased1; uint256 public totalTeamReleased2; uint256 public totalTeamReleased3; uint256 public totalTeamReleased4; address[] private partners; mapping (address => uint256) private partnersIndex; address[] private privateSaleAgents; mapping (address => uint256) private privateSaleAgentsIndex; mapping (address => uint256) private partnersAmountLimit; mapping (address => uint256) private partnersWithdrawed; mapping (address => uint256) private privateSalesReleased; address ownerWallet; event TransferLog(address from, address to, bytes32 functionName, uint256 value); constructor(address _ownerWallet) public { ownerWallet = _ownerWallet; totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol,CryptoRoses,"contract CryptoRoses { address constant DESTINATION_ADDRESS = 0x19Ed10db2960B9B21283FdFDe464e7bF3a87D05D; address owner; bytes32 name; enum Rose { Gold, White, Pink, Red }",1
0xf3c8ed6c721774c022c530e813a369dfe78a6e85.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x54c548703c6f423cf7ed22806b608d332fcebb3b.sol,StarbaseCrowdsaleContractW,"contract StarbaseCrowdsaleContractW is Ownable { using SafeMath for uint256; event TokenWithdrawn(address purchaser, uint256 tokenCount); event CrowdsalePurchaseBonusLog( uint256 purchaseIdx, uint256 rawAmount, uint256 bonus); AbstractStarbaseToken public starbaseToken; StarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; address[] public earlyPurchasers; mapping (address => uint256) public earlyPurchasedAmountBy; bool public earlyPurchasesLoaded = false; uint256 public totalAmountOfEarlyPurchases; uint public numOfDeliveredEarlyPurchases; uint256 public numOfLoadedEarlyPurchases; uint256 public totalAmountOfCrowdsalePurchases; uint256 public totalAmountOfCrowdsalePurchasesWithoutBonus; uint256 public startDate; uint256 public endedAt; mapping (address => uint256) public crowdsalePurchaseAmountBy; uint public numOfDeliveredCrowdsalePurchases; bool public crowdsalePurchasesLoaded = false; uint256 public numOfLoadedCrowdsalePurchases; uint256 public totalAmountOfPresalePurchasesWithoutBonus; mapping (address => bool) public tokenWithdrawn; mapping (address => uint256) public numOfPurchasedTokensOnCsBy; mapping (address => uint256) public numOfPurchasedTokensOnEpBy; modifier whenEnded() { assert(isEnded()); _; }",1
0x6cf8fcc9db80b7db3078afefa939524aa496266a.sol,NafeesToken,"contract NafeesToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NafeesToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 40000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoStorage,"contract DaoStorage is DaoWhitelistingCommon, BytesIteratorStorage { using DoublyLinkedList for DoublyLinkedList.Bytes; using DaoStructs for DaoStructs.Voting; using DaoStructs for DaoStructs.Proposal; using DaoStructs for DaoStructs.ProposalVersion; DoublyLinkedList.Bytes allProposals; mapping (bytes32 => DaoStructs.Proposal) proposalsById; mapping (bytes32 => DoublyLinkedList.Bytes) proposalsByState; constructor(address _resolver) public { require(init(CONTRACT_STORAGE_DAO, _resolver)); }",1
0x6dfd861fb01a99197fbeb01609c2c362f349b525.sol,LumenCoin,contract LumenCoin is Owned{ struct User{ string username; uint balance; },1
0x92eddd9a441ad85a97ddf52aadf853ba8026494e.sol,DecentralizedAdultToken,"contract DecentralizedAdultToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,Ownable,contract Ownable { address public owner; function Ownable() { owner = msg.sender; },1
0x57cff17810be242bc4760c03cd5bcc6ec0879470.sol,POWMlite,contract POWMlite { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x556e3cc5eaacfb87cc8ace3be0d3497abddee99c.sol,DooDooCoin,"contract DooDooCoin is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x742686bb1b136b396b59818f42e47a4fc3509394.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersPercent; uint public bountyTokensCount; uint public price; uint public percentRate = 100; bool public bountyMinted = false; CommonSale public nextSale; MintableToken public token; function setToken(address newToken) onlyOwner { token = MintableToken(newToken); },1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x890ee942fdce38034e3d3813344649c77a29e68f.sol,LemonSelfDrop1,contract LemonSelfDrop1 is Ownable { LemonToken public LemonContract; uint8 public dropNumber; uint256 public LemonsDroppedToTheWorld; uint256 public LemonsRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function LemonSelfDrop1 () { address c = 0x2089899d03607b2192afb2567874a3f287f2f1e4; LemonContract = LemonToken(c); dropNumber = 1; LemonsDroppedToTheWorld = 0; LemonsRemainingToDrop = 0; basicReward = 500; donatorRewardLevels = 1; totalDropTransactions = 0; },1
0x5ac25534c0d422fff109a76bc4bad07b67f7d5b1.sol,DCNYToken,"contract DCNYToken is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function DCNYToken() public { decimals = 6; _totalSupply = 10*10000*10000*(10 ** uint256(decimals)); name = ; symbol = ; balances[owner] = _totalSupply; deprecated = false; }",1
0x582b2489710a4189ad558b6958641789587fcc27.sol,PonziUnlimited,contract PonziUnlimited { modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x44a6bae1dba4d2b91ff7b0b54506fd0e1f9c44de.sol,TunTokenERC20,"contract TunTokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=1000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TunTokenERC20() public { balanceOf[msg.sender] = totalSupply; }",1
0xaa9b22f0e3e1e3dc88aa868571b4b0daa60f446b.sol,ECT,contract ECT { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x71325b9bdfc471323623e1183d789cf8df2f9716.sol,ERC20,"contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 public _decimals; constructor (string memory name, string memory symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; }",1
0x05aaaa829afa407d83315cded1d45eb16025910c.sol,SPXToken,"contract SPXToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public ico; bool public isFrozen = true; uint public constant TOKEN_LIMIT = 8888888888 * (1e18); address public migrationMaster; address public migrationAgent; uint public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint _value); function SPXToken(address _ico, address _migrationMaster) public { require(_ico != 0); ico = _ico; migrationMaster = _migrationMaster; }",1
0x7427cedbd696c9cc9420244f2ef633028f1ad238.sol,ERC777BaseToken,"contract ERC777BaseToken is ERC777Token, ERC820Implementer, Whitelist { using SafeMath for uint256; string internal mName; string internal mSymbol; uint256 internal mGranularity; uint256 internal mTotalSupply; mapping(address => uint) internal mBalances; address[] internal mDefaultOperators; mapping(address => bool) internal mIsDefaultOperator; mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator; mapping(address => mapping(address => bool)) internal mAuthorizedOperators; constructor(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) internal { mName = _name; mSymbol = _symbol; mTotalSupply = 0; require(_granularity >= 1, ); mGranularity = _granularity; mDefaultOperators = _defaultOperators; for (uint256 i = 0; i < mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }",1
0xd06d0e6694a2f12864941fc73d140346da143200.sol,FloodToken,"contract FloodToken { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; string public version = ; uint public init; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public {}",1
0xecbf1d636aefcb6025cae717d7103dd4a441fd99.sol,Tyrandetoken,"contract Tyrandetoken { address public admin_address = 0x2616218FEe33F36fcd2DC3366d3fc7DDd339D48e; address public account_address = 0x2616218FEe33F36fcd2DC3366d3fc7DDd339D48e; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 100000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownToken,"contract ExoTownToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public icoContract = 0x0; modifier onlyIcoContract() { require(msg.sender == icoContract); _; }",1
0x6e34ec8b63ce07cb8e78ce5bb5d4f122bbb3d2ee.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,SRNMagicBox,"contract SRNMagicBox is ServerControl, TokenReceiver { GirlOps girlOps; GenesFactory genesFactory; SRNG SRNGInstance; string public name; uint public keyRequired; address public keyAddress; address public prizePoolAddress; uint public boxPrice; uint[] public prizeIndex; uint[] public prizeRange; uint[] public NCards; uint[] public RCards; uint[] public SRCards; uint[] public SSRCards; event SendGirlFail(address _to, uint _type); constructor(string _name, address _girlAddress, address _SRNGAddress, address _genesFactoryAddress, address _prizePoolAddress, address _keyAddress, uint _keyRequired, uint _boxPrice) public { name = _name; girlOps = GirlOps(_girlAddress); SRNGInstance = SRNG(_SRNGAddress); genesFactory = GenesFactory(_genesFactoryAddress); prizePoolAddress = _prizePoolAddress; keyAddress = _keyAddress; keyRequired = _keyRequired; boxPrice = _boxPrice; }",1
0x3632c27273a5d928d0f09407380dc0d8164a8ac5.sol,TokenShares,"contract TokenShares is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5c0bd5d00588a4f004ce0d92958c96264026f7be.sol,EthPlot,contract EthPlot is Ownable { struct PlotOwnership { uint24 x; uint24 y; uint24 w; uint24 h; address owner; },1
0xf515c78ea440443021fd2abdccbf01afcaae3e65.sol,PreSignedContract,"contract PreSignedContract is Ownable { mapping (uint8 => bytes) internal _prefixPreSignedFirst; mapping (uint8 => bytes) internal _prefixPreSignedSecond; function upgradePrefixPreSignedFirst(uint8 _version, bytes _prefix) public onlyOwner { _prefixPreSignedFirst[_version] = _prefix; }",1
0x6d5eb8a12eb8cc38001c5fcbf877f70313c57251.sol,Owned,"contract Owned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); constructor() public { owner = msg.sender; }",1
0x719035ac096b12aad44578a2db8a352ad874892d.sol,VincoinCash,contract VincoinCash { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint public _totalSupply = 8600000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x6b3b198577e9a1e96ef681ee60e551845dd4ea79.sol,Detonator,contract Detonator is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x41451e8e7fd5b9a4f8176ccf1a0db2b68abc77fb.sol,FART,contract FART { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0xd25eccb97bfb908037de647d342dc055fc3785a2.sol,AccessControl,contract AccessControl { event ContractUpgrade(address newContract); event Paused(); event Unpaused(); address public ceoAddress; address public cfoAddress; address public cooAddress; address public withdrawalAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x707784ed2b464474f8fb763c058b33fcf8626db5.sol,Production,contract ProductionBoiler is BasicAuth { struct Boiler { uint m_Expire; uint32[] m_Chips; },1
0xc7a8bdeb5a2124805328bdbb2b93539cb49dc15c.sol,IBCLotteryGame,"contract IBCLotteryGame is IBCLotteryEvents, IBCLottery { using SafeMath for *; using IBCLotteryKeysCalcLong for uint256; uint256 private rndInit_ = 24 hours; uint256 private rndInc_ = 1 minutes; uint256 private rndMax_ = 24 hours; uint256 private maxUserId_ = 0; address private owner_; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => IBCLotteryDatasets.Player) public plyr_; mapping (uint256 => IBCLotteryDatasets.PlayerRounds) public plyrRnds_; IBCLotteryDatasets.Round round_; constructor( address _ibcoin, address _officialWallet, address _devATeamWallet, address _devBTeamWallet ) IBCLottery(_ibcoin, _officialWallet, _devATeamWallet, _devBTeamWallet) public { owner_ = msg.sender; }",1
0x01b90ee8249afdf628f738af4a2a8ffd7b8434ed.sol,DMC,"contract DMC { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x03b2dc629520693e69339baf84fd74cdcccb275c.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0x5a889cba88c2c7cc67652c2de4e46fc4b9aba9ce.sol,DSG_Turntable,contract DSG_Turntable{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint256 blockNumber; uint256 bet; },1
0x6fc2a052f82d0f8b5d774f8ef8b30fe933ce9953.sol,DMSCOIN,"contract DMSCOIN is Token { using SafeMath for uint256; uint256 public price = 3000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { tokenReward = token(address(this)); }",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0x369eb6821c94a78428f7c86c768590f53950068f.sol,ATFSToken,contract ATFSToken is ERC20 { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 8; address public crowdsaleMinter; modifier onlyCrowdsaleMinter(){ require(msg.sender == crowdsaleMinter); _; },1
0x1ca8ddc12e6618d007740c2bca92d2e69d84bec5.sol,OAICToken,"contract OAICToken is Ownable, BurnableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public version = ; uint256 public constant INITIAL_SUPPLY = 100 * 100000000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(this, msg.sender, INITIAL_SUPPLY); }",1
0x33259c14a28c89af457c9dbac9743f3efb651f09.sol,PODH,contract PODH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x127a78da95f02d9139db64ea7d3f6de355975494.sol,DACToken,contract DACToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 30000000000000000; bool public stopped = false; address owner = 0x1e113613C889C76b792AdfdcbBd155904F3310a5; modifier isOwner { assert(owner == msg.sender); _; },1
0xa25e8050f80ee99a17e861cd0931d5d362caa34e.sol,GameCards,contract GameCards { struct LeaseCard { uint id; address tenant; uint price; uint untilBlock; string title; string url; string image; },1
0xeb17f6b4b820e0b2ccf666694df78f01e18528e7.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint; address owner; token public tokenReward; uint start = 1523232000; uint period = 22; function Crowdsale ( address addressOfTokenUsedAsReward ) public { owner = msg.sender; tokenReward = token(addressOfTokenUsedAsReward); },1
0x723c7bca7ed11ab6a18b84c1ff5b979fec00f54e.sol,PlayCoinKey,"contract PlayCoinKey is modularKey { using SafeMath for *; using NameFilter for string; using PCKKeysCalcLong for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x14229878e85e57FF4109dc27bb2EfB5EA8067E6E); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 2 minutes; uint256 private rndGap_ = 15 minutes; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private rndMin_ = 10 minutes; uint256 public reduceMul_ = 3; uint256 public reduceDiv_ = 2; uint256 public rndReduceThreshold_ = 10e18; bool public closed_ = false; address private admin = msg.sender; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) private blacklist_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => PCKdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => PCKdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => PCKdatasets.TeamFee) public fees_; mapping (uint256 => PCKdatasets.PotSplit) public potSplit_; constructor() public { blacklist_[0xB04B473418b6f09e5A1f809Ae2d01f14211e03fF] = 1; fees_[0] = PCKdatasets.TeamFee(30,6); fees_[1] = PCKdatasets.TeamFee(43,0); fees_[2] = PCKdatasets.TeamFee(56,10); fees_[3] = PCKdatasets.TeamFee(43,8); potSplit_[0] = PCKdatasets.PotSplit(15,10); potSplit_[1] = PCKdatasets.PotSplit(25,0); potSplit_[2] = PCKdatasets.PotSplit(20,20); potSplit_[3] = PCKdatasets.PotSplit(30,10); }",1
0x2e061fdfbb2c63a43e4490465d3862094b38f394.sol,AxaToken,"contract AxaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 250000000000000000000000000; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWService,contract BWService { address private owner; address private bw; address private bwMarket; BWData private bwData; uint private seed = 42; uint private WITHDRAW_FEE = 20; modifier isOwner { if (msg.sender != owner) { revert(); },1
0x410cc76477d26b1582be9e8e829f25738b19fb62.sol,ProfitManager,contract ProfitManager { address public m_Owner; bool public m_Paused; AbstractDatabase m_Database= AbstractDatabase(0x400d188e1c21d592820df1f2f8cf33b3a13a377e); modifier NotWhilePaused() { require(m_Paused == false); _; },1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ca8ddc12e6618d007740c2bca92d2e69d84bec5.sol,OAICToken,"contract OAICToken is Ownable, BurnableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public version = ; uint256 public constant INITIAL_SUPPLY = 100 * 100000000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(this, msg.sender, INITIAL_SUPPLY); }",1
0x6dfdec940b83e424c1433d08b2e6096809d3698b.sol,AceReturns,"contract AceReturns { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) recentinvestment; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x27945afcdea13201263bfe8c71d2e8fdffd35ff7.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 public trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping (address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,Zethr,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6c6ee5e31d828de241282b9606c8e98ea48526e2.sol,HoloToken,"contract HoloToken is Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed to, uint256 amount); event MintingFinished(); event Burn(uint256 amount); uint256 public totalSupply; using SafeMath for uint256; mapping(address => uint256) public balances; function transfer(address _to, uint256 _value) public whenMintingFinished returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x58350795644f6a28bf36c54db1b88ee8a723ae84.sol,CryptoXchange,contract CryptoXchange { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x4d81198dc71ffd13917da27d1a3f8599ac690535.sol,DSG_Dice,contract DSG_Dice{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,IcoRocketFuel,"contract IcoRocketFuel is Ownable { using SafeMath for uint256; enum States {Ready, Active, Paused, Refunding, Closed}",1
0x373604ee6f3bce3b7126bb38f54ce6fd5ec59803.sol,Clip,"contract Clip is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 120e8 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping (address => uint) balances; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event MintFinished(); function Clip() public { totalSupply = initialSupply; balances[msg.sender] = totalSupply; }",1
0x5044ac8da9601edf970dcc91a10c5f41c5c548c0.sol,UPower,contract UPower { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x71c118b00759b0851785642541ceb0f4ceea0bd5.sol,ChibiFighters,"contract ChibiFighters is ERC721, ContractOwned, CustomEvents { using SafeMath for uint256; uint256 private totalTokens; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; GeneInterface geneContract; FcfInterface fcfContract; BattleInterface battleContract; address battleContractAddress; uint public priceChibi; uint priceFusionChibi; uint uniqueCounter; uint adultTime; uint exhaustionTime; uint comission; address battleRemoveContractAddress; struct Chibi { address owner; bool founder; string nameChibi; uint16[13] dna; uint256 father; uint256 mother; uint gen; uint256[] fusions; bool forFusion; uint256 fusionPrice; uint256 exhausted; uint256 adult; string infoUrl; }",1
0x6ce4642936028cf493c9bdd72e78130297cb77ea.sol,CollectableToken,"contract CollectableToken is PausableToken { mapping(address => uint256) nextNonce; event Collected(address indexed from, address indexed to, address indexed collector, uint256 value); function collectMessage(address _from, address _to, uint256 _value) public view returns (bytes32) { return keccak256(address(this), _from, _to, _value, nextNonce[_from]); }",1
0x1d2196207512665ad3beb7c3641f7db409dc7beb.sol,BitcoinBLUE,"contract BitcoinBLUE { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitcoinBLUE( ) public { totalSupply = 2100000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed943d75b2ff94d76f4eda892513255ef841261c.sol,KyberContirbutorWhitelist,contract KyberContirbutorWhitelist is Ownable { mapping(address=>uint) addressCap; function KyberContirbutorWhitelist() {},1
0x4c518f5dfdc03117b2ea388d1b4c4497954fd409.sol,TuurntWhitelist,contract TuurntWhitelist is Ownable{ mapping(address => bool) public whitelist; address public airdrop; function setAirdropAddress(address _airdrop) public onlyOwner{ airdrop = _airdrop; },1
0xd0f1a56f4bd5a9b992c91624b0d405a47cb251e6.sol,AirDrop,"contract AirDrop is OwnableWithAdmin { using SafeMath for uint256; uint256 private constant DECIMALFACTOR = 10**uint256(18); event FundsBooked(address backer, uint256 amount, bool isContribution); event LogTokenClaimed(address indexed _recipient, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed); event LogNewAllocation(address indexed _recipient, uint256 _totalAllocated); event LogRemoveAllocation(address indexed _recipient, uint256 _tokenAmountRemoved); event LogOwnerSetAllocation(address indexed _recipient, uint256 _totalAllocated); event LogTest(); uint256 public grandTotalClaimed = 0; ERC20 public token; uint256 public tokensTotal = 0; uint256 public hardCap = 0; mapping (address => uint256) public allocationsTotal; mapping (address => uint256) public totalClaimed; mapping(address => bool) public buyers; mapping(address => bool) public buyersReceived; address[] public addresses; constructor(ERC20 _token) public { require(_token != address(0)); token = _token; }",1
0x18a60cc53101d8aae343acc9357d347bc79c6549.sol,Trophy,"contract Trophy is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 { using strings for *; string internal name_; string internal symbol_; mapping(address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public allTokens; mapping(uint256 => uint256) public allTokensIndex; address public manager; uint256 public nextTokenId = 1; uint256 public nextTokenType = 1; string public tokenURIPrefix; mapping (uint256 => uint256) public tokenTypes; mapping (uint256 => address) public tokenTypeIssuers; mapping (uint256 => address) public tokenIssuer; mapping (uint256 => uint256[]) public tokensByType; event TokenTypeCreated( address _issuer, uint256 _type, uint256 _timestamp ); event TokenIssued( address _issuer, address _owner, uint256 _type, uint256 _tokenId, uint256 _timestamp ); event TokenRevoked( address _issuer, address _owner, uint256 _type, uint256 _tokenId, uint256 _timestamp ); event IssuanceTransferred( uint256 _type, address _oldIssuer, address _newIssuer, uint256 _timestamp ); event TransferAll( address _oldAddress, address _newAddress, uint256 _timestamp ); constructor(string _name, string _symbol, string _tokenURIPrefix) public { name_ = _name; symbol_ = _symbol; manager = msg.sender; tokenURIPrefix = _tokenURIPrefix; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x340d2bde5eb28c1eed91b2f790723e3b160613b7.sol,BlockvToken,"contract BlockvToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; PoolBLock public poolBLock; PoolCLock public poolCLock; PoolDLock public poolDLock; uint256 public constant totalAmountOfTokens = 3646271241200255205023407108; uint256 public constant amountOfTokensPoolA = 1276194934420089321758192488; uint256 public constant amountOfTokensPoolB = 911567810300063801255851777; uint256 public constant amountOfTokensPoolC = 911567810300063801255851777; uint256 public constant amountOfTokensPoolD = 546940686180038280753511066; address public migrationMaster; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); function BlockvToken(address _migrationMaster) Pausable(_migrationMaster) { require(_migrationMaster != 0); migrationMaster = _migrationMaster; totalSupply = totalAmountOfTokens; balances[msg.sender] = amountOfTokensPoolA; Transfer(0x0, msg.sender, amountOfTokensPoolA); poolBLock = new PoolBLock(this); poolCLock = new PoolCLock(this); poolDLock = new PoolDLock(this); balances[poolBLock] = amountOfTokensPoolB; balances[poolCLock] = amountOfTokensPoolC; balances[poolDLock] = amountOfTokensPoolD; Transfer(0x0, poolBLock, amountOfTokensPoolB); Transfer(0x0, poolCLock, amountOfTokensPoolC); Transfer(0x0, poolDLock, amountOfTokensPoolD); }",1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0x6f176ca12cc7e7a3b59e9a51eadf1b29fd98dae1.sol,Nines,"contract Nines { event NewOne(address owner, uint256 cost, uint256 new_price); struct Nine { address owner; uint256 cost; }",1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,MainChip,"contract MainChip is BasicAuth,MainBase { using IndexList for uint32[]; struct Chip { uint8 m_Level; uint8 m_LimitNum; uint8 m_Part; uint32 m_Index; uint256 m_UsedNum; }",1
0x559cd99b1eb1cd61224d9d2a9aec3f8634bfbef4.sol,Ownable,"contract Ownable { address public owner; uint256 public devFeePercent = 10; uint256 public SetPlayers = 1; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; }",1
0xeb6aaeff15f1faa7acecb0627364294fb085fbab.sol,FomoCube,contract FomoCube { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6db37629bb1da376e9a54d8ba3b30447043018d3.sol,GGCoin,"contract GGCoin is ERC20, Ownable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; }",1
0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff.sol,BTYCEC,contract BTYCEC is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sysusermoney; uint public sysoutmoney; uint public sellPrice; uint public buyPrice; uint public btycbuyPrice; uint public btycsellPrice; uint public sysPer; uint public sysPrice1; uint public sysPer1; uint public systime1; uint public sysPrice2; uint public sysPer2; uint public systime2; uint public transper; bool public actived; uint public onceAddTime; uint public upper1; uint public upper2; uint public teamper1; uint public teamper2; uint public outper1; uint public outper2; uint public sellper; uint public sysday; uint public sysminteth; uint public hasoutmony; uint public hasbuymoney; uint public hassellmoney; uint public hasbuyeth; uint public hasselleth; uint public hasbtycbuymoney; uint public hasbtycsellmoney; mapping(address => uint) balances; mapping(address => uint) myeth; mapping(address => uint) froeth; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => address) public fromaddr; mapping(address => uint) public crontime; mapping(address => uint) public mintnum; uint[] public permans; mapping(address => uint) public teamget; struct sunsdata{ uint n1; uint n2; uint getmoney; },1
0xeed3856ecbcb09b20cba1b3f5d448fed860483ba.sol,DappleAirdrops,"contract DappleAirdrops is Ownable { using SafeMath for uint256; mapping (address => uint256) public bonusDropsOf; mapping (address => uint256) public ethBalanceOf; mapping (address => bool) public tokenIsBanned; mapping (address => uint256) public trialDrops; uint256 public rate; uint256 public dropUnitPrice; uint256 public bonus; uint256 public maxDropsPerTx; uint256 public maxTrialDrops; string public constant website = ; event BonusCreditGranted(address indexed to, uint256 credit); event BonusCreditRevoked(address indexed from, uint256 credit); event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit); event AirdropInvoked(address indexed by, uint256 creditConsumed); event BonustChanged(uint256 from, uint256 to); event TokenBanned(address indexed tokenAddress); event TokenUnbanned(address indexed tokenAddress); event EthWithdrawn(address indexed by, uint256 totalWei); event RateChanged(uint256 from, uint256 to); event MaxDropsChanged(uint256 from, uint256 to); event RefundIssued(address indexed to, uint256 totalWei); event ERC20TokensWithdrawn(address token, address sentTo, uint256 value); function DappleAirdrops() public { rate = 10000; dropUnitPrice = 1e14; bonus = 20; maxDropsPerTx = 100; maxTrialDrops = 100; }",1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,Pausable,contract Pausable is PauserRole { event Paused(address account); event Unpaused(address account); bool private _paused; constructor() internal { _paused = false; },1
0xde5b6358808e783df374d1039f483e6ac02c9a28.sol,DecentralizedDinar,"contract DecentralizedDinar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c] = _totalSupply; emit Transfer(address(0), 0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c, _totalSupply); }",1
0xa5c9ecf54790334b73e5dfa1ff5668eb425dc474.sol,TokenNetwork,contract TokenNetwork is Utils { string constant public contract_version = ; Token public token; SecretRegistry public secret_registry; uint256 public chain_id; uint256 public settlement_timeout_min; uint256 public settlement_timeout_max; uint256 constant public MAX_SAFE_UINT256 = ( 115792089237316195423570985008687907853269984665640564039457584007913129639935 ); uint256 constant public channel_participant_deposit_limit = 75000000000000000 wei; uint256 constant public token_network_deposit_limit = 250000000000000000000 wei; uint256 public channel_counter; string public constant signature_prefix = ; address public deprecation_executor; bool public safety_deprecation_switch = false; mapping (uint256 => Channel) public channels; mapping (bytes32 => uint256) public participants_hash_to_channel_identifier; mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data; struct Participant { uint256 deposit; uint256 withdrawn_amount; bool is_the_closer; bytes32 balance_hash; uint256 nonce; },1
0x6dc896e52def34ff23ab0b07250e12b9fd9fe9e7.sol,Crowdsale,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint8 public decimals; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0x6fdbcd375f348325d4b8c1fac374753ec1b07c92.sol,WSKYToken,"contract WSKYToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WSKYToken() public { symbol = ; name = ; decimals = 6; _totalSupply = 9600000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x45d257558598076de596d49f10ba7326acd89212.sol,SVChain,"contract SVChain{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public SVChainSupply = 10000000; uint256 public buyPrice = 10000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function SVChain() public { totalSupply = SVChainSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x30f6a7dff2afba419677ede86d121d5675d67622.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; address public multisig; ERC20 public token; uint rate; uint priceETH; mapping (address => bool) whitelist; event Purchased(address indexed _addr, uint _amount); function getRateCentUsd() public view returns(uint) { if (block.timestamp >= 1539550800 && block.timestamp < 1541019600) { return(70); }",1
0x5833dbb0749887174b254ba4a5df747ff523a905.sol,XRUN,"contract XRUN is administrator, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; mapping (address => uint256) public limitAccount; struct Mission { string adName; string adCategory; string latitude; string longitude; uint256 time; }",1
0xaaabd58b6d94b21859f9fc2b4e829f532283cf69.sol,UCoinToken,"contract UCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UCoinToken( ) TokenERC20(5000000000, , ) public {}",1
0x732c6f4f1cf13d850d71e9dad229997db0818a52.sol,DateTime,contract DateTime { struct TDateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x64bfc90b31e508e8d0a0c35b848a9beb2ba278c7.sol,PuErh_HongSiang,"contract PuErh_HongSiang is MintableToken, BurnableToken { constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x6e5ace49d0e051936fcbe63e192445c808fcd490.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes32 a, bytes32 b) public pure returns(uint) { for (uint i = 0; i < 32; i++) { if (a[i] != b[i] || a[i] == 0) { return i; }",1
0x0355e20c49de30e04c7c693911694ba2450e5564.sol,InvoizChain,"contract InvoizChain is ERC20 { using SafeMath for uint256; address owner = 0xBc4b57D2789a0EfF23662F08A4210351909Aa4B0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 1e28; uint256 public tokenPerETH = 1e27; uint256 public valueToGive = 9e19; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xbce22ddb0caeb744060b814c57b4c88bee7337a6.sol,CryptoMinerPlus,contract CryptoMinerPlus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x504d00c4ad9df0783ef745a19130266667ffa888.sol,LB,"contract LBevents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); }",1
0x32f778f246ba5f8ad8eb35a0d638e9075abe5b19.sol,HipsterFarmer,contract HipsterFarmer{ uint256 public EGGS_TO_HATCH_1HIPSTER=86400; uint256 public STARTING_HIPSTER=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryHipster; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public hipstermasterReq=100000; function HipsterFarmer() public{ ceoAddress=msg.sender; },1
0x0e0989b1f9b8a38983c2ba8053269ca62ec9b195.sol,PoetToken,"contract PoetToken is Token { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 8; address constant public icoAllocation = 0x1111111111111111111111111111111111111111; address constant public foundationReserve = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; uint foundationTokens; mapping(uint8 => uint8) daysInMonth; uint Sept1_2017 = 1504224000; uint reserveDelta = 456; function PoetToken() { totalSupply = withDecimals(3141592653, decimals); foundationTokens = div(mul(totalSupply, 32), 100); balances[foundationReserve] = foundationTokens; balances[icoAllocation] = sub(totalSupply, foundationTokens); allowed[icoAllocation][owner] = balanceOf(icoAllocation); daysInMonth[1] = 31; daysInMonth[2] = 28; daysInMonth[3] = 31; daysInMonth[4] = 30; daysInMonth[5] = 31; daysInMonth[6] = 30; daysInMonth[7] = 31; daysInMonth[8] = 31; daysInMonth[9] = 30; daysInMonth[10] = 31; daysInMonth[11] = 30; daysInMonth[12] = 31; }",1
0x516f02475acf19bad0352ce3759c42adaac0000f.sol,SafeMath,contract SafeMath { function SafeMath() public { },1
0x30c1b3435b529cb429225f28acc1ea69964844b9.sol,BookBonus,contract BookBonus is Ownable { ERC20Basic GrrToken; function BookBonus(address _token) public payable { GrrToken = ERC20Basic(_token); },1
0xcf106b9644eb97deb5b78ab22da160ffca67a448.sol,ModuleRegistry,"contract ModuleRegistry is Owned { mapping (address => Info) internal modules; mapping (address => Info) internal upgraders; event ModuleRegistered(address indexed module, bytes32 name); event ModuleDeRegistered(address module); event UpgraderRegistered(address indexed upgrader, bytes32 name); event UpgraderDeRegistered(address upgrader); struct Info { bool exists; bytes32 name; }",1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0xbee61423ef891d33c1ef322338ef85c536898d80.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) public whitelist; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; },1
0x02992370df72da5b039c3a6249beb27c487e63cb.sol,Exchange,"contract Exchange is SafeMath, Admin { mapping( address => mapping( address => uint )) public tokens; mapping( address => mapping( bytes32 => bool )) public orders; mapping( bytes32 => mapping( address => uint )) public ordersBalance; event Deposit( address token, address user, uint amount, uint balance ); event Withdraw( address token, address user, uint amount, uint balance ); event Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder ); event HashOutput(bytes32 hash); constructor( address _admin, address _feeAccount, uint _feeTake, string _version) public { admin = _admin; feeAccount = _feeAccount; feeTake = _feeTake; orderEnd = false; version = _version; pause = false; }",1
0x533bafa16aa76218ec4a365ad71bf8816cf21bbb.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 timestamp); event cardChange( uint256 indexed search_token_id, address indexed search_owner, uint256 token_id, address owner, uint256 changeType, bytes32 data, uint256 timestamp); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x21ae23b882a340a22282162086bc98d3e2b73018.sol,LookRevToken,contract LookRevToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public VERSION = ; bool public finalised = false; address public wallet = 0x0; mapping(address => bool) public kycRequired; uint public constant START_DATE = 1504112400; uint public constant END_DATE = 1506790800; uint public constant DECIMALSFACTOR = 10**uint(decimals); uint public constant TOKENS_SOFT_CAP = 10000000 * DECIMALSFACTOR; uint public constant TOKENS_HARD_CAP = 2000000000 * DECIMALSFACTOR; uint public constant TOKENS_TOTAL = 5000000000 * DECIMALSFACTOR; uint public initialSupply = 10000000 * DECIMALSFACTOR; uint public tokensPerKEther = 2400000; uint public CONTRIBUTIONS_MIN = 0 ether; uint public CONTRIBUTIONS_MAX = 0 ether; uint public constant KYC_THRESHOLD = 1000000 * DECIMALSFACTOR; function LookRevToken() { owner = msg.sender; wallet = owner; totalSupply = initialSupply; balances[owner] = totalSupply; },1
0x27de94cb6af1f383430273f44ab4cf4baeb00fc4.sol,METADOLLAR,contract METADOLLAR { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xd344d3ee119668b11c18538797cf5e3454364c4e.sol,IMMFXCoin,contract IMMFXCoin { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint public _totalSupply = 1000000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x7982d996cd2bf4dfa329d91ce139779c23d30fa9.sol,MuskToken,contract MuskToken is StandardToken { function () { throw; },1
0x5884c40dded55b5649a1aaa677a750ead35e3043.sol,OnasanderToken,"contract OnasanderToken { using SafeMath for uint; address private wallet; address public owner; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint public totalSupply = 88000000e18; uint public totalTokensSold = 0e18; uint public totalTokensSoldInThisSale = 0e18; uint public maxTokensForSale = 79200000e18; uint public companyReserves = 8800000e18; uint public minimumGoal = 0e18; uint public tokensForSale = 0e18; bool public saleEnabled = false; bool public ICOEnded = false; bool public burned = false; uint public tokensPerETH = 800; bool public wasGoalReached = false; address private lastBuyer; uint private singleToken = 1e18; constructor(address icoWallet) public { require(icoWallet != address(0), ); owner = msg.sender; wallet = icoWallet; balances[owner] = totalSupply; emit TokensMinted(owner, totalSupply); }",1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0x5473311d1b728e6c66b71923e8efbd491ca5d435.sol,PennyGrab,"contract PennyGrab is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public totalSupply = 100000000000000000000000000; function PennyGrab() { balances[msg.sender] = totalSupply; }",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsStorage,contract EthernautsStorage is EthernautsAccessControl { function EthernautsStorage() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; },1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xbe585e9ae9d7e3277b2541dbac105c4ed540f806.sol,CoinEJP,"contract CoinEJP { address public admin_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; address public account_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 880000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x8633e144f2d9b9b8bdd12ddb58e4bef1e163a0ce.sol,Yellow,"contract Yellow { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Yellow( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1cdc6b8fe34d313ee45fcd98d7391b6f564069a4.sol,ClassyCoin,"contract ClassyCoin is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping(address=>bool) public frozenAccount; event FrozenFunds(address target, bool frozen); uint256 public constant initialSupply = 100000000 * 10**16; uint8 public constant decimalUnits = 16; string public tokenName = ; string public tokenSymbol = ; function ClassyCoin() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x296ec7b2b224ea122f8f8f9be2a824df092fc82c.sol,Scaltinof,"contract Scaltinof is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 10e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function Scaltinof() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,EmployeesList,"contract EmployeesList is ESOPTypes, Ownable, Destructable { event CreateEmployee(address indexed e, uint32 poolOptions, uint32 extraOptions, uint16 idx); event UpdateEmployee(address indexed e, uint32 poolOptions, uint32 extraOptions, uint16 idx); event ChangeEmployeeState(address indexed e, EmployeeState oldState, EmployeeState newState); event RemoveEmployee(address indexed e); mapping (address => Employee) employees; address[] public addresses; function size() external constant returns (uint16) { return uint16(addresses.length); }",1
0xe120c1ecbfdfea7f0a8f0ee30063491e8c26fedf.sol,SuretlyToken,"contract SuretlyToken { string public constant standard = ; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public totalSupply = 237614 * 100000000; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event NewOwner(address _newOwner); event Burn(address indexed _from, uint256 _value); function SuretlyToken() { owner = msg.sender; balanceOf[owner] = totalSupply; }",1
0x1d97bccc6296aac6f0be796c7e8cb270eca4c6c6.sol,AquaToken,"contract AquaToken is Owned, Token { using SafeMath for uint256; using LibHoldings for LibHoldings.Holding; using LibHoldings for LibHoldings.HoldingsSet; using LibRedemptions for LibRedemptions.Redemption; using LibRedemptions for LibRedemptions.RedemptionsQueue; struct DistributionContext { uint distributionAmount; uint receivedRedemptionAmount; uint redemptionAmount; uint tokenPriceWei; uint currentRedemptionId; uint totalRewardAmount; }",1
0x6a00a6cd60733c483070aa5e7d835fa81fe5b10a.sol,BJUIO,"contract BJUIO { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,GeocashToken,"contract GeocashToken is StandardToken, Destructible { string public name; string public symbol; uint public decimals; uint public buyPriceInWei; uint public sellPriceInWei; uint public minBalanceForAccounts; address public companyWallet; mapping(address => uint256) balances; mapping (address => bool) public frozenAccounts; event FrozenFunds(address target, bool frozen); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RNTMultiSigWallet,"contract RNTMultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event Pause(); event Unpause(); uint constant public MAX_OWNER_COUNT = 10; uint constant public ADMINS_COUNT = 2; mapping(uint => WalletTransaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; mapping(address => bool) public isAdmin; address[] public owners; address[] public admins; uint public required; uint public transactionCount; bool public paused = false; struct WalletTransaction { address sender; address destination; uint value; bytes data; bool executed; }",1
0x92e56fd4d1468a9f4c882a5394270427135538e4.sol,PentacoreToken,"contract PentacoreToken is StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public constant million = 1000000; uint256 public constant tokenCap = 1000 * million; bool public isPaused = true; mapping(address => bool) public whitelist; bool public isFreeTransferAllowed = false; uint256 public tokenNAVMicroUSD; uint256 public weiPerUSD; address public owner; address public kycAdmin; address public navAdmin; address public crowdsale; address public redemption; address public distributedAutonomousExchange; event Mint(address indexed to, uint256 amount); event Burn(uint256 amount); event AddToWhitelist(address indexed beneficiary); event RemoveFromWhitelist(address indexed beneficiary); function PentacoreToken() public { owner = msg.sender; tokenNAVMicroUSD = million; isFreeTransferAllowed = false; isPaused = true; totalSupply_ = 0; }",1
0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol,CryptoBetOn,contract CryptoBetOn { struct Gamer { address wallet; uint amount; },1
0x36e666eaac18ed22b8e370547c75e6782b63d5da.sol,Token,"contract Token { using SafeMath for uint256; address public owner; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 totalSupply_ = 20e8 * (10**18); bool public paused = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => uint256) internal locked; event Burn(address indexed burner, uint256 value); event Approval(address indexed owner, address indexed spender,uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Pause(); event Unpause(); event Lock(address indexed LockedAddress, uint256 LockAmount); event Unlock(address indexed LockedAddress); constructor() public { owner = msg.sender; balances[owner] = totalSupply_ ; }",1
0x032386ec0048f527bb611a913ff88bca54e7e81d.sol,_GreenStamps,"contract _GreenStamps is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _GreenStamps() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 2100000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 1000000000 * 10**uint(decimals); rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0xa5e9fd547d78f2b658ae6c45ad08d9ab432c797c.sol,VeraCoinPreSale,"contract VeraCoinPreSale is Haltable { using SafeMath for uint; string public name = ; VeraCoin public token; address public beneficiary; uint256 public hardCap; uint256 public softCap; uint256 public collected; uint256 public price; uint256 public tokensSold = 0; uint256 public weiRaised = 0; uint256 public investorCount = 0; uint256 public weiRefunded = 0; uint256 public startTime; uint256 public endTime; bool public softCapReached = false; bool public crowdsaleFinished = false; mapping (address => bool) refunded; event GoalReached(uint256 amountRaised); event SoftCapReached(uint256 softCap); event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); event Refunded(address indexed holder, uint256 amount); modifier onlyAfter(uint256 time) { require(now >= time); _; }",1
0xa20f317e3b6fe80ff76ee908860ecdb3edea4893.sol,TwelveHourFastTrain,contract TwelveHourFastTrain { address public owner; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; uint256 constant private THT_TOKEN_OWNERS = 10; address constant private PROMO = 0xC63eA85CC823c440319013d4B30E19b66466642d; uint constant public PROMO_PERCENT = 1; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.05 ether; uint256 constant public VERIFY_REFERRAL_PRICE = 0.01 ether; uint256 constant public REFERRAL = 3; uint constant public LAST_DEPOSIT_PERCENT = 10; LastDeposit public last; mapping(address => bool) public referrals; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0xdbe16aa3c77ff1bc391f2b311152b86610de1494.sol,IDCToken,"contract IDCToken is PausableToken, MintableToken, BurnableToken { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public weiRaised; uint256 public tokenSelled; address public creator; address public wallet; mapping(address => address) whiteList; mapping(address => uint256) tokensBuyed; uint256 public capPerAddress; event SellTokens(address indexed recipient, uint sellTokens, uint payEther, uint ratio); function IDCToken ( string _tokenName, string _tokenSymbol, uint256 _tokenDecimals, uint256 _startTime, uint256 _endTime, uint256 _totalSupply, uint256 _rate, uint256 _capPerAddress, address _wallet ) public { require(_endTime >= _startTime); require(_startTime >= now); require(_totalSupply > 0); require(_capPerAddress > 0); require(_wallet != address(0)); name = _tokenName; symbol = _tokenSymbol; decimals = _tokenDecimals; startTime = _startTime; endTime = _endTime; totalSupply = _totalSupply; rate = _rate; capPerAddress = _capPerAddress; wallet = _wallet; balances[msg.sender] = totalSupply; creator = msg.sender; }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,TokenRK50Z,"contract TokenRK50Z is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = false; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRK50Z() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x4c79c1c19cfac6c05e5850226ad41fc2ddf85491.sol,CslTokenDistribution,"contract CslTokenDistribution { using SafeMath for uint256; mapping (address => uint256) balances; Token public cslToken; address public owner; uint256 public decimals = 10e17; uint256 public value = 50000; uint256 public bonus = 5000; uint256 public drop; bool public contractLocked = true; bool public bonusTime = true; event sendTokens(address indexed to, uint256 value); event Locked(); event Unlocked(); event Bonustimer(); event NoBonustimer(); function CslTokenDistribution(address _tokenAddress, address _owner) public { cslToken = Token(_tokenAddress); owner = _owner; }",1
0x91e1dcfbfe7b6be8ac836d08fb493b085ebbb3ef.sol,CoinLottoToken,"contract CoinLottoToken is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function CoinLottoToken (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0xd89d6e3b1115743b3dc481f6afdb5bc2958031d6.sol,POWM,contract POWM { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7.sol,GodsOfOlympus,contract GodsOfOlympus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x347e451298778e02d2b0f0985c07aff677ff7b05.sol,CLVRCrowdsale,contract CLVRCrowdsale { using SafeMath for uint256; Token public tokenReward; address public creator; address public owner = 0x93a68484936E235e167729a4a1AB6f0d1897106F; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x338683298798ffefb4cabeb9ef3a18915b3a42e3.sol,ProofOfCloneWars,contract ProofOfCloneWars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc668715818831645cdf0eee3a9b84590fa979e65.sol,BGAToken,"contract BGAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 600000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xee52d05a2351151beabedb7a9e38cc1a2095a8ce.sol,PIPOT,"contract PIPOT is Owner { using SafeMath for uint256; event Game(uint _game, uint indexed _time); event ChangePrice(uint _price); event Ticket( address indexed _address, uint indexed _game, uint _number, uint _time, uint _price ); event ChangeFee(uint _fee); event Winner(address _winnerAddress, uint _price, uint _jackpot); event Lose(uint _price, uint _currentJackpot); uint public fee = 20; uint public game; uint public ticketPrice = 0.1 ether; uint public allTimeJackpot = 0; uint public allTimePlayers = 0; bool public isActive = true; bool public toogleStatus = false; uint[] public games; mapping(uint => uint) jackpot; mapping(uint => address[]) players; mapping(uint => mapping(uint => address[])) orders; address public fundsDistributor; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xed37a1395e3c9db3e6543ea770b91ea0e8bd4f05.sol,Mineable,"contract Mineable { address public owner; uint public supply = 100000000000000; string public name = ; string public symbol = ; uint8 public decimals = 8; uint public price = 1 finney; uint public durationInBlocks = 157553; uint public miningReward = 100000000; uint public amountRaised; uint public deadline; uint public tokensSold; uint private divider; mapping (address => uint256) public balanceOf; mapping (address => uint256) public successesOf; mapping (address => uint256) public failsOf; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function isOwner() returns (bool isOwner) { return msg.sender == owner; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x19126de222e01b4bbcf0d5844a9dfb17ab08ed43.sol,PalestinePound,"contract PalestinePound is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PalestinePound() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 12 weeks; }",1
0x4bbdeadf8334e8a85d3e22ec090af74c3a673118.sol,ReserveToken,"contract ReserveToken is StandardToken, SafeMath { string public name; string public symbol; uint public decimals = 18; address public minter; function ReserveToken(string name_, string symbol_) { name = name_; symbol = symbol_; minter = msg.sender; }",1
0xc32c4bd955cfd68bddbc13b4baef73bcef0e09da.sol,Draw,contract Draw is Ownable { address[9] private players; address public last_winner; uint public draw_number; uint public slots_left; uint private MAX_PLAYERS = players.length; uint private counter = 0; uint private t0 = now; uint private tdelta; uint private index; uint private owner_balance = 0 finney; function Draw() public { initGame(); draw_number = 1; last_winner = address(0); },1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownIco,"contract ExoTownIco is SafeMath, IcoLimits { ExoTownToken public exotownToken; enum State { Pause, Running }",1
0x6ccb56947ea1d6efdc81acfbacd8263ddfa9b202.sol,RKCToken,"contract RKCToken is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; bool public constant TEST_MODE = false; uint public constant atto = 1000000000000000000; uint public constant INITIAL_SUPPLY = 15000000 * atto; address public teamWallet = 0xb79F963f200f85D0e3dD60C82ABB8F80b5869CB9; address public ico_address = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public constant ICO_START_TIME = 1499810400; uint public current_supply = 0; uint public ico_starting_supply = 0; uint public current_price_atto_tokens_per_wei = 0; bool public preSoldSharesDistributed = false; bool public isICOOpened = false; bool public isICOClosed = false; uint[] public premiumPacks; mapping(address => uint) premiumPacksPaid; event ICOOpened(); event ICOClosed(); event PriceChanged(uint old_price, uint new_price); event SupplyChanged(uint supply, uint old_supply); event RKCAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function RKCToken() { distributePreSoldShares(); current_price_atto_tokens_per_wei = calculateCurrentPrice(1); premiumPacks.length = 0; }",1
0xece8128c8f2746d17c72c1a6a2c72a0b086a9098.sol,SYCToken,"contract SYCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x83dc8423170e95ee18b770bbdd6b3becb73c9c30.sol,StandardToken,"contract StandardToken is Token, SafeMath { uint256 public totalSupply; function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { require(_to != address(0)); require(balances[msg.sender] >= _value && _value > 0); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }",1
0xf4dc2cdadd6406e2fa5a82e7cb16feaf355869ca.sol,RexusExchange,"contract RexusExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000e18; uint256 public tokenPerETH = 10000000e18; uint256 public valueToGive = 5000e18; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xaa840b1138d31cc4a5fcd9545ed03441ef2a1213.sol,DIVIUMx2,contract DIVIUMx2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf1c91ad5d541567eb90a8a56373556a851a53e12.sol,Jancok,contract Jancok is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; function Jancok() public { totalSupply_ = 3000000 * 1 ether; balances[msg.sender] = totalSupply_; },1
0x3329a13218b9b311a7ee468dfe100f72c08ee2da.sol,PRECOE,"contract PRECOE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public devFeesAddr = 0x36Bdc3B60dC5491fbc7d74a05709E94d5b554321; address tierAdmin; uint256 public totalSupply = 71433000000000000000000; uint256 public mineableTokens = totalSupply; uint public tierLevel = 1; uint256 public fiatPerEth = 3.85E25; uint256 public circulatingSupply = 0; uint maxTier = 132; uint256 public devFees = 0; uint256 fees = 10000; bool public receiveEth = false; bool payFees = true; bool public canExchange = true; bool addTiers = true; bool public initialTiers = false; mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping(uint => uint256) public scheduleTokens; mapping(uint => uint256) public scheduleRates; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event TokensExchanged(address indexed _owningWallet, address indexed _with, uint256 _value); function PRECOE() { owner = msg.sender; balances[owner] = add(balances[owner],4500000000000000000000); Transfer(this, owner, 4500000000000000000000); circulatingSupply = add(circulatingSupply, 4500000000000000000000); mineableTokens = sub(mineableTokens,4500000000000000000000); }",1
0x64c36b4cec69ee9041b48b950dfd0fc59a849f68.sol,XenToken,"contract XenTokenStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0xeb7160d9fba402219ea868bc311e7d98688d3180.sol,TokenShield,contract TokenShield{ address public owner; bytes8[merkleWidth] private ns; bytes8[merkleWidth] private ds; uint constant merkleWidth = 256; uint constant merkleDepth = 9; uint constant lastRow = merkleDepth-1; bytes8[merkleWidth] private zs; uint private zCount; uint private nCount; bytes8[] private roots; uint public currentRootIndex; Verifier mv; Verifier tv; Verifier jv; Verifier sv; struct Proof { uint[2] a; uint[2] a_p; uint[2][2] b; uint[2] b_p; uint[2] c; uint[2] c_p; uint[2] h; uint[2] k; },1
0xde4f1f39242e779f4ae6324e06fb30ba3e14e377.sol,KTuneCustomToken,"contract KTuneCustomToken is Ownable { event LogBurnFinished(); event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan); KTunePricingPlan public pricingPlan; address public serviceProvider; bool public burningFinished; modifier onlyServiceProvider() { require(msg.sender == serviceProvider, ); _; }",1
0x0232ba609782cea145ec3663f52cf7aeb4ac773c.sol,Utils,contract Utils { ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee); uint constant internal PRECISION = (10**18); uint constant internal MAX_QTY = (10**28); uint constant internal MAX_RATE = (PRECISION * 10**6); uint constant internal MAX_DECIMALS = 18; uint constant internal ETH_DECIMALS = 18; mapping(address=>uint) internal decimals; function setDecimals(ERC20 token) internal { if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS; else decimals[token] = token.decimals(); },1
0xa1d12a357746fd44f282571d746d300eb85232ca.sol,ETHCutter,contract ETHCutter { using SafeMath for uint256; using AddressUtils for address; address public adminWallet; uint256 constant public DEPOSIT_MIN = 10 finney; uint256 constant public DEPOSIT_MAX = 10 ether; uint256 constant public DEPOSIT_PERIOD = 5 days; uint256 constant public TOTAL_PERCENT = 120; uint256 constant public UPLINE_PERCENT = 6; uint256 constant public EXPENSES_PERCENT = 15; uint256 public totalDeposited = 0; uint256 public totalWithdrawn = 0; uint256 public usersCount = 0; uint256 public depositsCount = 0; uint256 public expenses = 0; mapping(address => User) public users; mapping(uint256 => Deposit) public deposits; struct Deposit { uint256 createdAt; uint256 endAt; uint256 amount; uint256 accrued; uint256 totalForAccrual; bool active; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterCreatorInterface,"contract MonsterCreatorInterface is Ownable { uint8 public lockedMonsterStatsCount = 0; uint nonce = 0; function rand(uint16 min, uint16 max) public returns (uint16) { nonce++; uint16 result = (uint16(keccak256(block.blockhash(block.number-1), nonce))%max); if (result < min) { result = result+min; }",1
0x08b67e38b4ecc788eb0cfbab72074c374ecddbf3.sol,Bitlike,"contract Bitlike is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 4; uint256 public totalSupply = 760000000e4; uint256 public totalDistributed = 6500000e4; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c0f03411ab250f0a080a4420190b821affd4602.sol,GizerItems,"contract GizerItems is ERC721Token { string constant cName = ; string constant cSymbol = ; bytes32[] public code; uint[] public weight; uint public sumOfWeights; mapping(bytes32 => uint) public mCodeIndexPlus; uint public nonce = 0; uint public lastRandom = 0; mapping(uint => bytes32) public mIdxUuid; event MintToken(address indexed minter, address indexed _owner, bytes32 indexed _code, uint _input); event CodeUpdate(uint8 indexed _type, bytes32 indexed _code, uint _weight, uint _sumOfWeights); function GizerItems() public { }",1
0x40a835f8573c4b75e962e435591ea2200b74a714.sol,MyEtherTeller,contract MyEtherTeller { address public owner; struct EscrowStruct { address buyer; address seller; address escrow_agent; uint escrow_fee; uint amount; bool escrow_intervention; bool release_approval; bool refund_approval; bytes32 notes; },1
0x6f303642844f734ad4176d0dfe93ef7e0776ef46.sol,CrowdsaleWatch,"contract CrowdsaleWatch { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool crowdsaleClosed = false; function CrowdsaleWatch( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, token addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 5000 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 5000000 wei; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xa206d217c0642735e82a6b11547bf00659623163.sol,Staking,"contract Staking { using SafeMath for *; event Transfer ( address indexed from, address indexed to, uint256 tokens ); event onDeposit ( address indexed customer, uint256 tokens ); event onReinvestProfit ( address indexed customer, uint256 tokens ); event onWithdrawProfit ( address indexed customer, uint256 tokens ); event onWithdrawCapital ( address indexed customer, uint256 tokens ); modifier onlyTokenContract { require(msg.sender == address(tokenContract_)); _; }",1
0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c.sol,CSLottery,"contract CSLottery is ERC721, usingOraclize, Functional, Owned { uint256 public feeLottery; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0xeb2b6b3f3fa0ea711ceb2ed77a23baeaf5ac0796.sol,StandardToken,contract StandardToken is Token { uint256 _totalSupply; function totalSupply() constant returns (uint256 totalSupply) { totalSupply = _totalSupply; },1
0xeeb11ca61353ff0723f058d909debcf9c5d05f88.sol,SpyceCrowdsale,contract SpyceCrowdsale is Ownable{ using SafeMath for uint; uint decimals = 18; SpyceToken public token; function SpyceCrowdsale(address _tokenAddress) public{ token = SpyceToken(_tokenAddress); owner = msg.sender; token.setCrowdsaleContract(this); stageStruct memory buffer; buffer.startDate = 0; buffer.finishDate = 1522195199; buffer.tokenPrice = 0.00016 ether; buffer.minCap = 108 ether; buffer.maxCap = 24000 ether; stages.push(buffer); },1
0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff.sol,BeezGold,"contract BeezGold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 165 * 1 days; uint public round2 = now + 130 * 1 days; uint public round1 = now + 35 * 1 days; uint256 public totalSupply = 70000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25700e8; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0x654186811320885fC24C318E70a119A43279c1BE; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf028adee51533b1b47beaa890feb54a457f51e89.sol,BMToken,"contract BMToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 _supply = 0; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); address ico_contract; address public owner; function BMToken(){ ico_contract = address(0x0); owner = msg.sender; }",1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0x56b3f7e9c10dc62fddbbb69e66806f6034095f24.sol,Bestmoney_new,contract Bestmoney_new { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xcf5a08af322e52bee93861341f7bd90eb3d65aa3.sol,HeavyLitecoin,"contract HeavyLitecoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HeavyLitecoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8] = _totalSupply; Transfer(address(0), 0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8, _totalSupply); }",1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0xd0f2bf383d5d106f68f3e2077bcda617a0390ff0.sol,Startable,"contract Startable is Ownable, Authorizable { event Start(); bool public started = false; modifier whenStarted() { require( started || authorized[msg.sender], ); _; }",1
0x074661068c2cbca51dde811871554d2fa5bae312.sol,BountyHunterToken,"contract BountyHunterToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BountyHunterToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x84b6241ed47e935597bc5a14d5e9ef9fb53e77de.sol,AbstractSweeper,"contract AbstractSweeper { function sweep(address token, uint amount) returns (bool); function () { throw; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0xcf78f1a266113fe942e51484c45ccf3ec6db13f6.sol,VNDCToken,"contract VNDCToken is Pausable, StandardToken { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; mapping (address => bool) public isBlackListed; function VNDCToken(){ _totalSupply = 1000000000 * 10**uint(decimals); name = ; symbol = ; balances[owner] = 1000000000 * 10**uint(decimals); deprecated = false; }",1
0x008faf03038c810e478013d85659e25199a79e77.sol,Simple_Options_v3,"contract Simple_Options_v3 { address public feeAddress; uint256 public feePercent = 5000; uint256 constant roundCutoff = 1800; uint256 constant roundLength = 3600; address constant compoundOracleProxy = 0x2C9e6BDAA0EF0284eECef0e0Cc102dcDEaE4887e; address constant cUSDCAddress = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; enum RoundStatus { OPEN, CLOSED, STALEPRICE, NOCONTEST }",1
0x5c976e71bb27538bddb0ed399be1722c6745bcb6.sol,ProofOfKennyCoin,contract ProofOfKennyCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x40d6ab35c171cddc7fc81187e8a20d6711717ef0.sol,ProofOfBible,contract ProofOfBible { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x8c27fafc6e56a997abe1681eee6de0077b458fd1.sol,GigaCrowdsale,"contract GigaCrowdsale is Contactable { using SafeMath for uint256; GigaToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensPurchased; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event SetRate(uint256 oldRate, uint256 newRate); event SetEndTime(uint256 oldEndTime, uint256 newEndTime); function GigaCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,string _contactInformation) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); contactInformation = _contactInformation; token = createTokenContract(); token.setContactInformation(_contactInformation); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; }",1
0x3a24e13f4176d12208631ccb9236c345924c145b.sol,WeblifeGold,contract WeblifeGold { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 550000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,TrainingField,"contract TrainingField is AccessControl{ address public angelCardDataContract; address public petCardDataContract; address public accessoryDataContract; event EventSuccessfulTraining(uint64 angelId,uint64 pet1ID,uint64 pet2ID); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; uint price; uint64 createdTime; uint64 lastBattleTime; uint64 lastVsBattleTime; uint16 lastBattleResult; }",1
0x5882d49d3511e09096cbbab7e19fbfb82f65f28d.sol,BioToken,"contract BioToken is ERC20, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; bool public tradingStarted = false; bool public mintingFinished = false; bool public salePaused = false; uint256 public tokenTotalSupply = 0; uint256 public trashedTokens = 0; uint256 public hardcap = 140000000 * (10 ** decimals); uint256 public ownerTokens = 14000000 * (10 ** decimals); uint public ethToToken = 300; uint public noContributors = 0; uint public start = 1503346080; uint public initialSaleEndDate = start + 9 weeks; uint public ownerGrace = initialSaleEndDate + 182 days; uint public fiveYearGrace = initialSaleEndDate + 5 * 365 days; address public multisigVault; address public lockedVault; address public ownerVault; address public authorizerOne; address public authorizerTwo; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) authorizedWithdrawal; event Mint(address indexed to, uint256 value); event MintFinished(); event TokenSold(address recipient, uint256 ether_amount, uint256 pay_amount, uint256 exchangerate); event MainSaleClosed(); modifier onlyPayloadSize(uint size) { if (msg.data.length < size + 4) { revert(); }",1
0x01e6a8af629cc06ff37755a61d9e7dd1135d8c6a.sol,DRCT_Token,contract DRCT_Token { using DRCTLibrary for DRCTLibrary.TokenStorage; DRCTLibrary.TokenStorage public drct; string public constant name = ; string public constant symbol = ; constructor() public { drct.startToken(msg.sender); },1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x012910aa43d4be652a67935db4cc4db4b14593f5.sol,AllyICO,"contract AllyICO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; address _tokenContract = 0x03e2cE0C0B99998e6906B90Ab6F9eac0deFAFf16; AltcoinToken cddtoken = AltcoinToken(_tokenContract); string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 12000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x33f605291ad6305379404e86253ee4f7f0a713ec.sol,FBTT,contract FBTT is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; mapping(address => bool) touched; uint currentBalanceAirTotalSupply = 1000000*(10**18); uint currentBalanceAirSupply = 0; uint airdropNum = 100 ether; uint stopped; uint256 public total = 1000000000*(10**18) ; uint256 public totalSupply = total.mul(25).div(100); uint256 public lockTeamTotal = total.div(10) ; uint256 public unlockTeamTotal = 0; uint256 public lockRemainTotal = total.mul(45).div(100) ; uint256 public unlockRemainTotal = 0; uint256 public availableTotal = total.mul(2).div(10) ; uint256 public airdropTotal = total.div(20); uint256 public airdropedTotal = 0 ; uint256 public _startTime; modifier stoppable { assert(stopped == 0); _; },1
0xa1cb45a734151b63679e1aed48e4c3deb8d1908d.sol,GuardianGoldToken,"contract GuardianGoldToken is BasicToken, Ownable, RBAC { string public name = ; string public symbol = ; uint8 public decimals = 18; string public constant ADMIN_ROLE = ; uint256 constant internal magnitude = 2**64; uint public maxTokens = 5000e18; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal referralBalance_; mapping(address => mapping (address => uint256)) allowed; uint public goldAccount = 0; uint public operationsAccount = 0; uint256 internal profitPerShare_; address[] public transfers; uint public constant INITIAL_SUPPLY = 62207e15; uint public totalSupply = 62207e15; uint public totalGoldReserves = 62207e15; uint public pendingGold = 0; uint public totalETHReceived = 57.599 ether; bool public isTransferable = true; bool public toggleTransferablePending = false; address public transferToggleRequester = address(0); uint public tokenPrice = 0.925925 ether; uint public goldPrice = 0.390185 ether; uint public tokenSellDiscount = 950; uint public referralFee = 30; uint minGoldPrice = 0.2 ether; uint maxGoldPrice = 0.7 ether; uint minTokenPrice = 0.5 ether; uint maxTokenPrice = 2 ether; uint public dividendRate = 150; uint public minPurchaseAmount = 0.1 ether; uint public minSaleAmount = 1e18; uint public minRefStake = 1e17; bool public allowBuy = false; bool public allowSell = false; bool public allowRedeem = false; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; addRole(msg.sender, ADMIN_ROLE); emit Transfer(address(this), msg.sender, INITIAL_SUPPLY); }",1
0xa25e8050f80ee99a17e861cd0931d5d362caa34e.sol,GameCards,contract GameCards { struct LeaseCard { uint id; address tenant; uint price; uint untilBlock; string title; string url; string image; },1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0xc55aed771e58292bf24b5bd5f3febdc89b907b68.sol,VoteToken,"contract VoteToken is HasNoEther, BurnableToken { struct stSuggestion { string text; uint256 total_yes; uint256 total_no; uint256 timeStop; bool finished; uint voters_count; mapping(uint => address) voters_addrs; mapping(address => uint256) voters_value; }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RNTMultiSigWallet,"contract RNTMultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event Pause(); event Unpause(); uint constant public MAX_OWNER_COUNT = 10; uint constant public ADMINS_COUNT = 2; mapping(uint => WalletTransaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; mapping(address => bool) public isAdmin; address[] public owners; address[] public admins; uint public required; uint public transactionCount; bool public paused = false; struct WalletTransaction { address sender; address destination; uint value; bytes data; bool executed; }",1
0x0e725e7d526322be56f788c7786c3eba7f162226.sol,Testfan,contract Testfan { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint public _totalSupply = 120000000000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x6d2cfe7c64087b1d6d2f7e77039de64dcd232ced.sol,ERC777BaseToken,"contract ERC777BaseToken is ERC777Token, ERC820Implementer { using SafeMath for uint256; string internal mName; string internal mSymbol; uint256 internal mGranularity; uint256 internal mTotalSupply; mapping(address => uint) internal mBalances; mapping(address => mapping(address => bool)) internal mAuthorized; address[] internal mDefaultOperators; mapping(address => bool) internal mIsDefaultOperator; mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator; function ERC777BaseToken(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) internal { mName = _name; mSymbol = _symbol; mTotalSupply = 0; require(_granularity >= 1); mGranularity = _granularity; mDefaultOperators = _defaultOperators; for (uint i = 0; i < mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x360e51857242661de8f3ec4e6c684b45b3c0de87.sol,Karma,"contract Karma is Ownable, DetailedERC20(, , 0) { using SafeMath for uint256; using SafeMath64 for uint64; struct User { bytes20 username; uint64 karma; uint16 canWithdrawPeriod; uint16 birthPeriod; }",1
0x71f04062e5794e0190fdca9a2bf1f196c41c3e6e.sol,FreezeableToken,"contract FreezeableToken is StandardToken, Freezeable { function transfer(address to, uint256 value) public whenNotFreezed returns (bool) { return super.transfer(to, value); }",1
0xd9224c45c012d9b09bcf8e3347f5e3d084e3afc6.sol,DOGETOKEN,"contract DOGETOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint256 public constant SUPPLY_CAP = 100000000000 * (10 ** uint256(decimals)); address NULL_ADDRESS = address(0); event NoteChanged(string newNote); string public note = ; function setNote(string note_) public onlyOwner { note = note_; NoteChanged(note); }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,OwnableWithFoundation,"contract OwnableWithFoundation is OfflineSecret { address public owner; address public newOwnerCandidate; address public foundation; address public newFoundationCandidate; bytes32 public ownerHashed; bytes32 public foundationHashed; event OwnershipRequested(address indexed by, address indexed to, bytes32 hashed); event OwnershipTransferred(address indexed from, address indexed to); event FoundationRequested(address indexed by, address indexed to, bytes32 hashed); event FoundationTransferred(address indexed from, address indexed to); function OwnableWithFoundation(address _owner) public { foundation = msg.sender; owner = _owner; }",1
0x05cda2f1e70b01072038c3a62f8aa30cf9d4d509.sol,TOKENMOM,"contract TOKENMOM is BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public constant initialSupply = 200000000 * (10 ** uint256(decimals)); function TOKENMOM() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; }",1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0xc48e4349d482296c32bb7ca430466f324c694d34.sol,RozowkaCoin,"contract RozowkaCoin { string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RozowkaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000000; name = ; symbol = ; }",1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(_to != address(0)); var _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }",1
0x275c62ee45c7d4d7fc71af52d3fe0019f414e5dc.sol,TalaRCrowdsale,"contract TalaRCrowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for IERC20; IERC20 private _token; address private _wallet; uint256 private _rate; uint256 private _bonusRate; uint256 private _bonusCap; uint256 private _weiRaised; uint256 private _openingTime; uint256 private _bonusEndTime; uint256 private _closingTime; uint256 private constant MINIMAL_CONTRIBUTION = 50000000000000000; event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 rate, uint256 bonusRate, uint256 bonusCap, uint256 openingTime, uint256 bonusEndTime, uint256 closingTime, address wallet, IERC20 token) public { require(rate > 0); require(bonusRate > 0); require(bonusCap > 0); require(openingTime >= block.timestamp); require(bonusEndTime >= openingTime); require(closingTime >= bonusEndTime); require(wallet != address(0)); _rate = rate; _bonusRate = bonusRate; _bonusCap = bonusCap; _wallet = wallet; _token = token; _openingTime = openingTime; _closingTime = closingTime; _bonusEndTime = bonusEndTime; }",1
0xc3951d77737733174152532e8b0f27e2c4e9f0dc.sol,Cloud,"contract Cloud is Token { using Math for uint256; bool trading=false; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function transfer(address _to, uint256 _value) canTrade returns (bool success) { require(_value > 0); require(!frozenAccount[msg.sender]); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Registrar,"contract Registrar { ENS public ens; bytes32 public rootNode; mapping (bytes32 => Entry) _entries; mapping (address => mapping (bytes32 => Deed)) public sealedBids; enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }",1
0x29632c10d76bd1aed6b1524bf5bde4c992610670.sol,ApplicationEntity,"contract ApplicationEntityABI { address public ProposalsEntity; address public FundingEntity; address public MilestonesEntity; address public MeetingsEntity; address public BountyManagerEntity; address public TokenManagerEntity; address public ListingContractEntity; address public FundingManagerEntity; address public NewsContractEntity; bool public _initialized = false; bool public _locked = false; uint8 public CurrentEntityState; uint8 public AssetCollectionNum; address public GatewayInterfaceAddress; address public deployerAddress; address testAddressAllowUpgradeFrom; mapping (bytes32 => uint8) public EntityStates; mapping (bytes32 => address) public AssetCollection; mapping (uint8 => bytes32) public AssetCollectionIdToName; mapping (bytes32 => uint256) public BylawsUint256; mapping (bytes32 => bytes32) public BylawsBytes32; function ApplicationEntity() public; function getEntityState(bytes32 name) public view returns (uint8); function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external; function setUpgradeState(uint8 state) public ; function addAssetProposals(address _assetAddresses) external; function addAssetFunding(address _assetAddresses) external; function addAssetMilestones(address _assetAddresses) external; function addAssetMeetings(address _assetAddresses) external; function addAssetBountyManager(address _assetAddresses) external; function addAssetTokenManager(address _assetAddresses) external; function addAssetFundingManager(address _assetAddresses) external; function addAssetListingContract(address _assetAddresses) external; function addAssetNewsContract(address _assetAddresses) external; function getAssetAddressByName(bytes32 _name) public view returns (address); function setBylawUint256(bytes32 name, uint256 value) public; function getBylawUint256(bytes32 name) public view returns (uint256); function setBylawBytes32(bytes32 name, bytes32 value) public; function getBylawBytes32(bytes32 name) public view returns (bytes32); function initialize() external returns (bool); function getParentAddress() external view returns(address); function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256); function acceptCodeUpgradeProposal(address _newAddress) external; function initializeAssetsToThisApplication() external returns (bool); function transferAssetsToNewApplication(address _newAddress) external returns (bool); function lock() external returns (bool); function canInitiateCodeUpgrade(address _sender) public view returns(bool); function doStateChanges() public; function hasRequiredStateChanges() public view returns (bool); function anyAssetHasChanges() public view returns (bool); function extendedAnyAssetHasChanges() internal view returns (bool); function getRequiredStateChanges() public view returns (uint8, uint8); function getTimestamp() view public returns (uint256); }",1
0x6dfe212d1461014be1781b0be710dda1c036d8ef.sol,ZTST,"contract ZTST is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 30000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 50 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function ZTST() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x6b4252a52471ffe6a7bd52d67fb4835690007f31.sol,bebBUY,contract bebBUY is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; uint256 bebethex=88; uint256 BEBmax; mapping(address=>uint256)public bebOf; function bebBUY(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,Pausable,contract Pausable is OwnableWithFoundation { event Pause(); event Unpause(); bool public paused = false; function Pausable(address _owner) public OwnableWithFoundation(_owner) { },1
0x33bfd20660eeaf952e8d5bc3236e1918701f17d0.sol,RCCCToken,"contract RCCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RCCCToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x3618516f45cd3c913f81f9987af41077932bc40d.sol,PeculiumOld,"contract PeculiumOld is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function PeculiumOld() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0x406d7401f451ee9d3a04652102aaf923c59f64e9.sol,Elephant,contract Elephant { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,BitBonus,"contract BitBonus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x633A5cD23D95c26f750B802A03A82490C00Da802] = _totalSupply; emit Transfer(address(0), 0x633A5cD23D95c26f750B802A03A82490C00Da802, _totalSupply); }",1
0x1fc3294386ccbc834fdd1f1d78d236c634fe9fc6.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onUtilityfee (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 decimal, uint256 endtime); event onReceiveAirdrop (address indexed hodler, uint256 amount, uint256 datetime); event onAddContract (address indexed hodler, address indexed tokenAddress, uint256 percent, string tokenSymbol, uint256 amount, uint256 endtime); event onTokenPrice (address indexed hodler, address indexed tokenAddress, uint256 Currentprice, uint256 ETHprice, uint256 ICOprice, uint256 endtime); event onHoldAirdrop (address indexed hodler, address indexed tokenAddress, uint256 HPMstatus, uint256 d1, uint256 d2, uint256 d3,uint256 endtime); event onHoldDeposit (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onHoldWithdraw (address indexed hodler, address indexed tokenAddress, uint256 amount, uint256 endtime); event onUtilitySetting (address indexed hodler, address indexed tokenAddress, address indexed pwt, uint256 amount, uint256 ustatus, uint256 endtime); event onUtilityStatus (address indexed hodler, address indexed tokenAddress, uint256 ustatus, uint256 endtime); event onUtilityBurn (address indexed hodler, address indexed tokenAddress, uint256 uamount, uint256 bamount, uint256 endtime); struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; uint256 tokendecimal; uint256 startime; }",1
0xdc24f9cc79f802587b56f27a7db0833e40c8a22c.sol,FuckCoin,contract FuckCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ExyToken,"contract ExyToken is ERC223MintableToken, SignatoryPausable { using SafeMath for uint256; VestingAllocation private partnerTokensAllocation; VestingAllocation private companyTokensAllocation; BountyTokenAllocation private bountyTokensAllocation; uint256 private constant ICO_TOKENS = 14503506112248500000000000; address private constant ICO_TOKENS_ADDRESS = 0x97c967524d1eacAEb375d4269bE4171581a289C7; uint256 private constant SEED_TOKENS = 11700000000000000000000000; address private constant SEED_TOKENS_ADDRESS = 0x7C32c7649aA1335271aF00cd4280f87166474778; uint256 private constant COMPANY_TOKENS_PER_PERIOD = 727875169784680000000000; uint256 private constant COMPANY_PERIODS = 36; uint256 private constant MINUTES_IN_COMPANY_PERIOD = 60 * 24 * 365 / 12; uint256 private constant PARTNER_TOKENS_PER_PERIOD = 23821369192953200000000000; uint256 private constant PARTNER_PERIODS = 1; uint256 private constant MINUTES_IN_PARTNER_PERIOD = MINUTES_IN_COMPANY_PERIOD * 18; uint256 private constant BOUNTY_TOKENS = 2382136919295320000000000; uint256 private constant MARKETING_COST_TOKENS = 794045639765106000000000; address private constant MARKETING_COST_ADDRESS = 0xF133ef3BE68128c9Af16F5aF8F8707f7A7A51452; uint256 public INIT_DATE; string public constant name = ; bytes32 public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = ( COMPANY_TOKENS_PER_PERIOD * COMPANY_PERIODS + PARTNER_TOKENS_PER_PERIOD * PARTNER_PERIODS + BOUNTY_TOKENS + MARKETING_COST_TOKENS + ICO_TOKENS + SEED_TOKENS); function ExyToken(address signatory0, address signatory1, address signatory2) SignatoryPausable(signatory0, signatory1, signatory2) public { INIT_DATE = block.timestamp; companyTokensAllocation = new VestingAllocation( COMPANY_TOKENS_PER_PERIOD, COMPANY_PERIODS, MINUTES_IN_COMPANY_PERIOD, INIT_DATE); partnerTokensAllocation = new VestingAllocation( PARTNER_TOKENS_PER_PERIOD, PARTNER_PERIODS, MINUTES_IN_PARTNER_PERIOD, INIT_DATE); bountyTokensAllocation = new BountyTokenAllocation( BOUNTY_TOKENS ); mint(MARKETING_COST_ADDRESS, MARKETING_COST_TOKENS); mint(ICO_TOKENS_ADDRESS, ICO_TOKENS); mint(SEED_TOKENS_ADDRESS, SEED_TOKENS); }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant PAYBACK_PERMILLE = 2; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee, uint _discount ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x41e8eedfbd7d8765d18ef82c9d21c07cb27382a6.sol,GSCToken,"contract GSCToken is ERC20, Ownable { using SafeMath for uint256; address public engDevAddress = 0x20d3596A9C0986995225770F95CCb4fB30411E33; address public engCommunityAddress = 0x20d3596A9C0986995225770F95CCb4fB30411E33; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0x190f064876450617ded5f66735b822c18ba26dd2.sol,Cookie,"contract CookieStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0xf0fb984b464cdb7cbef0cc7222018bbba7f9e97e.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xedac0e5bedf702accc3a9b2b4b44b4ba0806e882.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x365845f52cae20676e7b86ecffe1afa91e45fb9a.sol,Adwardcoin,"contract Adwardcoin is PausableToken, BurnableToken { string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; uint256 constant TOKEN_UNIT = 10 ** uint256(decimals); uint256 constant INITIAL_SUPPLY = 3000000000 * TOKEN_UNIT; function Adwardcoin() public { paused = true; totalSupply = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY; }",1
0x185c5cef4b4659f025e258bf385a0b444d33077b.sol,YEYE,contract YEYE is ERC223 { using SafeMath for uint256; using SafeMath for uint; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; address[] StoreWelfareAddress; mapping (address => string) StoreWelfareDetails; address public OrganizationAddress; string internal constant _name = ; string internal constant _symbol = ; uint8 internal constant _decimals = 8; uint256 internal _totalSupply = 2000000000e8; uint256 internal StartEth = 1e16; uint256 private RandNonce; uint256 public Organization = _totalSupply.div(100).mul(5); uint256 public totalRemaining = _totalSupply; uint256 public totalDistributed = 0; uint256 public EthGet=1500000e8; uint256 public Send0GiveBase = 3000e8; bool internal EndDistr = false; bool internal EndSend0GetToken = false; bool internal EndEthGetToken = false; bool internal CanTransfer = true; bool internal EndGamGetToken = false; modifier canDistr() { require(!EndDistr); _; },1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterAuctionBase,contract MonsterAuctionBase { MonsterOwnership public nonFungibleContract; ChainMonstersCore public core; struct Auction { address seller; uint256 price; uint64 startedAt; uint256 id; },1
0x886fd5e16d39e062a38c4cbf7c39f65fbe4cfd4d.sol,CryptoCaps,"contract CryptoCaps is ERC721Token, Ownable { event BoughtToken(address indexed buyer, uint256 tokenId); uint8 constant TITLE_MIN_LENGTH = 1; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MIN_LENGTH = 1; uint256 constant DESCRIPTION_MAX_LENGTH = 10000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescription; constructor() ERC721Token(, ) public { }",1
0x1d72347bfc99b65a61ecf464676994ef725e3294.sol,StandardToken,contract StandardToken is ERC20Token{ string public version = ; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public transfersEnabled = true; modifier transable(){ require(transfersEnabled); _; },1
0x1e5cbdf415dc6a762ad4ded7743aa9fe0837ff9e.sol,HKIN,"contract HKIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HKIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x876617584678d5b9a6ef93eba92b408367d9457c.sol,DetherAccessControl,contract DetherAccessControl { event ContractUpgrade(address newContract); address public ceoAddress; address public cmoAddress; address public csoAddress; address public cfoAddress; mapping (address => bool) public shopModerators; mapping (address => bool) public tellerModerators; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x402da6684017b62bac0e13efa34be5cc55e0a855.sol,GACC,"contract GACC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 8; function GACC() public { owner = msg.sender; totalSupply=150000000000000000; balances[owner]=totalSupply; }",1
0x748c6ed3f78f5f06ceb76834f195d3a05b7d628a.sol,POWH33,contract POWH33 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x70d981358efe83d97d4d51d8c9958e00aa49f672.sol,Controlled,contract Controlled is Owned { bool public transferEnabled = true; bool public lockFlag = true; constructor() public { setExclude(msg.sender); },1
0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,Zethr,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x33cf13763ffe1606783b0f63d9e0dff3d7b80bbc.sol,ChargeNetwork,"contract ChargeNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,UltimateCoin,"contract UltimateCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UltimateCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x54053ea92b9366182dbbf3e4583c8a5496bb2903.sol,CCD_KOHLE_3_20190411,"contract CCD_KOHLE_3_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xef69369f6ed0b0e3551f45efa942b164fdff81ea.sol,WSPXCrowdsale,"contract WSPXCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; uint256 public rate = 312500; mapping (address => uint256) public deposited; mapping (address => bool) internal isRefferer; uint256 public weiMinSale = 0.1 ether; uint256 public constant INITIAL_SUPPLY = 9 * 10**9 * (10 ** uint256(decimals)); uint256 public fundForSale = 6 * 10**9 * (10 ** uint256(decimals)); uint256 public fundTeam = 1 * 10**9 * (10 ** uint256(decimals)); uint256 public fundBounty = 2 * 10**9 * (10 ** uint256(decimals)); address public addressFundTeam = 0xA2434A8F6457fe7CF29AEa841cf3D0B0FE3217c8; address public addressFundBounty = 0x8828c48DEc2764868aD3bBf7fE9e8aBE773E3064; uint256 startTimeIcoStage1 = 1546300800; uint256 endTimeIcoStage1 = 1547596799; uint256 startTimeIcoStage2 = 1547596800; uint256 endTimeIcoStage2 = 1548979199; uint256 startTimeIcoStage3 = 1548979200; uint256 endTimeIcoStage3 = 1554076799; uint256 limitStage1 = 2 * 10**9 * (10 ** uint256(decimals)); uint256 limitStage2 = 4 * 10**9 * (10 ** uint256(decimals)); uint256 limitStage3 = 6 * 10**9 * (10 ** uint256(decimals)); uint256 public countInvestor; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(address indexed sender, uint256 tokenRaised, uint256 purchasedToken); event CurrentPeriod(uint period); event ChangeTime(address indexed owner, uint256 newValue, uint256 oldValue); event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress); event ChangeRate(address indexed owner, uint256 newValue, uint256 oldValue); event Burn(address indexed burner, uint256 value); event HardCapReached(); constructor(address _owner, address _wallet) public Crowdsale(_wallet) { require(_owner != address(0)); owner = _owner; transfersEnabled = true; mintingFinished = false; totalSupply = INITIAL_SUPPLY; bool resultMintForOwner = mintForFund(owner); require(resultMintForOwner); }",1
0x69baeddcf90c95a4d81002de6a669c7b993139d4.sol,ZenswapContributeTest,contract ZenswapContributeTest is Ownable { address public beneficiary; uint256 public amountTokensPerEth = 200000000; uint256 public amountEthRaised = 0; uint256 public availableTokens; token public tokenReward; mapping(address => uint256) public balanceOf; constructor() public { beneficiary = msg.sender; tokenReward = token(0xbaD16E6bACaF330D3615539dbf3884836071f279); },1
0x3658e756e02c1515cd04a27bcab5281e3db06d7a.sol,StableCurrencyToken,"contract StableCurrencyToken is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function StableCurrencyToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public { _totalSupply = _initialSupply; name = _name; symbol = _symbol; decimals = _decimals; balances[owner] = _initialSupply; deprecated = false; }",1
0xa3d48af5b7541658e7b663905f11433f1b4074f5.sol,OysterPearl,"contract OysterPearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public funds = 0; address public owner; bool public saleClosed = false; bool public ownerLock = false; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed payout, address indexed fee); function OysterPearl() public { owner = msg.sender; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); }",1
0x3a299ceb5fcc7784dd25e56be826c77f96275deb.sol,CryptoT,"contract CryptoT is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; uint256 private constant PROMO_CREATION_LIMIT = 50000; mapping (uint256 => address) public teamIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public teamIndexToApproved; mapping (uint256 => uint256) private teamIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount = 0; struct Team { string name; }",1
0xdb9dfb67c6388291476b0c1db3b59838c447e1ec.sol,BasicToken,contract BasicToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; modifier nonZeroEth(uint _value) { require(_value > 0); _; },1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0xf463434733b26c6f5e79eb9dbde4b508dedda95c.sol,ScudoCash,contract ScudoCash is IERC20{ using SafeMath for uint256; uint256 private _totalSupply = 0; bool public purchasingAllowed = true; bool private bonusAllowed = true; string public constant symbol = ; string public constant name = ; uint256 public constant decimals = 18; uint256 private CREATOR_TOKEN = 3100000000 * 10**decimals; uint256 private CREATOR_TOKEN_END = 465000000 * 10**decimals; uint256 private constant RATE = 100000; uint constant LENGHT_BONUS = 5 * 1 days; uint constant PERC_BONUS = 100; uint constant LENGHT_BONUS2 = 7 * 1 days; uint constant PERC_BONUS2 = 30; uint constant LENGHT_BONUS3 = 7 * 1 days; uint constant PERC_BONUS3 = 30; uint constant LENGHT_BONUS4 = 7 * 1 days; uint constant PERC_BONUS4 = 20; uint constant LENGHT_BONUS5 = 7 * 1 days; uint constant PERC_BONUS5 = 20; uint constant LENGHT_BONUS6 = 7 * 1 days; uint constant PERC_BONUS6 = 15; uint constant LENGHT_BONUS7 = 7 * 1 days; uint constant PERC_BONUS7 = 10; uint constant LENGHT_BONUS8 = 7 * 1 days; uint constant PERC_BONUS8 = 10; uint constant LENGHT_BONUS9 = 7 * 1 days; uint constant PERC_BONUS9 = 5; uint constant LENGHT_BONUS10 = 7 * 1 days; uint constant PERC_BONUS10 = 5; address private owner; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; uint private start; uint private end; uint private end2; uint private end3; uint private end4; uint private end5; uint private end6; uint private end7; uint private end8; uint private end9; uint private end10; struct Buyer{ address to; uint256 value; },1
0x1777b7b44757a2c606953f5eab3396650b6e6ddc.sol,DCS,"contract DCS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 80000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 0e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xce9ecc71e134a4d2d36a8258082eeab6d1318da7.sol,Alpon,"contract Alpon is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 10e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function Alpon() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x201ec0bcc05d43c44a05836c6d5ce42e93cceccc.sol,ReleaseToken,contract ReleaseToken is OwnerContract { using SafeMath for uint256; struct TimeRec { uint256 amount; uint256 remain; uint256 endTime; uint256 releasePeriodEndTime; },1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x65514cd2d795d535a7bec8e0a08f43453fa26118.sol,BiLinkLoan,"contract BiLinkLoan is Ownable { using SafeMath for uint256; address public contractLoanLogic; address public contractBalance; address public contractMarketData; address public accountCost; uint256 public commissionRatio; mapping (address => mapping ( bytes32 => uint256)) public account2Order2TradeAmount; mapping (address => uint16) public token2PledgeRatio; bool public isLegacy; event OnTrade(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountInterest, uint256 amountBorrow, uint256 timestamp); event OnUserRepay(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountOriginInterest, uint256 amountActualInterest , uint256 amountRepaied, uint256 amountRepaiedPledgeToken, uint256 timestamp); event OnForceRepay(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountOriginInterest, uint256 amountActualInterest , uint256 amountRepaied, uint256 amountRepaiedPledgeToken, uint256 timestamp); event OnLossCompensated(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountLoss, uint256 amountCompensated, uint256 timestamp); event OnLossCompensatedByAssurance(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountLoss, uint256 amountCompensated, uint256 timestamp); constructor(address _owner, address _accountCost, address _contractLoanLogic, address _contractMarketData, uint256 _commissionRatio) public Ownable(_owner) { contractLoanLogic= _contractLoanLogic; contractMarketData= _contractMarketData; isLegacy= false; commissionRatio= _commissionRatio; accountCost= _accountCost; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,AdvHajjToken,"contract AdvHajjToken is owned, HajjERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) HajjERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,KydyAccessControl,contract KydyAccessControl { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x008faf03038c810e478013d85659e25199a79e77.sol,Simple_Options_v3,"contract Simple_Options_v3 { address public feeAddress; uint256 public feePercent = 5000; uint256 constant roundCutoff = 1800; uint256 constant roundLength = 3600; address constant compoundOracleProxy = 0x2C9e6BDAA0EF0284eECef0e0Cc102dcDEaE4887e; address constant cUSDCAddress = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; enum RoundStatus { OPEN, CLOSED, STALEPRICE, NOCONTEST }",1
0x1beef31946fbbb40b877a72e4ae04a8d1a5cee06.sol,Parachute,"contract Parachute is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Parachute() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x496E0Fb39D646a4Be80e85844d355d38F7570417] = _totalSupply; Transfer(address(0), 0x496E0Fb39D646a4Be80e85844d355d38F7570417, _totalSupply); }",1
0x5c26e6b2d1506e4e08039d4e1934cf425c611f63.sol,YUNLAI,contract YUNLAI is ERC20{ string public constant name = ; string public constant symbol = ; string public version = ; uint256 public constant decimals = 18; uint256 public totalSupply = 1500000000000000000000000000; address public owner; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; },1
0x72b825163fe0710a91272cb1b2593553be463d4b.sol,ERC20,contract ERC20 is IERC20{ using SafeMath for uint; mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal totalSupply_; function totalSupply() external view returns (uint) { return totalSupply_; },1
0xf3871f565a6a216fbe0ea3cf806ab15a32830c1c.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint8 public decimals = 5; uint256 public totalSupply_; constructor() public { totalSupply_ = 10000000000 * 10 ** uint256(decimals); balances[msg.sender] = totalSupply_ ; },1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x523630976eb6147621b5c31c781ebe2ec2a806e0.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 14 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdateTime; uint public stalePeriod = 60 minutes; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint _initialEtherPrice, address _owner, TokenState _initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, _initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = _initialEtherPrice; lastPriceUpdateTime = now; emit PriceUpdated(_initialEtherPrice); frozen[this] = true; }",1
0xedeab579e57a7d66297d0a67302647bb109db7a8.sol,BreakTheBank,contract BreakTheBank { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x5b7e1eb8623e7d71572254b92dff0c5ac5d21950.sol,YoobaICO,"contract YoobaICO is Owned,YooStop,Utils { IERC20Token public yoobaTokenAddress; uint256 public startICOTime = 0; uint256 public endICOTime = 0; uint256 public leftICOTokens = 0; uint256 public tatalEthFromBuyer = 0; uint256 public daysnumber = 0; mapping (address => uint256) public pendingBalanceMap; mapping (address => uint256) public totalBuyMap; mapping (address => uint256) public totalBuyerETHMap; mapping (uint256 => uint256) public daySellMap; mapping (address => uint256) public withdrawYOOMap; uint256 internal milestone1 = 4000000000000000000000000000; uint256 internal milestone2 = 2500000000000000000000000000; uint256 internal dayLimit = 300000000000000000000000000; bool internal hasInitLeftICOTokens = false; function YoobaICO(IERC20Token _yoobaTokenAddress) public{ yoobaTokenAddress = _yoobaTokenAddress; }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0x1e2d6ca17730e657f6ef0446126d5ae2869ee8d9.sol,MESSIToken,contract MESSIToken is ERC20 { using SafeMath for uint256; address public messiDev = 0xFf80AF92f137e708b6A20DcFc1af87e8627313B8; address public messiCommunity = 0xC2fe05066985385aa49B85697ff5847F43F26B7A; struct TokensWithLock { uint256 value; uint256 blockNumber; },1
0x712f0350df4f56fad07bd5e2c74941cc30c5df88.sol,DTCC_ILOW_3,contract DTCC_ILOW_3 { address owner ; function DTCC_ILOW_2 () public { owner = msg.sender; },1
0x4b93ff6695a76553cc50dae06ece3576723f0cc2.sol,NOITA,"contract NOITA is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event TransferEnabled (bool); event TransferDisabled (bool); function NOITA( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {TransferAllowed = true;}",1
0x70314cdf964596124f12fa8bd60e5e4668ec75cd.sol,H3D,contract H3D { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4ee1ba168551379fd8a59e2e918ff9ee109a6abf.sol,PlayerBook,"contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private owner; TeamDreamHubInterface public TeamDreamHub_; TeamDreamInterface public TeamDream_; MSFun.Data private msData; function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamDream_.requiredDevSignatures(), _whatFunction));}",1
0x2aec18c5500f21359ce1bea5dc1777344df4c0dc.sol,TokenVesting,"contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; }",1
0x5155a0722a45905dacf49598a02eff3777340acd.sol,SecurityToken,"contract SecurityToken is StandardToken, DetailedERC20, ReentrancyGuard, RegistryUpdater { using SafeMath for uint256; TokenLib.InvestorDataStorage investorData; struct SemanticVersion { uint8 major; uint8 minor; uint8 patch; }",1
0xe000cd29eb1f596f4fc1d9873eb1618cd3846f08.sol,Vote,contract Vote { using SafeMath for uint256; struct Proposal { uint deadline; mapping(address => uint) votes; uint yeas; uint nays; string reason; bytes data; address target; },1
0x0dc6a7d4b4f3165abbae838bf9d51e6c0993cb6f.sol,SafeMath,"contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a, ); }",1
0x5136c98a80811c3f46bdda8b5c4555cfd9f812f0.sol,IndaHashToken,"contract IndaHashToken is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510153200; uint public constant DATE_PRESALE_END = 1510758000; uint public constant DATE_ICO_START = 1511967600; uint public constant DATE_ICO_END = 1513782000; uint public tokensPerEth = 3200 * E6; uint public constant BONUS_PRESALE = 40; uint public constant BONUS_ICO_WEEK_ONE = 20; uint public constant BONUS_ICO_WEEK_TWO = 10; uint public constant TOKEN_SUPPLY_TOTAL = 400 * E6 * E6; uint public constant TOKEN_SUPPLY_ICO = 320 * E6 * E6; uint public constant TOKEN_SUPPLY_MKT = 80 * E6 * E6; uint public constant PRESALE_ETH_CAP = 15000 ether; uint public constant MIN_FUNDING_GOAL = 40 * E6 * E6; uint public constant MIN_CONTRIBUTION = 1 ether / 2; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 90 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function IndaHashToken() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0xf1c91ad5d541567eb90a8a56373556a851a53e12.sol,Jancok,contract Jancok is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; function Jancok() public { totalSupply_ = 3000000 * 1 ether; balances[msg.sender] = totalSupply_; },1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x051f73eaf3f93b0b5440cc1381cb604f1457a6d1.sol,HOPE,"contract HOPE is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26c7bdd051318b48092390eabd1b69fce5080b25.sol,CETH,"contract CETH is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 500000000e18; uint256 public totalDistributed = 350000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 4000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0xece98191b6812d86af4cd6dc654dab4a23c96446.sol,TestTokenTen,contract TestTokenTen is StandardToken { function () { revert(); },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,OwnerContract,contract OwnerContract is Claimable { Claimable public ownedContract; address internal origOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); origOwner = ownedContract.owner(); ownedContract.claimOwnership(); return true; },1
0x5b6acebad8f9e969d54bbe7c6efdc8674f8c7e76.sol,GemstoneToken,"contract GemstoneToken is owned, SafeMath { string public EthernetCashWebsite = ""https: address public EthernetCashAddress = this; address public creator = msg.sender; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 19999999986000000000000000000; uint256 public buyPrice = 18000000; uint256 public sellPrice = 18000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function GemstoneToken() public { balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x5b5afaa565aba14833de0cee321e63a807fd407b.sol,TulipMania,"contract TulipMania is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510758000; uint public constant DATE_PRESALE_END = 1511362800; uint public constant DATE_ICO_START = 1511362801; uint public constant DATE_ICO_END = 1513868400; uint public tokensPerEth = 336 * E6; uint public constant BONUS_PRESALE = 100; uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; uint public constant TOKEN_SUPPLY_ICO = 8500000 * E6; uint public constant TOKEN_SUPPLY_MKT = 1500000 * E6; uint public constant PRESALE_ETH_CAP = 750 ether; uint public constant MIN_CONTRIBUTION = 1 ether / 500; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 2 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function TulipMania() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0x4d73a6a5698990a01b6e526b73fceb0efbbfd159.sol,FAFA,"contract FAFA is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function FAFA(address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x74f7dca757597a5a9293c73895893fd2c295c5b6.sol,MinerX,"contract MinerX is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 2 * 10**9 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function MinerX() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x26d76a22859fec45da123dbf3e14053a8b5b0831.sol,FullFOMO,"contract FullFOMO is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5A3e43Ba22D1590C21ecB364f8fb46c17d683364); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 10 minutes; uint256 private rndGap_ = 10 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 22 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(60,0); fees_[1] = F3Ddatasets.TeamFee(60,0); fees_[2] = F3Ddatasets.TeamFee(60,0); fees_[3] = F3Ddatasets.TeamFee(60,0); potSplit_[0] = F3Ddatasets.PotSplit(25,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(25,0); potSplit_[3] = F3Ddatasets.PotSplit(25,0); }",1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xb3e9446e0d08b1124abba9f2e38787adf54373a9.sol,TimedCrowdsale,contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(now >= openingTime && now <= closingTime); _; },1
0x9122213da10c92586c2c99e533cd97726ef55d6a.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x5697611721e7d48f38d0cb47d4fe4d0fee336f0a.sol,LifeSet_008,contract LifeSet_008 { address owner ; function detOwner () public { owner = 0x694f59266d12e339047353a170e21233806ab900 ; },1
0x1dcadad44aa14154e2393d83edf6c7c6f83cb795.sol,DoggyEthPics,"contract DoggyEthPics is ERC721, Ownable { event DoggyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public doggyIdToOwner; mapping (uint256 => address) public doggyIdToDivs; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public doggyIdToApproved; mapping (uint256 => uint256) private doggyIdToPrice; struct Doggy { string name; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,PreSaleGuardian,"contract PreSaleGuardian is PreSaleCastle { event GuardianSaleCreate(uint indexed saleId, uint indexed guardianId, uint indexed price, uint race, uint level, uint starRate); event BuyGuardian(uint indexed saleId, uint guardianId, address indexed buyer, uint indexed currentPrice); event GuardianOfferSubmit(uint indexed saleId, uint guardianId, address indexed bidder, uint indexed price); event GuardianOfferAccept(uint indexed saleId, uint guardianId, address indexed newOwner, uint indexed newPrice); event SetGuardianSale(uint indexed saleId, uint indexed price); event GuardianAuctionCreate(uint indexed auctionId, uint indexed guardianId, uint indexed startPrice, uint race, uint level, uint starRate); event GuardianAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer); event VendingGuardian(uint indexed vendingId, address indexed buyer); event GuardianVendOffer(uint indexed vendingId, address indexed bidder, uint indexed offer); event GuardianVendAccept(uint indexed vendingId, address indexed newOwner, uint indexed newPrice); event SetGuardianVend(uint indexed priceId, uint indexed price); mapping (uint => address) public GuardianSaleToBuyer; mapping (uint => uint) public GuardianVendToOffer; mapping (uint => address) public GuardianVendToBidder; mapping (uint => uint) public GuardianVendToTime; struct GuardianSale { uint guardianId; uint race; uint starRate; uint level; uint price; bool ifSold; address bidder; uint offerPrice; uint timestamp; }",1
0x4b3b99e956588b54f5841f2fb7c63721e6c7c392.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0xd954af8b5559e188096afb11643111458b29cebf.sol,POEXToken,contract POEXToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x86e92c595de61fd22c0f0a0458c6eaa63d0b06ef.sol,FreezableToken,"contract FreezableToken is BasicToken { mapping (address => uint256) freezes; event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function freeze(uint256 _value) public returns (bool success) { require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); freezes[msg.sender] = freezes[msg.sender].add(_value); emit Freeze(msg.sender, _value); return true; }",1
0x35bc3bdc0da41b005c0a5ea342d212dcd77053c2.sol,CollectionToken,"contract CollectionToken is owned, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 0; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 18; }",1
0x260cc4d721112a1b49ad2a84cee2b05e38a556fc.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256[2][]) public frozens; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; name = ; symbol = ; }",1
0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol,BATMO,"contract BATMO is FOMOEvents { using SafeMath for *; using NameFilter for string; using KeysCalc for uint256; PlayerBookInterface private PlayerBook; OBOK public ObokContract; address private admin = msg.sender; address private admin2; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 2 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => BATMODatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => BATMODatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => BATMODatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => BATMODatasets.TeamFee) public fees_; mapping (uint256 => BATMODatasets.PotSplit) public potSplit_; constructor(address otherAdmin, address token, address playerbook) public { admin2 = otherAdmin; ObokContract = OBOK(token); PlayerBook = PlayerBookInterface(playerbook); fees_[0] = BATMODatasets.TeamFee(47,10); potSplit_[0] = BATMODatasets.PotSplit(15,10); }",1
0x864def510d754df9c1d43b925dd9887baa5acb07.sol,MyToken,"contract MyToken is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 _totalSupply; uint256 public amountRaised = 0; uint256 public amountOfTokensPerEther = 500; mapping (address => bool) public frozenAccounts; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) _allowance; bool public crowdsaleClosed = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); function MyToken() { _balanceOf[msg.sender] = 4000000000000000000000; _totalSupply = 4000000000000000000000; Transfer(this, msg.sender,4000000000000000000000); }",1
0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15.sol,EGFToken,"contract EGFToken is ERC20, owned { mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor () ERC20() public { }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x33848f45565259809a4aaaf44d49cba6b7573021.sol,NotesharesCatalog,"contract NotesharesCatalog is Authorizable { address[] public tokens; mapping (address => bool) public banned; event tokenAdded (address tokenAddress); event permissionChanged (address tokenAddress, bool permission); function getTokens () public view returns(address[]) { return tokens; }",1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6dd5b09acda78b05d0356483fe05eb0768352945.sol,SponseeTokenModelSolaCoin,"contract SponseeTokenModelSolaCoin is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public totalSupply = 500000000 * (10 ** uint256(decimals)); uint public cap = 1000000000 * (10 ** uint256(decimals)); uint public minimumSupport = 500; uint public etherRatioForInvestor = 10; address public sponseeAddress; bool public isPayableEnabled = true; RBInformationStore public rbInformationStore; Rate public rate; event LogReceivedEther(address indexed from, address indexed to, uint etherValue, string tokenName); event LogBuy(address indexed from, address indexed to, uint indexed value, uint paymentId); event LogRollbackTransfer(address indexed from, address indexed to, uint value); event LogExchange(address indexed from, address indexed token, uint value); event LogIncreaseCap(uint value); event LogDecreaseCap(uint value); event LogSetRBInformationStoreAddress(address indexed to); event LogSetName(string name); event LogSetSymbol(string symbol); event LogMint(address indexed to, uint value); event LogChangeSponseeAddress(address indexed to); event LogChangeIsPayableEnabled(bool flag); modifier onlyAccountAddressForSponsee() { require(rbInformationStore.accountAddressForSponsee() == msg.sender); _; }",1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,TokenVault,"contract TokenVault is Controlled { using SafeMath for uint256; TokenCampaign campaign; uint256 tDuration; uint256 tLock = 12 * 30 * (1 days); MiniMeToken token; uint256 extracted = 0; event Extract(address indexed _to, uint256 _amount); function TokenVault( address _tokenAddress, address _campaignAddress, uint256 _tDuration ) { require( _tDuration > 0); tDuration = _tDuration; token = RealistoToken(_tokenAddress); campaign = TokenCampaign(_campaignAddress); }",1
0xa2bcf0e52e5b1431699cba1b65f3d9754b3498f2.sol,bestmoneygroup,contract bestmoneygroup { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3aa343d578050e333676b560f6465fa181c02edf.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x063425e215701d2761a9065e647fa98f209b4ddd.sol,MavinToken,"contract MavinToken is MintableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public creator; function MavinToken() public Ownable() MintableToken() PausableToken() { creator = msg.sender; paused = true; }",1
0x0000000000075efbee23fe2de1bd0b7690883cc9.sol,OwnedUpgradeabilityProxy,"contract OwnedUpgradeabilityProxy is UpgradeabilityProxy { event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner); event NewPendingOwner(address currentOwner, address pendingOwner); bytes32 private constant proxyOwnerPosition = keccak256(); bytes32 private constant pendingProxyOwnerPosition = keccak256(); constructor() public { _setUpgradeabilityOwner(msg.sender); }",1
0x3714beb09377a27b81ade094a92be7f56445332e.sol,GoldVein,contract GoldVein is ERC223Token{ modifier onlyAgent() { bool flag = false; for(uint i = 0; i < addrCotracts.length; i++) { if(msg.sender == addrCotracts[i]) flag = true; },1
0x33540976411534a8d96c715a4ff7f4392d2e52d1.sol,POWHclone,"contract POWHclone { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); address owner; function POWHclone() public { owner = msg.sender; }",1
0x6ba29728e955ff970c94d7ab0a4ff17c628f325a.sol,EdgelessCasino,"contract EdgelessCasino is CasinoBank{ mapping(address => State) public lastState; event StateUpdate(address player, uint128 count, int128 winBalance, int difference, uint gasCost); event GameData(address player, bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint gasCost); struct State{ uint128 count; int128 winBalance; }",1
0xec7ba74789694d0d03d458965370dc7cf2fe75ba.sol,HBToken,"contract HBToken is splitableToken{ uint8 public decimals = 2; string public name = ; string public symbol = ; bool public locked = false; constructor() public { uint _initialSupply = 60000000; _balances[msg.sender] = _initialSupply; _totalSupply = _initialSupply; emit Transfer(address(this),msg.sender,_initialSupply); }",1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Auction,contract Auction is Beneficial { function Auction(address _gameToken) public { owner = msg.sender; shareholder = _gameToken; shareholderIsToken = true; },1
0x656038e97cee7c095673f7b9fad695b323a6f098.sol,WheelOf0xBitcoin,contract WheelOf0xBitcoin { using SafeMath for uint; modifier nonContract() { require(tx.origin == msg.sender); _; },1
0x1b332629b45136a3614fafcd927c8ea31d7cd717.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x411a81c8cd604941be13dbbd33b54e6f25d84683.sol,LetsfairToken,"contract LetsfairToken is SchedulableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address _beneficiary = 0xe0F158B382F30A1eccecb5B67B1cf7EB92B5f1E4; uint256 _maxSupply = 10 ** 27; uint256 _duration = 157788000; function LetsfairToken() SchedulableToken(_beneficiary, _maxSupply, _duration) public {}",1
0x6abf810730a342add1374e11f3e97500ee774d1f.sol,BCFAuction,contract BCFAuction is Pausable { struct CardAuction { address seller; uint128 startPrice; uint128 endPrice; uint64 duration; uint64 startedAt; },1
0x6c70879f56427b8c511e196c44ff05333a533987.sol,Cryptowealth,contract Cryptowealth is StandardToken { function () { throw; },1
0x0d409bcc1b0212348b9404e01599b843f44dd6c4.sol,VIDEX,"contract VIDEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 9000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 30000; uint256 public tokensPer2Eth = 35000; uint256 public tokensPer3Eth = 40000; uint256 public startPase = 1541548800; uint public maxPhase1 = 875000000e8; uint public maxPhase2 = 1750000000e8; uint public maxPhase3 = 2685000000e8; uint public currentPhase = 0; uint public soldPhase1 = 0; uint public soldPhase2 = 0; uint public soldPhase3 = 0; uint256 public pase1 = startPase + 1 * 30 days; uint256 public pase2 = pase1 + 1 * 30 days; uint256 public pase3 = pase2 + 1 * 30 days; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event StartPaseUpdated(uint256 _time); event TokensPerEthUpdated(uint _tokensPerEth); event TokensPerEth2Updated(uint _tokensPerEth); event TokensPerEth3Updated(uint _tokensPerEth); event MaxPhase1Updated(uint _maxPhase1); event MaxPhase2Updated(uint _maxPhase2); event MaxPhase3Updated(uint _maxPhase3); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xb402be8db1d9eb2beedfe2c8a6c38a604e9f13c6.sol,depositofferToken,contract depositofferTokenConfig { string public name = ; string public symbol = ; address public owner = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; address public fundWallet = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; uint public constant TOKENS_PER_USD = 2; uint public constant USD_PER_ETH = 800; uint public constant MIN_USD_FUND = 1; uint public constant MAX_USD_FUND = 2000000; uint public constant KYC_USD_LMT = 50000; uint public constant MAX_TOKENS = 4000000; uint public constant START_DATE = 1520776337; uint public constant FUNDING_PERIOD = 180 days; },1
0x1d556d7fb1af721da8b9c30d44f6d4a52f8e0ba2.sol,Token,"contract TokenI is ERC20Token { string public name; uint8 public decimals; string public symbol; function approveAndCall( address _spender, uint256 _amount, bytes _extraData ) public returns (bool success); function generateTokens(address _owner, uint _amount) public returns (bool); function destroyTokens(address _owner, uint _amount) public returns (bool); }",1
0x8d3bf3f8ad4b19d3143a24aeb953315609acb083.sol,EnterpriseCerditPass,"contract EnterpriseCerditPass { using SafeMath for uint256; address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x33f00114d5aca3dee03189d4ed9d4f886dad84b0.sol,PonziToken,"contract PonziToken { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function PonziToken() public { }",1
0x36e666eaac18ed22b8e370547c75e6782b63d5da.sol,Token,"contract Token { using SafeMath for uint256; address public owner; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 totalSupply_ = 20e8 * (10**18); bool public paused = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => uint256) internal locked; event Burn(address indexed burner, uint256 value); event Approval(address indexed owner, address indexed spender,uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Pause(); event Unpause(); event Lock(address indexed LockedAddress, uint256 LockAmount); event Unlock(address indexed LockedAddress); constructor() public { owner = msg.sender; balances[owner] = totalSupply_ ; }",1
0x4d807509aece24c0fa5a102b6a3b059ec6e14392.sol,MenloTokenReceiver,contract MenloTokenReceiver { MenloToken token; constructor(MenloToken _tokenContract) public { token = _tokenContract; },1
0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68.sol,ERC721,"contract ERC721 is ERC165, IERC721 { using SafeMath for uint256; using Address for address; bytes4 private constant _ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) private _tokenOwner; mapping (uint256 => address) private _tokenApprovals; mapping (address => uint256) private _ownedTokensCount; mapping (address => mapping (address => bool)) private _operatorApprovals; bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd; constructor() public { _registerInterface(_InterfaceId_ERC721); }",1
0x568a693e1094b1e51e8053b2fc642da7161603f5.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd07d571e0a45306350c005f5ed858783ae725d71.sol,OreOreCoin,"contract OreOreCoin is Owned{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => int8) public blackList; mapping (address => Members) public members; event Transfer(address indexed from, address indexed to, uint256 value); event Blacklisted(address indexed target); event DeleteFromBlacklist(address indexed target); event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value); event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value); event Cashback(address indexed from, address indexed to, uint256 value); function OreOreCoin(uint256 _supply, string _name, string _symbol, uint8 _decimals) public { balanceOf[msg.sender] = _supply; name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _supply; }",1
0xddce0e2b03724ca8edf733e09b3d5a7ccc913c48.sol,BitcoinX,"contract BitcoinX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 100000000000e18; uint256 public tokenPerETH = 10000000e18; uint256 public valueToGive = 4000e18; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d6a0df44625d70587d971a592d10d9651e0c053.sol,Ignite,"contract Ignite is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed = 400000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 75000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc7a8bdeb5a2124805328bdbb2b93539cb49dc15c.sol,IBCLottery,"contract IBCLottery { uint256 private ticketPrice_; mapping(address => Ticket) internal ticketRecord_; Token public ibcToken_; address public officialWallet_; address public devATeamWallet_; address public devBTeamWallet_; uint256 public tokenRaised_; uint256 public actualTokenRaised_; mapping(address => uint256) public userPaidIn_; constructor( address _ibcoin, address _officialWallet, address _devATeamWallet, address _devBTeamWallet ) public { ibcToken_ = Token(_ibcoin); officialWallet_ = _officialWallet; devATeamWallet_ = _devATeamWallet; devBTeamWallet_ = _devBTeamWallet; }",1
0xda830afa460526071d3d149e898fead664f0a4bb.sol,TokenCampaign,contract TokenCampaign is Controlled { using SafeMath for uint256; eat_token_interface public token; uint8 public constant decimals = 18; uint256 public constant scale = (uint256(10) ** decimals); uint256 public constant hardcap = 100000000 * scale; uint256 public constant PRCT100_D_TEAM = 63; uint256 public constant PRCT100_R_TEAM = 250; uint256 public constant PRCT100_R2 = 150; uint256 public constant FIXEDREWARD_MM = 100000 * scale; uint256 public constant PRCT100_ETH_OP = 4000; uint256 public constant preCrowdMinContribution = (20 ether); uint256 public constant minContribution = (1 ether) / 100; uint256 public constant preCrowd_tokens_scaled = 7142857142857140000000; uint256 public constant stage_1_tokens_scaled = 6250000000000000000000; uint256 public constant stage_2_tokens_scaled = 5555555555555560000000; uint256 public constant stage_3_tokens_scaled = 5000000000000000000000; uint256 public constant PreCrowdAllocation = 20000000 * scale ; uint256 public constant Stage1Allocation = 15000000 * scale ; uint256 public constant Stage2Allocation = 15000000 * scale ; uint256 public constant Stage3Allocation = 20000000 * scale ; uint256 public tokensRemainingPreCrowd = PreCrowdAllocation; uint256 public tokensRemainingStage1 = Stage1Allocation; uint256 public tokensRemainingStage2 = Stage2Allocation; uint256 public tokensRemainingStage3 = Stage3Allocation; uint256 public maxPreCrowdAllocationPerInvestor = 20000000 * scale ; uint256 public maxStage1AllocationPerInvestor = 15000000 * scale ; uint256 public maxStage2AllocationPerInvestor = 15000000 * scale ; uint256 public maxStage3AllocationPerInvestor = 20000000 * scale ; uint256 public tokensGenerated = 0; address[] public joinedCrowdsale; uint256 public amountRaised = 0; uint256 public amountRefunded = 0; address public dteamVaultAddr1; address public dteamVaultAddr2; address public dteamVaultAddr3; address public dteamVaultAddr4; address public rteamVaultAddr; address public r2VaultAddr; address public mmVaultAddr; address public reserveVaultAddr; address public trusteeVaultAddr; address public opVaultAddr; address public tokenAddr; uint8 public campaignState = 3; bool public paused = false; uint256 public tCampaignStart = 64060588800; uint256 public t_1st_StageEnd = 5 * (1 days); uint256 public t_2nd_StageEnd = 2 * (1 days); uint256 public tCampaignEnd = 35 * (1 days); uint256 public tFinalized = 64060588800; struct ParticipantListData { bool participatedFlag; uint256 contributedAmountPreAllocated; uint256 contributedAmountPreCrowd; uint256 contributedAmountStage1; uint256 contributedAmountStage2; uint256 contributedAmountStage3; uint256 preallocatedTokens; uint256 allocatedTokens; uint256 spentAmount; },1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x012fdf3183798f902314dd1f633c7bc61777619d.sol,HNCToken,"contract HNCToken is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9.sol,EthFlip,contract EthFlip is usingOraclize { struct Bet { bool win; uint betValue; uint timestamp; address playerAddress; uint randomNumber; bool low; },1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x518e5a711cf84666b98dddb00a0d4a0a6c59955e.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,GenericCrowdsale,"contract GenericCrowdsale is Ownable { using SafeMath for uint256; enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}",1
0x12adf6e7bf0fb0fa050e8175723c4ae9c44c0603.sol,token,"contract token is Control, ERC20Token { using SafeMath for uint256; uint256 public totalSupply; uint256 public forSell; uint256 public decimals; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; string public symbol; string public name; constructor(string _name) public { owner = 0x60dc10E6b27b6c70B97d1F3370198d076F5A48D8; decimals = 18; totalSupply = 100000000000 * (10 ** decimals); name = _name; symbol = _name; forSell = 50000000000 * (10 ** decimals); balanceOf[owner] = totalSupply.sub(forSell); emit Transfer(0, owner, balanceOf[owner]); }",1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0xef19f4e48830093ce5bc8b3ff7f903a0ae3e9fa1.sol,botXcoin,"contract botXcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public holdAccount; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 5000000000e18; uint256 public totalDistributed = 0; uint256 public min_contribution = 1 ether / 100; uint256 public tokensPerEth = 10000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event ICO(address indexed _owner, uint _amount, uint _balance); event MinContributionUpdated(uint _mincontribution); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event HoldFunds(address target, bool hold); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1806b3527c18fb532c46405f6f014c1f381b499a.sol,ERC721Enumerable_custom,"contract ERC721Enumerable_custom is ERC165, ERC721_custom, IERC721Enumerable { mapping(address => uint256[]) private _ownedTokens; mapping(uint256 => uint256) private _ownedTokensIndex; uint256[] private _allTokens; mapping(uint256 => uint256) private _allTokensIndex; bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63; constructor() public { _registerInterface(_InterfaceId_ERC721Enumerable); }",1
0xf264b7cf707afc6cd9eeadd1d7a7b96ed5743d02.sol,Tokens,contract Tokens { struct Token { address _address; string _websiteUrl; },1
0x56434ad1e38a564e76eae08c7118e5e7b450aa6c.sol,PlayerToken,"contract PlayerToken is ERC20 { address public owner; bool public paused = false; event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol); event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol); using SafeMath for uint256; uint256 public initialTokenPrice_; uint256 public incrementalTokenPrice_; string public name; string public symbol; uint8 public constant decimals = 0; address public exchangeContract_; BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F); uint256 public playerId_; address public originalOwner_; uint8 constant internal processingFee_ = 5; uint8 constant internal originalOwnerFee_ = 2; uint8 internal dividendBuyPoolFee_ = 15; uint8 internal dividendSellPoolFee_ = 20; uint8 constant internal referrerFee_ = 1; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; address[] public tokenHolders; mapping(address => uint256) public addressToTokenHolderIndex; mapping(address => int256) public totalCost; uint256 totalSupply_; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,SupportsInterfaceWithLookup,contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) internal supportedInterfaces; constructor() public { _registerInterface(InterfaceId_ERC165); },1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) { uint len = (a.length <= b.length) ? a.length : b.length; for (uint i = 0; i < len; i++) { if (a[i] != b[i]) { return i; }",1
0xf04c744c90c1c91ce7ec4bfd3ce364ddc5b87f4e.sol,NNT,"contract NNT is SafeMath { string public constant standard = ; uint8 public constant decimals = 18; string public constant name = ; string public constant symbol = ; uint256 public totalSupply = 0.25 * 10**8 * 10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NNT() public { Transfer(0x00, msg.sender, totalSupply); balanceOf[msg.sender] = totalSupply; }",1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,SafeGuardsPreSale,"contract SafeGuardsPreSale is FinalizableCrowdsale, CappedCrowdsale { using SafeMath for uint256; uint256 public tokensSold; uint256 public minimumGoal; uint public loadedRefund; uint public weiRefunded; mapping (address => uint) public boughtAmountOf; uint256 constant public minimumAmountWei = 1e16; uint256 public presaleTransfersPaused = now + 180 days; uint256 public presaleBurnPaused = now + 180 days; uint constant public preSaleBonus1Time = 1535155200; uint constant public preSaleBonus1Percent = 25; uint constant public preSaleBonus2Time = 1536019200; uint constant public preSaleBonus2Percent = 15; uint constant public preSaleBonus3Time = 1536883200; uint constant public preSaleBonus3Percent = 5; uint constant public preSaleBonus1Amount = 155 * 1e15; uint constant public preSaleBonus2Amount = 387 * 1e15; uint constant public preSaleBonus3Amount = 1550 * 1e15; uint constant public preSaleBonus4Amount = 15500 * 1e15; address constant public w_futureDevelopment = 0x4b297AB09bF4d2d8107fAa03cFF5377638Ec6C83; address constant public w_Reserv = 0xbb67c6E089c7801ab3c7790158868970ea0d8a7C; address constant public w_Founders = 0xa3b331037e29540F8BD30f3DE4fF4045a8115ff4; address constant public w_Team = 0xa8324689c94eC3cbE9413C61b00E86A96978b4A7; address constant public w_Advisers = 0x2516998954440b027171Ecb955A4C01DfF610F2d; address constant public w_Bounty = 0x1792b603F233220e1E623a6ab3FEc68deFa15f2F; event AddBonus(address indexed addr, uint256 amountWei, uint256 date, uint bonusType); struct Bonus { address addr; uint256 amountWei; uint256 date; uint bonusType; }",1
0xef650b86c56519826664e20198ee8211616619da.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; address public wallet; FullERC20 public token; uint256 public rate; uint256 public weiRaised; uint256 public tokensPurchased; event TokenPurchased(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; token = FullERC20(_token); }",1
0xedd7868662f1ae17c53ddaea63469b4c1292ea7c.sol,NescrowExchangeService,"contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateMin = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => bool) public traded; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event TradesLock(address user); event TradesUnlock(address user); modifier onlyOwner { assert(msg.sender == owner); _; }",1
0xa42868496e6b98d655e4a820801d8df8f4abe2b3.sol,KJC,contract KJC { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply =2000000* (10 ** 18); uint256 public totaldivineTokensIssued = 0; address owner = msg.sender; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; bool public saleEnabled = true; uint256 public totalEthereumRaised = 0; uint256 public KJCPerEthereum = 10000; function KJC() public { balanceOf[owner] += totalSupply; },1
0xefa2e92ee2f5f8da00120a8ddec92bad2a5d9b96.sol,OnePieceGold,"contract OnePieceGold { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; bool setupDone = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function OnePieceGold(address adr) { owner = adr; }",1
0x559cd99b1eb1cd61224d9d2a9aec3f8634bfbef4.sol,GalaxyETH1vs1Jackpot,"contract GalaxyETH1vs1Jackpot is Ownable { string public constant name = ; event newWinner(address winner, uint256 ticketNumber); event newContribution(address contributor, uint value); using SafeMath for uint256; address[] public players = new address[](15); uint256 public lastTicketNumber = 0; uint8 public lastIndex = 0; struct tickets { uint256 startTicket; uint256 endTicket; }",1
0x2efb0309f41648a9faa935e189e2c8ff763bce75.sol,MSCE,"contract MSCE is Ownable, StandardToken { using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0x528b165220a26565e00709cbaef7b88fc8600f81.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; uint public minPrice; uint public totalTokensMinted; CovestingToken public token; function setMinPrice(uint newMinPrice) public onlyOwner { minPrice = newMinPrice; },1
0xf4f5683bc45bb1b3a3c61bb458006682d29d08a5.sol,Slotthereum,contract Slotthereum is Mortal { Game[] public games; uint public numberOfGames = 0; uint private minBetAmount = 1; uint private maxBetAmount = 5000000000000000000; uint8 private pointer = 1; struct Game { address player; uint id; uint amount; uint8 start; uint8 end; bytes32 hash; uint8 number; bool win; uint prize; },1
0xeb108d7c4ab669beea11e3f2422348c5fd19d021.sol,AxeMining,"contract AxeMining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 9000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d14421da39b403baab1cb0eac158ee658590798.sol,Agencies,"contract Agencies { mapping (address => string) private agencyOfOwner; mapping (string => address) private ownerOfAgency; event Set (string indexed _agency, address indexed _owner); event Unset (string indexed _agency, address indexed _owner); function Agencies () public { }",1
0x843620cad173eb76fc0386c28dca4875c4011cf6.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,MintableToken,"contract MintableToken is StandardToken, MultiOwnable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xdbeefc28155894b887d379113c1dadb4db545a78.sol,PrivateSale,"contract PrivateSale { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 internal constant weekInSeconds = 604800; uint256 public endTime; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInEurWei; function PrivateSale(address _tokenSaleContract, uint256 _oneTokenInEurWei, uint256 _remainingTokens, uint256 _startTime , uint256 _endTime ) public { require ( _tokenSaleContract != 0 ); require ( _oneTokenInEurWei != 0 ); require( _remainingTokens != 0 ); tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInEurWei = _oneTokenInEurWei; setTimeRC( _startTime, _endTime ); }",1
0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6.sol,ManagedToken,"contract ManagedToken is ERC20Token, MultiOwnable { bool public allowTransfers = false; bool public issuanceFinished = false; ITokenEventListener public eventListener; event AllowTransfersChanged(bool _newState); event Issue(address indexed _to, uint256 _value); event Destroy(address indexed _from, uint256 _value); event IssuanceFinished(); modifier transfersAllowed() { require(allowTransfers); _; }",1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x34644911eeefd50877cca86562e673b94885048b.sol,RUSS_PFVI_III_883,"contract RUSS_PFVI_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1055519864651380000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0x77e00640a6343152a35542027ba76407bdde0bb6.sol,quiz_please,contract quiz_please { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a.sol,RocketCoin,"contract RocketCoin { string public constant symbol = ; string public constant name = ; uint public constant decimals = 18; uint public constant totalSupply = 10000000 * 10 ** decimals; address owner; bool airDropStatus = true; uint airDropAmount = 300 * 10 ** decimals; uint airDropGasPrice = 20 * 10 ** 9; mapping (address => bool) participants; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function RocketCoin() public { owner = msg.sender; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0xf1d0f528cb6b50e0035a7fe03b4bcc58dd09c1e2.sol,ENTROPIUM,"contract ENTROPIUM is ENToken { using SafeMath for uint256; uint256 private rate_=100; uint256 private start_ = now; uint256 private period_ = 90; uint256 private hardcap_=100000000000000000000000; uint256 private softcap_=2000000000000000000000; uint8 private percent_=30; uint256 private ethtotal_=0; mapping(address => uint) private ethbalances_; event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event RefundEvent(address indexed to, uint256 amount); event FinishEvent(uint256 amount); constructor () public payable { }",1
0xd311ac05ede4e4955ebb08116300ee2834d03362.sol,BBT,"contract BBT is BurnableToken, PausableToken, SnapshotToken, Whitelist { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 private overrideTotalSupply_ = 10 * 1e9 * 1e18; uint256 public circulation; uint256 public minedAmount; address public teamWallet; uint256 public constant gameDistributionRatio = 35; uint256 public constant teamReservedRatio = 15; mapping (uint256 => uint256) private snapshotCirculations_; event Mine(address indexed from, address indexed to, uint256 amount); event Release(address indexed from, address indexed to, uint256 amount); event SetTeamWallet(address indexed from, address indexed teamWallet); event UnlockTeamBBT(address indexed teamWallet, uint256 amount, string source); modifier hasEnoughUnreleasedBBT(uint256 _amount) { require(circulation.add(_amount) <= totalSupply_, ); _; }",1
0x337f0845b56496406585f42800e64e3af08035e3.sol,JimatCoin,"contract JimatCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function JimatCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xa6e69536c5e13Ba9056a62a63adf2F725CA62599] = _totalSupply; emit Transfer(address(0), 0xa6e69536c5e13Ba9056a62a63adf2F725CA62599, _totalSupply); }",1
0x0013d3b508a23feeeca45c4c62cc88966fb71aed.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0xee16240bfb5d1bd8b50d8d97b9a71ec1eba5dcc5.sol,VLToken,"contract VLToken is ERC20, Ownable, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public startWithdraw; address public ethExchangeWallet; address public VLTMultisig; uint256 public tokensPerEther = 1500; bool public startStop = false; mapping (address => uint256) public walletAngelSales; mapping (address => uint256) public walletPESales; mapping (address => uint256) public releasedAngelSales; mapping (address => uint256) public releasedPESales; mapping (uint => address) public walletAddresses; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function VLToken() public { totalSupply = 500000000 ether; balances[msg.sender] = totalSupply; }",1
0x65731ac534bc0d3fdf3f4bdd2b09cf05044920bc.sol,MetadollarFund,contract MetadollarFund { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x175a0423212dfdd467b18d70f72c16f111c26f17.sol,HongZhangCoin,contract HongZhangCoin is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public INITIAL_SUPPLY = 60000 * 10000 * (10 ** decimals); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x39ffccecc551f35f8dfcb52c8c01060919aed1ea.sol,FoMo3DUnlimited,"contract FoMo3DUnlimited is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x137679d52dfa0d8191600046afc29634e349182d); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 72 hours; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 999 years; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(20,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(52,0); fees_[3] = F3Ddatasets.TeamFee(43,0); potSplit_[0] = F3Ddatasets.PotSplit(30,0); potSplit_[1] = F3Ddatasets.PotSplit(20,0); potSplit_[2] = F3Ddatasets.PotSplit(10,0); potSplit_[3] = F3Ddatasets.PotSplit(20,0); }",1
0x71abd3479b5f3a1ffb16bf18342ecda13c53ab15.sol,kkTestICO1,"contract kkTestICO1 is ERC20, SafeMath{ mapping(address => uint256) balances; uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }",1
0xee418a19d6620aa478489032c2cb63464dd3e690.sol,FUTM1,"contract FUTM1 is MintableToken, BurnableToken, RBAC { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant ROLE_ADMIN = ; string public constant ROLE_SUPER = ; uint public swapLimit; uint public constant CYCLE_CAP = 100000 * (10 ** uint256(decimals)); uint public constant BILLION = 10 ** 9; event SwapStarted(uint256 startTime); event MiningRestart(uint256 endTime); event CMCUpdate(string updateType, uint value); uint offset = 10**18; uint public exchangeRateFUTB; uint public cycleMintSupply = 0; bool public isMiningOpen = false; uint public CMC = 129238998229; uint public cycleEndTime; address public constant FUTC = 0xf880d3C6DCDA42A7b2F6640703C5748557865B35; address public constant FUTB = 0x30c6Fe3AC0260A855c90caB79AA33e76091d4904; constructor() public { owner = this; totalSupply_ = 0; addRole(msg.sender, ROLE_ADMIN); addRole(msg.sender, ROLE_SUPER); exchangeRateFUTB = offset.mul(offset).div(CMC.mul(offset).div(BILLION)).mul(65).div(100); cycleEndTime = now + 100 days; }",1
0x6cc07cb2d1d354f9e2042a26697e7fe9cec4656c.sol,ERGCOIN,contract ERGCOIN is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 800000000 * 10**18; function name() public constant returns (string) { return ; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x02ebe0ce3ac0ada772a5831cf3a6742a84ee22f5.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x6a498c4d31aec7dd076d81e73d564f33c9a07764.sol,BitchipWallet,contract BitchipWallet is owned{ address private ETH = 0x0000000000000000000000000000000000000000; using SafeMath for uint; constructor() public { },1
0x8ae2d0e66b2725773f2e4fc83294c4886d4ab319.sol,BlackList,"contract BlackList is Ownable, BasicToken { function getBlackListStatus(address _maker) external constant returns (bool) { return isBlackListed[_maker]; }",1
0x50a0be7e38f2580ad3eafac20b923cccee673ce3.sol,EthCalendar,contract EthCalendar { uint256 constant initialDayPrice = 3000000000000000 wei; address contractOwner; mapping(address => uint256) pendingWithdrawals; mapping(uint16 => Day) dayStructs; event DayBought(uint16 dayId); struct Day { address owner; string message; uint256 sellprice; uint256 buyprice; },1
0x1806b3527c18fb532c46405f6f014c1f381b499a.sol,ERC721_custom,"contract ERC721_custom is ERC165, IERC721 { using SafeMath for uint256; using Address for address; bytes4 private constant _ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) private _tokenOwner; mapping (uint256 => address) private _tokenApprovals; mapping (address => uint256) private _ownedTokensCount; mapping (address => mapping (address => bool)) private _operatorApprovals; bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd; constructor() public { _registerInterface(_InterfaceId_ERC721); }",1
0xd378a2a4e37025f87528c7c1a4224b0a18f761eb.sol,BELLO_TOKEN,"contract BELLO_TOKEN { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Transfer(address indexed from, address indexed to, uint tokens); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint256 totalSupply_; using SafeMath for uint256; function BELLO_TOKEN(uint256 total) public { totalSupply_ = total; balances[msg.sender] = totalSupply_; }",1
0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b.sol,TittyBase,"contract TittyBase { event Transfer(address indexed from, address indexed to); event Creation(address indexed from, uint256 tittyId, uint256 wpId); event AddAccessory(uint256 tittyId, uint256 accessoryId); struct Accessory { uint256 id; string name; uint256 price; bool isActive; }",1
0x0d8f67a5792c156d0244f380a66655b9f4255586.sol,Carrot,"contract Carrot { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Carrot( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x68fcb1f0d07000a84b569ccb647dd8fe320cddaa.sol,owContract,"contract owContract is initLib { function owContract(address _token, address _cmc) public { tokenAddress = _token; ow_owner = msg.sender; cmcAddress = _cmc; }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,DSSafeAddSub,"contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2cc1060de78aa44e3e6a86102fac93f1de49adb2.sol,UbexCrowdsale,"contract UbexCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; mapping(address => uint256) public balances; uint256 public tokensIssued; uint256 public bonusMultiplier; bool public closed; event TokenDelivered(address indexed receiver, uint256 amount); event TokenAdded(address indexed beneficiary, uint256 amount); function UbexCrowdsale( uint256 _rate, address _wallet, ERC20 _token, uint256 _bonusMultiplier ) Crowdsale( _rate, _wallet, _token ) { bonusMultiplier = _bonusMultiplier; }",1
0xa4337c343132e134a23439d5386c29c610b93d5b.sol,CryptoAndDragonsAuction,"contract CryptoAndDragonsAuction is AccessControl{ event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event Hatch(address indexed _owner, uint16 _tableId); address public thisAddress; address public dragonTreasureToken; address public databaseContract; address public ERC721Contract; uint256 public totalAuction; uint256 private increaseRate = 0.1 ether; mapping (address => address) public masterToReferral; function setNewMonster(uint256 _genes,uint32 _classId,address _master,string _name,string _skills) onlyModerators public returns(uint64 _monsterId) { DataBase data = DataBase(databaseContract); uint64 monsterId = data.getTotalMonster() + 1; data.addMonsterObj(monsterId,_genes,_classId,_master,_name,_skills); return monsterId; }",1
0x2a92f24bfad42b04cfe5c000be404c2a84ca5b71.sol,CryptoSuperGirlfriend,"contract CryptoSuperGirlfriend { using SafeMath for uint256; address private addressOfOwner; event Add (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private priceInit = 0.01 ether; uint256 private idStart = 10001; uint256 private idMax = 10191; struct OwnerInfo{ string ownerName; string ownerWords; string ownerImg; string ownerNation; }",1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0xe8c65be49e76adbdef289b12ee648e6c5fa117a2.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x4d5c907a460b0844cc99b95003819c2aa2b2b77a.sol,RealEstateDirectIncome,"contract RealEstateDirectIncome is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address private admin; bool public transferEnabled = true; function RealEstateDirectIncome() { totalSupply = 32000000000000000000000000000 ; balances[msg.sender] = totalSupply; Transfer(address(0x0), msg.sender, totalSupply); admin = msg.sender; transferOwnership(admin); }",1
0x2793a23341012e0970cf478bab08606b56504c3e.sol,UpgradableToken,"contract UpgradableToken is ERC20, Ownable { address public predecessor; address public successor; string public version; event UpgradedTo(address indexed successor); event UpgradedFrom(address indexed predecessor); modifier unlessUpgraded() { require (msg.sender == successor || successor == address(0)); _; }",1
0xda32d3814b10aee35dcba4de4f6b2259916f9cbb.sol,Swap,"contract Swap is StandardToken, BurnableToken, Ownable { using SafeMath for uint; string constant public symbol = ; string constant public name = ; uint8 constant public decimals = 18; uint256 INITIAL_SUPPLY = 1000000000e18; address initialWallet = 0x41AA4bF6c87F5323214333c8885C5Fb660B00A57; function Swap() public { totalSupply_ = INITIAL_SUPPLY; initialFunding(initialWallet, totalSupply_); }",1
0xf4fe43df5179fae6ebd1337c62d68bb2606f5a40.sol,CryptFillToken,contract CryptFillToken is StandardToken { using SafeMath for uint256; function () { throw; },1
0x0dfaf19a15be6480b7831ba19e7ed877d5da40ee.sol,XPOT,"contract XPOT is Owner { event Game(uint _game, uint indexed _time); event Ticket( address indexed _address, uint indexed _game, uint _number, uint _time ); uint8 public fee = 10; uint public game; uint public ticketPrice = 0.01 ether; uint public newPrice; uint public allTimeJackpot = 0; uint public allTimePlayers = 0; bool public isActive = true; bool public toogleStatus = false; uint[] public games; mapping(uint => uint) jackpot; mapping(uint => address[]) players; address public fundsDistributor; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x54d3ad23846643b93098915001ab274ea19e5622.sol,Mythereum,"contract MythereumERC20Token is ERC20 { function burn(address burner, uint256 amount) public returns (bool); function mint(address to, uint256 amount) public returns (bool); }",1
0x03805a2347e4d0c07b7159d8f8f8f8b1482c1425.sol,PlayChainToken,"contract PlayChainToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PlayChainToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 12 weeks; }",1
0x926476bfc3550ccb424202004b9aab9ac40e32de.sol,VeChainX,"contract VeChainX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 3000000e18; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Owned,contract Owned { address public owner; address public nominatedOwner; function Owned(address _owner) public { owner = _owner; },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,TokenSale,"contract TokenSale is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; rateInterface public rateContract; address public wallet; address public advisor; uint256 public advisorFee; uint256 public constant decimals = 18; uint256 public endTime; uint256 public startTime; mapping(address => bool) public rc; function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public { tokenContract = tokenInterface(_tokenAddress); rateContract = rateInterface(_rateAddress); setTime(_startTime, _endTime); wallet = msg.sender; advisor = msg.sender; advisorFee = 0 * 10**3; }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add.sol,AllYours,contract AllYours { address private _platformAddress = 0xbE9C1088FEEB8B48A96Da0231062eA757D0a9613; uint private _totalEth = 0.06 ether; uint128 private _oneceEth = 0.02 ether; uint256 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0x71871f8d10b2965e06dc29b1be7122086aeb11e0.sol,LirkToken,"contract LirkTokenStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x71b8ab235890d3efb1ffcc29209a6b0fe5be4ec7.sol,DCoinFaxToken,"contract DCoinFaxToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply = 50 * 10000 * 10000 * (10 ** uint256(decimals)); constructor ( address initialTokenOwner ) public { balances[initialTokenOwner] = totalSupply; emit Transfer(0x0, initialTokenOwner, totalSupply); }",1
0xbd24918e527512c48e7f54b3bec8f47b9f48914b.sol,JanusNetwork,"contract JanusNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 12000000e8; uint256 public constant minContribution = 1 ether / 200; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdf3a0a958f5a599aa8f3071aa6488c22416efb89.sol,ERC20,"contract ERC20 is Context, Ownable, Pausable { using SafeMath for uint256; string private _name; string private _symbol; uint8 private _decimals; uint256 private _totalSupply; uint256 private ONE_TOKEN; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowances; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor () public { _name = ; _symbol = ; _decimals = 6; ONE_TOKEN = (10 ** uint256(_decimals)); _totalSupply = 1000000000 * ONE_TOKEN; _balances[_msgSender()] = _totalSupply; }",1
0x308cd1ebece7d99a360698ef47dd30269c7e2623.sol,AceWins,"contract AceWins is Ownable { uint256 public totalSupply; mapping(address => uint256) startBalances; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) startBlocks; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 10; uint256 public calc = 951839; function AceWins() public { totalSupply = 12500000 * 10**uint256(decimals); startBalances[owner] = totalSupply; startBlocks[owner] = block.number; Transfer(address(0), owner, totalSupply); }",1
0xe1f338e069f202f2113d32c8a5d1046d83c92ca4.sol,WorldFomo,"contract WorldFomo is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x6ed17ee485821cd47531f2e4c7b9ef8b48f2bab5); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 15 seconds; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 12 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(32,0); fees_[1] = F3Ddatasets.TeamFee(45,0); fees_[2] = F3Ddatasets.TeamFee(62,0); fees_[3] = F3Ddatasets.TeamFee(47,0); potSplit_[0] = F3Ddatasets.PotSplit(47,0); potSplit_[1] = F3Ddatasets.PotSplit(47,0); potSplit_[2] = F3Ddatasets.PotSplit(62,0); potSplit_[3] = F3Ddatasets.PotSplit(62,0); }",1
0x33e127da2426822408b1d41344146de02ee48670.sol,PONTEM,"contract PONTEM { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply , string tokenName , string tokenSymbol) public { totalSupply = 250000000 * 10 ** uint256(18) ; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf443aaaf1e0770a078b5e1b783e68eb71c9e2f0f.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0xd421bb79fddfd4333a03e00d8a4b5f4eba07f1f8.sol,TriggminePresale,"contract TriggminePresale is Ownable { uint public constant SALES_START = 1523890800; uint public constant SALES_END = 1525100400; address public constant ASSET_MANAGER_WALLET = 0x7E83f1F82Ab7dDE49F620D2546BfFB0539058414; address public constant ESCROW_WALLET = 0x2e9F22E2D559d9a5ce234AB722bc6e818FA5D079; address public constant TOKEN_ADDRESS = 0x98F319D4dc58315796Ec8F06274fe2d4a5A69721; uint public constant TOKEN_CENTS = 1000000000000000000; uint public constant TOKEN_PRICE = 0.0001 ether; uint public constant ETH_HARD_CAP = 3000 ether; uint public constant SALE_MAX_CAP = 36000000 * TOKEN_CENTS; uint public constant BONUS_WL = 20; uint public constant BONUS_2_DAYS = 20; uint public constant BONUS_3_DAYS = 19; uint public constant BONUS_4_DAYS = 18; uint public constant BONUS_5_DAYS = 17; uint public constant BONUS_6_DAYS = 16; uint public constant BONUS_15_DAYS = 15; uint public saleContributions; uint public tokensPurchased; address public whitelistSupplier; mapping(address => bool) public whitelistPrivate; mapping(address => bool) public whitelistPublic; event Contributed(address receiver, uint contribution, uint reward); event PrivateWhitelistUpdated(address participant, bool isWhitelisted); event PublicWhitelistUpdated(address participant, bool isWhitelisted); function TriggminePresale() public { whitelistSupplier = msg.sender; owner = ASSET_MANAGER_WALLET; }",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,Ownable,contract Ownable { address Owner; function Ownable() { Owner = msg.sender; },1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,AdvancedToken365,"contract AdvancedToken365 is owned, Token365 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function AdvancedToken365( uint256 initialSupply, string tokenName, string tokenSymbol ) Token365(initialSupply, tokenName, tokenSymbol) public {}",1
0x28c69cd429f785954ae4b0263db4d9871c033ca7.sol,VPCToken,"contract VPCToken is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 365000000 * (10 ** uint256(decimals)); constructor() public { _mint(msg.sender, INITIAL_SUPPLY); }",1
0xc6be00f7ed386015a3c751d38c126c62f231138d.sol,UniversalMobileToken,"contract UniversalMobileToken is Ownable { using SafeMath for uint; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); string public name; string public symbol; uint public decimals; uint public totalSupply; bool public mintingIsFinished; bool public transferIsPossible; modifier onlyEmitter() { require(emitters[msg.sender] == true); _; }",1
0xd4b33b74cec5141c0c40be4a664641495c6afc7e.sol,CFC,"contract CFC is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x9200f1be36761dab295673279afb09d4f2b2531c.sol,QuantstampSale,"contract QuantstampSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingCap; uint public minContribution; bool public fundingCapReached = false; bool public saleClosed = false; mapping(address => bool) public registry; mapping(address => uint256) public cap1; mapping(address => uint256) public cap2; mapping(address => uint256) public cap3; mapping(address => uint256) public cap4; mapping(address => uint256) public contributed1; mapping(address => uint256) public contributed2; mapping(address => uint256) public contributed3; mapping(address => uint256) public contributed4; uint public rate1 = 10000; uint public rate2 = 7000; uint public rate3 = 6000; uint public rate4 = 5000; uint public startTime; uint public endTime; uint public amountRaised; bool private rentrancy_lock = false; mapping(address => uint256) public balanceOf; mapping(address => uint256) public tokenBalanceOf; event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event RegistrationStatusChanged(address target, bool isRegistered, uint c1, uint c2, uint c3, uint c4); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x5b813a2f4b58183d270975ab60700740af00a3c9.sol,CrystalAirdropGame,contract CrystalAirdropGame { using SafeMath for uint256; address public administrator; uint256 public MINI_GAME_TIME_DEFAULT = 60 * 5; uint256 public MINI_GAME_PRIZE_CRYSTAL = 100; uint256 public MINI_GAME_BETWEEN_TIME = 8 hours; uint256 public MINI_GAME_ADD_TIME_DEFAULT = 15; address public miningWarContractAddress; uint256 public miniGameId = 0; uint256 public noRoundMiniGame; CryptoMiningWarInterface public MiningWarContract; uint256 public MINI_GAME_BONUS = 100; mapping(uint256 => MiniGame) public minigames; mapping(address => PlayerData) public players; struct MiniGame { uint256 miningWarRoundNumber; bool ended; uint256 prizeCrystal; uint256 startTime; uint256 endTime; address playerWin; uint256 totalPlayer; },1
0xce038523e278b6c1344d9e4f735f6064ad7a6032.sol,TokenSwap,"contract TokenSwap is Ownable { HumanStandardToken public ndc; HumanStandardToken public tpt; address public neverdieSigner; uint256 public minSwapAmount = 40; event Swap( address indexed to, address indexed PTaddress, uint256 rate, uint256 amount, uint256 ptAmount ); event BuyNDC( address indexed to, uint256 NDCprice, uint256 value, uint256 amount ); event BuyTPT( address indexed to, uint256 TPTprice, uint256 value, uint256 amount ); function TokenSwap(address _teleportContractAddress, address _neverdieContractAddress, address _signer) public { tpt = HumanStandardToken(_teleportContractAddress); ndc = HumanStandardToken(_neverdieContractAddress); neverdieSigner = _signer; }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoWhitelistingCommon,"contract DaoWhitelistingCommon is ResolverClient, DaoConstants { function daoWhitelistingStorage() internal view returns (DaoWhitelistingStorage _contract) { _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING)); }",1
0x876617584678d5b9a6ef93eba92b408367d9457c.sol,DetherCore,"contract DetherCore is DetherSetup, ERC223ReceivingContract, SafeMath { using BytesLib for bytes; event RegisterTeller(address indexed tellerAddress); event AddFunds(address indexed tellerAddress, uint amount); event DeleteTeller(address indexed tellerAddress); event UpdateTeller(address indexed tellerAddress); event Sent(address indexed _from, address indexed _to, uint amount); event RegisterShop(address shopAddress); event DeleteShop(address shopAddress); event DeleteShopModerator(address indexed moderator, address shopAddress); event DeleteTellerModerator(address indexed moderator, address tellerAddress); modifier tellerHasStaked(uint amount) { require(bank.getDthTeller(msg.sender) >= amount); _; }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0xf091cf09c51811819db705710e9634b8bf18f164.sol,Couchain,"contract Couchain is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Couchain( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeed3856ecbcb09b20cba1b3f5d448fed860483ba.sol,DappleAirdrops,"contract DappleAirdrops is Ownable { using SafeMath for uint256; mapping (address => uint256) public bonusDropsOf; mapping (address => uint256) public ethBalanceOf; mapping (address => bool) public tokenIsBanned; mapping (address => uint256) public trialDrops; uint256 public rate; uint256 public dropUnitPrice; uint256 public bonus; uint256 public maxDropsPerTx; uint256 public maxTrialDrops; string public constant website = ; event BonusCreditGranted(address indexed to, uint256 credit); event BonusCreditRevoked(address indexed from, uint256 credit); event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit); event AirdropInvoked(address indexed by, uint256 creditConsumed); event BonustChanged(uint256 from, uint256 to); event TokenBanned(address indexed tokenAddress); event TokenUnbanned(address indexed tokenAddress); event EthWithdrawn(address indexed by, uint256 totalWei); event RateChanged(uint256 from, uint256 to); event MaxDropsChanged(uint256 from, uint256 to); event RefundIssued(address indexed to, uint256 totalWei); event ERC20TokensWithdrawn(address token, address sentTo, uint256 value); function DappleAirdrops() public { rate = 10000; dropUnitPrice = 1e14; bonus = 20; maxDropsPerTx = 100; maxTrialDrops = 100; }",1
0x1e7f976224f74dd214e4b3610d1bfe2b39af98b7.sol,Ownable,contract Ownable { address public owner; function Ownable() { owner = 0xD1bF6f9AA810fB2a58798984371486F60636EC67; },1
0x53abc335bed36e0299ef5607f04bd297d3a10dba.sol,RigCraftPresalePackageManager,contract RigCraftPresalePackageManager { address owner; bool public isActive; uint16[] public presalePackSold; uint16[] public presalePackLimit; uint256[] public presalePackagePrice; mapping(address=>uint256) addressRefferedCount; mapping(address=>uint256) addressRefferredSpending; address[] referralAddressIndex; uint256 public totalFundsSoFar; RigCraftPresalePackageToken private presaleTokenContract; function RigCraftPresalePackageManager() public { owner = msg.sender; isActive = false; presaleTokenContract = RigCraftPresalePackageToken(address(0)); presalePackSold.length = 5; presalePackLimit.length = 5; presalePackagePrice.length = 5; presalePackLimit[0] = 65000; presalePackagePrice[0] = 0.1 ether; presalePackLimit[1] = 50; presalePackagePrice[1] = 0.33 ether; presalePackLimit[2] = 66; presalePackagePrice[2] = 0.66 ether; presalePackLimit[3] = 50; presalePackagePrice[3] = 0.99 ether; presalePackLimit[4] = 100; presalePackagePrice[4] = 1 ether; },1
0x86e92c595de61fd22c0f0a0458c6eaa63d0b06ef.sol,FreezableToken,"contract FreezableToken is BasicToken { mapping (address => uint256) freezes; event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function freeze(uint256 _value) public returns (bool success) { require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); freezes[msg.sender] = freezes[msg.sender].add(_value); emit Freeze(msg.sender, _value); return true; }",1
0x5216c8d4e0f29285b5c8805810487c5277788e31.sol,JiggsRezurrection,contract JiggsRezurrection { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xee3e9c95ad9b081055eb88c976e8e208a61a12ff.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x1dab4bbc3e8f0a0fa5e5f67890e715bc9285f359.sol,B24Token,contract B24Token is BasicToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; function B24Token() public {},1
0xa5c9ecf54790334b73e5dfa1ff5668eb425dc474.sol,TokenNetwork,contract TokenNetwork is Utils { string constant public contract_version = ; Token public token; SecretRegistry public secret_registry; uint256 public chain_id; uint256 public settlement_timeout_min; uint256 public settlement_timeout_max; uint256 constant public MAX_SAFE_UINT256 = ( 115792089237316195423570985008687907853269984665640564039457584007913129639935 ); uint256 constant public channel_participant_deposit_limit = 75000000000000000 wei; uint256 constant public token_network_deposit_limit = 250000000000000000000 wei; uint256 public channel_counter; string public constant signature_prefix = ; address public deprecation_executor; bool public safety_deprecation_switch = false; mapping (uint256 => Channel) public channels; mapping (bytes32 => uint256) public participants_hash_to_channel_identifier; mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data; struct Participant { uint256 deposit; uint256 withdrawn_amount; bool is_the_closer; bytes32 balance_hash; uint256 nonce; },1
0x0200412995f1bafef0d3f97c4e28ac2515ec1ece.sol,MigratoryToken,contract MigratoryToken is HoldersToken { using SafeMath for uint256; address public migrationAgent; uint256 public migrationCountComplete; function setMigrationAgent(address agent) public onlyOwner { migrationAgent = agent; },1
0x1b5f3b42a7dbd89fb6e4942de51876beb89ab969.sol,GOOGLE,"contract GOOGLE { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public googleSupply = 99999999986; uint256 public buyPrice = 100000000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function GOOGLE() public { totalSupply = googleSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,ShareToken,"contract ShareToken is ERC20Token, WhiteListManager { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; address public icoContract; uint256 constant E2 = 10**2; mapping(address => bool) public rewardTokenLocked; bool public mainSaleTokenLocked = true; uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT = 6666666667; uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT = 33333333333; uint256 public airDropTokenIssuedTotal; uint256 public bountyTokenIssuedTotal; uint256 public constant TOKEN_SUPPLY_SEED_LIMIT = 500000000 * E2; uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT = 2500000000 * E2; uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT; uint256 public seedAndPresaleTokenIssuedTotal; uint8 private constant PRESALE_EVENT = 0; uint8 private constant MAINSALE_EVENT = 1; uint8 private constant BOUNTY_EVENT = 2; uint8 private constant AIRDROP_EVENT = 3; function ShareToken() public { totalTokenIssued = 0; airDropTokenIssuedTotal = 0; bountyTokenIssuedTotal = 0; seedAndPresaleTokenIssuedTotal = 0; mainSaleTokenLocked = true; }",1
0x038ada8452ae3764f84a9f3e809b73de7938ae45.sol,DesToken,"contract DesToken { using ERC20Lib for ERC20Lib.TokenStorage; ERC20Lib.TokenStorage token; string public name = ; string public symbol = ; uint8 public decimals = 8; uint public INITIAL_SUPPLY = 100000000000; function DesToken() public { var totalSupply = INITIAL_SUPPLY * 10 ** uint256(decimals); token.init(totalSupply, 0x0c5E1F35336a4a62600212E3Dde252E35eEc99d5); }",1
0xbf8fb919a8bbf28e590852aef2d284494ebc0657.sol,Coinbase,"contract Coinbase is Ownable { using SafeMath for uint256; uint256 public blockHeight; uint256 public decimals; uint256 public coinbaseInit; uint256 public halvingPeriod = 4 * 120; uint256 public maxSupply; uint256[6] private coinbaseArray; uint256 public exodus; event LogBlockHeight(uint256 blockHeight); function Coinbase(uint256 _decimals) public{ decimals = _decimals; maxSupply = 210000000 * (10 ** uint256(decimals)); exodus = maxSupply / 10; coinbaseInit = 196875 * (10 ** uint256(decimals)); coinbaseArray = [ coinbaseInit, coinbaseInit / 2, coinbaseInit / 4, coinbaseInit / 8, coinbaseInit / 16, coinbaseInit / 16 ]; }",1
0x4b77bde81ceaf137d883e43aa27cf767cd2f8141.sol,StrongKek,contract StrongKek { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xbc86727e770de68b1060c91f6bb6945c73e10388.sol,InkProtocolCore,"contract InkProtocolCore is InkProtocolInterface, StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant gasLimitForExpiryCall = 1000000; uint256 private constant gasLimitForMediatorCall = 4000000; enum Expiry { Transaction, Fulfillment, Escalation, Mediation }",1
0xee418a19d6620aa478489032c2cb63464dd3e690.sol,FUTM1,"contract FUTM1 is MintableToken, BurnableToken, RBAC { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant ROLE_ADMIN = ; string public constant ROLE_SUPER = ; uint public swapLimit; uint public constant CYCLE_CAP = 100000 * (10 ** uint256(decimals)); uint public constant BILLION = 10 ** 9; event SwapStarted(uint256 startTime); event MiningRestart(uint256 endTime); event CMCUpdate(string updateType, uint value); uint offset = 10**18; uint public exchangeRateFUTB; uint public cycleMintSupply = 0; bool public isMiningOpen = false; uint public CMC = 129238998229; uint public cycleEndTime; address public constant FUTC = 0xf880d3C6DCDA42A7b2F6640703C5748557865B35; address public constant FUTB = 0x30c6Fe3AC0260A855c90caB79AA33e76091d4904; constructor() public { owner = this; totalSupply_ = 0; addRole(msg.sender, ROLE_ADMIN); addRole(msg.sender, ROLE_SUPER); exchangeRateFUTB = offset.mul(offset).div(CMC.mul(offset).div(BILLION)).mul(65).div(100); cycleEndTime = now + 100 days; }",1
0x44ec074723ed296b8fc2b81a0f9210cb65e61077.sol,LuckyDice,"contract LuckyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) { if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw; _; }",1
0x6dfe212d1461014be1781b0be710dda1c036d8ef.sol,ZTST,"contract ZTST is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 30000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 50 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function ZTST() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0xf317f4acfc0d70ccc79a2f24cfbbd7ebc02cfa2e.sol,CryptoStrategiesIntelligence,contract CryptoStrategiesIntelligence is StandardToken { function () public { revert(); },1
0x5afae785bc6ba7248dbd511a92c4d5cc5a803214.sol,DaoCommon,contract DaoCommonMini is IdentityCommon { using MathHelper for MathHelper; function isDaoNotReplaced() public view returns (bool _isNotReplaced) { _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao(); },1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,MNTP,contract MNTP is StdToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public creator = 0x0; address public icoContractAddress = 0x0; bool public lockTransfers = false; uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * (1 ether / 1 wei); modifier onlyCreator() { require(msg.sender == creator); _; },1
0x727443713e3ff01411feaae52dae5d142a3c7b29.sol,GLOBALFOUNDATION,contract GLOBALFOUNDATION { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 2100000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x1f331e900341ba6711f13c208f508bb305da4d0b.sol,TakeSeat,"contract TakeSeatEvents { event BuyTicket ( address indexed plyr ); event Withdraw ( address indexed plyr, uint256 indexed value, uint256 indexed num ); }",1
0x1778fffbd431be2ac3d69e64d1d819c786b2bee0.sol,GcgToken,"contract GcgToken is ERC20Interface { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 8; address public owner; uint public totalSupply = 1000000000 * (10 ** 8); bool public emergencyFreeze; mapping (address => uint) balances; mapping (address => mapping (address => uint) ) allowed; mapping (address => bool) frozen; constructor () public { owner = msg.sender; balances[owner] = totalSupply; emit Transfer(0x0, owner, totalSupply); }",1
0x510467f65a600926af2ed565419ad98cf1f706ed.sol,Slotthereum,contract Slotthereum is Mortal { mapping (address => Game[]) private games; uint private minBetAmount = 10000000000000000; uint private maxBetAmount = 5000000000000000000; uint private pointer = 1; uint private numberOfPlayers = 0; struct Game { uint id; uint amount; uint8 start; uint8 end; bytes32 hash; uint8 number; bool win; uint prize; },1
0xc430b33fceaaf717ae29754c1cdace06f5bb51ab.sol,ACOCoin,"contract ACOCoin is PausableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply_ = 1000000000 * (10 ** uint256(decimals)); uint256 public tokensForPublicSale = 200000000 * (10 ** 18); uint256 public pricePerToken = (10 ** 16); uint256 minETH = 0 * (10**18); uint256 maxETH = 1000 * (10**18); bool public isCrowdsaleOpen=false; constructor() public { totalSupply_ = initialSupply_; balances[msg.sender] = balances[msg.sender].add(initialSupply_); emit Transfer(address(0), msg.sender, initialSupply_); }",1
0x5157d619e89c5a8d82a9674bc950c554a639ee84.sol,MegaProjectToken,contract MegaProjectToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x40fdb6653bf98333b2c8ffa7c3625e7cc83668be.sol,FixStandardToken,"contract FixStandardToken is FixToken, Ownable { using FixMaths for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }",1
0xb613aa71ce4630e955548a61d089617e8e2f509a.sol,MomsAvenueCrowdsale,"contract MomsAvenueCrowdsale { using SafeMath for uint256; MomsAvenueToken public token; uint256 constant public rate = 10000; uint256 constant public goal = 20000000 * (10 ** 18); uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; bool public crowdsaleActive = true; address public wallet; address public tokenOwner; mapping(address => uint256) balances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function MomsAvenueCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _tokenOwner) public { require(_startTime < _endTime); require(_wallet != address(0)); require(_token != address(0)); require(_tokenOwner != address(0)); startTime = _startTime; endTime = _endTime; wallet = _wallet; tokenOwner = _tokenOwner; token = MomsAvenueToken(_token); }",1
0xd3cd638c5013b70b795dd0a171376b579fc76cbc.sol,AriumCrowdsale,contract AriumCrowdsale is Ownable { using SafeMath for uint; address multisig; uint restrictedPercent; address restricted; AriumToken public token; uint start; uint preico; uint rate; uint icostart; uint ico; bool hardcap = false; function AriumCrowdsale(AriumToken _token) { token=_token; multisig = 0xA2Bfd3EE5ffdd78f7172edF03f31D1184eE627F3; restricted = 0x8e7d40bb76BFf10DDe91D1757c4Ceb1A5385415B; restrictedPercent = 13; rate = 10000000000000; start = 1521849600; preico = 30; icostart= 1528588800; ico = 67; },1
0xcf321c5e50ea2222843fa4f0124cc2d1e0110aea.sol,Lescovex,"contract Lescovex is Ownable { uint256 public totalSupply; using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => uint256) holded; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(block.timestamp>blockEndICO || msg.sender==owner); balances[msg.sender] = balances[msg.sender].sub(_value); holded[_to]=block.number; balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x295e093f47d63258a102ea4bfa69fde4beb4ab2e.sol,IcoToken,"contract IcoToken is SafeMath, StandardToken, Pausable { string public name; string public symbol; uint256 public decimals; string public version; address public icoContract; constructor( string _name, string _symbol, uint256 _decimals, string _version ) public { name = _name; symbol = _symbol; decimals = _decimals; version = _version; }",1
0x180e35f768eb870962d2dc04cca1a927d206a089.sol,LuckySeven,"contract LuckySeven { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 7; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.5 ether; address public charityWallet = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; address public ownerWallet; address public owner; bool public gameStarted; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x4d24d8d75a8ec4a2d4bf2b2aa7f9a3cf27ef5fcf.sol,MVExpressCoin,"contract MVExpressCoin is DSTokenBase , DSStop { string public symbol=; string public name=; uint256 public decimals = 18; uint256 public initialSupply=100000000999999990000000000; address public burnAdmin; constructor() public DSTokenBase(initialSupply) { burnAdmin=0x88253D87990EdD1E647c3B6eD21F57fb061a3040; }",1
0x41df2d239ccc81e74031f86af7c13638e62ccb5f.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0xb3d0ab9fac5005c15a7f3d4c4205cc1e83fa3e2d.sol,Starpay,"contract Starpay is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xF6E8124654B03377c151EBD7359b28C64c72213d] = _totalSupply; emit Transfer(address(0), 0xF6E8124654B03377c151EBD7359b28C64c72213d, _totalSupply); }",1
0xd53811bede961d83a73516078446a5a32ce844aa.sol,SKPT,"contract SKPT is BasicToken, BurnableToken, ERC20, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant version = ; uint256 constant INITIAL_SUPPLY_SKPT = 6400000000; mapping(address => bool) public isBurner; function SKPT() public { totalSupply = INITIAL_SUPPLY_SKPT * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply; isBurner[msg.sender] = true; }",1
0xec270e8f52b492dd0c2dcd43fc6f868e78f49f18.sol,SmartzToken,"contract SmartzToken is ArgumentsChecker, multiowned, BurnableToken, StandardToken, TokenWithApproveAndCallMethod { struct FrozenCell { uint amount; uint128 thawTS; uint128 isKYCRequired; }",1
0x54ee540b38fc6e0548172fe651927d85366c6bf7.sol,TRSToken,contract TRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TRSToken () { owner = msg.sender; },1
0x018d7d179350f1bb9853d04982820e37cce13a92.sol,INXToken,"contract INXToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 53220000; uint256 public tokensPer2Eth = 62220000; uint256 public tokensPer3Eth = 72220000; uint256 public startPase = 1542646800; uint public maxPhase1 = 1500000e8; uint public maxPhase2 = 1000000e8; uint public maxPhase3 = 500000e8; uint public currentPhase = 0; uint public soldPhase1 = 0; uint public soldPhase2 = 0; uint public soldPhase3 = 0; uint256 public pase1 = startPase + 1 * 18 days; uint256 public pase2 = pase1 + 1 * 18 days; uint256 public pase3 = pase2 + 1 * 18 days; uint256 public constant minContribution = 1 ether / 4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event StartPaseUpdated(uint256 _time); event TokensPerEthUpdated(uint _tokensPerEth); event TokensPerEth2Updated(uint _tokensPerEth); event TokensPerEth3Updated(uint _tokensPerEth); event MaxPhase1Updated(uint _maxPhase1); event MaxPhase2Updated(uint _maxPhase2); event MaxPhase3Updated(uint _maxPhase3); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4d4ce166009ce46a73bca189f144e9c5fae25cc6.sol,Freezable,contract Freezable is Ownable { mapping(address => bool) public frozenAccount; modifier isFreezenAccount(){ require(frozenAccount[msg.sender]); _; },1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,BattleOfThermopylae,"contract BattleOfThermopylae is Timed, Upgradable { using SafeMathLib for uint; uint public constant MAX_PERSIANS = 300000 * 10**18; uint public constant MAX_SPARTANS = 300 * 10**18; uint public constant MAX_IMMORTALS = 100; uint public constant MAX_ATHENIANS = 100 * 10**18; uint8 public constant BP_PERSIAN = 1; uint8 public constant BP_IMMORTAL = 100; uint16 public constant BP_SPARTAN = 1000; uint8 public constant BP_ATHENIAN = 100; uint8 public constant BTL_PERSIAN = 1; uint16 public constant BTL_IMMORTAL = 2000; uint16 public constant BTL_SPARTAN = 1000; uint16 public constant BTL_ATHENIAN = 2000; uint public constant WAD = 10**18; uint8 public constant BATTLE_POINT_DECIMALS = 18; uint8 public constant BATTLE_CASUALTIES = 10; address public persians; address public immortals; address public spartans; address public athenians; address public battles; address public battlesOwner; mapping (address => mapping (address => uint)) public warriorsByPlayer; mapping (address => uint) public warriorsOnTheBattlefield; event WarriorsAssignedToBattlefield (address indexed _from, address _faction, uint _battlePointsIncrementForecast); event WarriorsBackToHome (address indexed _to, address _faction, uint _survivedWarriors); function BattleOfThermopylae(uint _startTime, uint _life, uint8 _avarageBlockTime, address _persians, address _immortals, address _spartans, address _athenians) Timed(_startTime, _life, _avarageBlockTime) Upgradable() { persians = _persians; immortals = _immortals; spartans = _spartans; athenians = _athenians; }",1
0x54a2d42a40f51259dedd1978f6c118a0f0eff078.sol,SecondPriceAuction,"contract SecondPriceAuction { event Buyin(address indexed who, uint accounted, uint received, uint price); event Injected(address indexed who, uint accounted, uint received); event Uninjected(address indexed who); event Ticked(uint era, uint received, uint accounted); event Ended(uint price); event Finalised(address indexed who, uint tokens); event Retired(); function SecondPriceAuction( address _certifierContract, address _tokenContract, address _treasury, address _admin, uint _beginTime, uint _tokenCap ) public { certifier = Certifier(_certifierContract); tokenContract = Token(_tokenContract); treasury = _treasury; admin = _admin; beginTime = _beginTime; tokenCap = _tokenCap; endTime = beginTime + 28 days; }",1
0x0dd1326b7b80107f002ba16dad7fe2dd22f00491.sol,LetsBreakThings,contract LetsBreakThings { address public creator; address public creatorproxy; function deposit() public payable { },1
0x5caeebfab3cd8655e04692351237efb7462c9d8f.sol,VfSE_Lottery,"contract VfSE_Lottery is Ownable { using SafeMath for uint256; address[] private players; address[] public winners; uint256[] public payments; uint256 private feeValue; address public lastWinner; address public authorizedToDraw; address[] private last10Winners = [0,0,0,0,0,0,0,0,0,0]; uint256 public lastPayOut; uint256 public amountRised; address public house; uint256 public round; uint256 public playValue; uint256 public roundEnds; uint256 public roundDuration = 1 days; bool public stopped; address public SecondAddressBalance = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98; address public ThirdAddressBalance = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE; address public FourthAddressBalance = 0x267be1C1D684F78cb4F6a176C4911b741E4Ffdc0; mapping (address => uint256) public payOuts; uint256 private _seed; function bitSlice(uint256 n, uint256 bits, uint256 slot) private pure returns(uint256) { uint256 offset = slot * bits; uint256 mask = uint256((2**bits) - 1) << offset; return uint256((n & mask) >> offset); }",1
0xf4fbef849bcf02ac4b305c2bc092fc270a14124c.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,SignedTransferToken,"contract SignedTransferToken is BaseToken { event TransferPreSigned( address indexed from, address indexed to, address indexed settler, uint256 value, uint256 fee ); event TransferPreSignedMany( address indexed from, address indexed settler, uint256 value, uint256 fee ); mapping(address => mapping(bytes32 => bool)) executedSettlements; function transferPreSigned(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public returns (bool) { uint256 total = _value.add(_fee); bytes32 calcHash = calculateHash(_from, _to, _value, _fee, _nonce); require(_to != address(0)); require(isValidSignature(_from, calcHash, _v, _r, _s)); require(balances[_from] >= total); require(!executedSettlements[_from][calcHash]); executedSettlements[_from][calcHash] = true; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(_from, _to, _value); balances[_from] = balances[_from].sub(_fee); balances[msg.sender] = balances[msg.sender].add(_fee); Transfer(_from, msg.sender, _fee); TransferPreSigned(_from, _to, msg.sender, _value, _fee); return true; }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,I_Pricer,contract I_Pricer { uint128 public lastPrice; I_minter public mint; string public sURL; mapping (bytes32 => uint) RevTransaction; function setMinter(address _newAddress) {},1
0xda36819cfa6167ab5d7932aa8a7852b377a15ab9.sol,DOJC,"contract DOJC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DOJC( ) public { totalSupply = 500000000000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000000000; name = ; symbol = ; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDLogic,contract BitSTDLogic { address public owner; BitSTDData private data; constructor(address dataAddress) { data = BitSTDData(dataAddress); owner = msg.sender; },1
0xcf321c5e50ea2222843fa4f0124cc2d1e0110aea.sol,Lescovex,"contract Lescovex is Ownable { uint256 public totalSupply; using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => uint256) holded; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(block.timestamp>blockEndICO || msg.sender==owner); balances[msg.sender] = balances[msg.sender].sub(_value); holded[_to]=block.number; balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x0e7d77bf4c468b6b626b07be5aa1c8222eb08324.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xdf100fa9a871669f1c99649fe7852ff45228a83b.sol,Star3Dlong,"contract Star3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using Star3DKeysCalcLong for uint256; string constant public name = ; string constant public symbol = ; uint256 private pID_ = 0; uint256 private rndExtra_ = 1 hours; uint256 private rndGap_ = 1 seconds; uint256 constant private rndInit_ = 10 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public registrationFee_ = 10 finney; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Star3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Star3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => Star3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => Star3Ddatasets.TeamFee) public fees_; mapping (uint256 => Star3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = Star3Ddatasets.TeamFee(32, 48, 10); fees_[1] = Star3Ddatasets.TeamFee(45, 35, 10); fees_[2] = Star3Ddatasets.TeamFee(50, 30, 10); fees_[3] = Star3Ddatasets.TeamFee(40, 40, 10); potSplit_[0] = Star3Ddatasets.PotSplit(20, 30); potSplit_[1] = Star3Ddatasets.PotSplit(15, 35); potSplit_[2] = Star3Ddatasets.PotSplit(25, 25); potSplit_[3] = Star3Ddatasets.PotSplit(30, 20); }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,DRCWalletMgrParams,"contract DRCWalletMgrParams is Claimable, Autonomy, Destructible { uint256 public singleWithdrawMin; uint256 public singleWithdrawMax; uint256 public dayWithdraw; uint256 public monthWithdraw; uint256 public dayWithdrawCount; uint256 public chargeFee; address public chargeFeePool; function initialSingleWithdrawMax(uint256 _value) onlyOwner public { require(!init); singleWithdrawMax = _value; }",1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0xee52d05a2351151beabedb7a9e38cc1a2095a8ce.sol,Owner,contract Owner { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x26c7bdd051318b48092390eabd1b69fce5080b25.sol,CETH,"contract CETH is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 500000000e18; uint256 public totalDistributed = 350000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 4000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1bbe0d2d0a284ef9118ee69d356fcdd5948bacf4.sol,BXC,contract BXC is MintableToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; constructor() public { },1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,TokenSaleAfterSplit,"contract TokenSaleAfterSplit is TokenController, Owned, SafeMath { uint public startFundingTime; uint public endFundingTime; uint public tokenCap; uint public totalTokenCount; uint public totalCollected; ControlledToken public tokenContract; address public vaultAddress; bool public transfersAllowed; uint256 public exchangeRate; uint public exchangeRateAt; function TokenSaleAfterSplit ( uint _startFundingTime, uint _endFundingTime, uint _tokenCap, address _vaultAddress, address _tokenAddress, bool _transfersAllowed, uint256 _exchangeRate ) public { require ((_endFundingTime >= now) && (_endFundingTime > _startFundingTime) && (_vaultAddress != 0)); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; tokenCap = _tokenCap; tokenContract = ControlledToken(_tokenAddress); vaultAddress = _vaultAddress; transfersAllowed = _transfersAllowed; exchangeRate = _exchangeRate; exchangeRateAt = block.number; }",1
0x5b135d7e2774c801a73208f258123d7623e07784.sol,SaifuToken,"contract SaifuToken is StandardToken, FreezableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_TOTAL_SUPPLY = 200e6 * (10 ** uint256(decimals)); uint256 public constant AMOUNT_TOKENS_FOR_SELL = 130e6 * (10 ** uint256(decimals)); uint256 public constant RESERVE_FUND = 20e6 * (10 ** uint256(decimals)); uint256 public constant RESERVED_FOR_TEAM = 50e6 * (10 ** uint256(decimals)); uint256 public constant RESERVED_TOTAL_AMOUNT = 70e6 * (10 ** uint256(decimals)); uint256 public alreadyReservedForTeam = 0; address public burnAddress; bool private isReservedFundsDone = false; uint256 private setBurnAddressCount = 0; mapping (address => address) private lockedList; modifier onlyBurnAddress() { require(msg.sender == burnAddress); _; }",1
0x29305d0b0b7046a0b6c2381bc33f771dd8ad13f8.sol,CrowdsaleBase,"contract CrowdsaleBase is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; FractionalERC20 public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (address => bool) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x293ed09bfc80b93cdf5a64306aaedcfad3c64955.sol,Halo3DShrimpFarmer,contract Halo3DShrimpFarmer is AcceptsHalo3D { uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function Halo3DShrimpFarmer(address _baseContract) AcceptsHalo3D(_baseContract) public{ ceoAddress=msg.sender; },1
0xed846c2962df064b6fecc7029bc5cd366699cc7f.sol,SafeMath,"contract SafeMath { function safeToAdd(uint a, uint b) pure internal returns (bool) { return (a + b >= a); }",1
0x8c3cd81e8987e44b8d8702ed6d5791b346d0e1e5.sol,CryptoMemes,"contract CryptoMemes is ERC721 { event Transfer(address from, address to, uint256 tokenId); event Created(address owner, uint256 tokenId, string url, uint256 hash, uint256 createdAt); event UrlUpdated(address owner, uint256 tokenId, string url); modifier onlyOwnerOf(uint256 tokenId) { require(memeIndexToOwner[tokenId] == msg.sender); _; }",1
0x02c86846887faa1d964a838dc50739b49c8329bc.sol,Arbitrator,"contract Arbitrator { enum DisputeStatus {Waiting, Appealable, Solved}",1
0x019d6222f05d67ce4f4d258809b149e8e4034540.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x25db2e489d21be85839992dfa0c17b500be02516.sol,KingdomEthGoldCoin,contract KingdomEthGoldCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x309dfe127881922c356fe8f571846150768c551e.sol,ChessLotto,"contract ChessLotto { uint256 private maxTickets; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address worldOwner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function ChessLotto() public { worldOwner = msg.sender; ticketPrice = 0.00064 * 10**18; maxTickets = 32; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = 0; }",1
0xee4cbe4eca503fef5bfa9a66c9b7ac832853c085.sol,Interim,contract Interim { address public owner; address public bubbled; BLInterface internal BL; CSInterface internal CS; StorageInterface internal s; uint public rate; function Interim() public { owner = msg.sender; },1
0xec7ba74789694d0d03d458965370dc7cf2fe75ba.sol,splitableToken,"contract splitableToken is ERC20,Ownable{ using SafeMath for uint256;using SafeMath for uint256; address[] private holders; constructor() public{ holders.push(msg.sender); }",1
0x4cc29dd2b01a3e0ed005c6e2deb5b3666e4c240c.sol,QMQCoin,"contract QMQCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 300000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x7329e152d805dec79c67e45d4e04f3b6ce545b7c.sol,HmcDistributor,contract HmcDistributor { uint64 public constant lockDuration = 1 minutes; uint256 public constant bonus = 2*10*18; uint public constant minBlockNumber = 5000000; address public owner; address public hmcAddress; uint256 public joinCount = 0; uint256 public withdrawCount = 0; uint256 public distributorCount = 0; struct member { uint unlockTime; bool withdraw; },1
0x5ba0d60f45c3769afe2cdf7826946c8338494467.sol,Multiplier,contract Multiplier { address constant private PROMO1 = 0x44fF136480768B6Ee57BC8c26c7658667A6ceb0F; address constant private PROMO2 = 0xB97Fd03Cf90E7b45451e9Bb9cB904a0862c5f251; address constant private TECH = 0x0365d67E339B09e59E0b56aB336140c02Ef172DC; uint constant public PROMO_PERCENT1 = 2; uint constant public PROMO_PERCENT2 = 2; uint constant public TECH_PERCENT = 2; uint constant public MULTIPLIER = 123; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x920231a0e58d685f29ca3838777093fad88f665f.sol,Moongang,contract Moongang { modifier onlyOwner { require(msg.sender == owner); _; },1
0x585a5601e2d95e988dc51a12759c0ca8309f4483.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a.sol,ZethrGame,"contract ZethrGame { using SafeMath for uint; using SafeMath for uint56; event Result (address player, uint amountWagered, int amountOffset); event Wager (address player, uint amount, bytes data); address[] pendingBetsQueue; uint queueHead = 0; uint queueTail = 0; mapping(address => BetBase) bets; struct BetBase { uint56 tokenValue; uint48 blockNumber; uint8 tier; }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,PreSaleCastle,"contract PreSaleCastle is PreSaleRealm { event CastleSaleCreate(uint indexed saleId, uint indexed castleId, uint indexed price, uint realmId, uint rarity); event BuyCastle(uint indexed saleId, uint castleId, address indexed buyer, uint indexed currentPrice); event CastleOfferSubmit(uint indexed saleId, uint castleId, address indexed bidder, uint indexed price); event CastleOfferAccept(uint indexed saleId, uint castleId, address indexed newOwner, uint indexed newPrice); event SetCastleSale(uint indexed saleId, uint indexed price, uint realmId, uint rarity); event CastleAuctionCreate(uint indexed auctionId, uint indexed castleId, uint indexed startPrice, uint realmId, uint rarity); event CastleAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer); mapping (uint => address) public CastleSaleToBuyer; mapping (uint => bool) CastleIdToIfCreated; struct CastleSale { uint castleId; uint realmId; uint rarity; uint price; bool ifSold; address bidder; uint offerPrice; uint timestamp; }",1
0xa1f30d32e650cabc0be20b921a014c30052145e0.sol,Chewbaka,contract Chewbaka { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2097790e62b5d9cad029e9e1732d1f42790fb648.sol,ExpERC20Token,"contract ExpERC20Token is ERC20Token, Ownable { constructor ( string _name, string _symbol, uint8 _decimals, uint256 _initSupply ) ERC20Token (_name, _symbol, _decimals, _initSupply) public {}",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,Authorizable,"contract Authorizable is Utils { using Math for uint256; address public owner; address public newOwner; mapping (address => Level) authorizeds; uint256 public authorizedCount; enum Level {ZERO,OWNER,ADMIN,DAPP}",1
0xcde881f8b37b41577c65a3904579fff6bb94f3c8.sol,EthKing,"contract EthKing { using SafeMath for uint256; event NewRound( uint _timestamp, uint _round, uint _initialMainPot, uint _initialBonusPot ); event NewKingBid( uint _timestamp, address _address, uint _amount, uint _newMainPot, uint _newBonusPot ); event PlaceChange( uint _timestamp, address _newFirst, address _newSecond, uint _firstPoints, uint _secondPoints ); event Winner( uint _timestamp, address _first, uint _firstAmount, address _second, uint _secondAmount ); event EarningsWithdrawal( uint _timestamp, address _address, uint _amount ); address owner; uint private constant NEXT_POT_FRAC_TOP = 1; uint private constant NEXT_POT_FRAC_BOT = 2; uint private constant MIN_LEADER_FRAC_TOP = 5; uint private constant MIN_LEADER_FRAC_BOT = 1000; uint private constant BONUS_POT_FRAC_TOP = 20; uint private constant BONUS_POT_FRAC_BOT = 100; uint private constant DEV_FEE_FRAC_TOP = 5; uint private constant DEV_FEE_FRAC_BOT = 100; uint private constant POINT_EXPONENT = 2; uint private constant POINTS_TO_WIN = 1000000; address null_address = address(0x0); address public king; uint public crownedTime; address public first; address public second; struct Player { uint points; uint roundLastPlayed; uint winnings; }",1
0x2928fd99b11a412a6b6724ed391943bae3fe1b2b.sol,MustToken,"contract MustToken is StandardBurnableToken, RBACERC223TokenFinalization, RBACMintableTokenMixin { string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 8; uint256 constant public cap = 500 * (10 ** 6) * (10 ** decimals); function mint( address _to, uint256 _amount ) public returns (bool) { require(totalSupply().add(_amount) <= cap); return super.mint(_to, _amount); }",1
0xc5fdd0f8cb5706ff35d62b16885c222574c295b2.sol,TokenRecover,"contract TokenRecover is Ownable { function recoverERC20( address _tokenAddress, uint256 _tokens ) public onlyOwner returns (bool success) { return ERC20Basic(_tokenAddress).transfer(owner, _tokens); }",1
0x7288c72af505e3a6ff2712699e2a695465d353b3.sol,MilitaryPay,"contract MilitaryPay is StandardToken { using SafeMath for uint256; event CreatedMTP(address indexed _creator, uint256 _amountOfMTP); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; uint256 public maxPresaleSupply; uint256 public constant preSaleStartTime = 1503130673; uint256 public constant preSaleEndTime = 1505894400; uint256 public saleStartTime = 1509696000; uint256 public saleEndTime = 1514707200; uint256 public lowEtherBonusLimit = 5 * 1 ether; uint256 public lowEtherBonusValue = 110; uint256 public midEtherBonusLimit = 24 * 1 ether; uint256 public midEtherBonusValue = 115; uint256 public highEtherBonusLimit = 50 * 1 ether; uint256 public highEtherBonusValue = 120; uint256 public highTimeBonusLimit = 0; uint256 public highTimeBonusValue = 120; uint256 public midTimeBonusLimit = 1036800; uint256 public midTimeBonusValue = 115; uint256 public lowTimeBonusLimit = 2073600; uint256 public lowTimeBonusValue = 110; uint256 public constant MTP_PER_ETH_PRE_SALE = 4000; uint256 public constant MTP_PER_ETH_SALE = 2000; address public constant ownerAddress = 0x144EFeF99F7F126987c2b5cCD717CF6eDad1E67d; bool public allowInvestment = true; uint256 public totalWEIInvested = 0; uint256 public totalMTPAllocated = 0; mapping (address => uint256) public WEIContributed; function MTPToken() { require(msg.sender == ownerAddress); totalSupply = 631*1000000*1000000000000000000; uint256 totalMTPReserved = totalSupply.mul(55).div(100); maxPresaleSupply = totalSupply*8/1000 + totalMTPReserved; balances[msg.sender] = totalMTPReserved; totalMTPAllocated = totalMTPReserved; }",1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x0240a41a931a97b5360c0be928a4eadda219bf86.sol,saleOwned,contract saleOwned is owned{ mapping (address => bool) public saleContract; modifier onlySaleOwner { require(msg.sender == owner || true == saleContract[msg.sender]); _; },1
0x25db2e489d21be85839992dfa0c17b500be02516.sol,KingdomEthGoldCoin,contract KingdomEthGoldCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x541317cbeea0d862bad9bc4d330feb565e610209.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; uint256 public currentTime; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmount; uint256 tokensIssued; },1
0x720df200439f47fd4185f76a0a131a322d61ddd3.sol,LIIRA,contract LIIRA { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 10000000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x8489549e39cff637dbe5be19eaf389beb47225d3.sol,StandardToken,"contract StandardToken is Token, Stop { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) public stoppable returns (bool success) { require(_to != address(0)); require(_value <= balanceOf[msg.sender]); require(balanceOf[_to] + _value > balanceOf[_to]); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; }",1
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol,FoMo3DLight,"contract FoMo3DLight is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; uint256 public pID_ = 4; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 20 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(49,2); fees_[1] = F3Ddatasets.TeamFee(49,2); fees_[2] = F3Ddatasets.TeamFee(49,2); fees_[3] = F3Ddatasets.TeamFee(49,2); potSplit_[0] = F3Ddatasets.PotSplit(38,2); potSplit_[1] = F3Ddatasets.PotSplit(38,2); potSplit_[2] = F3Ddatasets.PotSplit(38,2); potSplit_[3] = F3Ddatasets.PotSplit(38,2); }",1
0xedeab579e57a7d66297d0a67302647bb109db7a8.sol,BreakTheBank,contract BreakTheBank { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd6aca5b766853f7879d153fdb7567be356dd46ec.sol,ExeniumToken,"contract ExeniumToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 8; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function ExeniumToken() public {}",1
0x1bcbc935b377432224b9050211edaaf67f184f0d.sol,subSale,contract subSale{ AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b); address admin = 0x1f51d1d29AaFb00188168227a49d8f7E5D5b5bD9; struct Domain{ address originalOwner; uint regPeriod; bool subSale; uint subPrice; uint subExpiry; },1
0x6f655b9e1e79a8979ad5bf8f141f2fc4dc71540c.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x52e1558e02f72c2b876095accd5c6aec5be27e36.sol,CANDYGROUP,contract CANDYGROUP { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 1; uint public _totalSupply = 10000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x274bbd862606b7011fa961ecb5a697b9fdf804cf.sol,WrapperLock,"contract WrapperLock is BasicToken, Ownable { using SafeMath for uint256; address public TRANSFER_PROXY_VEFX = 0xdcDb42C9a256690bd153A7B409751ADFC8Dd5851; address public TRANSFER_PROXY_V2 = 0x2240Dab907db71e64d3E0dbA4800c83B5C502d4E; mapping (address => bool) public isSigner; bool public erc20old; string public name; string public symbol; uint public decimals; address public originalToken; mapping (address => uint256) public depositLock; mapping (address => uint256) public balances; function WrapperLock(address _originalToken, string _name, string _symbol, uint _decimals, bool _erc20old) Ownable() { originalToken = _originalToken; name = _name; symbol = _symbol; decimals = _decimals; isSigner[msg.sender] = true; erc20old = _erc20old; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,usingOraclize,contract usingOraclize is DSAuth { byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x70fa1a3b14a6dcc4228a3d2674d86b6d482b5f71.sol,Bluechipstoken,"contract Bluechipstoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 25000000e8; uint256 public constant minContribution = 1 ether / 1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd81ada188331e627567bbef80f91217cd3109592.sol,ExternStateToken,"contract ExternStateToken is SelfDestructible, Proxyable { using SafeMath for uint; using SafeDecimalMath for uint; TokenState public tokenState; string public name; string public symbol; uint public totalSupply; uint8 public decimals; constructor(address _proxy, TokenState _tokenState, string _name, string _symbol, uint _totalSupply, uint8 _decimals, address _owner) SelfDestructible(_owner) Proxyable(_proxy, _owner) public { tokenState = _tokenState; name = _name; symbol = _symbol; totalSupply = _totalSupply; decimals = _decimals; }",1
0xd48f07d942a075fbba9836a2898dda2702c7ffda.sol,SafeMath,"contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x0cf84a5dc7af17f6fb3e0c21d9f03398644a42d6.sol,IOXDistribution,contract IOXDistribution { address public owner; mapping(uint256 => bool) public claimers; token public ioxToken; event Signer(address signer); function IOXDistribution(address tokenAddress) public { owner = msg.sender; ioxToken = token(tokenAddress); },1
0x275b69aa7c8c1d648a0557656bce1c286e69a29d.sol,Enumivo,"contract Enumivo is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpImageStorage,contract BdpImageStorage is BdpBase { using SafeMath for uint256; struct Image { address owner; uint256 regionId; uint256 currentRegionId; mapping(uint16 => uint256[1000]) data; mapping(uint16 => uint16) dataLength; uint16 partsCount; uint16 width; uint16 height; uint16 imageDescriptor; uint256 blurredAt; },1
0x2a46885f8e02ce11dd21209f3cbc3e91561cfc8a.sol,TMToken,"contract TMToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7967e7ea76c0688cbc599df22befb29707bd2f7a.sol,MintableToken,"contract MintableToken is StandardTokenExt { using SafeMathLib for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); event Minted(address receiver, uint amount); function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply_ = totalSupply_.plus(amount); balances[receiver] = balances[receiver].plus(amount); Transfer(0, receiver, amount); }",1
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,TPXToken,"contract TPXToken is MintableToken, Destructible { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public maxSupply = 200000000 ether; bool public transferDisabled = true; event Confiscate(address indexed offender, uint256 value); constructor() public {}",1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,DecentralandVesting,"contract DecentralandVesting is TokenVesting { using SafeERC20 for ERC20; event LockedMANA(uint256 amount); ReturnVestingRegistry public returnVesting; TerraformReserve public terraformReserve; function DecentralandVesting( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable, ERC20 _token, ReturnVestingRegistry _returnVesting, TerraformReserve _terraformReserve ) TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable, _token) { returnVesting = ReturnVestingRegistry(_returnVesting); terraformReserve = TerraformReserve(_terraformReserve); }",1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,ERC20Token,"contract ERC20Token is IERC20Token, SafeMath { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ERC20Token(string _name, string _symbol, uint8 _decimals) { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; decimals = _decimals; }",1
0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9.sol,dividendsContract,contract dividendsContract is Owned{ Ethernational dc; mapping(address => uint) paid; uint public totalSupply; uint public totalPaid; address public ICOaddress; function ICOaddress(address _t) onlyOwner{ dc = Ethernational(_t); ICOaddress = _t; totalSupply = dc.totalSupply() / 1000000000000; },1
0x9c49b65ddef30ad4a32c0ff6bf103144cd7733fc.sol,Sports3D,contract Sports3D { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x753b5a6a90981e9fa9d4c6380d76226391c56b0e.sol,LoteoGame,"contract LoteoGame is Recoverable, usingOraclize { using SafeMath for uint256; StandardTokenExt public ticketToken; StandardTokenExt public bonusToken; uint256 public interval; uint256 public firstGameTime; address public ticketVault; address public bonusVault; address public serviceVault; address public feeVault; struct Game { uint256 endTime; mapping(uint256 => address) tickets; uint256 ticketsBought; uint256 ticketsUsed; address winner; uint256 prize; uint256 seed; mapping(address => uint256) ticketsByUser; }",1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5136c98a80811c3f46bdda8b5c4555cfd9f812f0.sol,IndaHashToken,"contract IndaHashToken is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510153200; uint public constant DATE_PRESALE_END = 1510758000; uint public constant DATE_ICO_START = 1511967600; uint public constant DATE_ICO_END = 1513782000; uint public tokensPerEth = 3200 * E6; uint public constant BONUS_PRESALE = 40; uint public constant BONUS_ICO_WEEK_ONE = 20; uint public constant BONUS_ICO_WEEK_TWO = 10; uint public constant TOKEN_SUPPLY_TOTAL = 400 * E6 * E6; uint public constant TOKEN_SUPPLY_ICO = 320 * E6 * E6; uint public constant TOKEN_SUPPLY_MKT = 80 * E6 * E6; uint public constant PRESALE_ETH_CAP = 15000 ether; uint public constant MIN_FUNDING_GOAL = 40 * E6 * E6; uint public constant MIN_CONTRIBUTION = 1 ether / 2; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 90 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function IndaHashToken() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0x92ddab77ed88c3b54b01e1b0d0268c8b0fa601bd.sol,NVTDrop,contract NVTDrop is Ownable{ mapping(address => bool) getDropped; bool public halted = true; uint256 public amout = 1 * 10 ** 4; address public NVTAddr; NVT NVTFace; function setNVTface(address _nvt) public onlyOwner { NVTFace = NVT(_nvt); },1
0x485b224c97ad56dc5b145eafdee71a7b5163f735.sol,PonziBet,contract PonziBet { using SafeMath for uint; EthPyramid public pyramid; address public admin; address public contractAddress; uint public minBet; uint public roundTime; uint public startPrice; uint public endPrice; uint[] public upBetRecords; uint[] public downBetRecords; mapping (address => uint) lastBet; mapping (address => bool) userBet; mapping (bool => uint) totalBalance; mapping (address => uint) feeBalance; mapping (address => mapping (bool => uint)) userBalances; function PonziBet() public { admin = msg.sender; },1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsPreSale,contract EthernautsPreSale is EthernautsLogic { function EthernautsPreSale() public EthernautsLogic() {},1
0x01805928b325078683818329526dab3f74865e10.sol,AumICO,"contract AumICO is usingOraclize, SafeMath { struct OperationInQueue { uint operationStartTime; uint depositedEther; address receiver; bool closed; }",1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,PreSaleDisciple,"contract PreSaleDisciple is PreSaleGuardian { event DiscipleSaleCreate(uint indexed saleId, uint indexed discipleId, uint indexed price, uint occupation, uint level); event BuyDisciple(uint indexed saleId, uint discipleId, address indexed buyer, uint indexed currentPrice); event DiscipleOfferSubmit(uint indexed saleId, uint discipleId, address indexed bidder, uint indexed price); event DiscipleOfferAccept(uint indexed saleId, uint discipleId, address indexed newOwner, uint indexed newPrice); event SetDiscipleSale(uint indexed saleId, uint indexed price, uint occupation, uint level); event DiscipleAuctionCreate(uint indexed auctionId, uint indexed discipleId, uint indexed startPrice, uint occupation, uint level); event DiscipleAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer); event VendingDisciple(uint indexed vendingId, address indexed buyer); event DiscipleVendOffer(uint indexed vendingId, address indexed bidder, uint indexed offer); event DiscipleVendAccept(uint indexed vendingId, address indexed newOwner, uint indexed newPrice); event SetDiscipleVend(uint indexed priceId, uint indexed price); mapping (uint => address) public DiscipleSaleToBuyer; mapping (uint => bool) DiscipleIdToIfCreated; mapping (uint => uint) public DiscipleVendToOffer; mapping (uint => address) public DiscipleVendToBidder; mapping (uint => uint) public DiscipleVendToTime; struct DiscipleSale { uint discipleId; uint occupation; uint level; uint price; bool ifSold; address bidder; uint offerPrice; uint timestamp; }",1
0xf19eac69f9566f0b40660bd0cc16234330f38456.sol,CraftR,"contract CraftRStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function pos() returns (bool); function coinAge() constant returns (uint256); function annualPos() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x5398dbc256fcd5128d92c32919f1da0885777ea3.sol,SAXO,"contract SAXO is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 15000000000000000000000000000; address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 15000000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 10000 * (10**uint256(decimals)); uint256 public startTimeDay = 1; uint256 public endTimeDay = 86400; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0xe304283c3e60cefaf7ea514007cf4e8fdc3d869d.sol,GECOIN,"contract GECOIN is MintableToken { event Burn(address indexed burner, uint256 value); string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; bool public AllowTransferGlobal = false; bool public AllowTransferLocal = false; bool public AllowTransferExternal = false; bool public AllowBurnByCreator = true; bool public AllowBurn = true; mapping(address => uint256) public Whitelist; mapping(address => uint256) public LockupList; mapping(address => bool) public WildcardList; mapping(address => bool) public Managers; function allowTransfer(address _from, address _to) public view returns (bool) { if (WildcardList[_from]) return true; if (LockupList[_from] > now) return false; if (!AllowTransferGlobal) { if (AllowTransferLocal && Whitelist[_from] != 0 && Whitelist[_to] != 0 && Whitelist[_from] < now && Whitelist[_to] < now) return true; if (AllowTransferExternal && Whitelist[_from] != 0 && Whitelist[_from] < now) return true; return false; }",1
0x25d94b021b69d9c01931ff40bd265cfc3d920f72.sol,HandleLogic,"contract HandleLogic is Ownable { uint256 public price; mapping (bytes32 => mapping (bytes32 => address)) public handleIndex; mapping (bytes32 => bool) public baseRegistred; mapping (address => mapping (bytes32 => bool)) public ownsBase; event NewBase(bytes32 _base, address indexed _address); event NewHandle(bytes32 _base, bytes32 _handle, address indexed _address); event BaseTransfered(bytes32 _base, address indexed _to); function registerBase(bytes32 _base) public payable { require(msg.value >= price); require(!baseRegistred[_base]); baseRegistred[_base] = true; ownsBase[msg.sender][_base] = true; NewBase(_base, msg.sender); }",1
0xb444264c33ef3c8f9ba46df194826c22d54d0d12.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (bytes32 => uint64) internal chains; mapping (bytes32 => uint) internal freezings; mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; }",1
0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8.sol,DailyDivs,contract DailyDivs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0532dd9ecb00c424c72335df4f60c11c03229ec0.sol,ObirumCrowdsale,"contract ObirumCrowdsale{ using SafeMath for uint256; uint256 public constant kRate = 20000; uint256 public constant kMinStake = 0.1 ether; uint256 public constant kMaxStake = 200 ether; uint256[9] internal stageLimits = [ 100 ether, 300 ether, 1050 ether, 3050 ether, 8050 ether, 18050 ether, 28050 ether, 38050 ether, 48050 ether ]; uint128[9] internal stageDiscounts = [ 300, 250, 200, 150, 135, 125, 115, 110, 105 ]; mapping(address => uint256) balances; uint256 public weiRaised; uint8 public currentStage = 0; token public reward; address public owner; uint public startTime; uint public endTime; address public wallet; uint256 public tokensSold; uint256 constant public softCap = 106000000 * (10**18); uint256 constant public hardCap = 1151000000 * (10**18); bool private isStartTimeSet = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Refund(address indexed receiver, uint256 amount); function ObirumCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _owner) public { require(_startTime >= now); require(_endTime >= _startTime); require(_wallet != address(0)); require(_token != address(0)); require(_owner != address(0)); startTime = _startTime; endTime = _endTime; wallet = _wallet; owner = _owner; reward = token(_token); }",1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x509a38b7a1cc0dcd83aa9d06214663d9ec7c7f4a.sol,BlocksquareToken,"contract BlocksquareToken is ERC20Token, owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public tokenFrozen; uint256 supply; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; mapping (address => bool) allowedToMint; event TokenFrozen(bool _frozen, string _reason); event Mint(address indexed _to, uint256 _value); function BlocksquareToken() public { tokenFrozen = true; }",1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed81af91c38ac12b0464bf1ca4b887469f7adaec.sol,DataManager,contract DataManager is Pausable { address public dataCentreAddr; function DataManager(address _dataCentreAddr) { dataCentreAddr = _dataCentreAddr; },1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0xc4dc589b8eb5f44d6c36e0dc8fdc7a96bbe33bcb.sol,COC_TOKEN,"contract COC_TOKEN is IERC20 { using SafeMath for uint256; address private deployer; string public name = ; string public symbol = ; uint8 public constant decimals = 6; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 1000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() public { balances[msg.sender] = totalSupply; deployer = msg.sender; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0f33bb20a282a7649c7b3aff644f084a9348e933.sol,YupieToken,"contract YupieToken is StandardToken { using SafeMath for uint256; event CreatedYUPIE(address indexed _creator, uint256 _amountOfYUPIE); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; uint256 public maxPresaleSupply; uint256 public constant preSaleStartTime = 1502784000; uint256 public constant preSaleEndTime = 1505671200; uint256 public saleStartTime = 1509523200; uint256 public saleEndTime = 1512115200; uint256 public lowEtherBonusLimit = 5 * 1 ether; uint256 public lowEtherBonusValue = 110; uint256 public midEtherBonusLimit = 24 * 1 ether; uint256 public midEtherBonusValue = 115; uint256 public highEtherBonusLimit = 50 * 1 ether; uint256 public highEtherBonusValue = 120; uint256 public highTimeBonusLimit = 0; uint256 public highTimeBonusValue = 120; uint256 public midTimeBonusLimit = 1036800; uint256 public midTimeBonusValue = 115; uint256 public lowTimeBonusLimit = 2073600; uint256 public lowTimeBonusValue = 110; uint256 public constant YUPIE_PER_ETH_PRE_SALE = 3000; uint256 public constant YUPIE_PER_ETH_SALE = 1000; address public constant ownerAddress = 0x20C84e76C691e38E81EaE5BA60F655b8C388718D; bool public allowInvestment = true; uint256 public totalWEIInvested = 0; uint256 public totalYUPIESAllocated = 0; mapping (address => uint256) public WEIContributed; function YupieToken() { require(msg.sender == ownerAddress); totalSupply = 631*1000000*1000000000000000000; uint256 totalYUPIESReserved = totalSupply.mul(55).div(100); maxPresaleSupply = totalSupply*8/1000 + totalYUPIESReserved; balances[msg.sender] = totalYUPIESReserved; totalYUPIESAllocated = totalYUPIESReserved; }",1
0xf00e5a59fde1cb2ead96a8be7711abc3f981e0f1.sol,TwelveHourTrains,"contract TwelveHourTrains { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 100; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 2 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x090d3c6558cbe8dd8a350ad8d54fc0d72dc38dac.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x47c5ee9d1993a6d83c3ca28e3046d9cebf72b48a.sol,PSTRToken,contract PSTRToken is AbstractToken { address public owner; uint256 tokenCount = 0; bool frozen = false; uint256 constant MAX_TOKEN_COUNT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; uint public constant _decimals = (10**8); modifier onlyOwner() { require(owner == msg.sender); _; },1
0xbf5fb038c28df2b8821988da78c3ebdbf7aa5ac7.sol,GIFT_ENVELOPE,contract GIFT_ENVELOPE { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb.sol,OXO,contract OXO is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x56b3f7e9c10dc62fddbbb69e66806f6034095f24.sol,Bestmoney_new,contract Bestmoney_new { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x1de89382684ce5a99fc9d3d4b709706d6a013571.sol,SolutionGame,contract SolutionGame is HWCIntegration { uint256 countWinnerPlace; mapping (uint256 => uint256) internal prizeDistribution; mapping (uint256 => uint256) internal prizesByPlace; mapping (uint256 => uint256) internal scoreByPlace; mapping (uint => uint) winnerMap; uint[] winnerList; mapping (uint256 => uint256) internal prizesByPlaceHWC; bool isWinnerTime = false; modifier whenWinnerTime() { require(isWinnerTime); _; },1
0x1e2e9cabb5744c314de7978c081bd57c357e000d.sol,CryptoMyWord,"contract CryptoMyWord { using SafeMath for uint256; using strings for *; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event NewWord(uint wordId, string name, uint price); address private owner; uint256 nameTokenId; uint256 tokenId; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.8 ether; uint256 private increaseLimit2 = 1.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) public ownerOfItem; mapping (address => string) public nameOfOwner; mapping (address => string) public snsOfOwner; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => string) private nameOfItem; mapping (uint256 => string) private urlOfItem; mapping (uint256 => address[]) private borrowerOfItem; mapping (string => uint256[]) private nameToItems; mapping (uint256 => address) private approvedOfItem; mapping (string => uint256) private nameToParents; mapping (string => uint256) private nameToNameToken; mapping (string => string) private firstIdOfName; mapping (string => string) private secondIdOfName; function CryptoMyWord () public { owner = msg.sender; admins[owner] = true; }",1
0x32dba556c82f6106bbb9982812d0255cf1959109.sol,AbToken,"contract AbToken is CappedToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public constant MAX_SUPPLY = 100 * 10000 * 10000 * (10 ** uint256(decimals)); constructor() CappedToken(MAX_SUPPLY) public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x0200412995f1bafef0d3f97c4e28ac2515ec1ece.sol,MigratoryToken,contract MigratoryToken is HoldersToken { using SafeMath for uint256; address public migrationAgent; uint256 public migrationCountComplete; function setMigrationAgent(address agent) public onlyOwner { migrationAgent = agent; },1
0xe1754d039c839192ee193d5cf8406fb24fcb421f.sol,ETHToken,"contract ETHToken is ERC20Interface { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant tokenCreationCap = 3000000* 10**18; uint256 public constant tokenCreationMin = 1* 10**18; mapping(address => mapping (address => uint256)) allowed; uint public fundingStart; uint public fundingEnd; bool public funding = true; address public master; uint256 totalTokens; uint256 soldAfterPowerHour; mapping (address => uint256) balances; mapping (address => uint) lastTransferred; mapping (address => uint256) balancesEther; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); uint totalParticipants; function ETHToken() { master = msg.sender; fundingStart = 1511654250; fundingEnd = 1511663901; }",1
0xef6efb3fc5b9aba75af7250989db7974fd6361ba.sol,FinToken,"contract FinToken is StandardToken { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals)); mapping (address => bool) internal verificatorAddresses; mapping (address => bool) internal verifiedAddresses; event AddVerificator(address indexed verificator); event RemoveVerificator(address indexed verificator); event AddVerified(address indexed verificatorAddress, address indexed verified); event RemoveVerified(address indexed verificatorAddress, address indexed verified); event Mint(address indexed to, uint256 amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x20807701c41f451a7661cb5ea00f3a12b66b818f.sol,Roi20,"contract Roi20 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; string public name = ; string public symbol = ; uint8 constant public decimals = 18; uint256 public step = 20; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 2 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x54702ad7b5607f71cb083c3ebb3447f15c6b4c83.sol,AdvanceToken,"contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { }",1
0x3619e0299f9c3f5c6502abdabf77d246fd328ea5.sol,CryptoMinerToken3,contract CryptoMinerToken3 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol,MahalaToken,"contract MahalaToken is owned, TokenERC20 { using SafeMath for uint256; uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MahalaToken() TokenERC20(180000000, , ) public {}",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINContract,"contract VINContract is SafeMath { VINNDTokenContract public VINToken; enum Stage{ Pause, Init, Running, Stopped }",1
0xf508548ef0ef6472760a36e15169b847ae427d38.sol,BasicCrowdsale,contract BasicCrowdsale is Ownable { using SafeMath for uint256; BasicERC20 token; address public ownerWallet; uint256 public startTime; uint256 public endTime; uint256 public totalEtherRaised = 0; uint256 public minDepositAmount; uint256 public maxDepositAmount; uint256 public softCapEther; uint256 public hardCapEther; mapping(address => uint256) private deposits; constructor () public { },1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Auction,contract Auction is Beneficial { function Auction(address _gameToken) public { owner = msg.sender; shareholder = _gameToken; shareholderIsToken = true; },1
0x261bb5e1c53248860f4bc405abaae3e0bfc12874.sol,MycodeCoin,"contract MycodeCoin is Token, LockBalance { function MycodeCoin() public { name = ; symbol = ; decimals = 18; uint256 initialSupply = 10000000000; totalSupply = initialSupply * 10 ** uint(decimals); user[owner].balance = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0x20c6c51edfb707f8965bb7caafc77372978eff10.sol,ProofOfSheepM,contract ProofOfSheepM { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0xc3ec3066c76e80b0643c523cbe82fc2befbb2de8.sol,MyTokenEVC,"contract MyTokenEVC is owned { string _name; string _symbol; uint8 _decimals = 18; uint256 _totalSupply; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) _allowance; mapping (address => bool) _frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(_decimals); _balanceOf[msg.sender] = _totalSupply; _name = ; _symbol = ; }",1
0x573e869ca9355299cddb3a912d444f137ded397c.sol,Fortis,contract Fortis { using SafeMath for uint; modifier onlyHolders() { require(myFrontEndTokens() > 0); _; },1
0xeb6ce9be3591d95c2bb5ce793ee2b9c58322bb9e.sol,PRASMToken,"contract PRASMToken is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 unlockAmountPerMonth; uint256 lockupBalance; }",1
0x36e666eaac18ed22b8e370547c75e6782b63d5da.sol,Token,"contract Token { using SafeMath for uint256; address public owner; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 totalSupply_ = 20e8 * (10**18); bool public paused = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => uint256) internal locked; event Burn(address indexed burner, uint256 value); event Approval(address indexed owner, address indexed spender,uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Pause(); event Unpause(); event Lock(address indexed LockedAddress, uint256 LockAmount); event Unlock(address indexed LockedAddress); constructor() public { owner = msg.sender; balances[owner] = totalSupply_ ; }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x1e3fe98d1c89865b6b819bbfd532dadab3b34d2d.sol,DETToken,"contract DETToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) private balances; mapping (address => mapping (address => uint256)) private allowed; uint256 private totalSupply_ = 98000000 * (10 ** 18); string private constant name_ = ; string private constant symbol_ = ; uint8 private constant decimals_ = 18; constructor () public { balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x183baee572249ab21999034277c8c64cccceacfa.sol,SEGFAULTCOIN,contract SEGFAULTCOIN { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xf34c12c6f87dbc09bfb586880e9b6d54bba13b1f.sol,LitecoinDiamond,"contract LitecoinDiamond is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 12000000000000000; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 1000000000000; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x88a3e4f35d64aad41a6d4030ac9afe4356cb84fa.sol,preToken,"contract preToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 public constant maxSupply = 1000000000e18; uint256 public constant initialSupply = 250000000e18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; address public owner; address public crowdsaleAddress; uint public unlockDate = 1512018000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; }",1
0x02242d41c54f261a85ac8e8efa7046a3dfd53113.sol,C_banK,"contract C_banK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRToken,contract VUULRTokenConfig { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS); uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR; },1
0x29488e24cfdaa52a0b837217926c0c0853db7962.sol,SuperCard,"contract SuperCard is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xb838c100EB1a1d08B215FBbCC06698e9c181358C); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 4637 seconds; uint256 constant private rndInc_ = 15 seconds; uint256 constant private rndMax_ = 3 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(19,4); fees_[1] = F3Ddatasets.TeamFee(37,6); fees_[2] = F3Ddatasets.TeamFee(67,7); potSplit_[0] = F3Ddatasets.PotSplit(15,30); potSplit_[1] = F3Ddatasets.PotSplit(25,25); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0xf19fda219b547bcd4d41bd6ed9b914a77b4202e1.sol,MoneroWhite_ERC20,"contract MoneroWhite_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 500000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 10; uint256 public tokensPerEth = 2000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6e3bc8f50d04f7262f5c99f1cbabe502eb5e37f5.sol,FlipCrowdsale,"contract FlipCrowdsale is Contactable, Pausable, HasNoContracts, HasNoTokens, FinalizableCrowdsale { using SafeMath for uint256; uint256 public tokensSold = 0; function FlipCrowdsale(MintableToken _token, uint256 _startTime, uint256 _endTime, address _ethWallet) Ownable() Pausable() Contactable() HasNoTokens() HasNoContracts() Crowdsale(_startTime, _endTime, 1, _ethWallet) FinalizableCrowdsale() { token = _token; contactInformation = 'https: }",1
0xf296fbc18ebce3eeb1026abbb4c9ee406f7c4467.sol,PowerOfCommunity,contract PowerOfCommunity { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x40f4991411ac5377675c421e87378e10470134a3.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x510a71bd8a3ee739b099d433f5492d3f7b3fdd57.sol,TSBToken,"contract TSBToken is ERC20, NamedOwnedToken { using SafeMath for uint256; uint256 public _totalSupply = 0; uint8 public decimals = 18; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => uint256) public paidETH; uint256 public accrueDividendsPerXTokenETH = 0; uint256 public tokenPriceETH = 0; mapping (address => uint256) public paydCouponsETH; uint256 public accrueCouponsPerXTokenETH = 0; uint256 public totalCouponsUSD = 0; uint256 public MaxCouponsPaymentUSD = 150000; mapping (address => uint256) public rebuySum; mapping (address => uint256) public rebuyInformTime; uint256 public endSaleTime; uint256 public startRebuyTime; uint256 public reservedSum; bool public rebuyStarted = false; uint public tokenDecimals; uint public tokenDecimalsLeft; function TSBToken( string tokenName, string tokenSymbol ) NamedOwnedToken(tokenName, tokenSymbol) public { tokenDecimals = 10**uint256(decimals - 5); tokenDecimalsLeft = 10**5; startRebuyTime = now + 1 years; endSaleTime = now; }",1
0xdcaad9fd9a74144d226dbf94ce6162ca9f09ed7e.sol,StrikersMetadata,contract StrikersMetadata { string public apiUrl; constructor(string _apiUrl) public { apiUrl = _apiUrl; },1
0x8aed6360f228a232cecfa86c64e9aff507aa84a6.sol,Migrations,contract Migrations { address public owner; uint public last_completed_migration; modifier restricted() { if (msg.sender == owner) _; },1
0x58ac2e510e41fd878d81131cf8d87bc09b2a7afd.sol,ExhaustionCoin,"contract ExhaustionCoin is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 500e9 * 1e8; uint256 public distributeAmount = 0; bool public mintingFinished = false; address public Addr1 = 0x68FF231F1AF6e982437a157db8DeddCf91878220; address public Addr2 = 0x97D3b60C2266484F415B7549B8E8fd73a66BF5e7; address public Addr3 = 0xaadA9D72f0b560f47B7e19eE26A6fBB78566CA24; address public Addr4 = 0xE7A55Cf0642A497921b67893D5a7cDF51B389f46; address public Addr5 = 0x55BA76b349669fF87367D98e7767C38396677aA3; address public Addr6 = 0xedF3dC209d58f7C05b7f5dC807F28A2835bC987a; address public Addr7 = 0x19839dC3b6981Fc511dc00fEc42C5aE549Eb51cD; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ExhaustionCoin() public { owner = Addr1; balanceOf[Addr1] = totalSupply.mul(20).div(100); balanceOf[Addr2] = totalSupply.mul(10).div(100); balanceOf[Addr3] = totalSupply.mul(10).div(100); balanceOf[Addr4] = totalSupply.mul(20).div(100); balanceOf[Addr5] = totalSupply.mul(20).div(100); balanceOf[Addr6] = totalSupply.mul(10).div(100); balanceOf[Addr7] = totalSupply.mul(10).div(100); }",1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,daylimit,contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; },1
0x84fe204e5d9f612d2fc92623f6b9bf980e816cb9.sol,RGO,"contract RGOinterface { function RGOFallback(address _from, uint _value, uint _code); }",1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,ETNToken,"contract ETNToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x6e9bd981c217be137312a34ee06bcdf8eb2b890f.sol,TrineChain,"contract TrineChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) locknum; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 1000000000 * _Rate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Locked(address indexed to, uint256 amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x03966330e7f60c95d2d8dd043735eea901c5e4e0.sol,ERC721,"contract ERC721 is ERC165, IERC721 { using SafeMath for uint256; using Address for address; bytes4 private constant _ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) private _tokenOwner; mapping (uint256 => address) private _tokenApprovals; mapping (address => uint256) private _ownedTokensCount; mapping (address => mapping (address => bool)) private _operatorApprovals; bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd; constructor() public { _registerInterface(_InterfaceId_ERC721); }",1
0x1fa3e0dfd510431f24d2b87802efa593bdbee8be.sol,Bitray,"contract Bitray is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 100000000000e8; uint256 public totalDistributed = 50000000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xfef5497bc53a69875e02ae5b14eeff668f09a729.sol,Infinity,"contract Infinity { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public initAmount; uint256 public amountProportion; uint256 public dividend; uint256 public jackpot; uint256 public jackpotProportion; uint256 public scientists; uint256 public promotionRatio; uint256 public duration; bool public activated = false; address public developerAddr; uint256 public rId; uint256 public sId; mapping (uint256 => Indatasets.Round) public round; mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage; mapping (address => Indatasets.Player) public player; mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; mapping (uint256 => mapping (address => uint256)) public playerRoundSid; mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount; uint256[] amountLimit = [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]; constructor() public { developerAddr = msg.sender; }",1
0xeee90e509a639e95e3bb502b17a0eed6e014bfc0.sol,BancorNetwork,"contract BancorNetwork is IBancorNetwork, TokenHolder, ContractIds, FeatureIds { using SafeMath for uint256; uint64 private constant MAX_CONVERSION_FEE = 1000000; address public signerAddress = 0x0; IContractRegistry public registry; mapping (address => bool) public etherTokens; mapping (bytes32 => bool) public conversionHashes; constructor(IContractRegistry _registry) public validAddress(_registry) { registry = _registry; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Jingle,"contract Jingle is Ownable, ERC721 { struct MetaInfo { string name; string author; }",1
0x3f9e8af3ab96c7560c1404ed2d6794ead7ce846a.sol,ERC20,"contract ERC20Interface { string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x6ec8a24cabdc339a06a172f8223ea557055adaa5.sol,GNX,"contract GNX is MiniMeIrrevocableVestedToken { uint constant D160 = 0x0010000000000000000000000000000000000000000; function GNX( address _tokenFactory ) MiniMeIrrevocableVestedToken( _tokenFactory, 0xBB13E608888E5D30C09b13F89d27631056161B9F, 4313000, , 9, , true ) {}",1
0xd2707cea59e2914bfc200d6188233309a6aece02.sol,Token,"contract Token is ERC20Interface, Owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { name = ; symbol = ; decimals = 18; _totalSupply = 15000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x1b82c3dec4a1ccfff5f326f4672784b46f83f309.sol,Promise,"contract Promise{ string public vow; address public promisor; address public beneficiary; uint public deposit; uint public endDate; address[3] public judges; uint[3] public signedByJudge; bool public signedByPromisor; uint[3] public votedFoul; uint public foulVotes = 0; uint[3] public votedShy; uint public shyVotes = 0; uint[3] public votedSuccess; uint public successVotes = 0; bool public sentMoney = false; constructor(address _promisor, string _vow, uint _deposit, uint _endDate, address[3] _judges, address _beneficiary) public{ promisor = _promisor; vow = _vow; deposit = _deposit; endDate = _endDate; judges = _judges; beneficiary = _beneficiary; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllCrowdsale,"contract ClinicAllCrowdsale is Crowdsale, FinalizableCrowdsale, MintedCrowdsale, ManagedWhitelist, Limited { constructor ( uint256 _tokenLimitSupply, uint256 _rate, address _wallet, address _privateSaleWallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _discountTokenAmount, uint256 _discountTokenPercent, uint256 _preSaleClosingTime, uint256 _softCapLimit, ClinicAllRefundEscrow _vault, uint256 _buyLimitSupplyMin, uint256 _buyLimitSupplyMax, uint256 _kycLimitEliminator ) Crowdsale(_rate, _wallet, _token) TimedCrowdsale(_openingTime, _closingTime) public { privateSaleWallet = _privateSaleWallet; tokenSupplyLimit = _tokenLimitSupply; discountTokenAmount = _discountTokenAmount; discountTokenPercent = _discountTokenPercent; preSaleClosingTime = _preSaleClosingTime; softCapLimit = _softCapLimit; vault = _vault; buyLimitSupplyMin = _buyLimitSupplyMin; buyLimitSupplyMax = _buyLimitSupplyMax; kycLimitEliminator = _kycLimitEliminator; }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0x528b165220a26565e00709cbaef7b88fc8600f81.sol,Mainsale,"contract Mainsale is CommonSale { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x40ae4acd08e65714b093bf2495fd7941aedfa231.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x6fcabeece449f535d2a9b199e7f190cd95f3e67b.sol,DefaultICO,"contract DefaultICO is TimedCrowdsale, TokenRecover { Contributions public contributions; uint256 public minimumContribution; uint256 public tierZero; constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _minimumContribution, address _token, address _contributions, uint256 _tierZero ) Crowdsale(_rate, _wallet, ERC20(_token)) TimedCrowdsale(_openingTime, _closingTime) public { require( _contributions != address(0), ); contributions = Contributions(_contributions); minimumContribution = _minimumContribution; tierZero = _tierZero; }",1
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x2132b2cd3bb47ce23600e2f9825f05feef1bab1d.sol,AternoToken,"contract AternoToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 13000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x316ee6b10479576e908e5272458c789c3f4d2a47.sol,DuanZiToken,contract DuanZiToken is ERC223 { using SafeMath for uint256; using SafeMath for uint; address public owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => uint) public increase; mapping (address => uint256) public unlockUnixTime; uint public maxIncrease=20; address public target; string internal name_= ; string internal symbol_ = ; uint8 internal decimals_= 18; uint256 internal totalSupply_= 2000000000e18; uint256 public toGiveBase = 5000e18; uint256 public increaseBase = 500e18; uint256 public OfficalHold = totalSupply_.mul(18).div(100); uint256 public totalRemaining = totalSupply_; uint256 public totalDistributed = 0; bool public canTransfer = true; uint256 public etherGetBase=5000000; bool public distributionFinished = false; bool public finishFreeGetToken = false; bool public finishEthGetToken = false; modifier canDistr() { require(!distributionFinished); _; },1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5afae785bc6ba7248dbd511a92c4d5cc5a803214.sol,DaoCommonMini,contract DaoCommonMini is IdentityCommon { using MathHelper for MathHelper; function isDaoNotReplaced() public view returns (bool _isNotReplaced) { _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao(); },1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x72fa6623cc0800bc180639d60c33c95426d76576.sol,KassaNetwork,"contract KassaNetwork is Ownable { using SafeMath for uint; string public constant name = ; uint public startTimestamp = now; uint public constant procKoef = 10000; uint public constant perDay = 75; uint public constant ownerFee = 700; uint[3] public bonusReferrer = [500, 200, 100]; uint public constant procReturn = 9000; uint public constant maxDepositDays = 200; uint public constant minimalDeposit = 0.5 ether; uint public constant maximalDepositStart = 30 ether; uint public constant maximalDepositFinish = 100 ether; uint public constant minimalDepositForBonusReferrer = 0.015 ether; uint public constant dayLimitStart = 50 ether; uint public constant progressProcKoef = 100; uint public constant dayLimitProgressProc = 2; uint public constant maxDepositProgressProc = 1; uint public countInvestors = 0; uint public totalInvest = 0; uint public totalPenalty = 0; uint public totalSelfInvest = 0; uint public totalPaid = 0; uint public unlimitedInvest = 3000 ether; bool public isUnlimitedContractInvest = false; bool public isUnlimitedDayInvest = false; event LogInvestment(address _addr, uint _value, bytes _refData); event LogTransfer(address _addr, uint _amount, uint _contactBalance); event LogSelfInvestment(uint _value); event LogPreparePayment(address _addr, uint _totalInteres, uint _paidInteres, uint _amount); event LogSkipPreparePayment(address _addr, uint _totalInteres, uint _paidInteres); event LogPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals, uint _amount); event LogSkipPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals); event LogNewReferralAtLevel(address _addr, uint[3] _levels); event LogMinimalDepositPayment(address _addr, uint _money, uint _totalPenalty); event LogPenaltyPayment(address _addr, uint currentSenderDeposit, uint referrerAdressLength, address _referrer, uint currentReferrerDeposit, uint _money, uint _sendBackAmount, uint _totalPenalty); event LogExceededRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _badDeposit, uint _sendBackAmount, uint _totalPenalty, uint _willDeposit); event LogUsedRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _realDeposit, uint _usedDepositPerDay); event LogCalcBonusReferrer(address _referrer, uint _money, uint _index, uint _bonusReferrer, uint _amountReferrer, address _nextReferrer); struct User { uint balance; uint paidInteres; uint timestamp; uint countReferrals; uint[3] countReferralsByLevel; uint earnOnReferrals; uint paidReferrals; address referrer; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0xcf5d889e2336d0f35f6121718f6c25e0650d4b25.sol,CryptloDex,"contract CryptloDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function CryptloDex(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x886fd5e16d39e062a38c4cbf7c39f65fbe4cfd4d.sol,ERC721BasicToken,"contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; using SafeMath for uint256; using AddressUtils for address; bytes4 private constant ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; }",1
0xeee90e509a639e95e3bb502b17a0eed6e014bfc0.sol,IBancorConverter,"contract IBancorConverter { function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256); function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256); function conversionWhitelist() public view returns (IWhitelist) {}",1
0x3967f481031f78a3fcbfe5c6a1079ec9f8426432.sol,Kongtou,contract Kongtou { address public owner; constructor() payable public { owner = msg.sender; },1
0xc74b66be9e70b02c23bbc841629bdd2c5ce51503.sol,TokenERC20,contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; struct freezeAccountInfo{ uint256 freezeStartTime; uint256 freezePeriod; uint256 freezeAmount; },1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x025334708ec64febfff398a71f0719a4c0d66739.sol,VTEXP,"contract VTEXP is Ownable,Locklisted { event Mint(address indexed to, uint256 amount); event MintFinished(); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; bool public mintingFinished = false; uint256 public totalSupply; mapping(address => uint256) balances; modifier canMint() { require(!mintingFinished); _; }",1
0x6ce4642936028cf493c9bdd72e78130297cb77ea.sol,Ownable,"contract Ownable { address public owner; address public ownerCandidate; address[4] public admins; uint256 public ownershipTransferCounter; constructor(address _owner, address[4] _admins) public { owner = _owner; admins[0] = _admins[0]; admins[1] = _admins[1]; admins[2] = _admins[2]; admins[3] = _admins[3]; }",1
0x316ee6b10479576e908e5272458c789c3f4d2a47.sol,DuanZiToken,contract DuanZiToken is ERC223 { using SafeMath for uint256; using SafeMath for uint; address public owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => uint) public increase; mapping (address => uint256) public unlockUnixTime; uint public maxIncrease=20; address public target; string internal name_= ; string internal symbol_ = ; uint8 internal decimals_= 18; uint256 internal totalSupply_= 2000000000e18; uint256 public toGiveBase = 5000e18; uint256 public increaseBase = 500e18; uint256 public OfficalHold = totalSupply_.mul(18).div(100); uint256 public totalRemaining = totalSupply_; uint256 public totalDistributed = 0; bool public canTransfer = true; uint256 public etherGetBase=5000000; bool public distributionFinished = false; bool public finishFreeGetToken = false; bool public finishEthGetToken = false; modifier canDistr() { require(!distributionFinished); _; },1
0x4ced73edbb326de8f7d9c5694b00da7b75506d96.sol,Elyxr,contract Elyxr { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xef69369f6ed0b0e3551f45efa942b164fdff81ea.sol,WSPXCrowdsale,"contract WSPXCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; uint256 public rate = 312500; mapping (address => uint256) public deposited; mapping (address => bool) internal isRefferer; uint256 public weiMinSale = 0.1 ether; uint256 public constant INITIAL_SUPPLY = 9 * 10**9 * (10 ** uint256(decimals)); uint256 public fundForSale = 6 * 10**9 * (10 ** uint256(decimals)); uint256 public fundTeam = 1 * 10**9 * (10 ** uint256(decimals)); uint256 public fundBounty = 2 * 10**9 * (10 ** uint256(decimals)); address public addressFundTeam = 0xA2434A8F6457fe7CF29AEa841cf3D0B0FE3217c8; address public addressFundBounty = 0x8828c48DEc2764868aD3bBf7fE9e8aBE773E3064; uint256 startTimeIcoStage1 = 1546300800; uint256 endTimeIcoStage1 = 1547596799; uint256 startTimeIcoStage2 = 1547596800; uint256 endTimeIcoStage2 = 1548979199; uint256 startTimeIcoStage3 = 1548979200; uint256 endTimeIcoStage3 = 1554076799; uint256 limitStage1 = 2 * 10**9 * (10 ** uint256(decimals)); uint256 limitStage2 = 4 * 10**9 * (10 ** uint256(decimals)); uint256 limitStage3 = 6 * 10**9 * (10 ** uint256(decimals)); uint256 public countInvestor; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(address indexed sender, uint256 tokenRaised, uint256 purchasedToken); event CurrentPeriod(uint period); event ChangeTime(address indexed owner, uint256 newValue, uint256 oldValue); event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress); event ChangeRate(address indexed owner, uint256 newValue, uint256 oldValue); event Burn(address indexed burner, uint256 value); event HardCapReached(); constructor(address _owner, address _wallet) public Crowdsale(_wallet) { require(_owner != address(0)); owner = _owner; transfersEnabled = true; mintingFinished = false; totalSupply = INITIAL_SUPPLY; bool resultMintForOwner = mintForFund(owner); require(resultMintForOwner); }",1
0x3779d960261f882750b39c622527822c88c98e13.sol,BitgetDeFiToken,"contract BitgetDeFiToken is SafeMath{ address public owner; uint8 public decimals = 18; uint256 public totalSupply; string public name; string public symbol; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor( uint256 initSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public { owner = msg.sender; totalSupply = initSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf299692d5e10f54856dd417df763a006e7589a7c.sol,OurPlace500,contract OurPlace500{ bytes9[250000] public pixels; address public owner; address public manager; bool public isPaused; uint public pixelCost; uint256 public CANVAS_HEIGHT; uint256 public CANVAS_WIDTH; uint public totalChangedPixels; struct Terms{ string foreword; string rules; string youShouldKnow; string dataCollection; uint versionForeword; uint versionRules; uint versionYouShouldKnow; uint versionDataCollection; },1
0x5c93bfe7d725d6dee8e65a2b670f1d401b1a5152.sol,inFuturePaymentToken,contract inFuturePaymentToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,MainSale,"contract MainSale is Ownable { using SafeMath for uint256; event TokensPurchased(address indexed buyer, uint256 ether_amount); event MainSaleClosed(); HeroOrigenToken public token = new HeroOrigenToken(); address public multisigVault = 0x1706024467ef8C9C4648Da6FC35f2C995Ac79CF6; uint256 public totalReceived = 0; uint256 public hardcap = 250000 ether; uint256 public minimum = 10 ether; uint256 public altDeposits = 0; uint256 public start = 1511178900; bool public saleOngoing = true; modifier isSaleOn() { require(start <= now && saleOngoing); _; }",1
0x6f05bf7c8d50079ac864f48480a4e579189de0c6.sol,QIU3D,"contract QIU3Devents { event onNewTicket( address indexed player, uint256 indexed matchId, uint256 indexed ticketId, uint256 fullMatResOpt, uint256 goalsOpt, uint256 gapGoalsOpt, uint256 bothGoalOpt, uint256 halfAndFullMatResOpt, uint256 ticketValue, uint256 cost ); event onNewBet( address indexed player, uint256 indexed matchId, uint256 indexed betId, uint256 option, uint256 odds, uint256 cost ); event onEndMatch( uint256 indexed matchId, uint256 compressData ); event onInvite( address indexed player, address indexed inviter, uint256 profit ); event onWithdraw( address indexed player, uint256 withdraw, uint256 withdrawType ); }",1
0x1ef1f77082df766c14d7c339ba17bef9a453c691.sol,TestCoin,"contract TestCoin is ERC20, Ownable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; }",1
0x4caecb46496b0af8b1b18d90773834ee8ccd8642.sol,Terminateable,contract Terminateable is Ownable { event Terminate(); bool public terminated = false; modifier whenNotTerminated() { require(!terminated); _; },1
0x738505a5f31bf72e0b70298bca81150eb1b7c751.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x537ffa421d035f42cb5860cc21857df4521f4ec8.sol,SafeERC20Timelock,"contract SafeERC20Timelock is ITimeMachine, Ownable { using SafeMath for uint; event Lock(address indexed _from, address indexed _for, uint indexed timestamp, uint value); event Withdraw(address indexed _for, uint indexed timestamp, uint value); mapping (address => mapping(uint => uint)) public balance; IERC20 public token; uint public totalBalance; constructor (address _token) public { token = IERC20(_token); }",1
0x8370b2d10956b9fa1db7faf14bac188a367fe7df.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0d3d475f035705a662f5ab34e374e3c44bb52187.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x78babd20f78cc40f2d49ebade7ed8355fb3b2e4a.sol,BPMToken,"contract BPMToken is Pausable, StandardToken, BlackList { string public name; string public symbol; uint public decimals; address public upgradedAddress; bool public deprecated; function BPMToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public { _totalSupply = _initialSupply; name = _name; symbol = _symbol; decimals = _decimals; balances[owner] = _initialSupply; deprecated = false; }",1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0xd4a1aca8aee512824d7d6c5c1d20ae33dff99ed6.sol,NexToken,"contract NexToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 12000000000e18; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e18; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x31cf75e0839a79c8914569465b6ce9e3d6fc9959.sol,EtherGenCore,"contract EtherGenCore is PlayersCollectionStorage, ERC721 { mapping(address => bool) private privilegedTransferModules; mapping(address => bool) private privilegedMintingModules; mapping(uint64 => address) private cardIdApproveds; uint64 private totalCardSupply; TransferRestrictionVerifier transferRestrictionVerifier = TransferRestrictionVerifier(0xd9861d9a6111bfbb9235a71151f654d0fe7ed954); address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163; bool public paused = false; function totalSupply() public view returns (uint256 cards) { return totalCardSupply; }",1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x1cd8d8ee6d08949f19044c9e320adf078e205fba.sol,Luxuriumgold,"contract Luxuriumgold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterOwnership,"contract MonsterOwnership is MonstersBase, ERC721 { function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return monsterIndexToOwner[_tokenId] == _claimant; }",1
0xecf0cdd36fbeeb07d69afc57cb94f6e90ad93ef1.sol,Freezable,"contract Freezable is Ownable { mapping (address => bool) public frozenAccount; event Freeze(address indexed target, bool frozen); event Unfreeze(address indexed target, bool frozen); modifier isNotFrozen(address _target) { require(!frozenAccount[_target]); _; }",1
0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0.sol,Owned,contract Owned { address owner; function Owned() public { owner = msg.sender; },1
0x8b5e31d05c3df25f809f2f82af098e8396ad82c8.sol,CappedDividendToken,contract CappedDividendToken is MintableDividendToken { uint256 public cap; function CappedDividendToken(uint256 _cap) public { require(_cap > 0); cap = _cap; },1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x41f94b7a3e2949088e7281f175c3ecbf10c3cdb4.sol,SGCH,"contract SGCH is ERC20ext,SafeMath { string public name; string public symbol; uint8 public decimals = 18; address _cfo; uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _allowance; mapping (address => bool) public _frozen; function SGCH(uint256 initialSupply,string tokenName,string tokenSymbol) public { _cfo = msg.sender; _supply = initialSupply * 10 ** uint256(decimals); _balances[_cfo] = _supply; name = tokenName; symbol = tokenSymbol; }",1
0xd9bcf875d0ca721ec89fe49b57c144e7c1f6451e.sol,ReserveBag,"contract ReserveBag is DRSEvents { using SafeMath for uint256; using NameFilter for string; using DRSDatasets for DRSDatasets.EventReturns; TeamPerfitForwarderInterface public teamPerfit; PlayerBookInterface public playerBook; DRSCoinInterface public drsCoin; string constant public name = ; string constant public symbol = ; uint256 constant private initKeyPrice = (10**18); uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; uint256 public keyPrice = initKeyPrice; uint256 public keyBought = 0; address public owner; uint256 public teamPerfitAmuont = 0; uint256 public rewardInternal = 36; uint256 public keyPriceIncreaseRatio = 8; uint256 public genRatio = 90; uint256 public drsCoinDividendRatio = 40; uint256 public teamPerfitRatio = 5; uint256 public ethMintDRSCoinRate = 100; bool public activated_ = false; mapping(address => uint256) public pIDxAddr_; mapping(bytes32 => uint256) public pIDxName_; mapping(uint256 => DRSDatasets.Player) public plyr_; mapping(uint256 => mapping(uint256 => DRSDatasets.PlayerRound)) public plyrRnds_; mapping(uint256 => mapping(bytes32 => bool)) public plyrNames_; DRSDatasets.BuyInfo[] buyinfos; uint256 private startIndex; uint256 private endIndex; mapping(uint256 => DRSDatasets.Round) public round_; constructor(address _teamPerfit, address _playBook, address _drsCoin) public { owner = msg.sender; teamPerfit = TeamPerfitForwarderInterface(_teamPerfit); playerBook = PlayerBookInterface(_playBook); drsCoin = DRSCoinInterface(_drsCoin); startIndex = 0; endIndex = 0; }",1
0x6f3a995e904c9be5279e375e79f3c30105efa618.sol,Crowdsale,"contract Crowdsale is ManualMigration { address public backend; address public cryptaurToken = 0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1; uint public crowdsaleStartTime = 1517270400; uint public crowdsaleFinishTime = 1522454400; uint public etherPrice; uint public collectedUSD; bool public crowdsaleFinished; event Mint(address indexed minter, uint tokens, bytes32 originalTxHash); modifier onlyPayloadSize(uint size) { require(msg.data.length >= size + 4); _; }",1
0x74d13225bc488397212e63dc38b497f6aa7a7a69.sol,CoinStacks,"contract CoinStacks { address private admin; uint256 private constant BOTTOM_LAYER_BET = 0.005 ether; uint16 private constant INITIAL_UNLOCKED_COLUMNS = 10; uint256 private maintenanceFeePercent; uint private NUM_COINS_TO_HIT_JACKPOT = 30; uint private MIN_AVG_HEIGHT = 5; uint256 private constant JACKPOT_PRIZE = 2 * BOTTOM_LAYER_BET; mapping(uint32 => address) public coordinatesToAddresses; uint32[] public coinCoordinates; uint256 public reserveForJackpot; mapping(address => uint256) public balances; event coinPlacedEvent ( uint32 _coord, address indexed _coinOwner ); function CoinStacks() public { admin = msg.sender; maintenanceFeePercent = 1; reserveForJackpot = 0; coordinatesToAddresses[uint32(0)] = admin; coinCoordinates.push(uint32(0)); coinPlacedEvent(uint32(0),admin); }",1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Ownable { string public name; string public symbol; uint public decimals; address public mintAgent; event UpdatedTokenInformation(string newName, string newSymbol); event TokenMinted(uint amount, address toAddress); function CrowdsaleToken(string _name, string _symbol, uint _decimals) { owner = msg.sender; name = _name; symbol = _symbol; decimals = _decimals; }",1
0x887ed27475f60f2df56fefc1f18f3aa8da65fb22.sol,ParkCoin,"contract ParkCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ParkCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed574d920a0c152ca136717c79a352b83f3bb058.sol,TuniuToken,"contract TuniuToken is Ownable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TuniuToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbd44c15f911a4bbb90954a314ae2c7fb96f234ee.sol,IPFSNETS,"contract IPFSNETS is ERC20 { using SafeMath for uint256; address owner = msg.sender; bool public key; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public frozenAccount; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) locknum; mapping (address => mapping (uint256 => uint256)) locktime; mapping (address => mapping (uint256 => uint256)) lockdays; mapping (address => mapping (uint256 => uint256)) releasepoint; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 100000000 * _Rate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,SafeMath,"contract SafeMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1aac60e9acafaed0cf84add412ab8071ef64196e.sol,SphinxToken,contract SphinxToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; constructor(uint256 initialSupply) public { totalSupply_ = initialSupply; balances[msg.sender] = totalSupply_; },1
0x269a6ffb97325e8e371f067fea216c9f62848833.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 0 minutes; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool CoolingMutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x4c60e311d8fba04e313f7e7b3dec61b3028726d1.sol,EtherWorldCup,"contract EtherWorldCup { using SafeMath for uint; address internal constant administrator = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae; address internal constant givethAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; string name = ; string symbol = ; mapping (string => int8) worldCupGameID; mapping (int8 => bool) gameFinished; mapping (int8 => uint) gameLocked; mapping (int8 => string) gameResult; int8 internal latestGameFinished; uint internal prizePool; uint internal givethPool; int registeredPlayers; mapping (address => bool) playerRegistered; mapping (address => mapping (int8 => bool)) playerMadePrediction; mapping (address => mapping (int8 => string)) playerPredictions; mapping (address => int8[64]) playerPointArray; mapping (address => int8) playerGamesScored; mapping (address => uint) playerStreak; address[] playerList; event Registration( address _player ); event PlayerLoggedPrediction( address _player, int _gameID, string _prediction ); event PlayerUpdatedScore( address _player, int _lastGamePlayed ); event Comparison( address _player, uint _gameID, string _myGuess, string _result, bool _correct ); event StartAutoScoring( address _player ); event StartScoring( address _player, uint _gameID ); event DidNotPredict( address _player, uint _gameID ); event RipcordRefund( address _player ); constructor () public { worldCupGameID[] = 1; gameLocked[1] = 1528988400; worldCupGameID[] = 2; worldCupGameID[] = 3; worldCupGameID[] = 4; gameLocked[2] = 1529064000; gameLocked[3] = 1529074800; gameLocked[4] = 1529085600; worldCupGameID[] = 5; worldCupGameID[] = 6; worldCupGameID[] = 7; worldCupGameID[] = 8; gameLocked[5] = 1529143200; gameLocked[6] = 1529154000; gameLocked[7] = 1529164800; gameLocked[8] = 1529175600; worldCupGameID[] = 9; worldCupGameID[] = 10; worldCupGameID[] = 11; gameLocked[9] = 1529236800; gameLocked[10] = 1529247600; gameLocked[11] = 1529258400; worldCupGameID[] = 12; worldCupGameID[] = 13; worldCupGameID[] = 14; gameLocked[12] = 1529323200; gameLocked[13] = 1529334000; gameLocked[14] = 1529344800; worldCupGameID[] = 15; worldCupGameID[] = 16; worldCupGameID[] = 17; gameLocked[15] = 1529409600; gameLocked[16] = 1529420400; gameLocked[17] = 1529431200; worldCupGameID[] = 18; worldCupGameID[] = 19; worldCupGameID[] = 20; gameLocked[18] = 1529496000; gameLocked[19] = 1529506800; gameLocked[20] = 1529517600; worldCupGameID[] = 21; worldCupGameID[] = 22; worldCupGameID[] = 23; gameLocked[21] = 1529582400; gameLocked[22] = 1529593200; gameLocked[23] = 1529604000; worldCupGameID[] = 24; worldCupGameID[] = 25; worldCupGameID[] = 26; gameLocked[24] = 1529668800; gameLocked[25] = 1529679600; gameLocked[26] = 1529690400; worldCupGameID[] = 27; worldCupGameID[] = 28; worldCupGameID[] = 29; gameLocked[27] = 1529755200; gameLocked[28] = 1529766000; gameLocked[29] = 1529776800; worldCupGameID[] = 30; worldCupGameID[] = 31; worldCupGameID[] = 32; gameLocked[30] = 1529841600; gameLocked[31] = 1529852400; gameLocked[32] = 1529863200; worldCupGameID[] = 33; worldCupGameID[] = 34; worldCupGameID[] = 35; worldCupGameID[] = 36; gameLocked[33] = 1529935200; gameLocked[34] = 1529935200; gameLocked[35] = 1529949600; gameLocked[36] = 1529949600; worldCupGameID[] = 37; worldCupGameID[] = 38; worldCupGameID[] = 39; worldCupGameID[] = 40; gameLocked[37] = 1530021600; gameLocked[38] = 1530021600; gameLocked[39] = 1530036000; gameLocked[40] = 1530036000; worldCupGameID[] = 41; worldCupGameID[] = 42; worldCupGameID[] = 43; worldCupGameID[] = 44; gameLocked[41] = 1530108000; gameLocked[42] = 1530108000; gameLocked[43] = 1530122400; gameLocked[44] = 1530122400; worldCupGameID[] = 45; worldCupGameID[] = 46; worldCupGameID[] = 47; worldCupGameID[] = 48; gameLocked[45] = 1530194400; gameLocked[46] = 1530194400; gameLocked[47] = 1530208800; gameLocked[48] = 1530208800; worldCupGameID[] = 49; worldCupGameID[] = 50; gameLocked[49] = 1530367200; gameLocked[50] = 1530381600; worldCupGameID[] = 51; worldCupGameID[] = 52; gameLocked[51] = 1530453600; gameLocked[52] = 1530468000; worldCupGameID[] = 53; worldCupGameID[] = 54; gameLocked[53] = 1530540000; gameLocked[54] = 1530554400; worldCupGameID[] = 55; worldCupGameID[] = 56; gameLocked[55] = 1530626400; gameLocked[56] = 1530640800; worldCupGameID[] = 57; worldCupGameID[] = 58; gameLocked[57] = 1530885600; gameLocked[58] = 1530900000; worldCupGameID[] = 59; worldCupGameID[] = 60; gameLocked[59] = 1530972000; gameLocked[60] = 1530986400; worldCupGameID[] = 61; gameLocked[61] = 1531245600; worldCupGameID[] = 62; gameLocked[62] = 1531332000; worldCupGameID[] = 63; gameLocked[63] = 1531576800; worldCupGameID[] = 64; gameLocked[64] = 1531666800; latestGameFinished = 0; }",1
0x703d81d19e147808633910b85537f04b76c4385b.sol,ERC20Token,contract ERC20Token { mapping (address => uint256) balances; address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; constructor() public { uint256 initialSupply = 100000000; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; name = ; symbol = ; },1
0xf35470b6182cbd9a0f0c01d8f491b18445707c7d.sol,ERC827Token,"contract ERC827Token is ERC827, StandardToken { ERC827Caller internal caller_; constructor() public { caller_ = new ERC827Caller(); }",1
0xd46ddc98c63f9705ca6689e7036dc3ce981fb335.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool public initialTranches = false; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping(address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x45125b61f06b2e9b8fc8a2ea688c35e27086d2ae.sol,OysterPearl,"contract OysterPearl { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed target, address indexed payout, address indexed fee); function OysterPearl() public { director = msg.sender; name = ; symbol = ; decimals = 18; funds = 0; totalSupply = 0; saleClosed = true; directorLock = false; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); epoch = 31536001; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0xc84d24242a792d8c87d10f92897328c490bfd7fa.sol,EVTCToken,"contract EVTCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 2000 * 10**18; uint public maxWithdraw = 50000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; balanceOf[_escrow] = 7850047931491270769372792; totalSupply = 7850047931491270769372792; }",1
0x53148bb4551707edf51a1e8d7a93698d18931225.sol,Peculium,"contract Peculium is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function Peculium() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,SafeMath,"contract SafeMath { function safeSub(uint256 x, uint256 y) internal pure returns (uint256) { assert(y <= x); uint256 z = x - y; return z; }",1
0x02992370df72da5b039c3a6249beb27c487e63cb.sol,Exchange,"contract Exchange is SafeMath, Admin { mapping( address => mapping( address => uint )) public tokens; mapping( address => mapping( bytes32 => bool )) public orders; mapping( bytes32 => mapping( address => uint )) public ordersBalance; event Deposit( address token, address user, uint amount, uint balance ); event Withdraw( address token, address user, uint amount, uint balance ); event Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder ); event HashOutput(bytes32 hash); constructor( address _admin, address _feeAccount, uint _feeTake, string _version) public { admin = _admin; feeAccount = _feeAccount; feeTake = _feeTake; orderEnd = false; version = _version; pause = false; }",1
0x5b5afaa565aba14833de0cee321e63a807fd407b.sol,TulipMania,"contract TulipMania is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510758000; uint public constant DATE_PRESALE_END = 1511362800; uint public constant DATE_ICO_START = 1511362801; uint public constant DATE_ICO_END = 1513868400; uint public tokensPerEth = 336 * E6; uint public constant BONUS_PRESALE = 100; uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; uint public constant TOKEN_SUPPLY_ICO = 8500000 * E6; uint public constant TOKEN_SUPPLY_MKT = 1500000 * E6; uint public constant PRESALE_ETH_CAP = 750 ether; uint public constant MIN_CONTRIBUTION = 1 ether / 500; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 2 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function TulipMania() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0x7323cb1288cde81500e744234a487c642823aa24.sol,DncToken,"contract DncToken is ERC20, ERC20Detailed , ERC20Pausable, ERC20Capped , ERC20Burnable, Ownable , ReentrancyGuard { constructor(string _name, string _symbol, uint8 _decimals, uint256 _cap) ERC20Detailed(_name, _symbol, _decimals) ERC20Capped (_cap * 1 ether) public { }",1
0x0f587d0b7b1c1ef68b432936b75c4d6c4d12b647.sol,MatBase,"contract MatBase is Ownable, MatToken, MatBonus { using SafeMath for uint256; uint256 public constant _START_DATE = 1508284800; uint256 public constant _END_DATE = 1513641600; uint256 public constant CROWDSALE_PRICE = 100; address public constant ICO_ADDRESS = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7; address public constant PARTNERS_WALLET = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E; address public constant TEAM_WALLET = 0xe1d32147b08b2a7808026D4A94707E321ccc7150; uint256 public startTime; uint256 public endTime; function setStartTime(uint256 _startTime) onlyOwner { startTime = _startTime; }",1
0x318bf186c7681ed7efd57839e6415cd8a162713c.sol,MainBonus,"contract MainBonus is BasicTime,BasicAuth,MainCard { uint constant BASERATIO = 10000; struct PlayerBonus { uint m_Bonus; uint m_DrawedDay; uint16 m_DDPermanent; mapping(uint => uint16) m_DayStatic; mapping(uint => uint16) m_DayPermanent; mapping(uint => uint32[]) m_DayDynamic; }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,TokenTimelock,"contract TokenTimelock { using SafeERC20 for ERC20Basic; ERC20Basic public token; address public beneficiary; uint64 public releaseTime; function TokenTimelock(ERC20Basic _token, address _beneficiary, uint64 _releaseTime) public { require(_releaseTime > now); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; }",1
0x01f2acf2914860331c1cb1a9acecda7475e06af8.sol,Controlled,contract Controlled is Owned{ function Controlled() public { setExclude(msg.sender); },1
0x12b470a5c9055d312e1af0259b65976dce608e5d.sol,Lighthouse,"contract Lighthouse { address public auth = msg.sender; Searcher seeker; uint value; uint maxAge; modifier onlyAuth { require(auth == msg.sender, ); _; }",1
0x6c456b11c743ab10f6796681bb4148aed6966bcf.sol,MyPaaaToken,"contract MyPaaaToken is ERC20, ERC20Detailed , ERC20Pausable, ERC20Capped , ERC20Burnable, Ownable , ReentrancyGuard { constructor(string _name, string _symbol, uint8 _decimals, uint256 _cap) ERC20Detailed(_name, _symbol, _decimals) ERC20Capped (_cap * 1 ether) public { }",1
0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6.sol,ERC20Token,"contract ERC20Token is IERC20Token, SafeMath { mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }",1
0xeeedac8686ae12183129e80e632e922dd8daecc4.sol,MDAPP,"contract MDAPPToken is MintableToken { using SafeMath16 for uint16; using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; mapping (address => uint16) locked; bool public forceTransferEnable = false; event AllowTransfer(); modifier hasLocked(address _account, uint16 _value) { require(_value <= locked[_account], ); _; }",1
0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a.sol,RocketCoin,"contract RocketCoin { string public constant symbol = ; string public constant name = ; uint public constant decimals = 18; uint public constant totalSupply = 10000000 * 10 ** decimals; address owner; bool airDropStatus = true; uint airDropAmount = 300 * 10 ** decimals; uint airDropGasPrice = 20 * 10 ** 9; mapping (address => bool) participants; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function RocketCoin() public { owner = msg.sender; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0x3475f292256d76dbe36c9dac3505fd6842de8167.sol,ArtificialNeuralNetwork,"contract ArtificialNeuralNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 1000000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8a96115b0fdc06ab845cf7d5196c80d8ebec4130.sol,Nikone,contract Nikone is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function Nikone() { balances[msg.sender] = 40000000000000000000000000000; totalSupply = 40000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 500000000; fundsWallet = msg.sender; },1
0x8b5e31d05c3df25f809f2f82af098e8396ad82c8.sol,JUNOToken,"contract JUNOToken is DividendToken , CappedDividendToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function JUNOToken() public payable CappedDividendToken(10000000*10**uint(decimals)) { uint premintAmount = 6000*10**uint(decimals); totalSupply_ = totalSupply_.add(premintAmount); balances[msg.sender] = balances[msg.sender].add(premintAmount); Transfer(address(0), msg.sender, premintAmount); m_emissions.push(EmissionInfo({ totalSupply: totalSupply_, totalBalanceWas: 0 }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x5824f275dab2c59b8972a1fda45ff404c9a703e3.sol,EqualToken,contract EqualToken is StandardToken { function () { revert(); },1
0xef19f4e48830093ce5bc8b3ff7f903a0ae3e9fa1.sol,botXcoin,"contract botXcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public holdAccount; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 5000000000e18; uint256 public totalDistributed = 0; uint256 public min_contribution = 1 ether / 100; uint256 public tokensPerEth = 10000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event ICO(address indexed _owner, uint _amount, uint _balance); event MinContributionUpdated(uint _mincontribution); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event HoldFunds(address target, bool hold); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x792e0fc822ac6ff5531e46425f13540f1f68a7a8.sol,Frozenable,"contract Frozenable is Operational, StandardBurnableToken, ReentrancyGuard { using DateTime for uint256; struct FrozenRecord { uint256 value; uint256 unfreezeIndex; }",1
0x2667fe18232f308a9eeb7b437978b53a7fd8d6d7.sol,EGCTToken,"contract EGCTToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); }",1
0xf16d5b36d6a29832898c439bc596c6a01218dc59.sol,PHICrowdsale,"contract PHICrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; uint256 public ratePreIco = 600; uint256 public rateIco = 400; uint256 public weiMin = 0.03 ether; mapping (address => uint256) public deposited; uint256 public constant INITIAL_SUPPLY = 63 * 10**6 * (10 ** uint256(decimals)); uint256 public fundForSale = 60250 * 10**3 * (10 ** uint256(decimals)); uint256 fundTeam = 150 * 10**3 * (10 ** uint256(decimals)); uint256 fundAirdropPreIco = 250 * 10**3 * (10 ** uint256(decimals)); uint256 fundAirdropIco = 150 * 10**3 * (10 ** uint256(decimals)); uint256 fundBounty = 100 * 10**3 * (10 ** uint256(decimals)); uint256 fundAdvisor = 210 * 10**3 * (10 ** uint256(decimals)); uint256 fundReferal = 1890 * 10**3 * (10 ** uint256(decimals)); uint256 limitPreIco = 12 * 10**5 * (10 ** uint256(decimals)); address addressFundTeam = 0x26cfc82A77ECc5a493D72757936A78A089FA592a; address addressFundAirdropPreIco = 0x87953BAE7A92218FAcE2DDdb30AB2193263394Ef; address addressFundAirdropIco = 0xaA8C9cA32cC8A6A7FF5eCB705787C22d9400F377; address addressFundBounty = 0x253fBeb28dA7E85c720F66bbdCFC4D9418196EE5; address addressFundAdvisor = 0x61eAEe13A2a3805b57B46571EE97B6faf95fC34d; address addressFundReferal = 0x4BfB1bA71952DAC3886DCfECDdE2a4Fea2A06bDb; uint256 public startTimePreIco = 1538406000; uint256 public endTimePreIco = 1539129600; uint256 public startTimeIco = 1541300400; uint256 public endTimeIco = 1542931200; uint256 percentReferal = 5; uint256 public countInvestor; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(address indexed sender, uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Burn(address indexed burner, uint256 value); event CurrentPeriod(uint period); event ChangeTime(address indexed owner, uint256 newValue, uint256 oldValue); event ChangeAddressFund(address indexed owner, address indexed newAddress, address indexed oldAddress); constructor(address _owner, address _wallet) public Crowdsale(_wallet) { require(_owner != address(0)); owner = _owner; transfersEnabled = false; mintingFinished = false; totalSupply = INITIAL_SUPPLY; bool resultMintForOwner = mintForFund(owner); require(resultMintForOwner); }",1
0xee52d05a2351151beabedb7a9e38cc1a2095a8ce.sol,PIPOT,"contract PIPOT is Owner { using SafeMath for uint256; event Game(uint _game, uint indexed _time); event ChangePrice(uint _price); event Ticket( address indexed _address, uint indexed _game, uint _number, uint _time, uint _price ); event ChangeFee(uint _fee); event Winner(address _winnerAddress, uint _price, uint _jackpot); event Lose(uint _price, uint _currentJackpot); uint public fee = 20; uint public game; uint public ticketPrice = 0.1 ether; uint public allTimeJackpot = 0; uint public allTimePlayers = 0; bool public isActive = true; bool public toogleStatus = false; uint[] public games; mapping(uint => uint) jackpot; mapping(uint => address[]) players; mapping(uint => mapping(uint => address[])) orders; address public fundsDistributor; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol,BasicToken,"contract BasicToken is ERC20Basic, Pausable { uint256 startPreSale; uint256 endPreSale; uint256 startSale; uint256 endSale; using SafeMath for uint256; mapping(address => uint256)balances; uint256 preICOReserveTokens; uint256 icoReserveTokens; address businessReserveAddress; uint256 public timeLock = 1586217600; uint256 public incentiveTokensLimit; modifier checkAdditionalTokenLock(uint256 value) { if (msg.sender == businessReserveAddress) { if ((now<endSale) ||(now < timeLock &&value>incentiveTokensLimit)) { revert(); }",1
0xd35be56e4ed6818d09e6f95b9c744c4607fda453.sol,ProofOfBitConnect,contract ProofOfBitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd8ee3a6b246674a7c6ca07ed9d8b4500d1d80371.sol,Meme,"contract Meme { string public ipfsHash; address public creator; uint256 exponent; uint256 PRECISION; uint256 public totalSupply; string public name; uint256 public decimals; uint256 public poolBalance; using CheckOverflows for uint256; constructor(string _ipfsHash, address _creator, string _name, uint256 _decimals, uint256 _exponent, uint256 _precision) public { ipfsHash = _ipfsHash; creator = _creator; name = _name; decimals = _decimals; exponent = _exponent; PRECISION = _precision; totalSupply = 100000; tokenBalances[msg.sender] = 100000; }",1
0x291fe087234eaa19f8b16b5d341b4e4540c220aa.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 initialSupply=4000000000; uint256 MAX_CAP = 4000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6e4c0f93cfa81ce9ab66bf07dd9264957d1ca10c.sol,FomoSuper,"contract FomoSuper is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xB2b3d6feAE1AB2af4a07Cf4C047D69aa01D809Aa); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 8 minutes; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(22,6); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(52,10); fees_[3] = F3Ddatasets.TeamFee(68,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x721da477f68c71788a262d58853fe6977d86535e.sol,EtheremonPayment,"contract EtheremonPayment is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public STAT_COUNT = 6; uint8 constant public STAT_MAX = 32; uint8 constant public GEN0_NO = 24; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,EternalStorage,"contract EternalStorage { address public owner; mapping(bytes32 => uint256) private uIntStorage; mapping(bytes32 => uint8) private uInt8Storage; mapping(bytes32 => string) private stringStorage; mapping(bytes32 => address) private addressStorage; mapping(bytes32 => bytes) private bytesStorage; mapping(bytes32 => bool) private boolStorage; mapping(bytes32 => int256) private intStorage; mapping(bytes32 => bytes32) private bytes32Storage; modifier onlyLatestContract() { require(addressStorage[keccak256(abi.encodePacked(, msg.sender))] != 0x0 || msg.sender == owner); _; }",1
0x0d7c864bf6c86bf11da2c8068b4c4edee4d76080.sol,DappVolumeAd,contract DappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,BonusableCrowdsale,"contract BonusableCrowdsale is usingConsts, Crowdsale { function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 bonusRate = getBonusRate(weiAmount); uint256 tokens = weiAmount.mul(bonusRate).div(1 ether); weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); }",1
0x6be9ad54d8ad5510d61690a7bd3823d0790c71b6.sol,IRAN_WINS,"contract IRAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5206357752953970000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6c6d6e2971a85d3d3a1353ee15a08fb7c819ed8b.sol,Experiment,contract Experiment { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x8c01722fc426841e7f508d2aadc9678b79228281.sol,RST,"contract RST is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; string public version = ; uint256 public constant decimals = 8; bool public disabled = false; uint256 public constant MILLION = (10**6 * 10**decimals); constructor() public { totalSupply_ = 500 * MILLION; balances[msg.sender] = totalSupply_; }",1
0x84eeca28082982abd1d68eadf2c5f509dd181bad.sol,ShroomFarmer,contract ShroomFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function ShroomFarmer() public{ ceoAddress=msg.sender; },1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,SafeGuardsPreSale,"contract SafeGuardsPreSale is FinalizableCrowdsale, CappedCrowdsale { using SafeMath for uint256; uint256 public tokensSold; uint256 public minimumGoal; uint public loadedRefund; uint public weiRefunded; mapping (address => uint) public boughtAmountOf; uint256 constant public minimumAmountWei = 1e16; uint256 public presaleTransfersPaused = now + 180 days; uint256 public presaleBurnPaused = now + 180 days; uint constant public preSaleBonus1Time = 1535155200; uint constant public preSaleBonus1Percent = 25; uint constant public preSaleBonus2Time = 1536019200; uint constant public preSaleBonus2Percent = 15; uint constant public preSaleBonus3Time = 1536883200; uint constant public preSaleBonus3Percent = 5; uint constant public preSaleBonus1Amount = 155 * 1e15; uint constant public preSaleBonus2Amount = 387 * 1e15; uint constant public preSaleBonus3Amount = 1550 * 1e15; uint constant public preSaleBonus4Amount = 15500 * 1e15; address constant public w_futureDevelopment = 0x4b297AB09bF4d2d8107fAa03cFF5377638Ec6C83; address constant public w_Reserv = 0xbb67c6E089c7801ab3c7790158868970ea0d8a7C; address constant public w_Founders = 0xa3b331037e29540F8BD30f3DE4fF4045a8115ff4; address constant public w_Team = 0xa8324689c94eC3cbE9413C61b00E86A96978b4A7; address constant public w_Advisers = 0x2516998954440b027171Ecb955A4C01DfF610F2d; address constant public w_Bounty = 0x1792b603F233220e1E623a6ab3FEc68deFa15f2F; event AddBonus(address indexed addr, uint256 amountWei, uint256 date, uint bonusType); struct Bonus { address addr; uint256 amountWei; uint256 date; uint bonusType; }",1
0x6cdccb2b249298419ab3dea261a92fbacf2223ab.sol,BountyEscrow,"contract BountyEscrow { address public admin; mapping(address => bool) public authorizations; event Bounty( address indexed sender, uint256 indexed amount ); event Payout( uint256 indexed id, bool indexed success ); function BountyEscrow() public { admin = msg.sender; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldToken,"contract HelloGoldToken is ERC20, SafeMath, Pausable, StandardToken { string public name; string public symbol; uint8 public decimals; GBT goldtoken; function setGBT(address gbt_) onlyOwner { goldtoken = GBT(gbt_); }",1
0x6d531bce8755694aaf2e157747063fcd917ded7c.sol,liyk002Token,"contract liyk002Token is StandardToken, Ownable{ string public version = ; string public name = ; string public symbol = ; string public website = ""https: uint8 public decimals = 18; mapping(address=>uint256) lockedBalance; mapping(address=>uint) timeRelease; uint256 internal constant INITIAL_SUPPLY = 100 * (10**8) * (10**18); event Burn(address indexed burner, uint256 value); event Lock(address indexed locker, uint256 value, uint releaseTime); event UnLock(address indexed unlocker, uint256 value); constructor() public { address onwer = msg.sender; balances[onwer] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; }",1
0x2878d33523a8025b66bdf606c8670fdf3f4c8cdd.sol,S3DContract,"contract S3DContract is Ownable, PausableToken { modifier shareholderOnly { require(balances[msg.sender] > 0); _; }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,ERC223ReceivingContract,"contract ERC223ReceivingContract { function tokenFallback(address _from, uint256 _value, bytes _data) public pure { _from; _value; _data; }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ERC721BasicToken,"contract ERC721BasicToken is ERC721Basic, ERC165MappingImplementation { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping(uint256 => address) internal tokenOwner; mapping(uint256 => address) internal tokenApprovals; mapping(address => uint256) internal ownedTokensCount; mapping(address => mapping(address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; }",1
0x412a658d1c8bbff78a61a2053373cb57fe7d14a5.sol,Payments,"contract Payments is Accounts { event PaymentRegistered( uint32 indexed payIndex, uint indexed from, uint totalNumberOfPayees, uint amount ); event PaymentUnlocked(uint32 indexed payIndex, bytes key); event PaymentRefunded(uint32 beneficiaryAccountId, uint64 amountRefunded); event Collect( uint indexed delegate, uint indexed slot, uint indexed to, uint32 fromPayindex, uint32 toPayIndex, uint amount ); event Challenge1(uint indexed delegate, uint indexed slot, uint challenger); event Challenge2(uint indexed delegate, uint indexed slot); event Challenge3(uint indexed delegate, uint indexed slot, uint index); event Challenge4(uint indexed delegate, uint indexed slot); event ChallengeSuccess(uint indexed delegate, uint indexed slot); event ChallengeFailed(uint indexed delegate, uint indexed slot); Payment[] public payments; mapping (uint32 => mapping (uint32 => CollectSlot)) public collects; function registerPayment( uint32 fromId, uint64 amount, uint64 fee, bytes payData, uint newCount, bytes32 rootHash, bytes32 lockingKeyHash, bytes32 metadata ) external { require(payments.length < 2**32, ); require(isAccountOwner(fromId), ); require(amount > 0, ); require(newCount == 0 || rootHash > 0, ); require(fee == 0 || lockingKeyHash > 0, ); Payment memory p; p.totalNumberOfPayees = SafeMath.add32(Challenge.getPayDataCount(payData), newCount); require(p.totalNumberOfPayees > 0, ); require(p.totalNumberOfPayees < params.maxTransfer, ); p.fromAccountId = fromId; p.amount = amount; p.fee = fee; p.lockingKeyHash = lockingKeyHash; p.metadata = metadata; p.smallestAccountId = uint32(accounts.length); p.greatestAccountId = SafeMath.add32(p.smallestAccountId, newCount); p.lockTimeoutBlockNumber = SafeMath.add64(block.number, params.unlockBlocks); p.paymentDataHash = keccak256(abi.encodePacked(payData)); uint64 totalCost = SafeMath.mul64(amount, p.totalNumberOfPayees); totalCost = SafeMath.add64(totalCost, fee); balanceSub(fromId, totalCost); if (newCount > 0) { bulkRegister(newCount, rootHash); }",1
0x52a8908a90760898da84b430cbdda30d9bfae403.sol,Sales,contract Sales is Discount { constructor(address _address) public { ParentInterface candidateContract = ParentInterface(_address); parent = candidateContract; paused = true; },1
0x6d6db51e3e4838369676508ce25db64f4ca7e5e4.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5c8b75429089bcc36fc71988d53ba7da05364206.sol,PoP,"contract PoP{ using SafeMath for uint256; using SafeInt for int256; using Player for Player.Data; using BettingRecordArray for BettingRecordArray.Data; using WrappedArray for WrappedArray.Data; using FixedPoint for FixedPoint.Data; string public name; string public symbol; uint8 public decimals; address private author; event Bet(address player, uint256 betAmount, uint256 betNumber, uint256 gameNumber); event Withdraw(address player, uint256 amount, uint256 numberOfRecordsProcessed); event EndGame(uint256 currentGameNumber); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); event Mined(address indexed miner, uint256 value); function PoP() public { name = ; symbol = ; decimals = 18; author = msg.sender; totalSupply_ = 10000000 * 10 ** uint256(decimals); lastBetBlockNumber = 0; currentGameNumber = 0; currentPot = 0; initialSeed = 0; minimumWager = kBaseMinBetSize.toUInt256Raw(); minimumNumberOfBlocksToEndGame = kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd).toUInt256Raw(); gameHasStarted = false; currentMiningDifficulty = FixedPoint.fromInt256(kStartingGameMiningDifficulty); unPromisedSupplyAtStartOfCurrentGame_ = totalSupply_; currentPotSplit = 1000; nextGameMaxBlock = kUpperBoundBlocksTillGameEnd; nextGameMinBlock = kLowerBoundBlocksTillGameEnd; currentGameInitialMinBetSize = kBaseMinBetSize; nextGameInitialMinBetSize = currentGameInitialMinBetSize; nextFrontWindowAdjustmentRatio = frontWindowAdjustmentRatio; nextBackWindowAdjustmentRatio = backWindowAdjustmentRatio; nextGameSeedPercent = percentToTakeAsSeed; nextGameRakePercent = percentToTakeAsRake; nextGameDeveloperMiningPower = developerMiningPower; nextGamePotSplit = currentPotSplit; canUpdateNextGameInitalMinBetSize = true; canUpdateFrontWindowAdjustmentRatio = true; canUpdateBackWindowAdjustmentRatio = true; canUpdateNextGamePotSplit = true; canUpdatePercentToTakeAsSeed = true; canUpdateNextGameMinAndMaxBlockUntilGameEnd = true; canUpdateAmountToTakeAsRake = true; canUpdateDeveloperMiningPower = true; }",1
0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xeb6aaeff15f1faa7acecb0627364294fb085fbab.sol,FomoCube,contract FomoCube { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x178ab5b0ff6db1e0cbe569c091607d8f5d6e4c6c.sol,FinPro,contract FinPro is Ownable { using SafeMath for uint256; string private constant name = ; string private constant version = ; uint256[] private fplowerlim; uint256[] private fplocktime; uint256[] private fpinterest; uint256 private fpcount; ERC20Token private token; struct investedData { uint256 fpnum; uint256 buytime; uint256 unlocktime; uint256 value; bool withdrawn; },1
0xe1e83a85c9db1bbd7cfab3e6bffaf255c5013adb.sol,BasicMultiToken,"contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken { using CheckedERC20 for ERC20; ERC20[] public tokens; uint internal inLendingMode; bool public bundlingDenied; event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); event BundlingDenied(bool denied); modifier notInLendingMode { require(inLendingMode == 0, ); _; }",1
0x72a73495b769682d7b09a9641fa1a95e308fbe08.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoStorage,"contract DaoStorage is DaoWhitelistingCommon, BytesIteratorStorage { using DoublyLinkedList for DoublyLinkedList.Bytes; using DaoStructs for DaoStructs.Voting; using DaoStructs for DaoStructs.Proposal; using DaoStructs for DaoStructs.ProposalVersion; DoublyLinkedList.Bytes allProposals; mapping (bytes32 => DaoStructs.Proposal) proposalsById; mapping (bytes32 => DoublyLinkedList.Bytes) proposalsByState; constructor(address _resolver) public { require(init(CONTRACT_STORAGE_DAO, _resolver)); }",1
0x71084a6624a45ef06605dd2a9c3b44336cb1bdd7.sol,BasicToken,"contract BasicToken is ERC20Basic, Pausable { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; address public contractAddress; address public setPriceAccount; address public setReferralAccount; uint256 public tokenPrice; uint256 public managersFee; uint256 public referralFee; uint256 public supportFee; uint256 public withdrawFee; address public ethAddress; address public supportWallet; address public fundManagers; event Deposit(address indexed buyer, uint256 weiAmount, uint256 tokensAmount, uint256 tokenPrice, address referral, uint256 referralFee, uint256 managersFee, uint256 supportFee); event Withdraw(address indexed buyer, uint256 tokensAmount, uint256 tokenPrice, uint256 commission); function totalSupply() public view returns (uint256) { return totalSupply_; }",1
0x75b9f86e79ad930b9396c0d165e4bb93c8382ca9.sol,ChibiFighters,"contract ChibiFighters is ERC721, ContractOwned, CustomEvents { using SafeMath for uint256; uint256 private totalTokens; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; GeneInterface geneContract; FcfInterface fcfContract; BattleInterface battleContract; address battleContractAddress; uint public priceChibi; uint priceFusionChibi; uint uniqueCounter; uint adultTime; uint exhaustionTime; uint comission; address battleRemoveContractAddress; struct Chibi { address owner; bool founder; string nameChibi; uint16[13] dna; uint256 father; uint256 mother; uint gen; uint256[] fusions; bool forFusion; uint256 fusionPrice; uint256 exhausted; uint256 adult; string infoUrl; }",1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkOwnership,"contract ArtworkOwnership is ArtworkBase, ArtworkUnique, ERC721 { string public constant NAME = ; string public constant SYMBOL = ; ERC721Metadata public erc721Metadata; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256()); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function approve( address _to, uint256 _tokenId ) external whenNotPaused { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); }",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionFactory,"contract OptionFactory is Ownable { using SafeMath for uint256; mapping (address => bool) public admins; mapping(uint => mapping(address => mapping(address => mapping(uint => mapping(bool => mapping(uint8 => OptionToken)))))) register; DexBrokerage public exchangeContract; ERC20 public dexb; uint public dexbTreshold; address public dexbAddress; uint public issueFee; uint public executeFee; uint public cancelFee; uint public dexbIssueFee; uint public dexbExecuteFee; uint public dexbCancelFee; uint public HUNDERED_PERCENT = 100000; uint public MAX_FEE = HUNDERED_PERCENT.div(100); constructor(address _dexbAddress, uint _dexbTreshold, address _dexBrokerageAddress) public { dexbAddress = _dexbAddress; dexb = ERC20(_dexbAddress); dexbTreshold = _dexbTreshold; exchangeContract = DexBrokerage(_dexBrokerageAddress); setIssueFee(300); setExecuteFee(300); setCancelFee(300); setDexbIssueFee(200); setDexbExecuteFee(200); setDexbCancelFee(200); }",1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,Synthetix,"contract SynthetixState is ISynthetixState, State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; mapping(address => IssuanceData) public issuanceData; uint public totalIssuerCount; uint[] public debtLedger; uint public importedXDRAmount; uint public issuanceRatio = SafeDecimalMath.unit() / 5; uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit(); mapping(address => bytes4) public preferredCurrency; constructor(address _owner, address _associatedContract) State(_owner, _associatedContract) LimitedSetup(1 weeks) public {}",1
0x523a4d2e260ee6230b4a99f1c74833e0aca94178.sol,EDToken,"contract EDToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function EDToken() public { totalSupply = 250000000 * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; Transfer(0x0, msg.sender, totalSupply); }",1
0x2f13fa06c0efd2a5c4cf2175a0467084672e648b.sol,MarketPlace,"contract MarketPlace { using LSafeMath for uint; address public admin; address public feeAccount; uint public feeTake; uint public freeUntilDate; bool private depositingTokenFlag; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; address public predecessor; address public successor; uint16 public version; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); event FundsMigrated(address user, address newContract); modifier isAdmin() { require(msg.sender == admin); _; }",1
0x360e51857242661de8f3ec4e6c684b45b3c0de87.sol,Karma,"contract Karma is Ownable, DetailedERC20(, , 0) { using SafeMath for uint256; using SafeMath64 for uint64; struct User { bytes20 username; uint64 karma; uint16 canWithdrawPeriod; uint16 birthPeriod; }",1
0x6e4c0f93cfa81ce9ab66bf07dd9264957d1ca10c.sol,FomoSuper,"contract FomoSuper is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xB2b3d6feAE1AB2af4a07Cf4C047D69aa01D809Aa); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 8 minutes; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(22,6); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(52,10); fees_[3] = F3Ddatasets.TeamFee(68,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x0069e491f2ed9e562a7c9c92ba40f73d946718e0.sol,Crowdsale,"contract Crowdsale is owned, SafeMath { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public rate; uint public tokenDecimals; token public tokenReward; uint public tokensSold = 0; uint public start; uint public bonusEndDate; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; event GoalReached(address beneficiary, uint capital); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( ) { beneficiary = 0xe579891b98a3f58e26c4b2edb54e22250899363c; rate = 80000; tokenDecimals=8; fundingGoal = 2500000000 * (10 ** tokenDecimals); start = 1536537600; deadline = 1539129600; bonusEndDate =1537156800; tokenReward = token(0xBD64a0d7330bc16c30aA1AE34eD2C329F6DB49C9); }",1
0x17d67ac402b014af1894c63379976b46930b1337.sol,Crowdsale,"contract Crowdsale is Pausable { using SafeMath for uint256; string public projectName; string public tokenName; string public tokenSymbol; uint256 public rate; uint256 public ethRaised; uint256 public eth_decimal_num = 100000; uint256 public cap; TokenImpl public token; ERC20Basic public targetToken; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value); event IncreaseCap(uint256 cap); event DecreaseCap(uint256 cap); function Crowdsale(string _projectName, string _tokenName, string _tokenSymbol, uint256 _cap) public { require(_cap > 0); projectName = _projectName; tokenName = _tokenName; tokenSymbol = _tokenSymbol; cap = _cap.mul(eth_decimal_num); token = createTokenContract(); }",1
0x6efca3bae1d10fca39a184175e03db5065d2fa60.sol,ShitCloneFarmer,contract ShitCloneFarmer { uint256 public TIME_TO_MAKE_1_SHITCLONE = 86400; uint256 public STARTING_SHITCLONE = 100; uint256 PSN = 10000; uint256 PSNH = 5000; bool public initialized = true; address public ShitCloneslordAddress; uint256 public ShitCloneslordReq = 500000; mapping (address => uint256) public ballShitClone; mapping (address => uint256) public claimedTime; mapping (address => uint256) public lastEvent; mapping (address => address) public referrals; uint256 public marketTime; function ShitCloneFarmer() public { ShitCloneslordAddress = msg.sender; },1
0x1ba3845bdc6ff17de21f4211b9d24d5544e878b2.sol,BBArtefact,"contract BBArtefact is Ownable, ERC721Token { uint public incrementId; struct Artefact { uint id; uint typeId; uint packId; uint packTypeId; }",1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpImageStorage,contract BdpImageStorage is BdpBase { using SafeMath for uint256; struct Image { address owner; uint256 regionId; uint256 currentRegionId; mapping(uint16 => uint256[1000]) data; mapping(uint16 => uint16) dataLength; uint16 partsCount; uint16 width; uint16 height; uint16 imageDescriptor; uint256 blurredAt; },1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) public whitelist; mapping(uint => address) whitelistCheck; uint public countAddress = 0; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; },1
0x41775c5783d6d04d4ad31cabdb1596d6625a12d2.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x27a66f1415dcae9e196827b7bd2dd850aeb301f7.sol,PreSale,"contract PreSale is Ownable { using SafeMath for uint256; TokenContract public tkn; CrowdSale public cSale; InvestorsStorage public investorsStorage; uint256 public levelEndDate; uint256 public currentLevel; uint256 public levelTokens = 375000; uint256 public tokensSold; uint256 public weiRised; uint256 public ethPrice; address[] public investorsList; bool public presalePaused; bool public presaleEnded; uint256[12] private tokenPrice = [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48]; uint256 private baseTokens = 375000; uint256 private usdCentValue; uint256 private minInvestment; constructor() public { tkn = TokenContract(0xea674f79acf3c974085784f0b3e9549b39a5e10a); investorsStorage = InvestorsStorage(0x15c7c30B980ef442d3C811A30346bF9Dd8906137); minInvestment = 100 finney; updatePrice(5000); }",1
0x0eb29d27265d818dbbb395b7c9423f77aea70fa7.sol,COLOMBIA_WINS,"contract COLOMBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 476721916935210000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); if(!isParticipated[_to]){ allParticipants.push(_to); isParticipated[_to] = true; }",1
0xf4a26409f3f60f14e6e1c62ca4c2f4cbefa34084.sol,Operatable,contract OperatableBasic { function setPrimaryOperator (address addr) public; function setSecondaryOperator (address addr) public; function isPrimaryOperator(address addr) public view returns (bool); function isSecondaryOperator(address addr) public view returns (bool); },1
0x6b9167d6ccf38a4e286c0180286053c8bedf5cf9.sol,Test1,"contract Test1 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 500000e8; uint256 public constant minContribution = 1 ether / 500; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2029fdb81d226e0e45a620c47314b3ab1f78bf46.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd6e91857090c901f3b96d6df7cfb3b41f8673942.sol,ZBXToken,"contract ZBXToken is ERC20, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; uint256 public hardcap = 500000000 * (10**uint256(18)); bool private _enbaleActions = true; constructor() public { _totalSupply = hardcap; _balances[owner()] = _totalSupply; emit Transfer(address(0), owner(), _totalSupply); }",1
0x01c8bb9205fec775deb38534ea50a84c9b30a84b.sol,VNETPrivatePlacement,"contract VNETPrivatePlacement is Ownable { using SafeMath for uint256; ERC20Basic public vnetToken; string public description; uint256 public rate; uint256 public etherMinimum; uint256 public etherMaximum; constructor(ERC20Basic _vnetToken, string _description, uint256 _rate, uint256 _min, uint256 _max) public { vnetToken = _vnetToken; rate = _rate; etherMinimum = _min; etherMaximum = _max; description = _description; }",1
0x313c54eb9f08f1be0f18e8ad505135fa7041a52f.sol,Token,"contract Token is SafeMath { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] = sub(balances[msg.sender], _value); balances[_to] = add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; }",1
0xa584c5eaccb5dd4a5c0fc0a785dee952becc4c06.sol,Crowdsale,contract Crowdsale { uint256 public price; token public tokenReward; address owner; uint256 public amount; modifier onlyCreator() { require(msg.sender == owner); _; },1
0x1c048352237ab1ff92b34d032148d87e825b44c1.sol,LeRT_Bounty,"contract LeRT_Bounty is owned { using SafeMath for uint256; address public token; mapping (address => uint256) public sent; address[] internal extention; event Withdraw(address user, uint256 amount, uint256 balance); function LeRT_Bounty() public { token = 0x13646D839725a5E88555a694ac94696824a18332; }",1
0x45ca8d5458d7f3f7d2f47daae253924cafc2f331.sol,EmiratesCoin,"contract EmiratesCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EmiratesCoin( ) public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf0150cec4fe8477d039c4b4e679c040480763170.sol,HumanRegistry,"contract HumanRegistry { event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data); event _Challenge(bytes32 indexed listingHash, uint challengeID, uint deposit, string data); event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal); event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal); event _ApplicationWhitelisted(bytes32 indexed listingHash); event _ApplicationRemoved(bytes32 indexed listingHash); event _ListingRemoved(bytes32 indexed listingHash); event _ListingWithdrawn(bytes32 indexed listingHash); event _TouchAndRemoved(bytes32 indexed listingHash); event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _RewardClaimed(uint indexed challengeID, uint reward, address voter); event _ListingMigrated(bytes32 indexed listingHash, address newRegistry); using SafeMath for uint; struct Listing { uint applicationExpiry; bool whitelisted; address owner; uint unstakedDeposit; uint challengeID; }",1
0xc4805e505b29f5858292148b11919a880630ebee.sol,Ownable,"contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }",1
0xe1e83a85c9db1bbd7cfab3e6bffaf255c5013adb.sol,BasicMultiToken,"contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken { using CheckedERC20 for ERC20; ERC20[] public tokens; uint internal inLendingMode; bool public bundlingDenied; event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); event BundlingDenied(bool denied); modifier notInLendingMode { require(inLendingMode == 0, ); _; }",1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,Goldmint,"contract GoldmintUnsold is SafeMath { address public creator; address public teamAccountAddress; address public icoContractAddress; uint64 public icoIsFinishedDate; MNTP public mntToken; function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){ creator = msg.sender; teamAccountAddress = _teamAccountAddress; mntToken = MNTP(_mntTokenAddress); }",1
0x2651a435e2d451a3c2c2649067b79548d9f3859b.sol,CardsRead,contract CardsRead { CardsInterface public cards; GameConfigInterface public schema; address owner; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x212fa406fd28663ee6110d863a18e80960300e5c.sol,AnxToken,"contract AnxToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x963012c66676F1B4d8cbb491dd78AF3278789738] = _totalSupply; emit Transfer(address(0), 0x963012c66676F1B4d8cbb491dd78AF3278789738, _totalSupply); }",1
0x723c7bca7ed11ab6a18b84c1ff5b979fec00f54e.sol,PlayCoinKey,"contract PlayCoinKey is modularKey { using SafeMath for *; using NameFilter for string; using PCKKeysCalcLong for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x14229878e85e57FF4109dc27bb2EfB5EA8067E6E); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 2 minutes; uint256 private rndGap_ = 15 minutes; uint256 constant private rndInit_ = 24 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private rndMin_ = 10 minutes; uint256 public reduceMul_ = 3; uint256 public reduceDiv_ = 2; uint256 public rndReduceThreshold_ = 10e18; bool public closed_ = false; address private admin = msg.sender; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) private blacklist_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => PCKdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => PCKdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => PCKdatasets.TeamFee) public fees_; mapping (uint256 => PCKdatasets.PotSplit) public potSplit_; constructor() public { blacklist_[0xB04B473418b6f09e5A1f809Ae2d01f14211e03fF] = 1; fees_[0] = PCKdatasets.TeamFee(30,6); fees_[1] = PCKdatasets.TeamFee(43,0); fees_[2] = PCKdatasets.TeamFee(56,10); fees_[3] = PCKdatasets.TeamFee(43,8); potSplit_[0] = PCKdatasets.PotSplit(15,10); potSplit_[1] = PCKdatasets.PotSplit(25,0); potSplit_[2] = PCKdatasets.PotSplit(20,20); potSplit_[3] = PCKdatasets.PotSplit(30,10); }",1
0x556e3cc5eaacfb87cc8ace3be0d3497abddee99c.sol,DooDooCoin,"contract DooDooCoin is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0xa45d88c06a8643fb53f9c9923162403852bf3592.sol,HareemMinePoolToken,"contract HareemMinePoolToken is BasicToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 constant INITIAL_SUPPLY = 1000 * (10 ** uint256(decimals)); uint256 public sellPrice = 0.35 * 10 ** 18; uint256 public buyPrice = 0.25 * 10 ** 18; string public constant COLLATERAL_HELD = ; uint payout_worth = 0; event Debug(string message, uint256 num); mapping(address => uint256) amountLeftToBePaid; mapping(address => uint256) partialAmtToBePaid; address[] listAddr; address ethStore = 0x66Ef84EE378B07012FE44Df83b64Ea2Ae35fD09b; address exchange = 0x093af86909F7E2135aD764e9cB384Ed7311799d3; uint perTokenPayout = 0; uint tokenToTakeBack = 0; event addr(string message, address sender); event logString(string message); function () public payable { buy(msg.sender); }",1
0x2898ca01df2dc4062e8b269806de4996295a1f5c.sol,SaleAuction,contract SaleAuction is AuctionBase { address public beneficiary = msg.sender; function SaleAuction(address _nftAddress) public { ERC721 candidateContract = ERC721(_nftAddress); nonFungibleContract = candidateContract; },1
0x04efc7daef8e5ba7b23f1cc1b3a36e2d50000ff7.sol,AmmuNationStore,"contract AmmuNationStore is Claimable, ERC721Holder{ using SafeMath for uint256; GTAInterface public token; uint256 private tokenSellPrice; uint256 private tokenBuyPrice; uint256 public buyDiscount; mapping (address => mapping (uint256 => uint256)) public nftPrices; event Buy(address buyer, uint256 amount, uint256 payed); event Robbery(address robber); constructor (address _tokenAddress) public { token = GTAInterface(_tokenAddress); }",1
0xf0cdb03eeb1027bcaea7b7648293339c5bb12c58.sol,CustomToken,"contract CustomToken is Pausable{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function CustomToken ( string tokenName, string tokenSymbol ) public { decimals = 18; name = tokenName; symbol = tokenSymbol; }",1
0xf030b8fbe57c4498298449fc78a0f7054a5ef76d.sol,Ownable,"contract Ownable { address public owner; mapping (address => bool) public admins; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; admins[owner] = true; }",1
0xf167c6e18202f11866350a135eaa04f5c8857481.sol,CPS,"contract CPS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 3; uint256 public totalSupply = 32000000e3; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public CPSPerEth = 2500e3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event CPSPerEthUpdated(uint _CPSPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8ab7404063ec4dbcfd4598215992dc3f8ec853d7.sol,TokenProxy,"contract TokenProxy is UpgradeabilityProxy, TokenStorage, Ownable { constructor(address _implementation, address _balances, address _allowances, string _name, uint8 _decimals, string _symbol) UpgradeabilityProxy(_implementation) TokenStorage(_balances, _allowances, _name, _decimals, _symbol) public { }",1
0x71972877d68acf22114e05578364a307cafe2885.sol,BsCrowdsale,"contract BsCrowdsale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, DASH, ZEC, WAVES, USD, EUR }",1
0xeb72f169016fec42b63ae5e87207f0fb274408c7.sol,MidexToken,"contract MidexToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public exchangeRegulatorWallet; address public wallet; uint256 public initialSupply = 75000000 * (10 ** uint256(decimals)); uint256 public amountToken = 1 * (10 ** uint256(decimals)); uint public endTime; mapping(address => bool) transferAllowed; function MidexToken() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; wallet = owner; exchangeRegulatorWallet = owner; endTime = 1523750400; }",1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,CapperRole,contract CapperRole { using Roles for Roles.Role; event CapperAdded(address indexed account); event CapperRemoved(address indexed account); Roles.Role private cappers; constructor() internal { _addCapper(msg.sender); },1
0x35ac7dcba25ba2192c87981bfcf024208070a25f.sol,BasicMultiToken,"contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken, SupportsInterfaceWithLookup { using CheckedERC20 for ERC20; using CheckedERC20 for DetailedERC20; ERC20[] private _tokens; uint private _inLendingMode; bool private _bundlingEnabled = true; event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); event BundlingStatus(bool enabled); modifier notInLendingMode { require(_inLendingMode == 0, ); _; }",1
0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4.sol,FccToken,"contract FccToken is Owned, StandardToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function FccToken() { balances[msg.sender] = 200000000* 10**8; totalSupply = 200000000* 10**8; locked = false; }",1
0x32e996a5a0b6d93c457bfa70917b08622ccdb3f4.sol,Digitelcoin,"contract Digitelcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Digitelcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 30000000000000000; balances[ 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894] = _totalSupply; Transfer(address(0), 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894, _totalSupply); }",1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownIco,"contract ExoTownIco is SafeMath, IcoLimits { ExoTownToken public exotownToken; enum State { Pause, Running }",1
0x70287b389aa4d35368bc9ee39cec7bf43e7439a8.sol,cDaiGatewayAggregate,"contract cDaiGatewayAggregate is Ownable { Exchange1 cDaiEx = Exchange1(0x45A2FDfED7F7a2c791fb1bdF6075b83faD821ddE); Exchange2 DaiEx2 = Exchange2(0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14); Exchange3 DaiEx3 = Exchange3(0x818E6FECD516Ecc3849DAf6845e3EC868087B755); Exchange4 DaiEx4 = Exchange4(0x793EbBe21607e4F04788F89c7a9b97320773Ec59); Erc20 dai = Erc20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); CErc20 cDai = CErc20(0xF5DCe57282A584D2746FaF1593d3121Fcac444dC); address etherAddr = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee; function () public payable { etherTocDai1(msg.sender, owner); }",1
0x54d3ad23846643b93098915001ab274ea19e5622.sol,Mythereum,"contract MythereumERC20Token is ERC20 { function burn(address burner, uint256 amount) public returns (bool); function mint(address to, uint256 amount) public returns (bool); }",1
0xebbdf302c940c6bfd49c6b165f457fdb324649bc.sol,HydroToken,contract HydroToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function HydroToken() public { totalSupply = 11111111111 * 10**18; balances[msg.sender] = totalSupply; },1
0xc0d72d45cca854e0f2fe3cd2d4bab91e772fe4c0.sol,Pixereum,contract Pixereum { struct Pixel { address owner; string message; uint256 price; bool isSale; },1
0xdb25f211ab05b1c97d595516f45794528a807ad8.sol,EURSToken,contract EURSToken is AbstractToken { uint256 constant internal FEE_DENOMINATOR = 100000; uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR; uint256 constant internal MIN_FEE_NUMERATIOR = 0; uint256 constant internal MAX_TOKENS_COUNT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / MAX_FEE_NUMERATOR; uint256 constant internal DEFAULT_FEE = 5e2; uint256 constant internal BLACK_LIST_FLAG = 0x01; uint256 constant internal ZERO_FEE_FLAG = 0x02; modifier delegatable { if (delegate == address (0)) { require (msg.value == 0); _; },1
0x03b0be689f36f383568d0a2486834cc6ceddda50.sol,EtherPyramid_PowH_Revived,"contract EtherPyramid_PowH_Revived { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function ethpyramid() public { }",1
0x4488ed050cd13ccfe0b0fcf3d168216830142775.sol,NetkillerAdvancedTokenAirDrop,"contract NetkillerAdvancedTokenAirDrop { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false; bool public airdropStatus = false; uint256 public airdropTotalSupply; uint256 public airdropCurrentTotal; uint256 public airdropAmount; mapping(address => bool) public touched; event AirDrop(address indexed target, uint256 value); function NetkillerAdvancedTokenAirDrop( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; airdropAmount = 1 * 10 ** uint256(decimals); }",1
0x74902714d325e794f50f7e07bd802aa61b5f450d.sol,BBToken,"contract BBToken is Migrations, ERC20Base { bool public isTokenLocked; bool public isUseFreeze; struct Frozen { bool from; uint256 fromUntil; bool to; uint256 toUntil; uint256 amount; uint256 amountUntil; }",1
0x025334708ec64febfff398a71f0719a4c0d66739.sol,Locklisted,"contract Locklisted { Locklist.List private _list; modifier onlyLocklisted() { require(Locklist.check(_list, msg.sender) == true); _; }",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0x9adc8a707ee86497461472c4055e039d99e70d6d.sol,Iou_Token,"contract Iou_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*30/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1528416000; uint256 public ico_start = 1531008000; uint256 public ico_finish = 1541635200; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint public coef = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ERC721BasicToken,"contract ERC721BasicToken is ERC721Basic, ERC165MappingImplementation { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping(uint256 => address) internal tokenOwner; mapping(uint256 => address) internal tokenApprovals; mapping(address => uint256) internal ownedTokensCount; mapping(address => mapping(address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; }",1
0x4d49849dcc51ea1675140cb007d9f6897ae53260.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,Registry,"contract Registry { event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant); event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger); event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner); event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner); event _ApplicationWhitelisted(bytes32 indexed listingHash); event _ApplicationRemoved(bytes32 indexed listingHash); event _ListingRemoved(bytes32 indexed listingHash); event _ListingWithdrawn(bytes32 indexed listingHash, address indexed owner); event _TouchAndRemoved(bytes32 indexed listingHash); event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter); event _ExitInitialized(bytes32 indexed listingHash, uint exitTime, uint exitDelayEndDate, address indexed owner); using SafeMath for uint; struct Listing { uint applicationExpiry; bool whitelisted; address owner; uint unstakedDeposit; uint challengeID; uint exitTime; uint exitTimeExpiry; }",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0xf293df3337bdfc76a454ce00b3d2fa5c8ba086a5.sol,BitRich,"contract BitRich is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0x1f895c4805561a19be9d3bb8867bdcbbeb724848.sol,BazzEX,contract BazzEX { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 3; uint public _totalSupply = 3300000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x340d2bde5eb28c1eed91b2f790723e3b160613b7.sol,BlockvToken,"contract BlockvToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; PoolBLock public poolBLock; PoolCLock public poolCLock; PoolDLock public poolDLock; uint256 public constant totalAmountOfTokens = 3646271241200255205023407108; uint256 public constant amountOfTokensPoolA = 1276194934420089321758192488; uint256 public constant amountOfTokensPoolB = 911567810300063801255851777; uint256 public constant amountOfTokensPoolC = 911567810300063801255851777; uint256 public constant amountOfTokensPoolD = 546940686180038280753511066; address public migrationMaster; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); function BlockvToken(address _migrationMaster) Pausable(_migrationMaster) { require(_migrationMaster != 0); migrationMaster = _migrationMaster; totalSupply = totalAmountOfTokens; balances[msg.sender] = amountOfTokensPoolA; Transfer(0x0, msg.sender, amountOfTokensPoolA); poolBLock = new PoolBLock(this); poolCLock = new PoolCLock(this); poolDLock = new PoolDLock(this); balances[poolBLock] = amountOfTokensPoolB; balances[poolCLock] = amountOfTokensPoolC; balances[poolDLock] = amountOfTokensPoolD; Transfer(0x0, poolBLock, amountOfTokensPoolB); Transfer(0x0, poolCLock, amountOfTokensPoolC); Transfer(0x0, poolDLock, amountOfTokensPoolD); }",1
0x6bbb3f23c64e840a381e0615635475c56324d784.sol,BEU,"contract BEU { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 2000000000000000000000000000; address public owner; bool public lockAll = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => uint256) public lockOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor() public { owner = msg.sender; balanceOf[msg.sender] = totalSupply; }",1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x0d5f8a079042d5071220498fa0f0d7fd2c5fffbe.sol,WalletSimple,"contract WalletSimple { event Deposited(address from, uint value, bytes data); event SafeModeActivated(address msgSender); event Transacted( address msgSender, address otherSigner, bytes32 operation, address toAddress, uint value, bytes data ); address[] public signers; bool public safeMode = false; uint constant SEQUENCE_ID_WINDOW_SIZE = 10; uint[10] recentSequenceIds; function WalletSimple(address[] allowedSigners) public { if (allowedSigners.length != 3) { revert(); }",1
0x4b77bde81ceaf137d883e43aa27cf767cd2f8141.sol,StrongKek,contract StrongKek { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSTokenBase,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0xa5225ec025c1765fc925c0051955ad80d9965755.sol,FireWorks,"contract FireWorks is ERC20Detailed { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; string constant tokenName = ; string constant tokenSymbol = ; uint8 constant tokenDecimals = 10; uint256 _totalSupply = 9000000000000; uint256 public basePercent = 50; constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) { _mint(msg.sender, _totalSupply); }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,usingOraclize,contract usingOraclize is DSAuth { byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x338614bb06e4857d140b5f241349cff0a6128679.sol,FoMo3Dlong,"contract FoMo3Dlong is F3Devents { using SafeMath for *; using F3DKeysCalcLong for uint256; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ =0 ; uint256 constant private rndInit_ = 72 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 72 hours; uint256 public rID_; uint256 public comB_; uint256 public userCount_ = 1; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(63,0); fees_[1] = F3Ddatasets.TeamFee(40,0); potSplit_[0] = F3Ddatasets.PotSplit(30,50); potSplit_[1] = F3Ddatasets.PotSplit(20,60); }",1
0x0d409bcc1b0212348b9404e01599b843f44dd6c4.sol,VIDEX,"contract VIDEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 9000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 30000; uint256 public tokensPer2Eth = 35000; uint256 public tokensPer3Eth = 40000; uint256 public startPase = 1541548800; uint public maxPhase1 = 875000000e8; uint public maxPhase2 = 1750000000e8; uint public maxPhase3 = 2685000000e8; uint public currentPhase = 0; uint public soldPhase1 = 0; uint public soldPhase2 = 0; uint public soldPhase3 = 0; uint256 public pase1 = startPase + 1 * 30 days; uint256 public pase2 = pase1 + 1 * 30 days; uint256 public pase3 = pase2 + 1 * 30 days; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event StartPaseUpdated(uint256 _time); event TokensPerEthUpdated(uint _tokensPerEth); event TokensPerEth2Updated(uint _tokensPerEth); event TokensPerEth3Updated(uint _tokensPerEth); event MaxPhase1Updated(uint _maxPhase1); event MaxPhase2Updated(uint _maxPhase2); event MaxPhase3Updated(uint _maxPhase3); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1e2d6ca17730e657f6ef0446126d5ae2869ee8d9.sol,MESSIToken,contract MESSIToken is ERC20 { using SafeMath for uint256; address public messiDev = 0xFf80AF92f137e708b6A20DcFc1af87e8627313B8; address public messiCommunity = 0xC2fe05066985385aa49B85697ff5847F43F26B7A; struct TokensWithLock { uint256 value; uint256 blockNumber; },1
0xd433138d12beb9929ff6fd583dc83663eea6aaa5.sol,BTR,"contract BTR is owned{ using SafeMath for uint; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor(string tokenName,string tokenSymbol,address tokenOwner) public { decimals = 18; totalSupply = 1000000000 * 10 ** uint(decimals); balanceOf[tokenOwner] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = tokenOwner; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x03e53ffab44c5b60ad7f4eda5969773717007056.sol,useqvolOracle,contract useqvolOracle{ address private owner; function useqvolOracle() payable { owner = msg.sender; },1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x03324c5bce64a142f0110040851574903516b2ac.sol,DarkPool,"contract DarkPool is Ownable { ERC20Basic hodl; uint public end; uint public raised; uint public cap; mapping(address => uint) public balances; event Deposit(address indexed beneficiary, uint value); event Withdraw(address indexed beneficiary, uint value); function () external payable whenActive { require(whitelisted(msg.sender), ); raised += msg.value; balances[msg.sender] += msg.value; require(raised <= cap, ); emit Deposit(msg.sender, msg.value); }",1
0x69d94dc74dcdccbadec877454a40341ecac34a7c.sol,IRideToken,"contract IRideToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IRideToken() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0e7c28fb8ed4f5f63aabd022deaeeba40ecc335c.sol,EtherCenter,contract EtherCenter { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x888888ecb41d5abb38bdd9c5e2f653f411c70765.sol,Lottery,"contract Lottery { using SafeMath for uint256; modifier withdrawRight(){ require(msg.sender == address(bankContract), ); _; }",1
0x3793ea257ad168ef1b4d0ed56464f9b0ab388c12.sol,CryptoEmojis,contract CryptoEmojis { using SafeMath for uint256; address dev; string constant private tokenName = ; string constant private tokenSymbol = ; struct Emoji { string codepoints; string name; uint256 price; address owner; bool exists; },1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoStorage,"contract DaoStorage is DaoWhitelistingCommon, BytesIteratorStorage { using DoublyLinkedList for DoublyLinkedList.Bytes; using DaoStructs for DaoStructs.Voting; using DaoStructs for DaoStructs.Proposal; using DaoStructs for DaoStructs.ProposalVersion; DoublyLinkedList.Bytes allProposals; mapping (bytes32 => DaoStructs.Proposal) proposalsById; mapping (bytes32 => DoublyLinkedList.Bytes) proposalsByState; constructor(address _resolver) public { require(init(CONTRACT_STORAGE_DAO, _resolver)); }",1
0xecfae6f958f7ab15bdf171eeefa568e41eabf641.sol,AcceptsLYNIA,contract AcceptsLYNIA { LYNIA public tokenContract; function AcceptsLYNIA(address _tokenContract) public { tokenContract = LYNIA(_tokenContract); },1
0x0608cae11d659aa29527aad2efaa51e8707b63fa.sol,SelfDropIco,"contract SelfDropIco is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 10 * 10**7 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function SelfDropIco() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0xa1cb45a734151b63679e1aed48e4c3deb8d1908d.sol,GuardianGoldToken,"contract GuardianGoldToken is BasicToken, Ownable, RBAC { string public name = ; string public symbol = ; uint8 public decimals = 18; string public constant ADMIN_ROLE = ; uint256 constant internal magnitude = 2**64; uint public maxTokens = 5000e18; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal referralBalance_; mapping(address => mapping (address => uint256)) allowed; uint public goldAccount = 0; uint public operationsAccount = 0; uint256 internal profitPerShare_; address[] public transfers; uint public constant INITIAL_SUPPLY = 62207e15; uint public totalSupply = 62207e15; uint public totalGoldReserves = 62207e15; uint public pendingGold = 0; uint public totalETHReceived = 57.599 ether; bool public isTransferable = true; bool public toggleTransferablePending = false; address public transferToggleRequester = address(0); uint public tokenPrice = 0.925925 ether; uint public goldPrice = 0.390185 ether; uint public tokenSellDiscount = 950; uint public referralFee = 30; uint minGoldPrice = 0.2 ether; uint maxGoldPrice = 0.7 ether; uint minTokenPrice = 0.5 ether; uint maxTokenPrice = 2 ether; uint public dividendRate = 150; uint public minPurchaseAmount = 0.1 ether; uint public minSaleAmount = 1e18; uint public minRefStake = 1e17; bool public allowBuy = false; bool public allowSell = false; bool public allowRedeem = false; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; addRole(msg.sender, ADMIN_ROLE); emit Transfer(address(this), msg.sender, INITIAL_SUPPLY); }",1
0x40b85cffab146eefcceee004392168d6b4d5a24c.sol,ADRToken,"contract ADRToken is StandardToken{ string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000000000000000000000; uint256 public constant MAX_SUPPLY = 100 * 10000 * 10000 * (10 ** uint256(decimals)); constructor() ADRToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xed2f35867a1afc19eeff7f0fbd7cd30c0c8c288a.sol,Etheropoly,contract Etheropoly { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x723437fade99e15a33a0355189e0a00ece23a7d6.sol,GreatHarmon,contract GreatHarmon is Ownable { using SafeMath for uint256; function GreatHarmon() public { },1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,Gallery_MuYi_No2,contract Gallery_MuYi_No2 is StandardToken { function () { throw; },1
0x0cfae4866c11cf6194d787cf76d479e28a7cc577.sol,FundariaToken,"contract FundariaToken { string public constant name = ; string public constant symbol = ; uint public totalSupply; uint public supplyLimit; uint public course; mapping(address=>uint256) public balanceOf; mapping(address=>mapping(address=>uint256)) public allowance; mapping(address=>bool) public allowedAddresses; address public fundariaPoolAddress; address creator; event SuppliedTo(address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event SupplyLimitChanged(uint newLimit, uint oldLimit); event AllowedAddressAdded(address _address); event CourseChanged(uint newCourse, uint oldCourse); function FundariaToken() { allowedAddresses[msg.sender] = true; creator = msg.sender; }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCommon,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 2000 * 10**18; uint public maxWithdraw = 50000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; balanceOf[_escrow] = 7850047931491270769372792; totalSupply = 7850047931491270769372792; }",1
0x2821fb31998e60d220ff52af6299872f25a3e149.sol,MiniMeToken,contract MiniMeToken is Controlled { using SafeMath for uint256; string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x64b103aee34d1fa22fb4c45c4be105cbe1c4a179.sol,RainbowsEverywhere,contract RainbowsEverywhere { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1fecdc11d045cfe5a564610c23120ebe35852cb3.sol,s_Form003,contract s_Form003 { mapping (bytes32 => string) data; address owner; function s_Form003() { owner = msg.sender; },1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x3fab1c4216e401de80cef4ac5387452d16314c6e.sol,BurritoToken,"contract BurritoToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256[] private listed; uint256 public devOwed; uint256 public poolTotal; uint256 public lastPurchase; mapping (uint256 => Burrito) public burritoData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) private payoutBalances; event BurritoPurchased(uint256 indexed _tokenId, address indexed _owner, uint256 _purchasePrice); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 3.0 ether; uint256 private finalCap = 5.0 ether; uint256 public devCutPercentage = 4; struct Burrito { uint256 startingPrice; uint256 price; uint256 lastPrice; uint256 payout; uint256 withdrawn; address owner; }",1
0x33ec7788795360fa3d2461606e9fe2fb95b942e9.sol,Bitbose,"contract Bitbose is StandardToken { using SafeMath for uint256; mapping (address => uint256) public freezed; event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event Withdraw(address indexed _from, address indexed _to, uint256 _value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function burn(uint256 _value) public onlyOwner whenNotPaused { _burn(msg.sender, _value); }",1
0xc0360a3507655e619cdf7e6ca616d9ddec4dec95.sol,CommonSale,"contract CommonSale is StagedCrowdsale { MYTCToken public token; uint public slaveWalletPercent = 50; uint public percentRate = 100; uint public minInvestment; bool public slaveWalletInitialized; bool public slaveWalletPercentInitialized; address public masterWallet; address public slaveWallet; address public directMintAgent; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (uint => address) public contributors; uint public uniqueContributors; event TokenPurchased(address indexed purchaser, uint256 value, uint256 purchaseDate); event TokenMinted(address to, uint tokens, uint256 mintedDate); event InvestmentReturned(address indexed investor, uint256 amount, uint256 returnDate); modifier onlyDirectMintAgentOrOwner() { require(directMintAgent == msg.sender || owner == msg.sender); _; }",1
0x27bc53596dc0ea71de3c65c799d8e6c96c1dda98.sol,YunJiaMiToken,contract YunJiaMiToken is Ownable{ using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply = 800000000000 ether; uint256 public currentTotalSupply = 0; uint256 startBalance = 100000 ether; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function YunJiaMiToken() public { balances[msg.sender] = startBalance * 6000000; currentTotalSupply = balances[msg.sender]; },1
0x0f43093b586b011258479e61d41a862e909386e0.sol,PO8BaseToken,"contract PO8BaseToken is ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 totalSupply_; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public{ name = _name; symbol = _symbol; decimals = _decimals; totalSupply_ = _totalSupply; }",1
0xefcec6d87e3ce625c90865a49f2b7482963d73fe.sol,FETCOIN,"contract FETCOIN is ERC223, Pausable { using SafeMath for uint256; struct Offering { uint256 amount; uint256 locktime; }",1
0x5041d5c444c2d730b406ae5ec9199cd8e47e463c.sol,POHMO,"contract POHMO is PoHEVENTS { using SafeMath for *; using NameFilter for string; using KeysCalc for uint256; PlayerBookInterface private PlayerBook; POHCONTRACT private POHToken; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 seconds; uint256 private rndGap_ = 1 seconds; uint256 private rndInit_ = 6 hours; uint256 constant private rndInc_ = 10 seconds; uint256 private rndMax_ = 6 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => POHMODATASETS.Player) public plyr_; mapping (uint256 => mapping (uint256 => POHMODATASETS.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => POHMODATASETS.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => POHMODATASETS.TeamFee) public fees_; mapping (uint256 => POHMODATASETS.PotSplit) public potSplit_; constructor(address token, address playerbook) public { POHToken = POHCONTRACT(token); PlayerBook = PlayerBookInterface(playerbook); fees_[0] = POHMODATASETS.TeamFee(47,12); potSplit_[0] = POHMODATASETS.PotSplit(15,10); }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0x5befe0f9a29ba63aec7664e7f5e9c198e5be113b.sol,DSTToken,"contract DSTToken is ERC20, Ownable, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public tokensPerEther = 1500; address public DSTMultisig; address dstWalletLMNO; bool public startStop = false; mapping (address => uint256) public walletA; mapping (address => uint256) public walletB; mapping (address => uint256) public walletC; mapping (address => uint256) public walletF; mapping (address => uint256) public walletG; mapping (address => uint256) public walletH; mapping (address => uint256) public releasedA; mapping (address => uint256) public releasedB; mapping (address => uint256) public releasedC; mapping (address => uint256) public releasedF; mapping (address => uint256) public releasedG; mapping (address => uint256) public releasedH; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct WalletConfig{ uint256 start; uint256 cliff; uint256 duration; }",1
0xbc86727e770de68b1060c91f6bb6945c73e10388.sol,InkProtocolCore,"contract InkProtocolCore is InkProtocolInterface, StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant gasLimitForExpiryCall = 1000000; uint256 private constant gasLimitForMediatorCall = 4000000; enum Expiry { Transaction, Fulfillment, Escalation, Mediation }",1
0x28a40acf39b1d3c932f42dd8068ad00a5ad6448f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint _value) returns (bool success) { require( msg.data.length >= (2 * 32) + 4 ); require( _value > 0 ); require( balances[msg.sender] >= _value ); require( balances[_to] + _value > balances[_to] ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xedc8c33d811ed9628472a6555e41782f3d8b389f.sol,Ownable,contract Ownable { address public owner; address candidate; address public manager1; address public manager2; function Ownable() public { owner = msg.sender; manager1 = msg.sender; manager2 = msg.sender; },1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsContest,contract CSportsContestBase { struct Team { address owner; int32 score; uint32 place; bool holdsEntryFee; bool ownsPlayerTokens; uint32[] playerTokenIds; },1
0x6ec8a24cabdc339a06a172f8223ea557055adaa5.sol,MiniMeToken,"contract MiniMeToken is ERC20, Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; }",1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0xf5308f8023fd7f6008f78ef6dec7264e2f91403d.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,NeuroToken,"contract NeuroToken is MyAdvancedToken { uint256 public frozenTokensSupply; function NeuroToken() MyAdvancedToken(17500000, , 0, ) { freezeTokens(17437000); }",1
0x04efc7daef8e5ba7b23f1cc1b3a36e2d50000ff7.sol,AmmuNationStore,"contract AmmuNationStore is Claimable, ERC721Holder{ using SafeMath for uint256; GTAInterface public token; uint256 private tokenSellPrice; uint256 private tokenBuyPrice; uint256 public buyDiscount; mapping (address => mapping (uint256 => uint256)) public nftPrices; event Buy(address buyer, uint256 amount, uint256 payed); event Robbery(address robber); constructor (address _tokenAddress) public { token = GTAInterface(_tokenAddress); }",1
0x26cb3641aaa43911f1d4cb2ce544eb652aac7c47.sol,CrystalToken,"contract CrystalToken is SafeStandardToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 28000000 * (10 ** uint256(decimals)); struct Round { uint256 startTime; uint256 endTime; uint256 availableTokens; uint256 maxPerUser; uint256 rate; mapping(address => uint256) balances; }",1
0x377dfa7bab23a798ca1fa0923bcd4d4ef2184d85.sol,StarbaseCrowdsale,"contract StarbaseCrowdsale is Ownable { event CrowdsaleEnded(uint256 endedAt); event StarBasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage); event StarBasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data); event CnyEthRateUpdated(uint256 cnyEthRate); event CnyBtcRateUpdated(uint256 cnyBtcRate); event QualifiedPartnerAddress(address qualifiedPartner); event PurchaseInvalidated(uint256 purchaseIdx); event PurchaseAmended(uint256 purchaseIdx); AbstractStarbaseToken public starbaseToken; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; uint256 constant public MIN_INVESTMENT = 1; uint256 constant public MAX_CROWDSALE_CAP = 60000000; string public constant PURCHASE_AMOUNT_UNIT = ; struct CrowdsalePurchase { address purchaser; uint256 amount; uint256 rawAmount; uint256 purchasedAt; string data; uint256 bonus; }",1
0x6f655b9e1e79a8979ad5bf8f141f2fc4dc71540c.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsOwnership,"contract EthernautsOwnership is EthernautsAccessControl, ERC721 { EthernautsStorage public ethernautsStorage; string public constant name = ; string public constant symbol = ; bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256()); event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed owner, address indexed approved, uint256 tokens); event Build(address owner, uint256 tokenId, uint16 assetId, uint256 price); function implementsERC721() public pure returns (bool) { return true; }",1
0x4c517cfda3b326317120865a9d70d17554748f6f.sol,LOTS,"contract LOTS is EIP20Interface { using SafeMath for uint; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; uint public constant finalSupply = 10**9 * 10**uint(decimals); uint public totalSupply; uint public constant fundraisingReservation = 50 * finalSupply / 100; uint public constant foundationReservation = 5 * finalSupply / 100; uint public constant communityReservation = 25 * finalSupply / 100; uint public constant teamReservation = 20 * finalSupply / 100; uint public nextWithdrawDayFoundation; uint public nextWithdrawDayCommunity; uint public nextWithdrawDayTeam; uint public withdrawedFundrasingPart; uint public withdrawedFoundationCounter; uint public withdrawedCoummunityCounter; uint public withdrawedTeamCounter; address public manager; bool public paused; event Burn(address _from, uint _value); modifier onlyManager() { require(msg.sender == manager); _; }",1
0x3a04336c56f510f60bda4a927b0dbf8d7a1b658c.sol,CoinGdt,"contract CoinGdt { address public admin_address = 0x635BbC42d615F415e4Ad1BAD6B213532EC4325B1; address public account_address = 0x635BbC42d615F415e4Ad1BAD6B213532EC4325B1; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 180000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameCore,contract BurnupGameCore is BurnupGameFinance { function BurnupGameCore(address burnupHoldingAddress) public BurnupGameFinance(burnupHoldingAddress) {},1
0x38c87aa89b2b8cd9b95b736e1fa7b612ea972169.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0xecea1d051a5c3339983ecc2dbdc3f38a7f52c636.sol,Nerotoken,"contract Nerotoken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Nerotoken() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x99c4ef0a180c19e929452e94972aa60cac1b0b7d] = _totalSupply; Transfer(address(0), 0x99c4ef0a180c19e929452e94972aa60cac1b0b7d, _totalSupply); }",1
0x707bd951c676c5f7a957df363d6ce1b2af4b636d.sol,ANOCrowdsale,contract ANOCrowdsale { using SafeMath for uint256; ANOToken token; uint256 public startDate; uint256 public endDate; uint256 private weekNo = 0; uint256 public allocatedToken = 21000000000 * 10 ** 18; uint256 private tokenAllocatedForWeek; uint256 private tokenSoldForWeek; uint256 public ethRaised; uint32 public tokenRate = 6078; uint32 public appreciationRate = 1216; bool private isTokenSet = false; address public founderAddress; address public beneficiaryAddress; struct weeklyData { uint256 startTime; uint256 endTime; uint32 weekRate; },1
0xf2031a9636371b592e7bdb19ca054e918a45eb2e.sol,Token,"contract Token { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; bool setupDone = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) { owner = adr; }",1
0x778dddf23ec1b5cb18394c6c110480caadb3b0f6.sol,Package,"contract Package is Ownable { event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI); struct Version { uint64[3] semanticVersion; address contractAddress; bytes contentURI; }",1
0x1caecd601911d84941fddc74f94a871e15d24299.sol,JAPAN_WINS,"contract JAPAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x774ba492cbdd14992da56212de1335e00039906c.sol,DivideDrainDestroy,"contract DivideDrainDestroy is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 1; balances[owner] = _totalSupply; emit Transfer(address(0),owner, _totalSupply); }",1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; }",1
0xf04436b2edaa1b777045e1eefc6dba8bd2aebab8.sol,TokenSale,contract TokenSaleConfig { uint public constant EXA = 10 ** 18; uint256 public constant PUBLIC_START_TIME = 1515542400; uint256 public constant END_TIME = 1518220800; uint256 public constant CONTRIBUTION_MIN = 0.1 ether; uint256 public constant CONTRIBUTION_MAX = 2500.0 ether; uint256 public constant COMPANY_ALLOCATION = 40 * 10 ** 6 * EXA; Tranche[4] public tranches; struct Tranche { uint untilToken; uint tokensPerEther; },1
0x00e126e283b0e116470a0f6d6108f314e5cf2a0e.sol,BatPay,"contract BatPay is Payments { constructor( IERC20 token_, uint32 maxBulk, uint32 maxTransfer, uint32 challengeBlocks, uint32 challengeStepBlocks, uint64 collectStake, uint64 challengeStake, uint32 unlockBlocks, uint64 maxCollectAmount ) public { require(token_ != address(0), ); require(maxBulk > 0, ); require(maxTransfer > 0, ); require(challengeBlocks > 0, ); require(challengeStepBlocks > 0, ); require(collectStake > 0, ); require(challengeStake > 0, ); require(unlockBlocks > 0, ); require(maxCollectAmount > 0, ); owner = msg.sender; token = IERC20(token_); params.maxBulk = maxBulk; params.maxTransfer = maxTransfer; params.challengeBlocks = challengeBlocks; params.challengeStepBlocks = challengeStepBlocks; params.collectStake = collectStake; params.challengeStake = challengeStake; params.unlockBlocks = unlockBlocks; params.maxCollectAmount = maxCollectAmount; }",1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6fc2a052f82d0f8b5d774f8ef8b30fe933ce9953.sol,DMSCOIN,"contract DMSCOIN is Token { using SafeMath for uint256; uint256 public price = 3000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { tokenReward = token(address(this)); }",1
0xafb4fe1315504c92c3ed3657cd600712a8938aac.sol,Batman,"contract Batman is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Batman( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe0c0f5ce4e746eaa048ae5db5c61b6b1ef3b56ed.sol,CryptoSim,contract CryptoSim{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=10; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function CryptoSim() public{ ceoAddress=msg.sender; },1
0x48783486ddd7fa85eca6b0c4ae8920bc25dfbcd7.sol,GoMoney2,"contract GoMoney2 is ERC20, Ownable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; }",1
0xd4c2a5c4be6ec37a84a78382c6c7368651d8b443.sol,ManagedToken,"contract ManagedToken is Operable { using SafeMath for uint256; mapping (address => uint256) private _balances; uint256 private _totalSupply; event Transfer( address indexed from, address indexed to, uint256 value ); function totalSupply() public view returns (uint256) { return _totalSupply; }",1
0x6e4c0f93cfa81ce9ab66bf07dd9264957d1ca10c.sol,FomoSuper,"contract FomoSuper is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xB2b3d6feAE1AB2af4a07Cf4C047D69aa01D809Aa); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 8 minutes; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(22,6); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(52,10); fees_[3] = F3Ddatasets.TeamFee(68,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0xf270f361edca19f7063184b0e6b4f264468ecbc1.sol,PDAToken,contract PDAToken is StandardToken { function () payable public { require(false); },1
0xbf95d4957d481473e39c70d3bc08896740e3ca96.sol,CvcProxy,"contract CvcProxy is ImplementationStorage { event Upgraded(address implementation); event AdminChanged(address previousAdmin, address newAdmin); bytes32 private constant ADMIN_SLOT = 0x2bbac3e52eee27be250d682577104e2abe776c40160cd3167b24633933100433; modifier ifAdmin() { if (msg.sender == currentAdmin()) { _; }",1
0x5c2f940281e735ca3496d8138be12d18023dce9f.sol,BNANAToken,"contract BNANAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xD967E4422F7A6465396E14c39990409cFee42AB0] = _totalSupply; emit Transfer(address(0), 0xD967E4422F7A6465396E14c39990409cFee42AB0, _totalSupply); }",1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,TokenCampaign,contract TokenCampaign is Controlled{ using SafeMath for uint256; rea_token_interface public token; TokenVault teamVault; uint256 public constant PRCT_TEAM = 10; uint256 public constant PRCT_BOUNTY = 3; uint256 public constant PRCT_ETH_OP = 10; uint8 public constant decimals = 18; uint256 public constant scale = (uint256(10) ** decimals); uint256 public constant baseRate = 330; uint256 public constant bonusTokenThreshold = 2000000 * scale ; uint256 public constant minContribution = (1 ether) / 100; uint256 public constant bonusMinContribution = (1 ether) /10; uint256 public constant bonusAdd = 99; uint256 public constant stage_1_add = 50; uint256 public constant stage_2_add = 33; uint256 public constant stage_3_add = 18; address public teamVaultAddr = 0x0; address public bountyVaultAddr; address public trusteeVaultAddr; address public opVaultAddr; address public tokenAddr; address public robotAddr; uint8 public campaignState = 4; bool public paused = false; uint256 public tokensGenerated = 0; uint256 public amountRaised = 0; uint256 public tCampaignStart = 64060588800; uint256 public tBonusStageEnd = 7 * (1 days); uint256 public tRegSaleStart = 8 * (1 days); uint256 public t_1st_StageEnd = 15 * (1 days); uint256 public t_2nd_StageEnd = 22* (1 days); uint256 public t_3rd_StageEnd = 29 * (1 days); uint256 public tCampaignEnd = 38 * (1 days); uint256 public tFinalized = 64060588800; modifier onlyRobot () { require(msg.sender == robotAddr); _; },1
0xf0fb984b464cdb7cbef0cc7222018bbba7f9e97e.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xd934f629303416ba435f51c1a162756302fb686f.sol,WhitelistedAICrowdsale,"contract WhitelistedAICrowdsale is TokenlessCrowdsale, Ownable { using SafeMath for uint256; mapping(address => bool) public accredited; mapping(address => uint256) public contributions; mapping(address => uint256) public caps; function isWhitelisted(address _beneficiary) public view returns (bool) { if (caps[_beneficiary] != 0) { return true; }",1
0x00ab698bbb34ce1ac75ec1398fbeba8db82a5c63.sol,Socialife,"contract Socialife is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 18000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xed2bd91e69155782d045ca8254eafa8935e99b58.sol,P6,"contract P6 is Whitelist, SessionQueue { modifier onlyTokenHolders { require(myTokens() > 0); _; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0xf296fbc18ebce3eeb1026abbb4c9ee406f7c4467.sol,PowerOfCommunity,contract PowerOfCommunity { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xebc39fa7796d281549f63058b0de56a7199890b9.sol,KFCExchange,"contract KFCExchange is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0xB0Db95F1811A59fE7D9f7572115063Aa1AA154ab] = _totalSupply; emit Transfer(address(0), 0xB0Db95F1811A59fE7D9f7572115063Aa1AA154ab, _totalSupply); }",1
0x27ce70a584c085712cd42f20181237178ddc5a45.sol,ENECT,"contract ENECT is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x6daa60ed2b441a64d128c9d3b0a168d8245c3d1a.sol,UNICToken,"contract UNICToken is owned, StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public initialSupply = 250000000 * 10 ** uint256(decimals); address public icoManager; mapping (address => uint256) public WhiteList; modifier onlyManager() { require(msg.sender == icoManager); _; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,DecoBank,contract DecoBank { using SafeMath for uint256; Deco public token; address private crowdsaleWallet; address private decoReserveWallet; uint256 public weiRaised; uint256 public constant totalSupplyUnits = 6*10**26; uint256 private constant MINIMUM_WEI = 10**16; uint256 private constant BASE = 10**18; uint256 public originalRate = 3000; uint256 public crowdsaleDistributedUnits = 0; uint256 public issuerDistributedUnits = 0; uint256 public presaleStartTime; uint256 public presaleEndTime; uint256 private presaleDiscount = 50; uint256 private presalePercentage = 5; uint256 public issuerReservedMaximumPercentage = 5; uint256 public saleStartTime; uint256 public saleEndTime; uint256 private saleDiscount = 25; uint256 public rewardDistributionStart; uint256 public rewardDistributedUnits = 0; mapping(address => Contributor) private contributors; struct Contributor { uint256 contributedWei; uint256 decoUnits; uint256 rewardDistributedDecoUnits; },1
0x1b60504beb425f7cfc8dd14f29924cf596ffaf0b.sol,Matrioska,"contract MatrioskaToken{ uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,TokenWithFees,"contract TokenWithFees is Manageable, StandardToken { uint8 public transferFeeNumerator = 0; uint8 public transferFeeDenominator = 100; address public beneficiary; event ChangeWallet(address indexed addr); event ChangeFees(uint8 transferFeeNumerator, uint8 transferFeeDenominator); constructor(address _wallet) public { beneficiary = _wallet; }",1
0x52a6ade96e2571aef35215997a8516e52f9016ab.sol,Oracle,contract Oracle is DSMath { uint32 constant public DELAY = 900; uint128 constant public prem = 1100000000000000000; uint128 constant public turn = 1010000000000000000; MedianizerInterface med; uint32 public expiry; uint32 public timeout; uint128 assetPrice; uint128 public paymentTokenPrice; uint256 rewardAmount; mapping(bytes32 => AsyncRequest) asyncRequests; struct AsyncRequest { address rewardee; uint128 payment; uint128 disbursement; ERC20 token; bool assetPriceSet; bool paymentTokenPriceSet; },1
0xcfd2e5876cb479dc9d86abb2ff4bfe166c8d8d22.sol,Dedit,"contract Dedit { event RegistrationCreated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); event RegistrationUpdated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); struct Registration { address registrant; bytes32 hash; uint blockNumber; string description; }",1
0x651efeba62be2911f211b9e39ae7dcf3094bd758.sol,Sale,contract Sale is RI { using SafeMath for uint; uint public poolCapUSD = 1002750; uint public usdPerEther = 350; uint public supplyCap; uint public businessPlannedPeriodDuration = 365 days; uint public businessPlannedPeriodEndTimestamp; uint public teamCap; uint8 public teamShare = 45; uint public distributedTeamStakes; uint public contractCreatedTimestamp; address public pool = 0x1882464533072e9fCd8C6D3c5c5b588548B95296; mapping (address=>bool) public rejectedInvestmentWithdrawals; uint public allowedAmountToTransferToPool; uint public allowedAmountTransferedToPoolTotal; uint public investmentGuidesRewardsWithdrawn; uint public distributedBountyStakes; uint public bountyCap; uint8 public bountyShare = 7; address supplier = 0x0000000000000000000000000000000000000000; struct saleData { uint stakes; uint invested; uint bonusStakes; uint guideReward; address guide; },1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x41e8eedfbd7d8765d18ef82c9d21c07cb27382a6.sol,GSCToken,"contract GSCToken is ERC20, Ownable { using SafeMath for uint256; address public engDevAddress = 0x20d3596A9C0986995225770F95CCb4fB30411E33; address public engCommunityAddress = 0x20d3596A9C0986995225770F95CCb4fB30411E33; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x33e85f62383aa7601d6ca117fe35b9b397ffe056.sol,UXDToken,contract UXDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UXDToken () { owner = msg.sender; },1
0xd99bb99326cb7d9f10dcd1fd25fd7ce6c3b8ec46.sol,GandhiJi,contract GandhiJi { modifier onlybelievers () { require(myTokens() > 0); _; },1
0x4d49849dcc51ea1675140cb007d9f6897ae53260.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x5565e9824e9d4a9f4175d912a7376d3a10e187ba.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public startBalance = 2 ether; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x92ca7bec7a5acdea3c38ba9fca2ac4e2cf5a88ff.sol,BRC,"contract BRC is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply; uint256 public targetsecure = 50000e18; mapping (address => uint256) public balanceOf; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function totalSupply() public constant returns (uint) { return _totalSupply - balances[address(0)]; }",1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0xd47e449c721eb270341b690960576c333f2c1174.sol,BTCR,contract BTCRConfig { string public constant name = ; string public constant symbol = ; address public constant OWNER = 0x8579A678Fc76cAe308ca280B58E2b8f2ddD41913; address public constant ADMIN_TOO = 0xE7e10A474b7604Cfaf5875071990eF46301c209c; uint public constant TOTAL_TOKENS = 10; uint8 public constant decimals = 18; },1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x0057826d01b84775dbc9b3a5ba1152b095988481.sol,SquirrelFarmer,contract SquirrelFarmer{ uint256 public EGGS_TO_HATCH_1SQUIRREL=86400; uint256 public STARTING_SQUIRREL=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcherySquirrel; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public squirrelmasterReq=100000; function SquirrelFarmer() public{ ceoAddress=msg.sender; },1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,AssemblyBase,contract AssemblyBase is DetailBase { struct Assembly { uint256 idParent; uint256 dna; uint64 releaseTime; uint64 updateTime; uint64 startMiningTime; uint64[] spares; uint8 countMiningDetail; uint8 rang; },1
0xc4123b7a155a8a337d7b45155483a81e0d2ebf59.sol,_0xBabylon,"contract _0xBabylon{ uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 3; int constant crr_d = 5; int constant price_coeff = 0x42ea9ce452cde449f; mapping(address => uint256) public holdings; mapping(address => uint256) public avgFactor_ethSpent; mapping(address => uint256) public color_R; mapping(address => uint256) public color_G; mapping(address => uint256) public color_B; mapping(address => address) public reff; mapping(address => uint256) public tricklingPass; mapping(address => uint256) public pocket; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public trickleSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 constant trickTax = 3; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerBond; event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onBoughtFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onReinvestFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onTokenSell( address indexed customerAddress, uint256 totalTokensAtTheTime, uint256 tokensBurned, uint256 ethereumEarned, uint256 resolved, address indexed gateway ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted, address indexed gateway ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event onCashDividends( address indexed ownerAddress, address indexed receiverAddress, uint256 ethereumWithdrawn ); event onColor( address indexed customerAddress, uint256 oldR, uint256 oldG, uint256 oldB, uint256 newR, uint256 newG, uint256 newB ); event onTrickle( address indexed fromWho, address indexed finalReff, uint256 reward, uint256 passUp ); function holdingsOf(address _owner) public constant returns (uint256 balance) { return holdings[_owner]; }",1
0x86dae30c437872fe12151a2b0542eb3fb696bba2.sol,Airdrop,"contract Airdrop is Pausable { using SafeMath for uint; using ECRecovery for bytes32; event Distribution(address indexed to, uint256 amount); mapping(bytes32 => address) public users; mapping(bytes32 => uint) public unclaimedRewards; address public signer; KMHTokenInterface public token; NameRegistryInterface public nameRegistry; constructor(address _token, address _nameRegistry, address _signer) public { require(_token != address(0)); require(_nameRegistry != address(0)); require(_signer != address(0)); token = KMHTokenInterface(_token); nameRegistry = NameRegistryInterface(_nameRegistry); signer = _signer; }",1
0x26d76a22859fec45da123dbf3e14053a8b5b0831.sol,FullFOMO,"contract FullFOMO is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5A3e43Ba22D1590C21ecB364f8fb46c17d683364); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 10 minutes; uint256 private rndGap_ = 10 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 22 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(60,0); fees_[1] = F3Ddatasets.TeamFee(60,0); fees_[2] = F3Ddatasets.TeamFee(60,0); fees_[3] = F3Ddatasets.TeamFee(60,0); potSplit_[0] = F3Ddatasets.PotSplit(25,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(25,0); potSplit_[3] = F3Ddatasets.PotSplit(25,0); }",1
0x52a9700551128585f0d68b6d4d2fa322a2aeee47.sol,ERC721Token,"contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 { string internal name_; string internal symbol_; mapping(address => uint256[]) internal ownedTokens; mapping(uint256 => uint256) internal ownedTokensIndex; uint256[] internal allTokens; mapping(uint256 => uint256) internal allTokensIndex; mapping(uint256 => string) internal tokenURIs; constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa440bd8cef10998266d5920f0518e378cefb6584.sol,ZealaxToken,"contract ZealaxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether /100; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3670a029a6ce9be3bd62c76853e747e65ddf6431.sol,NTA3D,"contract NTA3DEvents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 timeStamp ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onBuyKey ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 roundID, uint256 ethIn, uint256 keys, uint256 timeStamp ); event onBuyCard ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 cardID, uint256 ethIn, uint256 timeStamp ); event onRoundEnd ( address winnerAddr, bytes32 winnerName, uint256 roundID, uint256 amountWon, uint256 newPot, uint256 timeStamp ); event onDrop ( address dropwinner, bytes32 winnerName, uint256 roundID, uint256 droptype, uint256 win, uint256 timeStamp ); }",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,TemplateCrowdsale,"contract TemplateCrowdsale is Consts, MainCrowdsale , BonusableCrowdsale , RefundableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(10000000 * TOKEN_DECIMAL_MULTIPLIER, 0x2e2f33B0D829c844916b486ee1185B1186bc2f83, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1543158000) CappedCrowdsale(1300000000000000000000) RefundableCrowdsale(200000000000000000000) { }",1
0x038d5044c7a8e7146763524f84f8850e2805673b.sol,Coinbase,"contract Coinbase is Ownable { using SafeMath for uint256; uint256 public blockHeight; uint256 public decimals; uint256 public coinbaseInit; uint256 public halvingPeriod = 4 * 120; uint256 public maxSupply; uint256[6] private coinbaseArray; uint256 public exodus; event LogBlockHeight(uint256 blockHeight); constructor(uint256 _decimals) public{ decimals = _decimals; maxSupply = 710000000 * (10 ** uint256(decimals)); exodus = maxSupply / 10; coinbaseInit = 196875 * (10 ** uint256(decimals)); coinbaseArray = [ coinbaseInit, coinbaseInit / 2, coinbaseInit / 4, coinbaseInit / 8, coinbaseInit / 16, coinbaseInit / 16 ]; }",1
0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd.sol,Mythereum,"contract MythereumERC20Token is ERC20 { function burn(address burner, uint256 amount) public returns (bool); function mint(address to, uint256 amount) public returns (bool); }",1
0x1d1ff336189f16fcb5aea6f00398c06bec5fd0cc.sol,casinoProxy,contract casinoProxy is casinoBank{ mapping(address => bool) public authorized; mapping(address => mapping(address => bool)) public authorizedByUser; mapping(address => mapping(address => uint8)) public lockedByUser; address[] public casinoGames; mapping(address => uint) public count; modifier onlyAuthorized { require(authorized[msg.sender]); _; },1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,ConvertLib,"contract ConvertLib { uint16[12] days_since = [ 11, 42, 70, 101, 131, 162, 192, 223, 254, 284, 315, 345 ]; function b32toString(bytes32 x) internal returns (string) { bytes memory bytesString = new bytes(32); uint charCount = 0; for (uint j = 0; j < 32; j++) { byte char = byte(bytes32(uint(x) * 2 ** (8 * j))); if (char != 0) { bytesString[charCount] = char; charCount++; }",1
0x8af9e74991044827449946d334a478b6fe8f5740.sol,MUBEX,"contract MUBEX { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MUBEX() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5c93bfe7d725d6dee8e65a2b670f1d401b1a5152.sol,inFuturePaymentToken,contract inFuturePaymentToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,CapperRole,contract CapperRole { using Roles for Roles.Role; event CapperAdded(address indexed account); event CapperRemoved(address indexed account); Roles.Role private cappers; constructor() internal { _addCapper(msg.sender); },1
0x748c6ed3f78f5f06ceb76834f195d3a05b7d628a.sol,POWH33,contract POWH33 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2732dd0f79f6cf4f257232ea2291ffbab2c18c15.sol,CoinFlipperDSG,contract CoinFlipperDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x0f612a09ead55bb81b6534e80ed5a21bf0a27b16.sol,EUNOMIA,"contract EUNOMIA is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5ad9e100bc58e57a20cf1cae204f046006d27a27.sol,Ambassador,contract Ambassador { using SafeMath for uint256; CoinCrowdICO icoContract; uint256 public startRC; uint256 public endRC; address internal contractOwner; uint256 public soldTokensWithoutBonus; function euroRaisedRc() public view returns(uint256 euro) { return icoContract.euroRaised(soldTokensWithoutBonus); },1
0xec760f48d714255aa63007c85cd739b1c623513e.sol,PresalerVoting,"contract PresalerVoting { string public constant VERSION = ; uint public VOTING_START_BLOCKNR = 0; uint public VOTING_END_TIME = 0; TokenStorage PRESALE_CONTRACT = TokenStorage(0x4Fd997Ed7c10DbD04e95d3730cd77D79513076F2); string[3] private stateNames = [, , ]; enum State { BEFORE_START, VOTING_RUNNING, CLOSED }",1
0x018d7d179350f1bb9853d04982820e37cce13a92.sol,INXToken,"contract INXToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 53220000; uint256 public tokensPer2Eth = 62220000; uint256 public tokensPer3Eth = 72220000; uint256 public startPase = 1542646800; uint public maxPhase1 = 1500000e8; uint public maxPhase2 = 1000000e8; uint public maxPhase3 = 500000e8; uint public currentPhase = 0; uint public soldPhase1 = 0; uint public soldPhase2 = 0; uint public soldPhase3 = 0; uint256 public pase1 = startPase + 1 * 18 days; uint256 public pase2 = pase1 + 1 * 18 days; uint256 public pase3 = pase2 + 1 * 18 days; uint256 public constant minContribution = 1 ether / 4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event StartPaseUpdated(uint256 _time); event TokensPerEthUpdated(uint _tokensPerEth); event TokensPerEth2Updated(uint _tokensPerEth); event TokensPerEth3Updated(uint _tokensPerEth); event MaxPhase1Updated(uint _maxPhase1); event MaxPhase2Updated(uint _maxPhase2); event MaxPhase3Updated(uint _maxPhase3); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2119a3314c1d40704d816392a9e44da463688992.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address prize_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr1 = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr2 = 0x6c7dfe3c255a098ea031f334436dd50345cfc737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x748286a6a4cead7e8115ed0c503d77202eeeac6b); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x347c099f110ca6761779329d2879957b606b6ace.sol,ERC20Token,"contract ERC20Token is IERC20Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0x6571ec4474893799454da4900b225e82249dcc30.sol,ProofOfTrevonJames2,contract ProofOfTrevonJames2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xde4f1f39242e779f4ae6324e06fb30ba3e14e377.sol,KTuneTokenBurner,"contract KTuneTokenBurner is Pausable { using SafeMath for uint256; event LogKTuneTokenBurnerCreated(address indexed caller, address indexed wallet); event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage); address public wallet; uint256 public burningPercentage; uint256 public burnedTokens; uint256 public transferredTokens; constructor(address _wallet) public { require(_wallet != address(0), ); wallet = _wallet; burningPercentage = 100; emit LogKTuneTokenBurnerCreated(msg.sender, _wallet); }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,AdvancedToken365,"contract AdvancedToken365 is owned, Token365 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function AdvancedToken365( uint256 initialSupply, string tokenName, string tokenSymbol ) Token365(initialSupply, tokenName, tokenSymbol) public {}",1
0x1d1b9264f4ed2476fa8cc08d7c001af9668d05ed.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,GivethCampaign,"contract GivethCampaign is TokenController, Owned, Escapable { uint public startFundingTime; uint public endFundingTime; uint public maximumFunding; uint public totalCollected; MiniMeToken public tokenContract; address public vaultAddress; function GivethCampaign( address _escapeHatchCaller, address _escapeHatchDestination, uint _startFundingTime, uint _endFundingTime, uint _maximumFunding, address _vaultAddress, address _tokenAddress ) Escapable(_escapeHatchCaller, _escapeHatchDestination) { require(_endFundingTime > now); require(_endFundingTime > _startFundingTime); require(_maximumFunding <= 1000000 ether); require(_vaultAddress != 0); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; maximumFunding = _maximumFunding; tokenContract = MiniMeToken(_tokenAddress); vaultAddress = _vaultAddress; }",1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,FTXToken,"contract FTXToken is StandardToken, Ownable { string public constant NAME = ; string public constant SYMBOL = ; string public constant VERSION = ; uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**18; uint256 public constant FINTRUX_RESERVE_FTX = 10000000 * 10**18; uint256 public constant CROSS_RESERVE_FTX = 5000000 * 10**18; uint256 public constant TEAM_RESERVE_FTX = 10000000 * 10**18; address public constant FINTRUX_RESERVE = 0x633348b01B3f59c8A445365FB2ede865ecc94a0B; address public constant CROSS_RESERVE = 0xED200B7BC7044290c99993341a82a21c4c7725DB; address public constant TEAM_RESERVE = 0xfc0Dd77c6bd889819E322FB72D4a86776b1632d5; uint256 public constant VESTING_DATE = 1519837200 + 1 years; uint256 public token4Gas = 1*10**18; uint256 public gas4Token = 80000*0.6*10**9; uint256 public minGas4Accts = 80000*4*10**9; bool public allowTransfers = false; mapping (address => bool) public transferException; event Withdraw(address indexed from, address indexed to, uint256 value); event GasRebateFailed(address indexed to, uint256 value); function FTXToken(address _owner) public { require(_owner != address(0)); totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY - FINTRUX_RESERVE_FTX - CROSS_RESERVE_FTX - TEAM_RESERVE_FTX; balances[FINTRUX_RESERVE] = FINTRUX_RESERVE_FTX; balances[CROSS_RESERVE] = CROSS_RESERVE_FTX; balances[TEAM_RESERVE] = TEAM_RESERVE_FTX; owner = _owner; transferException[owner] = true; }",1
0x411139af515804562ddca220220728c9791cc714.sol,BountyKN,contract BountyKN { using SafeMath for uint256; KnowToken public token; mapping(address => uint256) tokens; constructor() public { token = KnowToken(0xbfd18F20423694a69e35d65cB9c9D74396CC2c2d); tokens[address(0x0941A88F7a6ee30E08498a580799Da5e6608124D)] = 1400; tokens[address(0xfD207944B3F2a7eFE9f6272930A717E5075D55E9)] = 2100; tokens[address(0xc720B97782D494AE64ff9E4Fe5c4A4Cb5e427Df0)] = 2700; tokens[address(0xB9c2638f354008b89844A4e47998F25564a24cd5)] = 2100; tokens[address(0xa0860bc693F2A531d65F6fFAb4aB551510971c37)] = 15400; tokens[address(0xB44DA40daC4CcCb8F2b0198187ABE4FBc2623a2F)] = 2300; tokens[address(0xd0FfEdE652D3453501463b3281973e1cB2cE30BC)] = 1100; tokens[address(0x3D5d3555135A4c36817B971196e4e441e2e82E38)] = 1400; tokens[address(0x95D52f953cDA1270F3BaB0c281bFeCCDB660515c)] = 4500; tokens[address(0x41fa0945FbC3416895006aFE2a25174816a68673)] = 8600; tokens[address(0xE646AFbbd439831Da07b7F7be8593D04a9b53C9D)] = 2800; tokens[address(0xD78b69C011ff6C910428163bE64129C29bC88311)] = 2100; tokens[address(0xE8d92Eb3F9Ee2e1e14453DA69ab91a3597DEdaBD)] = 2500; tokens[address(0x8b4A92B9183fE94Ae2B6f5D52D207F59bBE8Ff72)] = 17700; tokens[address(0x7Af4DdF725A3F2F1547518553d8A030B5Cf8323d)] = 600; tokens[address(0xF360ABbDEA1283d342AD9CB3770e10597217d4b2)] = 5800; tokens[address(0x7DaA87DE1d7C0C95FE47407480f50Bec45026D9F)] = 5400; tokens[address(0xc546BdCBE2dca6a2539273CfFB0daF76488676aF)] = 1400; tokens[address(0x3bA0A6942458c6e70cb08F1Cb836e778B44937Bc)] = 1200; tokens[address(0xB4c370a2f3d1c8d3f512aD493DD1E5aAB31e845b)] = 35700; tokens[address(0x28791A193f4f07F41A4bA1472362a899768564b9)] = 5900; tokens[address(0xCd8543b68802dB509Bc90DBb93FcBdF22FDA2414)] = 2100; tokens[address(0xD3489b36655faA8F9CD68AB6e7B96C93A31AA09B)] = 1900; tokens[address(0xC9276d01EF0271189bc831eF2AE4a7830D9CC711)] = 20700; tokens[address(0x4aDAecE33a542511FB9C075b6E197E560af0d260)] = 2300; tokens[address(0x9FBE5Be513d11d3d4066648B35304722406d86e7)] = 1200; tokens[address(0x83b7062779cC4E9fB2195EF643DFaf5a10940f55)] = 1600; tokens[address(0xCFE0d265eF56be39a557Ca0788cC4C648aeD4256)] = 22100; tokens[address(0xb61098608C21800a3DbEa92e45131a2059Fabe69)] = 3100; tokens[address(0xF7fcA9a5A74E2b4ce80272D9A7AeBc3889CC38eA)] = 1600; tokens[address(0x1cB9e7CCfc1C431eE711F40ecB8CfBE9DeDd2848)] = 1600; tokens[address(0x4A11B358DC9Cd81f3532F19215B1d252d9aBA6f7)] = 5600; tokens[address(0x406586B2683826fB8546f8cf91ba2d43b930f2dB)] = 1200; tokens[address(0x4bD2096F27a7f29bF0D382753e5Aa8596adC3835)] = 1600; tokens[address(0x16b06822E0354337ffa7E32438ACa8a58d8a71dA)] = 3100; tokens[address(0x54Ff62E93f5801d423919aD2fD4b1b58D793C635)] = 6700; tokens[address(0xe054C4795CDDc4a7616f5a5615ece5221d319431)] = 2700; tokens[address(0x7E2081D632e7aC2554ED0Eb03f03F464b22CF1e2)] = 1700; tokens[address(0x97a9ffbad5f34Fb83C090F38fEB0189BF43caD46)] = 1400; tokens[address(0xA60655bc5C4C311bD56C93005C0C52bc52d7BA9c)] = 2100; tokens[address(0xDE8AEd3c54805F3CD7E681a1f7C70aB5361f09d0)] = 2100; tokens[address(0x03740abCf89dA53c5e331C48cbA61Fc4e1DA61bf)] = 1000; tokens[address(0x3EB13628f4a7E76d87ca0EcfA8dad629f5eC7a85)] = 3900; tokens[address(0xB38eae3fb6733b7DF9E1A8070F8060E586ca966e)] = 700; tokens[address(0xdcaF58f7A3e91ad7a49aE42f9454c06891FB14b0)] = 2135; tokens[address(0x612d9189D5442a54a5995d0bE8b1A7833Bb093d4)] = 1600; tokens[address(0x8Eadd5c5DE68A9F1B3bA0D5862B2dD091E467288)] = 2200; tokens[address(0x4f4a5be801Cf09b94c1807d728fCc7a32608AdA1)] = 3600; tokens[address(0x15bf03dDB2A547cda86F88273B4419D93A6b7191)] = 4700; tokens[address(0x085dC96c98695edaE27866540B9B33df57567Fe9)] = 600; tokens[address(0x9741bc612fB318a9a9475D11582564A71693f132)] = 50900; tokens[address(0xc374E66ff5D6A6eA1f30Ce8e35A98f4705D10871)] = 1300; tokens[address(0x0E1653D0dA5ffd5F4b59Abb08fbd2a5C9eD3A2D8)] = 4900; tokens[address(0xEf9b4ECeB926d687e8421B47EdF90A3C61Cc4261)] = 4500; tokens[address(0xC31702F684Ac4474E6892Cf1841d7762062b62b8)] = 1200; tokens[address(0x3842828A77A670224b3296fF4F63482189cdEAFa)] = 2000; tokens[address(0xF27AA919fB5f1B449fceDF58B8Ff2f25D9b3Bf4c)] = 1700; tokens[address(0xa5BFE70F7f7F96329ebD60Ad527739ee1405F434)] = 600; tokens[address(0xb74E15da83687E0A0237cE6ecbeFEbAAc9162e75)] = 2400; tokens[address(0xF664E2C7c5126340058bB918d0a27a60a0938089)] = 8900; tokens[address(0x40170aDAB40C78519e8606B200B1F7c30813fe20)] = 1600; tokens[address(0xC2E0EE421ECeB9DeAa27B06F812035401A8fa249)] = 18800; tokens[address(0x9d804ca277b9cc8Bec9eA42fdBc41eC17A3d4D40)] = 600; tokens[address(0x63782B9465ed59Fed9bfC22321D066Dfa6901db5)] = 2000; tokens[address(0xCa6d5bCaDb1b652Db568D7475faDB42c18Ef8702)] = 2400; tokens[address(0x2A7f654a78632bbff061FAF0dD21B7DbAd9397Bb)] = 3000; tokens[address(0xbcDc8c2f3939F9abcc72eac373c961147Cba0Ea4)] = 1300; tokens[address(0x9806AAB9F61E28668B5925A7AF0aBC77C1d3118d)] = 600; tokens[address(0xcd645307bf75d01b14d10Ceff74Eb5CEEf329Ba5)] = 9500; tokens[address(0x5a247c15D4bdB05D90fcaA84C27B641B80C36166)] = 1900; tokens[address(0x229d8D4872Ef6f3DC29E0243f8FAf219F746Ca4D)] = 600; tokens[address(0x2B7fa6C81a759B4F75a8Da54C771bBCbfD6D6eFe)] = 2900; tokens[address(0x187B702d7676BB27F8737a44A99a00C57F62ca8f)] = 1400; tokens[address(0x1A5957480C03c220540eeb3752d81cA63D05eeB0)] = 1600; tokens[address(0xEa40272571b523C87e67F392F942C28668201eBd)] = 1000; tokens[address(0x03B501B00D5c1dEccAc462DED676C5d3b1e3B578)] = 2600; tokens[address(0xA050EEeFb3a56bd08eA34c4664E9888Eda89f2Cb)] = 1000; tokens[address(0x21501eb303490A9bd2E24d1e37974D9CAB3A1975)] = 4800; tokens[address(0x823dde5b4b0068440bc6c4d5E96471447b8715BA)] = 1900; tokens[address(0xD9Bc45A741ED2692436f4F9278eF5F764c7D4DAb)] = 3600; tokens[address(0xE7A2d7ce01dB677efdd3bBbeae7ce02D49A847f0)] = 4100; tokens[address(0xad497Fba56d915A37E2664c895C3762bdB91063F)] = 3100; tokens[address(0x42F8D3d00569bAD0587Bc7c129D6AB2A02d38bb2)] = 2100; tokens[address(0x34209Dd9B7b1791111DCFb4F2a5180B5302396A6)] = 6100; tokens[address(0x6b67b5Daf8F736C7A4334575f621D78C57c8e8B0)] = 600; tokens[address(0x0187A422b4faD439Fbfcf20f21F32159fd2a4f97)] = 14100; tokens[address(0xDF489E9b14fA9140F1D061C2864153a3bF42d702)] = 1900; tokens[address(0x5448eA30c16d94283468fFC78B56ca6Cf55627C9)] = 1400; tokens[address(0x7863145782E3b68554f69169aCb78C49D53acA86)] = 15000; tokens[address(0x516526B4F552bc28a2963460fcf2dEAF51379Ef3)] = 2200; tokens[address(0x26bE30e807985aC821e752AB8BaAfB9e24ff5BF8)] = 2200; tokens[address(0x1179f72F797E0b593A416D89213aa781Cb1d505b)] = 17400; tokens[address(0x9be2cb8d5742e44A7f41Cae139731fc7B174c92F)] = 900; tokens[address(0xaf15F8EEf5D408Af7f2A96a0bA43933394896fE8)] = 600; tokens[address(0x3EF19882D6fdf524eF5806E96B2148f6E68f8765)] = 3100; tokens[address(0xe1950cB15faacAEA071b5CFD2e47BD343D166348)] = 1600; tokens[address(0xa1564b6DE580e3Fefe8b7511f9bEa3B016442cf8)] = 1600; tokens[address(0xc04107121ABD5c4aDbA8Fe1E5e8F6C3eB4Dc943a)] = 3900; tokens[address(0xA2bCCa90d554c0BeA7EF98514EAfAceBFabC7e01)] = 1600; tokens[address(0x7f19e512b646e340c91212dA64d5c29ddfAB5A88)] = 1600; tokens[address(0x49572b891f781C63C4c3d5f0369ff5848b10cC8A)] = 1900; tokens[address(0x4E267850f9306d69D4E6924378dfBf6BddF92987)] = 1600; tokens[address(0x1b2F2BA6076d5bD6016c3Ac6720B1b4eFe039ab0)] = 2100; tokens[address(0xd13b82e701F36d07C8b305c03b0D22322AA07Eca)] = 4900; tokens[address(0x10B37D101d52111c15e031c06693E4029ac16FB9)] = 5200; tokens[address(0xc15D4Bc7B9144Bfc5465C663f7C850d262bEadA8)] = 21100; tokens[address(0xc3FE5b76320E35356578B9cEa8380273eE1E1014)] = 1600; tokens[address(0x605E23B31FeF49614f42119A385B5C6a25cBD197)] = 1600; tokens[address(0x80131B1a904b4F93f17f5a2548F8BbD1Ea173a1B)] = 5600; tokens[address(0x5898A9A31C418782308A1d794AcB36ebF5BF2366)] = 600; tokens[address(0xB4631C95E026ad54AFA1655b7e61ae6B8796cc87)] = 2100; tokens[address(0xcDa68c18d3DE67D0875AC5f1B0ecDa8013eAb402)] = 1200; tokens[address(0xF375729a12bF1B3C4E67259DBE518995999be1c7)] = 1600; tokens[address(0xbf5e8f557c14C8162977400FEE3Daf771713e0c4)] = 600; tokens[address(0x3c37B9178969AF7d5D3B76C4454ec8483852c7b8)] = 1900; tokens[address(0x5916Ef86dA9Bf7e80fCF424fF79Dbf130e3e61be)] = 1600; tokens[address(0x9B96814F007C47ae421176B91520dDD55A5567e4)] = 13600; tokens[address(0x29a696B5172BD2eFEA8db0D591f38636C970aAA3)] = 2000; tokens[address(0x5FD14b0Dac21ed28f580b4f543B027B75E9D3a72)] = 2600; tokens[address(0x6DAf093f0Aa4e94802b163110e4699551CEF5C32)] = 1600; tokens[address(0x2F71C6BcFb2472732D845b7e7A8217E1f7E904ac)] = 4700; tokens[address(0xF9F35534402F7277241dcC44BF36C13f1ca2f9e1)] = 1600; tokens[address(0x2C393BC3550091D5e51941Ad822ebE15146e6bea)] = 29500; tokens[address(0x71247234373524D6d0408ed58c4f26b8391222E1)] = 1700; tokens[address(0x4608c18E751c5E9D4352f8b4A4B933531B8D9509)] = 1200; tokens[address(0x1C62dad9cd2AcA923d7fb99ad83cCe601db2Ae02)] = 2100; tokens[address(0xEE0407bd4F059aC2694E84aF4c6dcc862DAd0858)] = 3900; tokens[address(0x96d07EB199655D506911b00d6243f3d990832CFE)] = 6000; tokens[address(0x68CD10F06226CaefDc1996282AF8b11e15759008)] = 4300; tokens[address(0x23cDE37A52C9c316b2941644Cf25431AF83B2C5E)] = 11900; tokens[address(0x57Ffa87375932828D40016c8DaE9A081A12E9af0)] = 2200; tokens[address(0x520744A635E930D0d731fb6114dab88037091A1F)] = 5600; tokens[address(0x21950AAaBE932Af13E1b7dF2F7B838D9150289C4)] = 1600; tokens[address(0x17c566E12Ee786c264dc90e057058BDE4EDc71a0)] = 2100; tokens[address(0xF7A3da501EC53f5BF2E7BA7910330bC16f27d901)] = 11400; tokens[address(0xEACB88D78723Cb3544870f53cbBABD3355e2231D)] = 4600; tokens[address(0x14E28A9eF1618Ea4a86A06b42089526CA05b4e93)] = 3900; tokens[address(0x2249d77A6f81fFc04A6f86171cC0eB07ebfC4CED)] = 1600; tokens[address(0x344Af82a1Fb49AFB2e6d7E481Fb32cb2b739d22d)] = 1600; tokens[address(0x45584187b4a88bDE98dcb374F310436E6D63a8e9)] = 1000; tokens[address(0xD240B9ee1365081593C04da6CfC13191c8A0548c)] = 3200; tokens[address(0x34Ba228704864D4627B290edF32486d2DA367Fd1)] = 1600; tokens[address(0xa1435AcfC988489F5f32159901e07eCB5cdBfA45)] = 3400; tokens[address(0xf42671e88257101d41AD302515E710cF23A89907)] = 1900; tokens[address(0xc58C40D3C61cfCFE138eB7CF341533F55ABBF7fC)] = 1200; tokens[address(0xC0eC438f7F6B666a462cC929CEfb03bc4a8e689a)] = 23900; tokens[address(0x54FfC86Af4CfB17fd099C82bB4a5cE8Fa78AFC3d)] = 1400; tokens[address(0x77A13176a13cC9577c081c12b4CB707C118D38Bb)] = 1600; tokens[address(0x57a62c38307F7A1d8a5f2C607Ea02413c07B5EcC)] = 1400; tokens[address(0x963BEd69835425a5c17a73e6130AA8D8F7F7d727)] = 2400; tokens[address(0x74B96DCCA44f3cB6686B2c29EC96BDb537E54510)] = 1400; tokens[address(0xE66F9a2d957b56782f6A80C036f01394551e1778)] = 13500; tokens[address(0xF987941a8A9697DAb01492B15D62c97dCFFE2a2f)] = 1600; tokens[address(0xb9ABBDEe6D9A7Ffd147C3ea38939c63183b9aEd3)] = 13900; tokens[address(0xaA2DD7A80C4b5c8936F799F32a9F151bF7efA654)] = 1600; tokens[address(0xBE73ea87464aD5CDCA3d42fe2617fa86F94D9533)] = 2100; tokens[address(0x6168e8085bCE7267fBc9127b8497Fb40a5b48Dfe)] = 2100; tokens[address(0x780452089042c21f9Ad835976eF5FA6ed3c99fe5)] = 1600; tokens[address(0x3d5e74dEB0624Fe37eBfF8d8c90272Fb5F16f3C6)] = 1400; tokens[address(0xE493A720c6D4F897535F3cE325E7D0b079734260)] = 4300; tokens[address(0xaDa1F8A8a1f09CC4FB954B23Ca2ea6C3caaac95e)] = 8900; tokens[address(0xF1843910b07Aa565e6Dcb95154F14B5e67e621C9)] = 1000; tokens[address(0xA64922AF57b675eF3786BF9AE2B0a5600ddA673E)] = 1200; tokens[address(0xECe17b1FB30F17f43D225e99892173d379A1518a)] = 1900; tokens[address(0x97321F362f9D664ccfa78c761e7d0Ac4C9d0304c)] = 4200; tokens[address(0x994Cf20f5084427d078dBE368eE9C5B6b9eC0755)] = 8400; tokens[address(0x9971d04F33Bc2AD2FAb5f23A87D086DE018b2a3B)] = 1300; tokens[address(0x6D343fBA3b1abC5f729bC14F5C83F0CAC5502342)] = 1200; tokens[address(0x7f4FFCa375aD8c913734D1429Ca2EA904f80fc71)] = 1500; tokens[address(0xab260c2BC5Bdbbf4100358D4Fea347847b9D61b4)] = 3500; tokens[address(0x08F7895752716401999c23EBc18357Ac6dEFf6ed)] = 10400; tokens[address(0x87CebfED9b92f41C68dd5f974AD2AdFa7a47813D)] = 900; tokens[address(0x5d4A9af9DDeb4bc288c180FC7996075Db455d99b)] = 1600; tokens[address(0x9339C376b2f6a816f5a3ED0027b3948c5d316386)] = 1600; tokens[address(0x5379EDa35100e4944149C5852Adc08b360ab37d3)] = 1700; tokens[address(0xe2ce954168541195d258a4Cb0637d8fEe7Be60b1)] = 32700; tokens[address(0x2bA07Ab5648351d846D7b108e11be1f6Ec404099)] = 1600; tokens[address(0xb28a184084971eC50366B47305afa103b9753f4b)] = 14200; tokens[address(0xEF70cC46a9Abc185b3cED2bf99007Bb4f0cE91Ad)] = 1600; tokens[address(0xB1846cE26e2A038AFE1B69eF7b100cfb7859d47C)] = 1200; tokens[address(0x797981A22f3D8521EFA3fE505Cb69E47A36E9BAE)] = 2500; tokens[address(0xfcFC8B51DBd5CB48b4a62ec247E5b219D78AD21D)] = 1700; tokens[address(0xf8ab947c5CE3F3F5994e8e8e5aa7D701ED050f2d)] = 2000; tokens[address(0x5F2EC1B8069BD871B60aD08fB717A69FcF3024b8)] = 3600; tokens[address(0x120E2a1c39d418698D8E12A26F0Dd01304bdd1Ae)] = 1600; tokens[address(0x7563A44dD5d4C22E602BE9851b36aF55a7547d16)] = 2500; tokens[address(0x8A3a772BC27FCb580064D546eD01e61f7e2c4B7e)] = 1400; tokens[address(0x903a2Aa7b6Fdd77B9595184DA8CF59dd11c68aCF)] = 1600; tokens[address(0xc809746d20Ff840a7469fF343C7b6eFafEbE552A)] = 1400; tokens[address(0x53299f326DFced4f9f99c5e5b77BE66D42B1c4Cd)] = 1100; tokens[address(0xb04809441F04b845f3f1c3AB477D769545C50F4f)] = 2200; tokens[address(0xd6aF3630a306388456C7759deF88Ab3c5e1a64aF)] = 2100; tokens[address(0xe5FB492Bc55B5114D6C9D89A93310d2919ce6228)] = 1700; tokens[address(0x715f8D35F9f6a3E0ac56D334343411C1Fa1440a4)] = 2100; tokens[address(0x14d047E9452434c10aA5d619aB1371Cf2457B0e0)] = 1200; tokens[address(0xB6dbd3F6835dd1adfF1dB32f4c46729Eb34Bb548)] = 1900; tokens[address(0x4BDFD5982eE61a9fDAB565FA13ea22Fe72f16eAb)] = 1900; tokens[address(0xD2C9e34a07fDC074B572d6B2CC5c0A264Ea9f1F0)] = 2600; tokens[address(0xB780118A103ED52cA74F02958313F2BaA019d4f9)] = 3300; tokens[address(0x175BCdE6CaC5060B534A3869b6A78A0C13957504)] = 1200; tokens[address(0xdeB46B9160fAEcC3ba685087d6b56CAD60f7b8cE)] = 1600; tokens[address(0x5Bc673937833106b00FCd5df7741ef39d2a49121)] = 1500; tokens[address(0xFaFf103FbD7e44C75bcE019b827a31c53CAD94fc)] = 1200; tokens[address(0x0c745112a5707381d9aF0D8BD9A490e5EcDA60B2)] = 52000; tokens[address(0x05805a663aE51C9759CAde16c59fa783c1852239)] = 1700; tokens[address(0xFff611555912490477349d2B3f4282643888656C)] = 1600; tokens[address(0xeCef3237858FEd095B2F2488DEeF388fab420beE)] = 600; tokens[address(0xcaCa7caF489541791434fCC9cba230C0B7e11CAD)] = 1600; tokens[address(0x147013fb53eadE5F51121fabC7333dB5058a9fD6)] = 1600; tokens[address(0xDD25550d692800B4b17Ce38221bE63E1507296b4)] = 1600; tokens[address(0x289D3c421688D1534d8e80Fd0E3C3514c00dEa65)] = 2100; tokens[address(0xD8d0f2195739fFE38c45f679b65C20DA81719658)] = 2100; tokens[address(0x1a3fb44AEd947487837C08f2602682838768bc16)] = 1200; tokens[address(0xa0f93EF12870A029917AE93884AcC6d935a2a4A0)] = 1600; tokens[address(0x8758197ab1B659d35dDFFe2DA0eD35963Fce8d4a)] = 600; tokens[address(0xcE142871CcE8422b7B2df046b7169E6F82C5A829)] = 53400; tokens[address(0x916383707F0bFbAA8d68146E50829A797D34f10e)] = 1200; tokens[address(0x7A4418cD2D619461F53d72F65c70a29A6a5D6a9b)] = 2100; tokens[address(0x32C235751A2C9C7f472d6eC6068E1608b6a35aD9)] = 600; tokens[address(0x9B205a6458D73591e934a41f21f81B83ddd010CE)] = 1400; tokens[address(0xF59217418f02c5BBEe52734e6B1FE46879d1e8AA)] = 2500; tokens[address(0xC40A0b2418D35B36E241F2555e813ACB6b172DFc)] = 4600; tokens[address(0x120542afEa6F3E649Ec4782444011b9164A97502)] = 4700; tokens[address(0x40a2a8B21c6f6A13476EA14501e5EA66780D3720)] = 3700; tokens[address(0xbaD57334Bd686BA055DaD9063Cf4f6D40414ea2e)] = 2100; tokens[address(0x1259253e0A90A454942F1924Ea16ca449f3bf714)] = 1600; tokens[address(0xedB4dcE561956cA9F588a2668ffc1F24574Bbb31)] = 1600; tokens[address(0xc3b7A1474e6146c0F27B8f8F73d682E1131Cef55)] = 1400; tokens[address(0x2d4298debB0f9EAd6350667850B6bb76FcCafE26)] = 1200; tokens[address(0x34353f65d4E625d356190764397D89188bD69B09)] = 1500; tokens[address(0x020984eC66d672E64cb366285a7ADD76A65D8Eba)] = 24100; tokens[address(0x1d35417Ac16fAcEc1766b951Bb832758Caef6F3c)] = 4200; tokens[address(0x28Fa0e3521CCb4474479d4EfeA43895912ed21e7)] = 1600; tokens[address(0xb0c7E1470E9Af9801c3b49fff94a2390976AbE9f)] = 2300; tokens[address(0xA205CCD6F91eA72DcCFBAbeC5b285FB6822118b1)] = 1600; tokens[address(0x278781A2FFB74c9dc29224bC4B70523b77545c63)] = 600; tokens[address(0x19605FC09ffB842E0756d6bfA3521Df481e422fb)] = 2100; tokens[address(0xFfe55FdACE48C6e7a2939E2EDE0D8A853814ACac)] = 900; tokens[address(0x4ADFFc3c5A3e47104E09E7F00C98727459040446)] = 2100; tokens[address(0xae31168bE5f76463fFb5a72512674e809C5a9822)] = 2100; tokens[address(0x9b65dAd0cdEba4A82bbCCdf72A1D7bf7E4C55F6B)] = 4200; tokens[address(0x5D75eA765186b5cE8Fe4aC440e68d37Ff19944B6)] = 700; tokens[address(0xCd06583715F23340d2b58781B820F005c8A57486)] = 9600; tokens[address(0xE7C81522a0A20a01a45383F3B7e2df884E777D39)] = 1400; tokens[address(0x42af94da5Eb7E3416E7dF3F3FbB6e44351ecfe57)] = 13700; tokens[address(0xdA2C38D482B363D70E995C77FBDE11C032c97BCe)] = 2000; tokens[address(0x14e291DE4D5210c7d9158684471586507905d5B2)] = 2500; tokens[address(0x05105c9FaC9B17f832CC77886a7dC7BE908A354c)] = 1600; tokens[address(0xF907556fE8B43D255Cc68aDaFb746b361C7A8DD5)] = 4600; tokens[address(0xE1C926C2C3634d245F5Bcad11fF08D0902bFE579)] = 1200; tokens[address(0xb34770c1903e2aA6b0FFC320cD7c26c97c9afddc)] = 1500; tokens[address(0xbaF2F9426521C8b4e955DC9e8f888095DD1322B5)] = 4800; tokens[address(0xd9322dE0Ef3f3651cE8ccd509b3a58aB04D3e6F3)] = 1700; tokens[address(0x8CEd8d3eF7d4E0116456cc6c9CE3d2F82b2C81f6)] = 600; tokens[address(0xDf76810EeF6A90F85128a38b74efFB7A2C0b1956)] = 4100; tokens[address(0xA619e5Eb2fAAc9d6EBcaC4fE5387C7dc419Ebe8C)] = 5900; tokens[address(0x7a1aac634a73547320afD03E09571b9c0842A002)] = 11600; tokens[address(0xdA5c5dB1B98676512e44b410dBaE10569a243c80)] = 1700; tokens[address(0x77DCBbA8dfF597b9F21bc443138F925831536Fcd)] = 4100; tokens[address(0x1aE6E1b318584b15679B84340EFad09D9ACdA954)] = 2200; tokens[address(0x93445A1205aB423Ce1d72f7E7c08fD720cf3413C)] = 8400; tokens[address(0xc518e4B67D9360321c2B6a023E57E4A85a0463A6)] = 2600; tokens[address(0x761c95Be69A29b487B2388896FCebb231263f1Ba)] = 1800; tokens[address(0xf572b9aDCe5de63a45aCBc5B317828d5CF4066e6)] = 8500; tokens[address(0x9492D8894C12142cCA8f6752c284c71036B6aCE0)] = 1400; tokens[address(0x2f828e0c48cBee0C36fb743344c6b8d579C6a6e2)] = 2600; tokens[address(0xd2716630d67dce0489aD7A254db4079c7F70fc80)] = 2500; tokens[address(0xb8025B514480a68e5B60741F9B2a3B4302d4cDf5)] = 4100; tokens[address(0x25112a6363D8a75f7325Dcba279b791936d52592)] = 3400; tokens[address(0x5878e7697d45d4AFc10CceDD7a7A89334215AE83)] = 1200; tokens[address(0x26d91d8028130dB3eFAD83Cdb9eCE392F19177ac)] = 3200; tokens[address(0xd1f543544c720417D69c0C8C46f468c357Dc10aB)] = 1400; tokens[address(0x2eEFfb0905b631A3b30b39C4E0B846803ff4AC80)] = 3900; tokens[address(0x6EedF082d9EEB45b7C0fcb640041824C2Dc88cbE)] = 1600; tokens[address(0x25740C74401eAb76b939DcD41d7BC22757bF0862)] = 1900; tokens[address(0xB02848986D468429EAfc9e66bB2c302ebd1CB216)] = 4600; tokens[address(0xd4E49644CA87faCf616a2a3a3784bf35a51aEE0E)] = 4100; tokens[address(0x36e7b69af795A9b563c5987D848c934833375F96)] = 1200; tokens[address(0x25B8165D74192B97a078722f0FA46cf4c8387bBF)] = 3700; tokens[address(0xe247205aC4E448fF05c6f0d536C7309Baf9A1Fc5)] = 2100; },1
0x194524355f26af663468d4996f207a918c73e013.sol,DVCToken,contract DVCToken is StandardBurnableToken{ string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public INITIAL_SUPPLY = 1000000000000000000; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x72268385b3620157f0b051e876c801841a716b8e.sol,KT,contract KTaccess is ownable{ address public o1Address; address public o2Address; address public o3Address; modifier onlyOLevel() { require( msg.sender == o1Address || msg.sender == o2Address || msg.sender == o3Address || msg.sender == owner ); _; },1
0x65844f2e98495b6c8780f689c5d13bb7f4975d65.sol,Factory,"contract Factory is Owned{ mapping(uint8 => mapping(uint8 => address)) public MaterialTokens; address mix_address; address boxFactory_address; function control(uint8 boxIndex, uint8 materialIndex, address _addr, uint _value) public{ require(checkBox()); Test test = Test(MaterialTokens[boxIndex][materialIndex]); test.mint(_addr, _value); }",1
0x5ad9e100bc58e57a20cf1cae204f046006d27a27.sol,CoinCrowdICO,contract CoinCrowdICO is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; uint256 public decimals = 18; uint256 public tokenValue; uint256 public constant centToken = 20; function euroRaised(uint256 _weiTokens) public view returns (uint256) { return _weiTokens.mul(centToken).div(100).div(10**decimals); },1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0x5bb1632fa0023e1aa76a1ae92b4635c8dba49fa2.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x02dc001b5e9191a51b338950d8cdea1cb4481bb3.sol,SponseeTokenModel,"contract SponseeTokenModel is StandardToken { string public name; string public symbol; uint8 public decimals = 0; uint public totalSupply = 0; uint public cap = 100000000; uint public minimumSupport = 500; uint public etherRatioForInvestor = 10; address public sponseeAddress; bool public isPayableEnabled = true; RBInformationStore public rbInformationStore; Rate public rate; event LogReceivedEther(address indexed from, address indexed to, uint etherValue, string tokenName); event LogBuy(address indexed from, address indexed to, uint indexed value, uint paymentId); event LogRollbackTransfer(address indexed from, address indexed to, uint value); event LogExchange(address indexed from, address indexed token, uint value); event LogIncreaseCap(uint value); event LogDecreaseCap(uint value); event LogSetRBInformationStoreAddress(address indexed to); event LogSetName(string name); event LogSetSymbol(string symbol); event LogMint(address indexed to, uint value); event LogChangeSponseeAddress(address indexed to); event LogChangeIsPayableEnabled(bool flag); modifier onlyAccountAddressForSponsee() { require(rbInformationStore.accountAddressForSponsee() == msg.sender); _; }",1
0x7012a5ada4cee1d0bfb9f93d0f4ced094d6e8577.sol,SpringNFT,"contract SpringNFT is NFToken{ event RecipientUpdate(bytes32 indexed recipientId, bytes32 updateId); modifier recipientExists(bytes32 id) { require(recipients[id].exists, ); _; }",1
0x2fca5f257895b8bcede0c0d06141b718ec9a3041.sol,TrexDexMain,"contract TrexDexMain { using SafeMath for uint256; address public owner; address public feeAddress; mapping (address => mapping (address => uint256)) public makeFees; mapping (address => mapping (address => uint256)) public takeFees; mapping (address => uint256) public depositFees; mapping (address => uint256) public withdrawFees; mapping (address => bool) public strictTokens; mapping (address => bool) public tokenDeposits; mapping (address => bool) public tokenWithdraws; mapping (address => mapping (address => bool)) public tokenTrades; mapping (address => mapping (address => uint256)) public deposits; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint256)) public orderFills; event Order(address buyTokenAddress, uint256 buyAmount, address sellTokenAddress, uint256 sellAmount, address takeAddress, address baseTokenAddress, uint256 expireBlock, uint256 nonce, address makeAddress); event Cancel(bytes32 orderHash); event Trade(bytes32 orderHash, uint256 buyAmount, uint256 sellAmount, uint256 takeFee, uint256 makeFee, address takeAddress); event Deposit(address tokenAddress, address userAddress, uint256 amount, uint256 fee, uint256 balance); event Withdraw(address tokenAddress, address userAddress, uint256 amount, uint256 fee, uint256 balance); event TransferIn(address tokenAddress, address userAddress, uint256 amount, uint256 balance); event TransferOut(address tokenAddress, address userAddress, uint256 amount, uint256 balance); modifier isOwner { assert(msg.sender == owner); _; }",1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x4d6e0922e6b703f0fdf92745343a9b83eb656402.sol,RaidenMicroTransferChannels,contract RaidenMicroTransferChannels { uint32 public challenge_period; string public constant version = ; uint256 public constant channel_deposit_bugbounty_limit = 10 ** 18 * 100; Token public token; mapping (bytes32 => Channel) public channels; mapping (bytes32 => ClosingRequest) public closing_requests; struct Channel { uint192 deposit; uint32 open_block_number; },1
0x541ac3dbde0712b1a121bdd5e8c506ae594a4631.sol,XPTToken,contract XPTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XPTToken () { owner = msg.sender; },1
0x55c87c2e26f66fd3642645c3f25c9e81a75ec0f4.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; },1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x4c9b31eeca8da5a63237097176691bef68e8b8c5.sol,PunkLombard,contract PunkLombard { address public CryptoPunksContract; uint256 public loanAmount; uint256 public punkIndex; uint256 public annualInterestRate; uint256 public loanTenor; uint256 public loanPeriod; address public lender; address public borrower; uint256 public loanStart; uint256 public loanEnd; uint256 public interest; address public contractOwner; modifier onlyOwner { if (msg.sender != contractOwner) revert(); _; },1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x586bf07847618b7c28ee5aca68b1c455c7c5172d.sol,Ownable,"contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; }",1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TFcoin,"contract TFcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TFcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4cb697dab84df0192b6693a2efad75b1c9a3fdc9.sol,SpermLab,contract SpermLab{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function SpermLab() public{ ceoAddress=msg.sender; },1
0xd532375971258953263218994966e2a0a3d5c18a.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721 { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0xa35e4a5c0c228a342c197e3440dff1a584cc479c.sol,SGNL,"contract SGNL is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping(address=>bool) public frozenAccount; event FrozenFunds(address target, bool frozen); uint256 public constant initialSupply = 60000000 * 10**16; uint8 public constant decimalUnits = 16; string public tokenName = ; string public tokenSymbol = ; function SGNL() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xf244176246168f24e3187f7288edbca29267739b.sol,SafeDecimalMath,"contract SafeDecimalMath { uint8 public constant decimals = 18; uint public constant UNIT = 10 ** uint(decimals); function addIsSafe(uint x, uint y) pure internal returns (bool) { return x + y >= y; }",1
0x4ef76ae870979cc9a4c5c0a54a2099c67dcfa15c.sol,Platform,contract Platform is Ownable{ using SafeMath for uint256; struct accountInfo { address addr; uint256 amount; },1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,SRNMagicBox,"contract SRNMagicBox is ServerControl, TokenReceiver { GirlOps girlOps; GenesFactory genesFactory; SRNG SRNGInstance; string public name; uint public keyRequired; address public keyAddress; address public prizePoolAddress; uint public boxPrice; uint[] public prizeIndex; uint[] public prizeRange; uint[] public NCards; uint[] public RCards; uint[] public SRCards; uint[] public SSRCards; event SendGirlFail(address _to, uint _type); constructor(string _name, address _girlAddress, address _SRNGAddress, address _genesFactoryAddress, address _prizePoolAddress, address _keyAddress, uint _keyRequired, uint _boxPrice) public { name = _name; girlOps = GirlOps(_girlAddress); SRNGInstance = SRNG(_SRNGAddress); genesFactory = GenesFactory(_genesFactoryAddress); prizePoolAddress = _prizePoolAddress; keyAddress = _keyAddress; keyRequired = _keyRequired; boxPrice = _boxPrice; }",1
0x1da015ea4ad2d3e5586e54b9fb0682ca3ca8a17a.sol,DragonToken,contract DragonToken is DragonReleaseableToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function DragonToken( address operator ) DragonReleaseableToken(operator) {},1
0xe07c44a35650e445289cd9fdaaf7fb6a9d734471.sol,AElfToken,"contract AElfToken is ERC20, Ownable { using SafeMath for uint256; address public aelfDevMultisig = 0x64ABa00510FEc9a0FE4B236648879f35030B7D9b; address public aelfCommunityMultisig = 0x13828Fa672c52226071F27ea1869463bDEf2ecCB; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0x1de89382684ce5a99fc9d3d4b709706d6a013571.sol,SolutionGame,contract SolutionGame is HWCIntegration { uint256 countWinnerPlace; mapping (uint256 => uint256) internal prizeDistribution; mapping (uint256 => uint256) internal prizesByPlace; mapping (uint256 => uint256) internal scoreByPlace; mapping (uint => uint) winnerMap; uint[] winnerList; mapping (uint256 => uint256) internal prizesByPlaceHWC; bool isWinnerTime = false; modifier whenWinnerTime() { require(isWinnerTime); _; },1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,BaseCrowdsale,"contract BaseCrowdsale { using SafeMath for uint256; using SafeERC20 for CosquareToken; CosquareToken public token; uint256 public tokensSold; event TokensPurchaseLog(string purchaseType, address indexed beneficiary, uint256 value, uint256 tokens, uint256 bonuses); constructor(CosquareToken _token) public { require(_token != address(0), ); token = _token; }",1
0xbdfbe3918c6c3e719abf3affedb8dfd67f3cf634.sol,BTYCToken,"contract BTYCToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sellPrice; uint public buyPrice; uint public sysPrice; uint8 public sysPer; uint public givecandyto; uint public givecandyfrom; uint public candyper; uint public onceOuttime; uint public onceAddTime; mapping(address => uint) balances; mapping(address => uint) used; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => uint[]) public mycantime; mapping(address => uint[]) public mycanmoney; mapping(address => address) public fromaddr; mapping(address => uint) public cronaddOf; event FrozenFunds(address target, bool frozen); constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 86400000 ether; sellPrice = 510 szabo; buyPrice = 526 szabo; sysPrice = 766 ether; sysPer = 225; candyper = 1 ether; givecandyfrom = 10 ether; givecandyto = 40 ether; onceOuttime = 10 seconds; onceAddTime = 20 seconds; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x33714a8203aafcdba86682406dd599e94f9c2e6e.sol,LockAccount,"contract LockAccount is Ownable{ mapping (address => bool) public lockAccounts; event LockFunds(address target, bool lock); constructor() public{ }",1
0x51c5ca1bad35e5435ee65aa0170af5b6b662a416.sol,Voting,"contract Voting{ address owner; mapping (uint256=>uint256) totalVoting; event ChangeOwner(address owner); event Voting(uint256 videoNum, uint256 totalVoting); constructor() public{ owner = msg.sender; }",1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyExchange,"contract HorseyExchange is Pausable, ERC721Holder { event HorseyDeposit(uint256 tokenId, uint256 price); event SaleCanceled(uint256 tokenId); event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay); uint256 public marketMakerFee = 3; uint256 collectedFees = 0; ERC721Basic public token; struct SaleData { uint256 price; address owner; }",1
0xc001111832a4b5c61bae8080f2000335285efc69.sol,ERC20,"contract ERC20 is Owned { using SafeMath for uint; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function transfer(address _to, uint _value) isStartedOnly public returns (bool success) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xedd4941d09bb0fafd230100c86ffbbd7907b6fed.sol,ArcanaToken,"contract ArcanaToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 7000000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 100000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x532975d56cf18f597480e2521246b273ad9ae348.sol,LiabilityFactory,"contract LiabilityFactory { constructor( address _robot_liability_lib, address _lighthouse_lib, XRT _xrt ) public { robotLiabilityLib = _robot_liability_lib; lighthouseLib = _lighthouse_lib; xrt = _xrt; }",1
0x2671500a8a6d099ae8743ad3ff848a6636fe9a75.sol,ZEON,"contract ZEON is StandardToken { constructor() public DetailedERC20(, , 18) { totalSupply_ = 50000000000000000000000000000; balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,DSMath,"contract DSMath { function hmore(uint128 x, uint128 y) constant internal returns (bool) { return x>y; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x6b18b3808fd9c4401af4839b6aa2971aae7a8aad.sol,ODEEPToken,"contract ODEEPToken is StandardToken , BurnableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public Bounties_Wallet = 0x70F48becd584115E8FF298eA72D5EFE199526655; address public Team_Wallet = 0xd3186A1e1ECe80F2E1811904bfBF876e6ea27A41; address public OEM_Wallet = 0x4fD0e4E8EFDf55D2C1B41d504A2977a9f8453714; address public LA_wallet = 0xA0AaFDbDD5bE0d5f1A5f980331DEf9b5e106e587; address public tokenWallet = 0x81cb9078e3c19842B201e2cCFC4B0f111d693D47; uint256 public constant INITIAL_SUPPLY = 100000000 ether; uint256 tokenRate = 560; function ODEEPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[Bounties_Wallet] = INITIAL_SUPPLY.mul(5).div(100) ; balances[Team_Wallet] = INITIAL_SUPPLY.mul(8).div(100); balances[OEM_Wallet] = INITIAL_SUPPLY.mul(10).div(100) ; balances[LA_wallet] = INITIAL_SUPPLY.mul(8).div(100) ; balances[tokenWallet] = INITIAL_SUPPLY.mul(69).div(100); endDate = _endDate; emit Transfer(0x0, Bounties_Wallet, balances[Bounties_Wallet]); emit Transfer(0x0, Team_Wallet, balances[Team_Wallet]); emit Transfer(0x0, OEM_Wallet, balances[OEM_Wallet]); emit Transfer(0x0, LA_wallet, balances[LA_wallet]); emit Transfer(0x0, tokenWallet, balances[tokenWallet]); }",1
0x1a2e39e6e166cfb3f249f727dd5098a1055f457d.sol,RBAC,"contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address addr, string roleName); event RoleRemoved(address addr, string roleName); string public constant ROLE_ADMIN = ; function RBAC() public { addRole(msg.sender, ROLE_ADMIN); }",1
0x016396044709eb3edc69c44f4d5fa6996917e4e8.sol,KingXChainToken,"contract KingXChainToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 25000000000e18; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e18; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6f05bf7c8d50079ac864f48480a4e579189de0c6.sol,QIU3D,"contract QIU3Devents { event onNewTicket( address indexed player, uint256 indexed matchId, uint256 indexed ticketId, uint256 fullMatResOpt, uint256 goalsOpt, uint256 gapGoalsOpt, uint256 bothGoalOpt, uint256 halfAndFullMatResOpt, uint256 ticketValue, uint256 cost ); event onNewBet( address indexed player, uint256 indexed matchId, uint256 indexed betId, uint256 option, uint256 odds, uint256 cost ); event onEndMatch( uint256 indexed matchId, uint256 compressData ); event onInvite( address indexed player, address indexed inviter, uint256 profit ); event onWithdraw( address indexed player, uint256 withdraw, uint256 withdrawType ); }",1
0xedd7868662f1ae17c53ddaea63469b4c1292ea7c.sol,NescrowExchangeService,"contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateMin = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => bool) public traded; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event TradesLock(address user); event TradesUnlock(address user); modifier onlyOwner { assert(msg.sender == owner); _; }",1
0x54e529f3673eb585c1690880186eac3c4dd30b09.sol,SafeMath,contract SafeMath { function SafeMath() { },1
0x35c2307cd831741187d4ef71ce9fbe91fa822df5.sol,BOX33Token,"contract BOX33Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 2680; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5b2988f2d77c38b46a753ea09a4f6bf726e07e34.sol,LILE,"contract LILE1Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0x1f9e3a06574cb24a0c447b07a0a2c84988a16a10.sol,ldoh,"contract ldoh is EthereumSmartContract { event onAffiliateBonus( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onClaimTokens( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onHodlTokens( address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime ); event onAddContractAddress( address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime ); event onCashbackCode( address indexed hodler, address cashbackcode ); event onUnlockedTokens( uint256 returned ); event onReturnAll( uint256 returned ); address internal DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; }",1
0x6d39766fc715217ba313e338a4c023065d963889.sol,BeringiaContract,"contract BeringiaContract is TokenERC20Standart{ using SafeMath for uint256; string public name; uint256 public decimals; string public symbol; string public version; uint256 public _totalSupply = 0; uint256 public constant RATE = 2900; uint256 public fundingEndTime = 1538179200000; uint256 public minContribution = 350000000000000; uint256 public oneTokenInWei = 1000000000000000000; uint256 public tokenCreationCap; uint256 private firstPeriodEND = 1532217600000; uint256 private secondPeriodEND = 1534896000000; uint256 private thirdPeriodEND = 1537574400000; uint256 private firstPeriodDis = 25; uint256 private secondPeriodDis = 20; uint256 private thirdPeriodDis = 15; uint256 private foundersTokens; uint256 private depositorsTokens; constructor () public { name = ; decimals = 0; symbol = ; owner = 0xdc889afED1ab326966c51E58abBEdC98b4d0DF64; version = ; tokenCreationCap = 510000000 * 10 ** uint256(decimals); balances[owner] = tokenCreationCap; emit Transfer(address(0x0), owner, tokenCreationCap); foundersTokens = tokenCreationCap / 10; depositorsTokens = tokenCreationCap.sub(foundersTokens); }",1
0x1b5242794288b45831ce069c9934a29b89af0197.sol,AccessMint,"contract AccessMint is Claimable { mapping(address => bool) private mintAccess; event Mint( address indexed _to, uint256 indexed _tokenId ); modifier onlyAccessMint { require(msg.sender == owner || mintAccess[msg.sender] == true); _; }",1
0x1cb82f4228719a53a6f5fc98de74f12eebdc31ed.sol,Fusionchain,"contract FusionchainSafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); }",1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0xd111bcb8c30a600c12f4af8314235f628ea2cb3c.sol,AMLToken,"contract AMLToken is BurnableCrowdsaleToken { event OwnerReclaim(address fromWhom, uint amount); constructor(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) public BurnableCrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) { }",1
0x512aa94d28f30ac915f32d24bcb32fc385edc976.sol,Alfa_quiz,contract Alfa_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5acbe8b82bec243f420214b35ed5b6cad2055f07.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x38c80b0a8a4e9d6fe925d47ae82251eb0c79cfa8.sol,ExoTokensSwap,contract ExoTokensSwap{ ERC20token TokenFrom; ERC20token TokenTo; uint256 FromDecimals; uint256 ToDecimals; address owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0xd532375971258953263218994966e2a0a3d5c18a.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721 { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0xa1f30d32e650cabc0be20b921a014c30052145e0.sol,Chewbaka,contract Chewbaka { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xdccc53ca8263e79548aff6aa81ccf1c42e2c1a89.sol,Storage,contract Storage { using SafeMath for uint; address public addrCommission = msg.sender; uint public constant minimalDeposit = 0.0001 ether; uint public constant minimalPayout = 0.000001 ether; uint public constant profit = 4; uint public constant projectCommission = 5; uint public constant cashbackInvestor = 13; uint public constant cashbackPartner = 12; uint public countInvestors = 0; uint public totalInvest = 0; uint public totalPaid = 0; mapping (address => uint256) internal balances; mapping (address => uint256) internal withdrawn; mapping (address => uint256) internal timestamps; mapping (address => uint256) internal referrals; mapping (address => uint256) internal referralsProfit; function getUserInvestBalance(address addr) public view returns(uint) { return balances[addr]; },1
0x5add573f09099147dbf37db34f0c0ab3d8105188.sol,InGRedientToken,"contract InGRedientToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function InGRedientToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x4720f2468eeb7a795945c5ffbc3b0178e32250e0.sol,PetBase,"contract PetBase is PopulationControl{ event Birth(address owner, uint64 petId, uint16 quality, uint256 genes); event Death(uint64 petId); event Transfer(address from, address to, uint256 tokenId); struct Pet { uint256 genes; uint64 birthTime; uint16 quality; }",1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Ledger = 0x30; byte constant proofType_Android = 0x40; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x33ec7788795360fa3d2461606e9fe2fb95b942e9.sol,StandardToken,"contract StandardToken is Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 supply; uint256 public initialSupply; uint256 public totalSupply; address public marketingReserve; address public bountyReserve; address public teamReserve; uint256 marketingToken; uint256 bountyToken; uint256 teamToken; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() public { name = ; symbol = ; decimals = 18; supply = 300000000; initialSupply = supply * (10 ** uint256(decimals)); totalSupply = initialSupply; balances[owner] = totalSupply; bountyTransfers(); }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0x3a590f86d78fa85bbd287f44d0d20ddd10c78a1e.sol,HealthTokenCrowdsale,"contract HealthTokenCrowdsale is AllowanceCrowdsale, HasNoTokens { constructor ( uint256 _rate, address _wallet, StandardToken _token, address _tokenWallet ) public Crowdsale(_rate, _wallet, _token) AllowanceCrowdsale(_tokenWallet) { discount = 25; rate = _rate; volumeDiscounts.push(VolumeDiscount(10 ether, 5)); volumeDiscounts.push(VolumeDiscount(50 ether, 10)); volumeDiscounts.push(VolumeDiscount(100 ether, 15)); }",1
0x750120015bb290d0be129b10d786793883a1378d.sol,Ignite,"contract Ignite is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed = 400000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 100000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6b7470bfa67566df5275365933f5984530f54a7a.sol,EtheeraCrowdsale,"contract EtheeraCrowdsale { using SafeMath for uint256; EtheeraToken public token; uint public startTime; uint public endTime; address public wallet; uint256 public ratePerWei = 500000; uint256 public weiRaised; bool public isSoftCapReached = false; bool public isHardCapReached = false; bool public refundToBuyers = false; uint256 public softCap = 6000; uint256 public hardCap = 105000; uint256 public tokens_sold = 0; uint maxTokensForSale = 52500000000; uint256 public tokensForReservedFund = 0; uint256 public tokensForAdvisors = 0; uint256 public tokensForFoundersAndTeam = 0; uint256 public tokensForMarketing = 0; uint256 public tokensForTournament = 0; bool ethersSentForRefund = false; mapping(address=>uint256) usersThatBoughtETA; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event ICOStarted(uint256 startTime, uint256 endTime); function EtheeraCrowdsale(uint256 _startTime, address _wallet) public { startTime = _startTime; endTime = startTime.add(79 days); require(endTime >= startTime); require(_wallet != 0x0); wallet = _wallet; token = createTokenContract(wallet); ICOStarted(startTime,endTime); }",1
0x0d851a1a608f9f6c48f4fac4b4b8d53ac82176fa.sol,YoloCoin,"contract YoloCoin is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x1be7c913f9c0b04d9b85d760861a4f9381d0ef98.sol,BCBToken,"contract BCBToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 370000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x6c2cbad7827510859998a3233609cfdf831e7dfb.sol,Contributor,"contract Contributor { bool isInitiated = false; address creatorAddress; address contributorAddress; address marketplaceAddress; string name; uint creationTime; bool isRepudiated = false; enum ExtensionType {MODULE, THEME}",1
0xf01af4cf777d8b596bd94a35ccfdf9356eb2a083.sol,AdPotato,"contract AdPotato{ address ceoAddress; ShrimpFarmer fundsTarget; Advertisement[] ads; uint256 NUM_ADS=10; uint256 BASE_PRICE=0.005 ether; uint256 PERCENT_TAXED=30; event BoughtAd(address sender, uint256 amount); modifier onlyCLevel() { require( msg.sender == ceoAddress ); _; }",1
0x72df2df74f60c8141058c05346d13847a62940fe.sol,FlexibleToken,"contract FlexibleToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; bool public locked = false; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Locked(); event SymbolUpdated(string oldSymbol, string newSymbol); event NameUpdated(string oldName, string newName); function FlexibleToken(string _symbol, string _name, uint8 _decimals, uint _initialSupply) public { symbol = _symbol; name = _name; decimals = _decimals; _totalSupply = _initialSupply; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x8825026b162401cc50f2a614a1c2354aa59e8496.sol,Ownable,"contract Ownable { address public owner; address public pendingOwner; address public manager; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xb3febafd02c9e1f9116bab80ffbc17df1650b50a.sol,TokenSales,"contract TokenSales { using SafeMath for uint256; event TokenPurchase( address indexed token, address indexed seller, address indexed purchaser, uint256 value, uint256 amount ); mapping(address => mapping(address => uint)) public saleAmounts; mapping(address => mapping(address => uint)) public saleRates; function createSale(iERC20 token, uint256 rate, uint256 addedTokens) public { uint currentSaleAmount = saleAmounts[msg.sender][token]; if(addedTokens > 0 || currentSaleAmount > 0) { saleRates[msg.sender][token] = rate; }",1
0x0d62b001ca7f2fb4f9458f8585a0bb38a4d8fde7.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for RESTOToken; uint256 hardCap = 50000 * 1 ether; address myAddress = this; RESTOToken public token = new RESTOToken(myAddress); uint64 crowdSaleStartTime = 1537401600; uint64 crowdSaleEndTime = 1544745600; TeamAddress1 public teamAddress1 = new TeamAddress1(); TeamAddress2 public teamAddress2 = new TeamAddress2(); MarketingAddress public marketingAddress = new MarketingAddress(); RetailersAddress public retailersAddress = new RetailersAddress(); ReserveAddress public reserveAddress = new ReserveAddress(); BountyAddress public bountyAddress = new BountyAddress(); uint256 public rate; uint256 public weiRaised; event Withdraw( address indexed from, address indexed to, uint256 amount ); event TokensPurchased( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor() public { uint256 totalTokens = token.INITIAL_SUPPLY(); _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000)); _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000)); _deliverTokens(marketingAddress, totalTokens.mul(18).div(100)); _deliverTokens(retailersAddress, totalTokens.mul(9).div(100)); _deliverTokens(reserveAddress, totalTokens.mul(8).div(100)); _deliverTokens(bountyAddress, totalTokens.div(100)); rate = 10000; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisToken,"contract ApisToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => LockedInfo) public lockedWalletInfo; mapping (address => bool) public manoContracts; struct LockedInfo { uint timeLockUpEnd; bool sendLock; bool receiveLock; }",1
0x39e6af40357dd640f16088662a5fe3d321162ed6.sol,BasicFundraiser,"contract BasicFundraiser is HasOwner, AbstractFundraiser { using SafeMath for uint256; uint8 constant DECIMALS = 18; uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS); uint256 public startTime; uint256 public endTime; address public beneficiary; uint256 public conversionRate; uint256 public totalRaised; event ConversionRateChanged(uint _conversionRate); function initializeBasicFundraiser( uint256 _startTime, uint256 _endTime, uint256 _conversionRate, address _beneficiary ) internal { require(_endTime >= _startTime); require(_conversionRate > 0); require(_beneficiary != address(0)); startTime = _startTime; endTime = _endTime; conversionRate = _conversionRate; beneficiary = _beneficiary; }",1
0x923108a439c4e8c2315c4f6521e5ce95b44e9b4c.sol,BTTSToken,"contract BTTSTokenInterface is ERC20Interface { uint public constant bttsVersion = 100; bytes public constant signingPrefix = ; bytes4 public constant signedTransferSig = ; bytes4 public constant signedApproveSig = ; bytes4 public constant signedTransferFromSig = ; bytes4 public constant signedApproveAndCallSig = ; event OwnershipTransferred(address indexed from, address indexed to); event MinterUpdated(address from, address to); event Mint(address indexed tokenOwner, uint tokens, bool lockAccount); event MintingDisabled(); event TransfersEnabled(); event AccountUnlocked(address indexed tokenOwner); function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success); function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash); function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash); function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result); function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success); function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success); function unlockAccount(address tokenOwner) public; function disableMinting() public; function enableTransfers() public; enum CheckResult { Success, NotTransferable, AccountLocked, SignerMismatch, AlreadyExecuted, InsufficientApprovedTokens, InsufficientApprovedTokensForFees, InsufficientTokens, InsufficientTokensForFees, OverflowError }",1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd9ff8cc0433c995f3a9711f1400329cd6a40387f.sol,EtherKnightGame,"contract EtherKnightGame { HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882); using SafeMath for uint256; using SafeMath128 for uint128; event OwnershipTransferred( address previousOwner, address nextOwner, uint256 timeStamp ); event HDXcontractChanged( address previous, address next, uint256 timeStamp ); event onWithdrawGains( address customerAddress, uint256 ethereumWithdrawn, uint256 timeStamp ); event onNewRound( uint256 gRND, uint32 turnRound, uint32 eventType, uint32 eventTarget, uint32[4] persoEnergy, uint32[4] persoDistance, uint32[4] powerUpSpeed, uint32[4] powerUpShield, uint256 blockNumberTimeout, uint256 treasureAmountFind, address customerAddress ); event onNewRace( uint256 gRND, uint8[4] persoType, uint256 blockNumber ); event onBuyShare( address customerAddress, uint256 gRND, uint32 perso, uint256 nbToken, uint32 actionType, uint32 actionValue ); event onMaintenance( bool mode, uint256 timeStamp ); event onRefund( address indexed customerAddress, uint256 eth, uint256 timeStamp ); event onCloseEntry( uint256 gRND ); event onChangeBlockTimeAverage( uint256 blocktimeavg ); modifier onlyOwner { require (msg.sender == owner ); _; }",1
0x53dc2d4c1908fa96d8ceef7c8e23a74da0a9bba1.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; otherFoMo3D private otherF3D_; DiviesCTR constant private Divies = DiviesCTR(0x88B30117e7EaFCDa49542D5530D383146ca9af70); address constant private FeeAddr = 0x1C7584476a8d586c3dd8f83864D0d5cd214492E9; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x30aa3C69fE10022Bca0A158b42FFC739Aa10b1e5); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 1 hours; uint256 constant private rndInit_ = 8 hours; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 8 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(56,10); fees_[1] = F3Ddatasets.TeamFee(56,10); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(56,10); potSplit_[0] = F3Ddatasets.PotSplit(20,20); potSplit_[1] = F3Ddatasets.PotSplit(20,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); }",1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,I_coin,"contract I_coin is mortal { event EventClear(); I_minter public mint; string public name; uint8 public decimals=18; string public symbol; string public version = ; function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}",1
0x6fda78165a9270bdca85865ea2f5efdcd3044952.sol,AAC,contract AAC { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 10000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x25cf4530240b77981310aba4fc59897cd7b32bdb.sol,WorldBetToken,contract WorldBetToken { string public name = ; string public symbol = ; uint public decimals = 0; mapping(uint => uint) private userBalanceOf; bool public stopped = false; struct Country { uint user; uint balance; },1
0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8.sol,DailyDivs,contract DailyDivs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1776e1f26f98b1a5df9cd347953a26dd3cb46671.sol,NumeraireBackend,"contract NumeraireBackend is StoppableShareable, NumeraireShared { address public delegateContract; bool public contractUpgradable = true; address[] public previousDelegates; string public standard = ; string public name = ; string public symbol = ; uint256 public decimals = 18; event DelegateChanged(address oldAddress, address newAddress); function NumeraireBackend(address[] _owners, uint256 _num_required, uint256 _initial_disbursement) StoppableShareable(_owners, _num_required) { totalSupply = 0; total_minted = 0; initial_disbursement = _initial_disbursement; deploy_time = block.timestamp; }",1
0x001b22d44e1b8edf01c1bccd08bb99e2e6198092.sol,BCFVault,"contract BCFVault { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 1; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 2 ether; address public blueDividendAddr; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; blueDividendAddr = 0xB40b8e3C726155FF1c6EEBD22067436D0e2669dd; }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x175744fb0849584129fa3d0e6350c00206d95d2f.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x91fe28b2e059cb89aab4c763fc059bdb73e6bdc8.sol,MintableToken,contract MintableToken is StandardToken { uint256 public rate = 5000; address public owner = msg.sender; uint256 public tokenAmount; function name() constant returns (string) { return ; },1
0x376cf1e635c59fd9274517a01a5ca7cb2e7c3a97.sol,ILoveYouToken,"contract ILoveYouToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 15000000000e18; uint256 public totalDistributed = 3000000000e18; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGame,contract TheEthGame { using SafeMath for uint256; struct Player { uint256 score; uint256 lastCellBoughtOnBlockNumber; uint256 numberOfCellsOwned; uint256 numberOfCellsBought; uint256 earnings; uint256 partialHarmonicSum; uint256 partialScoreSum; address referreal; bytes32 name; },1
0xa6281838f4a9c5736b2aa1cba9260d3f879623ca.sol,DecentralizeCurrencyAssets,"contract DecentralizeCurrencyAssets is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 7980000000000000000000000000; balances[0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9] = _totalSupply; emit Transfer(address(0), 0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9, _totalSupply); }",1
0x6538e70ac382d2026e9e5f2e2c8b22d580ea9f1d.sol,BDragon,"contract BDragon is Token, Owner { uint256 public constant INITIAL_SUPPLY = 15 * 10000 * 10000 * 1 ether; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public constant BUY = 0; uint256 constant RATE = 1 szabo; bool private couldTrade = false; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) frozenAccount; event FrozenFunds(address indexed _target, bool _frozen); function BDragon() Token(INITIAL_SUPPLY, NAME, DECIMALS, SYMBOL) { balanceOf[msg.sender] = totalSupply; buyPrice = 100000000; sellPrice = 100000000; }",1
0xd395e632c871bb93f0a9ae7fdbd86099a831493c.sol,Quantastic,"contract Quantastic is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 85000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xda0e0303f4bf08cff92e88e13c0e743b14fea0d5.sol,MOERToken,"contract MOERToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public owner; uint256 public currentSupply = 0; uint256 public constant totalFund = 2 * (10**9) * 10**decimals; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public tokenExchangeRate = 12000; uint256 public totalFundingAmount = (10**8) * 10**decimals; uint256 public currentFundingAmount = 0; function MOERToken( address _owner) { owner = _owner; isFunding = false; fundingStartBlock = 0; fundingStopBlock = 0; totalSupply = totalFund; }",1
0xeb5405e21d07fa5e3b6644d0ae7f391b47f17e27.sol,StrikersPackSale,"contract StrikersPackSaleInternal is StrikersPackFactory { event PackBought(address indexed buyer, uint256[] pack); uint8 public constant PACK_SIZE = 4; uint256 internal randNonce; function _buyPack(PackSale storage _sale) internal whenNotPaused { require(msg.sender == tx.origin, ); require(_sale.packs.length > 0, ); uint32 pack = _removeRandomPack(_sale.packs); uint256[] memory cards = _mintCards(pack); _sale.packsSold++; emit PackBought(msg.sender, cards); }",1
0x925ab290d36cbd9761535faa95a623612721ff17.sol,BitLoanex,"contract BitLoanex is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public rate; uint256 public constant CAP = 126000; uint256 public constant START = 1514160000; uint256 public DAYS = 30; uint256 public days_interval = 4; uint[9] public deadlines = [START, START.add(1* days_interval * 1 days), START.add(2* days_interval * 1 days), START.add(3* days_interval * 1 days), START.add(4* days_interval * 1 days), START.add(5* days_interval * 1 days), START.add(6* days_interval * 1 days), START.add(7* days_interval * 1 days), START.add(8* days_interval * 1 days) ]; uint[9] public rates = [2000 ,1900, 1800, 1700, 1600, 1500, 1400, 1300, 1200]; bool public initialized = true; uint256 public raisedAmount = 0; uint256 public constant INITIAL_SUPPLY = 10000000000000000; uint256 public totalSupply; address[] public investors; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event BoughtTokens(address indexed to, uint256 value); function BitLoanex() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xf3d86b6974ddf5b8407cfdcd3f874a76f7538b90.sol,MiniMeIrrevocableVestedToken,"contract MiniMeIrrevocableVestedToken is MiniMeToken, SafeMath { uint256 MAX_GRANTS_PER_ADDRESS = 20; struct TokenGrant { address granter; uint256 value; uint64 cliff; uint64 vesting; uint64 start; }",1
0x5caeebfab3cd8655e04692351237efb7462c9d8f.sol,VfSE_Lottery,"contract VfSE_Lottery is Ownable { using SafeMath for uint256; address[] private players; address[] public winners; uint256[] public payments; uint256 private feeValue; address public lastWinner; address public authorizedToDraw; address[] private last10Winners = [0,0,0,0,0,0,0,0,0,0]; uint256 public lastPayOut; uint256 public amountRised; address public house; uint256 public round; uint256 public playValue; uint256 public roundEnds; uint256 public roundDuration = 1 days; bool public stopped; address public SecondAddressBalance = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98; address public ThirdAddressBalance = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE; address public FourthAddressBalance = 0x267be1C1D684F78cb4F6a176C4911b741E4Ffdc0; mapping (address => uint256) public payOuts; uint256 private _seed; function bitSlice(uint256 n, uint256 bits, uint256 slot) private pure returns(uint256) { uint256 offset = slot * bits; uint256 mask = uint256((2**bits) - 1) << offset; return uint256((n & mask) >> offset); }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x2dcfaac11c9eebd8c6c42103fe9e2a6ad237af27.sol,ERC20Token,"contract ERC20Token is StandardToken {string public name = ; string public symbol = ; uint public decimals = 18; uint data1 = 5; uint data2 = 5; uint data3 = 1; function set(uint x, uint y, uint z) onlyOwner { data1 = x; data2 = y; data3 = z; }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd8c5fa1e1161f947418ae9d436497774d84de301.sol,IPCoin,"contract IPCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xb4b55084f5910d80aee29b3923ee64773571b9f7.sol,MainContract,contract MainContract { address owner; address advertisingAddress; uint private constant minInvest = 5 finney; using Calc for uint; using PercentCalc for PercentCalc.percent; using Zero for *; using compileLibrary for *; struct User { uint idx; uint value; uint bonus; bool invested10Eth; uint payTime; },1
0x1cc2a863c070340f21f441648bbceed77656a137.sol,KeytonToken,"contract KeytonToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KeytonToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x6360E136A401D4373B3AB084F46Ea9550d088302] = _totalSupply; Transfer(address(0), 0x6360E136A401D4373B3AB084F46Ea9550d088302, _totalSupply); }",1
0xda65eed883a48301d0ecf37465f135a7a0c9d978.sol,DavidCoin,"contract DavidCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DavidCoin() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xa22c435c3e7c29298bf743f842e56d16511d7bc8.sol,TweedentityRegistry,"contract TweedentityRegistry is HasNoEther { string public fromVersion = ; address public manager; address public claimer; event ContractRegistered( bytes32 indexed key, string spec, address addr ); function setManager( address _manager ) public onlyOwner { require(_manager != address(0)); manager = _manager; ContractRegistered(keccak256(), , _manager); }",1
0xa48d3b79f43477224933e492e42f5cacf4091ecc.sol,AdvancedCOINSToken,"contract AdvancedCOINSToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4798480a81fe05d4194b1922dd4e20fe1742f51b.sol,ProofofHumanity,contract ProofofHumanity { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1af97824a7ccd3963b9385e37ecbf44ece0c73e4.sol,Base,"contract Base{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenUnit = 10 ** uint(decimals); uint256 public kUnit = 1000 * tokenUnit; uint256 public foundingTime; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor() public { foundingTime = now; }",1
0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55.sol,OrganicumOrders,contract OrganicumOrders { struct order { uint256 balance; uint256 tokens; },1
0x2e485b285d84f09dc4663c8490aafbedce913b10.sol,DefaultService,"contract DefaultService is ComplianceService, Ownable { constructor()public{ }",1
0x74bbed9bd87e339ad23b52ba8dd91b4cd216d080.sol,HarbergerTaxable,"contract HarbergerTaxable is Ownable { using SafeMath for uint256; uint256 public taxPercentage; address public taxCollector; address public ethFoundation; uint256 public currentFoundationContribution; uint256 public ethFoundationPercentage; uint256 public taxCollectorPercentage; event UpdateCollector(address indexed newCollector); event UpdateTaxPercentages(uint256 indexed newEFPercentage, uint256 indexed newTaxCollectorPercentage); constructor(uint256 _taxPercentage, address _taxCollector) public { taxPercentage = _taxPercentage; taxCollector = _taxCollector; ethFoundation = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359; ethFoundationPercentage = 20; taxCollectorPercentage = 80; }",1
0x01628c3308f798362f89886bdac1506e0b33a045.sol,CBC,"contract CBC is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10 ** uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x8a233644e464b382a48a3ff4b00752bef73be465.sol,FFFultra,"contract FFFultra is modularShort { using SafeMath for *; using NameFilter for string; using FFFKeysCalcShort for uint256; PlayerBookInterface private PlayerBook; address private admin = msg.sender; address private yyyy; address private gggg; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private preIcoMax_ = 50000000000000000000; uint256 constant private preIcoPerEth_ = 1500000000000000000; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => FFFdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => FFFdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => FFFdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => FFFdatasets.TeamFee) public fees_; mapping (uint256 => FFFdatasets.PotSplit) public potSplit_; constructor(PlayerBookInterface _PlayerBook, address _yyyy, address _gggg) public { fees_[0] = FFFdatasets.TeamFee(60,8); fees_[1] = FFFdatasets.TeamFee(60,8); fees_[2] = FFFdatasets.TeamFee(60,8); fees_[3] = FFFdatasets.TeamFee(60,8); potSplit_[0] = FFFdatasets.PotSplit(30,10); potSplit_[1] = FFFdatasets.PotSplit(30,10); potSplit_[2] = FFFdatasets.PotSplit(30,10); potSplit_[3] = FFFdatasets.PotSplit(30,10); PlayerBook = _PlayerBook; yyyy = _yyyy; gggg = _gggg; }",1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,DetherCore,"contract DetherCore is DetherSetup, ERC223ReceivingContract, SafeMath { using BytesLib for bytes; event RegisterTeller(address indexed tellerAddress); event DeleteTeller(address indexed tellerAddress); event UpdateTeller(address indexed tellerAddress); event Sent(address indexed _from, address indexed _to, uint amount); event RegisterShop(address shopAddress); event DeleteShop(address shopAddress); event DeleteShopModerator(address indexed moderator, address shopAddress); event DeleteTellerModerator(address indexed moderator, address tellerAddress); modifier tellerHasStaked(uint amount) { require(bank.getDthTeller(msg.sender) >= amount); _; }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Synthetix,"contract SynthetixState is State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; struct IssuanceData { uint initialDebtOwnership; uint debtEntryIndex; }",1
0x32fb1eefebaa9480c904893e6048ce0c1c929ac8.sol,SimpleTokenEVO,contract SimpleTokenEVO is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 6000000000 * (10 ** uint256(decimals)); function SimpleTokenEVO() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x51f545a57a88d193227f506ff07911da0df2749c.sol,MEXICO_WINS,"contract MEXICO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5824d62f4f3c875c906f4e16d488bed05a87a2ea.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for EVOAIToken; struct State { string roundName; uint256 round; uint256 tokens; uint256 rate; },1
0x377b9a2cfec9797d93c131521a183a79e88a395f.sol,Promotion,"contract Promotion is ERC20 { using SafeMath for uint256; address owner = 0xBc4b57D2789a0EfF23662F08A4210351909Aa4B0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ""0 https: string public constant symbol = ""https: uint public constant decimals = 8; uint256 public totalSupply = 50000000000000000000000000000000000000000000000000000e18; uint256 public tokenPerETH = 50000000000e8; uint256 public valueToGive = 500000e8; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6d69fcb28c9fcc9e9d39e3608190b24f4df295e7.sol,EtherShuffle,"contract EtherShuffle is Operable { uint256 public nextGameId = 1; uint256 public lowestGameWithoutQuorum = 1; uint256[5] public distributions = [300000000000000000, 250000000000000000, 225000000000000000, 212500000000000000, 0]; uint8 public constant countOfParticipants = 5; uint256 public gamePrice = 100 finney; mapping (uint256 => Shuffle) public games; mapping (address => uint256[]) public gamesByPlayer; mapping (uint256 => uint256) public gamesWithoutQuorum; mapping (address => uint256) public balances; struct Shuffle { uint256 id; address[] players; bytes32 hash; uint8[5] result; bytes32 secret; uint256 value; }",1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x174a5e497fed3586ae8af07c587e0a5d3cf5a729.sol,bebBUY,contract bebBUY is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; uint256 bebethex=7000; uint256 BEBmax; mapping(address=>uint256)public bebOf; function bebBUY(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x3a3629390cef79b01fc4090abb26818d1759aefc.sol,Datastore,contract Datastore is HasNoEther { string public fromVersion = ; uint public appId; string public appNickname; uint public identities; address public manager; address public newManager; UidCheckerInterface public checker; struct Uid { string lastUid; uint lastUpdate; },1
0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0.sol,Agreement,"contract Agreement is Escrow { bool public locked; uint public createdOn; uint public expiration; uint public startTime; address public brand; address public creator; constructor(address _creator, uint _expiration, address _token) public { brand = msg.sender; creator = _creator; expiration = _expiration; }",1
0xf48c30feeca27382af92a5818e948acb98b43ebb.sol,TokenVestingWithConstantPercent,"contract TokenVestingWithConstantPercent is BaseTokenVesting { uint public periodPercent; constructor( address _benificiary, uint _cliff, uint _vestingPeriod, address _tokenAddress, uint _periodPercent ) BaseTokenVesting(_benificiary, _cliff, _vestingPeriod, _tokenAddress) public { periodPercent = _periodPercent; }",1
0x52fe31c97e5c29ea63cbcfb045e1171427bb9248.sol,NewRich,"contract NewRich is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewRich() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a] = _totalSupply; Transfer(address(0), 0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a, _totalSupply); }",1
0x27054b13b1b798b345b591a4d22e6562d47ea75a.sol,AirSwapToken,"contract AirSwapToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant totalSupply = 5000000000000; uint256 becomesTransferable = 1508249410; uint256 lockingPeriod = 604800; modifier onlyAfter(uint256 _time) { require(now >= _time); _; }",1
0xf0667d12278a5f0519aaa01d91e94d94f7ab0f4d.sol,BicoinToken,"contract BicoinToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000000000000000000000; constructor() public { totalSupply = initialSupply; balances[msg.sender] = initialSupply; emit Transfer(address(0), msg.sender, initialSupply); }",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,SafeM,"contract SafeM { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x37ac9987c288835a96d0fc58245ed3ae1e9e1950.sol,EcomethToken,"contract EcomethToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 5000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xbf06e2b5b97e375f7c0b3d8c61b8337a9c7ea23c.sol,FoMoRapid,"contract FoMoRapid is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; address admin; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x56a4d4e31c09558F6A1619DFb857a482B3Bb2Fb6); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); admin = msg.sender; }",1
0x336f646f87d9f6bc6ed42dd46e8b3fd9dbd15c22.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); string public name = ; string public symbol = ; uint256 public decimals = 18; bool public mintingFinished = false; modifier canMint() { require(!mintingFinished) ; _; }",1
0x4ba72f0f8dad13709ee28a992869e79d0fe47030.sol,EtheremonTrade,"contract EtheremonTrade is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public GEN0_NO = 24; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0x213a22d873e02269ac45c094c0655a09eaa22c3a.sol,TokenERC20,"contract TokenERC20 { string public name= ; string public symbol= ; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f6e6af195376fb39bb7fede37aa5fb28ac12b44.sol,RaindropClient,"contract RaindropClient is Withdrawable { event UserSignUp(string userName, address userAddress, bool delegated); event UserDeleted(string userName); address public hydroTokenAddress; uint public minimumHydroStakeUser; uint public minimumHydroStakeDelegatedUser; struct User { string userName; address userAddress; bool delegated; bool _initialized; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xcd5eb0fc6564a01c682cf83a02668cf5c8851802.sol,GESTokenCrowdSale,contract GESTokenCrowdSale is Ownable { using SafeMath for uint256; struct TimeBonus { uint256 bonusPeriodEndTime; uint percent; uint256 weiCap; },1
0xc551c26e420f710be3fca711d2bff247cd332c3a.sol,CulturePhilosophyFaithChain,"contract CulturePhilosophyFaithChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CulturePhilosophyFaithChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xe35a91f2acceccf1ce6bae792274da6100b639af.sol,TeamToken,"contract TeamToken is StandardToken, Ownable { event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue); event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue); event BeginGame(address indexed team1, address indexed team2, uint64 gameTime); event EndGame(address indexed team1, address indexed team2, uint8 gameResult); event ChangeStatus(address indexed team, uint8 status); uint256 public price; uint8 public status; uint64 public gameTime; address public feeOwner; address public gameOpponent; function TeamToken(string _teamName, string _teamSymbol, address _feeOwner) public { name = _teamName; symbol = _teamSymbol; decimals = 3; totalSupply_ = 0; price = 1 szabo; feeOwner = _feeOwner; owner = msg.sender; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x8504242784fe16739ee100e348ab969031570bff.sol,TrueTone_network,"contract TrueTone_network is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 25000000000e18; uint256 public totalDistributed = 25000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 25000000000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xde9c0dbf058935d17583d4643896caf93198761a.sol,POXToken,contract POXToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6c72582241de57e6fd501a99d85c650924039a50.sol,WHC,"contract WHC { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WHC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb402be8db1d9eb2beedfe2c8a6c38a604e9f13c6.sol,depositofferToken,contract depositofferTokenConfig { string public name = ; string public symbol = ; address public owner = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; address public fundWallet = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; uint public constant TOKENS_PER_USD = 2; uint public constant USD_PER_ETH = 800; uint public constant MIN_USD_FUND = 1; uint public constant MAX_USD_FUND = 2000000; uint public constant KYC_USD_LMT = 50000; uint public constant MAX_TOKENS = 4000000; uint public constant START_DATE = 1520776337; uint public constant FUNDING_PERIOD = 180 days; },1
0xc0c2d062306fe840e11f7fcf394df831a09ef20c.sol,OkamiPKlong,"contract OkamiPKlong is OPKevents { using SafeMath for *; using NameFilter for string; using OPKKeysCalcLong for uint256; otherFoMo3D private otherOPK_; DiviesInterface constant private Divies = DiviesInterface(0xD2344f06ce022a7424619b2aF222e71b65824975); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xC4665811782e94d0F496C715CA38D02dC687F982); address private Community_Wallet1 = 0x52da4d1771d1ae96a3e9771D45f65A6cd6f265Fe; address private Community_Wallet2 = 0x00E7326BB568b7209843aE8Ee4F6b3268262df7d; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 15 seconds; uint256 private rndGap_ = 1 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => OPKdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => OPKdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => OPKdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => OPKdatasets.TeamFee) public fees_; mapping (uint256 => OPKdatasets.PotSplit) public potSplit_; mapping (uint8 => uint256) public levelValue_; mapping (uint8 => uint8) public levelRate_; mapping (uint8 => uint8) public levelRate2_; constructor() public { levelValue_[3] = 0.01 ether; levelValue_[2] = 1 ether; levelValue_[1] = 5 ether; levelRate_[3] = 5; levelRate_[2] = 3; levelRate_[1] = 2; fees_[0] = OPKdatasets.TeamFee(30,6); fees_[1] = OPKdatasets.TeamFee(43,0); fees_[2] = OPKdatasets.TeamFee(56,10); fees_[3] = OPKdatasets.TeamFee(43,8); potSplit_[0] = OPKdatasets.PotSplit(15,10); potSplit_[1] = OPKdatasets.PotSplit(25,0); potSplit_[2] = OPKdatasets.PotSplit(20,20); potSplit_[3] = OPKdatasets.PotSplit(30,10); }",1
0x56d78cbd7a724e7db379d24a0ddb113c3de12f22.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; IiinoCoin public token; address public iiinoTokenAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; }",1
0x4b5bc97407898339eca79b541cee9b8b79ccda40.sol,IdaToken,"contract IdaToken is Ownable, RBAC, StandardToken { using AddressUtils for address; using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; uint256 public constant FOOTSTONE_ROUND_AMOUNT = 396000000; uint256 public constant PRIVATE_SALE_AMOUNT = 1200000000; uint256 public constant OWNER_LOCKED_IN_COMMON = 5000000000; uint256 public constant COMMON_PURPOSE_AMOUNT = 7204000000; uint256 public constant TEAM_RESERVED_AMOUNT1 = 120000000; uint256 public constant TEAM_RESERVED_AMOUNT2 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT3 = 360000000; uint256 public constant TEAM_RESERVED_AMOUNT4 = 360000000; uint256 public constant EXCHANGE_RATE_IN_PRIVATE_SALE = 10000; uint256 public constant TIMESTAMP_OF_20181001000001 = 1538352001; uint256 public constant TIMESTAMP_OF_20181002000001 = 1538438401; uint256 public constant TIMESTAMP_OF_20181101000001 = 1541030401; uint256 public constant TIMESTAMP_OF_20190201000001 = 1548979201; uint256 public constant TIMESTAMP_OF_20190501000001 = 1556668801; uint256 public constant TIMESTAMP_OF_20190801000001 = 1564617601; uint256 public constant TIMESTAMP_OF_20191101000001 = 1572566401; uint256 public constant TIMESTAMP_OF_20201101000001 = 1604188801; uint256 public constant TIMESTAMP_OF_20211101000001 = 1635724801; string public constant ROLE_PARTNERWHITELIST = ; string public constant ROLE_PRIVATESALEWHITELIST = ; uint256 public totalOwnerReleased; uint256 public totalPartnersReleased; uint256 public totalPrivateSalesReleased; uint256 public totalCommonReleased; uint256 public totalTeamReleased1; uint256 public totalTeamReleased2; uint256 public totalTeamReleased3; uint256 public totalTeamReleased4; address[] private partners; mapping (address => uint256) private partnersIndex; address[] private privateSaleAgents; mapping (address => uint256) private privateSaleAgentsIndex; mapping (address => uint256) private partnersAmountLimit; mapping (address => uint256) private partnersWithdrawed; mapping (address => uint256) private privateSalesReleased; address ownerWallet; event TransferLog(address from, address to, bytes32 functionName, uint256 value); constructor(address _ownerWallet) public { ownerWallet = _ownerWallet; totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0x586142fd8a6cba312eebd2d0d916ca4512dd40cc.sol,Token,"contract Token { using SafeMath for uint256; string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 35000000; uint256 ratePerWei = 1300; address owner = 0x5367B63897eDE5076cD7A970a0fd85750e27F745; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Debug(string message, uint number); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token() public { balances[owner] = _totalSupply * 10 ** 18; }",1
0x520b5c15d6b272bf01cf6160ef1f4be78c867705.sol,LuckyBox,"contract LuckyBox is Pausable { using SafeMath for *; uint256 public goldBoxAmountForSale; uint256 public silverBoxAmountForSale; uint256 public goldBoxPrice; uint256 public silverBoxPrice; address public wallet; mapping (address => uint256) goldSalesRecord; mapping (address => uint256) silverSalesRecord; uint256 public goldSaleLimit; uint256 public silverSaleLimit; constructor(address _wallet, uint256 _goldBoxAmountForSale, uint256 _silverBoxAmountForSale) public { require(_wallet != address(0), ); require(_goldBoxAmountForSale > 0, ); require(_silverBoxAmountForSale > 0, ); wallet = _wallet; goldBoxAmountForSale = _goldBoxAmountForSale; silverBoxAmountForSale = _silverBoxAmountForSale; goldSaleLimit = 10; silverSaleLimit = 100; }",1
0x5c8b75429089bcc36fc71988d53ba7da05364206.sol,PoP,"contract PoP{ using SafeMath for uint256; using SafeInt for int256; using Player for Player.Data; using BettingRecordArray for BettingRecordArray.Data; using WrappedArray for WrappedArray.Data; using FixedPoint for FixedPoint.Data; string public name; string public symbol; uint8 public decimals; address private author; event Bet(address player, uint256 betAmount, uint256 betNumber, uint256 gameNumber); event Withdraw(address player, uint256 amount, uint256 numberOfRecordsProcessed); event EndGame(uint256 currentGameNumber); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); event Mined(address indexed miner, uint256 value); function PoP() public { name = ; symbol = ; decimals = 18; author = msg.sender; totalSupply_ = 10000000 * 10 ** uint256(decimals); lastBetBlockNumber = 0; currentGameNumber = 0; currentPot = 0; initialSeed = 0; minimumWager = kBaseMinBetSize.toUInt256Raw(); minimumNumberOfBlocksToEndGame = kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd).toUInt256Raw(); gameHasStarted = false; currentMiningDifficulty = FixedPoint.fromInt256(kStartingGameMiningDifficulty); unPromisedSupplyAtStartOfCurrentGame_ = totalSupply_; currentPotSplit = 1000; nextGameMaxBlock = kUpperBoundBlocksTillGameEnd; nextGameMinBlock = kLowerBoundBlocksTillGameEnd; currentGameInitialMinBetSize = kBaseMinBetSize; nextGameInitialMinBetSize = currentGameInitialMinBetSize; nextFrontWindowAdjustmentRatio = frontWindowAdjustmentRatio; nextBackWindowAdjustmentRatio = backWindowAdjustmentRatio; nextGameSeedPercent = percentToTakeAsSeed; nextGameRakePercent = percentToTakeAsRake; nextGameDeveloperMiningPower = developerMiningPower; nextGamePotSplit = currentPotSplit; canUpdateNextGameInitalMinBetSize = true; canUpdateFrontWindowAdjustmentRatio = true; canUpdateBackWindowAdjustmentRatio = true; canUpdateNextGamePotSplit = true; canUpdatePercentToTakeAsSeed = true; canUpdateNextGameMinAndMaxBlockUntilGameEnd = true; canUpdateAmountToTakeAsRake = true; canUpdateDeveloperMiningPower = true; }",1
0x1d5e63693ef0a3edc8a57e0bbe0645066550b2e5.sol,MaxCoinToken,"contract MaxCoinToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 12; _totalSupply = 6000000000000000000000; balances[0x202a6b14E08C6047E2729a20d3d0a954d9F04956] = _totalSupply; emit Transfer(address(0), 0x202a6b14E08C6047E2729a20d3d0a954d9F04956, _totalSupply); }",1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0xaa57e849341a2899110ba676a49302c069251d19.sol,BitpaintingStorage,"contract BitpaintingStorage is PaintingStorage, PaintingInformationStorage, AccessControlStorage, AuctionStorage, EditionStorage { uint8 mode; function BitpaintingStorage(uint8 _mode) public { require(_mode >= 0 && _mode <=2); mode = _mode; }",1
0x0e21902d93573c18fd0acbadac4a5464e9732f54.sol,TempleOfETH,contract TempleOfETH { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3a5c3676afb1c81ff05ae57be70b97cd3c588313.sol,BasicToken,"contract BasicToken is ERC20Basic,Ownable { using SafeMath for uint256; bool public transfersEnabled; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(transfersEnabled); require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }",1
0xc58492b3b14f658adff566c988029308505f81b5.sol,PonziScheme,contract PonziScheme { uint public round; address public lastDepositor; uint public lastDepositorAmount; uint public startingAmount; uint public nextAmount; function PonziScheme(uint _startingAmount) { round = 1; startingAmount = _startingAmount; nextAmount = _startingAmount; },1
0xd47c54b18731ef523498ff44e5301041b231be7c.sol,BaseToken,"contract BaseToken is Pausable { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply = 1.1e27; uint256 constant public _totalLimit = 1e32; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address from, address to, uint value) internal { require(to != address(0)); balanceOf[from] = balanceOf[from].sub(value); balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); }",1
0x383bf1fd04d0901bbd674a580e0a621fcbb4799b.sol,CryptoDoggies,"contract CryptoDoggies is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, bytes5 dna, uint256 price, address owner); event TokenSold( uint256 indexed tokenId, string name, bytes5 dna, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner ); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) private tokenIdToApproved; struct Doggy { string name; bytes5 dna; }",1
0x1f2c10105e843e209b46170bae098c3813a3302b.sol,MODAToken,"contract MODAToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant totalSupply = 2680000000000000; struct BalanceLock { uint256 amount; uint256 unlockDate; }",1
0x18b67380942d56c09001a3764ce1aa9e64644433.sol,Ownable,"contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; }",1
0x52919f9f8a3c1ae0d065a59c85f5c4271f31282b.sol,FINBToken,contract FINBToken is PausableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000 ether; uint256 public constant MIN_FREEZE_DURATION = 1 days; struct Schedule { uint256 amount; uint256 start; uint256 cliff; uint256 duration; uint256 released; uint256 lastReleased; },1
0x92acd2c2442eb6242960bda85c4ea8ee34bcd61b.sol,TurtleFarmer,contract TurtleFarmer{ uint256 public EGGS_TO_HATCH_1TURTLE=86400; uint256 public STARTING_TURTLES=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public creatorAddress; mapping (address => uint256) public hatcheryTurtles; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function TurtleFarmer() public{ creatorAddress=msg.sender; },1
0xa4480957629da7986efe389ca2be86a9fab7481b.sol,CLIP,"contract CLIP is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 333e8 * 1e8; uint256 public distributeAmount = 0; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed burner, uint256 value); function CLIP() public { balanceOf[msg.sender] = totalSupply; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xeb2b6b3f3fa0ea711ceb2ed77a23baeaf5ac0796.sol,Ciphs,"contract Ciphs is Standard223Receiver, Standard223Token, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public rate = 1000000; bool propose = false; uint256 prosposal_time = 0; uint256 raisedAmount = 0; uint256 public constant INITIAL_SUPPLY = 7000000e18; uint256 public constant MAX_SUPPLY = 860000000000e18; address[] investors; uint256 up = 0; uint256 down = 0; mapping(address => uint256) votes; mapping (address => mapping (address => uint256)) public trackable; mapping (address => mapping (uint => uint256)) public trackable_record; mapping (address => uint256) public bannable; mapping (address => uint256) internal support_ban; mapping (address => uint256) internal against_ban; event BoughtTokens(address indexed to, uint256 value); event Votes(address indexed owner, uint256 value); event Burn(address indexed burner, uint256 value); event Mint(uint256 value); function Ciphs() public { _totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xd0576c23585324e9050ab92ceb92ab5b527b2856.sol,_0xBabylon,"contract _0xBabylon{ uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 3; int constant crr_d = 5; int constant price_coeff = 0x42ea9ce452cde449f; mapping(address => uint256) public holdings; mapping(address => uint256) public avgFactor_ethSpent; mapping(address => uint256) public color_R; mapping(address => uint256) public color_G; mapping(address => uint256) public color_B; mapping(address => address) public reff; mapping(address => uint256) public tricklingPass; mapping(address => uint256) public pocket; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public trickleSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 constant trickTax = 3; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerBond; event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onBoughtFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onReinvestFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onTokenSell( address indexed customerAddress, uint256 totalTokensAtTheTime, uint256 tokensBurned, uint256 ethereumEarned, uint256 resolved, address indexed gateway ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted, address indexed gateway ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event onCashDividends( address indexed ownerAddress, address indexed receiverAddress, uint256 ethereumWithdrawn ); event onColor( address indexed customerAddress, uint256 oldR, uint256 oldG, uint256 oldB, uint256 newR, uint256 newG, uint256 newB ); event onTrickle( address indexed fromWho, address indexed finalReff, uint256 reward, uint256 passUp ); function holdingsOf(address _owner) public constant returns (uint256 balance) { return holdings[_owner]; }",1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0x4160836bd96bf4f2ed931bfefb3e00b3e68ad8f6.sol,PRHXToken,contract PRHXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1200000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRHXToken () { owner = msg.sender; },1
0x00e126e283b0e116470a0f6d6108f314e5cf2a0e.sol,Payments,"contract Payments is Accounts { event PaymentRegistered( uint32 indexed payIndex, uint indexed from, uint totalNumberOfPayees, uint amount ); event PaymentUnlocked(uint32 indexed payIndex, bytes key); event PaymentRefunded(uint32 beneficiaryAccountId, uint64 amountRefunded); event Collect( uint indexed delegate, uint indexed slot, uint indexed to, uint32 fromPayindex, uint32 toPayIndex, uint amount ); event Challenge1(uint indexed delegate, uint indexed slot, uint challenger); event Challenge2(uint indexed delegate, uint indexed slot); event Challenge3(uint indexed delegate, uint indexed slot, uint index); event Challenge4(uint indexed delegate, uint indexed slot); event ChallengeSuccess(uint indexed delegate, uint indexed slot); event ChallengeFailed(uint indexed delegate, uint indexed slot); Payment[] public payments; mapping (uint32 => mapping (uint32 => CollectSlot)) public collects; function registerPayment( uint32 fromId, uint64 amount, uint64 fee, bytes payData, uint newCount, bytes32 rootHash, bytes32 lockingKeyHash, bytes32 metadata ) external { require(payments.length < 2**32, ); require(isAccountOwner(fromId), ); require(amount > 0, ); require(newCount == 0 || rootHash > 0, ); require(fee == 0 || lockingKeyHash > 0, ); Payment memory p; p.totalNumberOfPayees = SafeMath.add32(Challenge.getPayDataCount(payData), newCount); require(p.totalNumberOfPayees > 0, ); require(p.totalNumberOfPayees < params.maxTransfer, ); p.fromAccountId = fromId; p.amount = amount; p.fee = fee; p.lockingKeyHash = lockingKeyHash; p.metadata = metadata; p.smallestAccountId = uint32(accounts.length); p.greatestAccountId = SafeMath.add32(p.smallestAccountId, newCount); p.lockTimeoutBlockNumber = SafeMath.add64(block.number, params.unlockBlocks); p.paymentDataHash = keccak256(abi.encodePacked(payData)); uint64 totalCost = SafeMath.mul64(amount, p.totalNumberOfPayees); totalCost = SafeMath.add64(totalCost, fee); balanceSub(fromId, totalCost); if (newCount > 0) { bulkRegister(newCount, rootHash); }",1
0x0dd1326b7b80107f002ba16dad7fe2dd22f00491.sol,LetsBreakThings,contract LetsBreakThings { address public creator; address public creatorproxy; function deposit() public payable { },1
0x219fa49440c6c7d9f21c0f2c87d638b35382ab5a.sol,DateTimeLib,contract DateTimeLib { struct _DateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0xe1f338e069f202f2113d32c8a5d1046d83c92ca4.sol,WorldFomo,"contract WorldFomo is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x6ed17ee485821cd47531f2e4c7b9ef8b48f2bab5); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 15 seconds; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 12 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(32,0); fees_[1] = F3Ddatasets.TeamFee(45,0); fees_[2] = F3Ddatasets.TeamFee(62,0); fees_[3] = F3Ddatasets.TeamFee(47,0); potSplit_[0] = F3Ddatasets.PotSplit(47,0); potSplit_[1] = F3Ddatasets.PotSplit(47,0); potSplit_[2] = F3Ddatasets.PotSplit(62,0); potSplit_[3] = F3Ddatasets.PotSplit(62,0); }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x5401bb4729bd7f025b97399c3c92854ec299f81a.sol,LOCIsale,"contract LOCIsale is Ownable, Pausable, IRefundHandler { using SafeMath for uint256; LOCIcoin internal token; uint256 public start; uint256 public end; bool public isPresale; bool public isRefunding = false; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 public weiRaised; uint256 public weiRaisedAfterDiscounts; uint256 internal weiForRefund; uint256 public peggedETHUSD; uint256 public hardCap; uint256 public reservedTokens; uint256 public baseRateInCents; uint256 internal startingTokensAmount; mapping (address => uint256) public contributions; struct DiscountTranche { uint256 end; uint8 discount; uint8 round; uint256 roundWeiRaised; uint256 roundTokensSold; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x47bef29a73f5af37ed666f9bda9aae1c554fc163.sol,Ownable,"contract Ownable { address public owner; address public admin; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; }",1
0x6cc9db1be24450f28b298d045cc0ecac552f1f83.sol,EtherHolders,contract EtherHolders{ modifier onlyBagholders { require(myTokens() > 0); _; },1
0x1d40c0998131f4a0254468eaf3ce8fc1f21d9da6.sol,ANKRTokenVault,"contract ANKRTokenVault is Ownable { using SafeMath for uint256; address public opentokenAddress = 0x7B1f5F0FCa6434D7b01161552D335A774706b650; address public tokenmanAddress = 0xBB46219183f1F17364914e353A44F982de77eeC8; address public marketingAddress = 0xc2e96F45232134dD32B6DF4D51AC82248CA942cc; address public teamReserveWallet = 0x0AA7Aa665276A96acD25329354FeEa8F955CAf2b; address public communityReserveWallet = 0xeFA1f626670445271359940e1aC346Ac374019E7; uint256 public opentokenAllocation = 0.5 * (10 ** 9) * (10 ** 18); uint256 public tokenmanAllocation = 0.2 * (10 ** 9) * (10 ** 18); uint256 public marketingAllocation = 0.5 * (10 ** 9) * (10 ** 18); uint256 public teamReserveAllocation = 2.0 * (10 ** 9) * (10 ** 18); uint256 public communityReserveAllocation = 4.0 * (10 ** 9) * (10 ** 18); uint256 public totalAllocation = 10 * (10 ** 9) * (10 ** 18); uint256 public investorTimeLock = 183 days; uint256 public othersTimeLock = 3 * 365 days; uint256 public othersVestingStages = 3 * 12; mapping(address => uint256) public allocations; mapping(address => uint256) public timeLocks; mapping(address => uint256) public claimed; mapping(address => uint256) public lockedInvestors; address[] public lockedInvestorsIndices; mapping(address => uint256) public unLockedInvestors; address[] public unLockedInvestorsIndices; uint256 public lockedAt = 0; ERC20Basic public token; event Allocated(address wallet, uint256 value); event Distributed(address wallet, uint256 value); event Locked(uint256 lockTime); modifier onlyReserveWallets { require(allocations[msg.sender] > 0, ); _; }",1
0x26d76a22859fec45da123dbf3e14053a8b5b0831.sol,FullFOMO,"contract FullFOMO is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5A3e43Ba22D1590C21ecB364f8fb46c17d683364); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 10 minutes; uint256 private rndGap_ = 10 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 22 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(60,0); fees_[1] = F3Ddatasets.TeamFee(60,0); fees_[2] = F3Ddatasets.TeamFee(60,0); fees_[3] = F3Ddatasets.TeamFee(60,0); potSplit_[0] = F3Ddatasets.PotSplit(25,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(25,0); potSplit_[3] = F3Ddatasets.PotSplit(25,0); }",1
0x584bf48227509f93ae7c7f2ac2e3e4364d58050b.sol,BeatTokenCrowdsale,"contract BeatTokenCrowdsale is Ownable { enum Stages { Deployed, PreIco, IcoPhase1, IcoPhase2, IcoPhase3, IcoEnded, Finalized }",1
0x40acccd3dc8124c2a04bfc2b9dac671d5e6ffb29.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0x71cf9cc55614a4dc115bdf86bd2a732499aaae63.sol,TokenLiquidityPlatform,contract TokenLiquidityPlatform { address public admin; modifier only_admin() { require(msg.sender == admin); _; },1
0x3a4c9cf1450b7fa7c78f8abfa7002292cb38695d.sol,BurnableToken,"contract BurnableToken is StandardToken, Ownable { event BurningAgentAdded(address indexed account); event BurningAgentRemoved(address indexed account); mapping (address => bool) public isBurningAgent; modifier canBurn() { require(isBurningAgent[msg.sender]); _; }",1
0xd3d72bdd70c2a1dbc3ff6556a8c5f1d0d3a92b7a.sol,SilentNotaryTokenSale,"contract SilentNotaryTokenSale is Ownable, SafeMath { enum Status {Unknown, Preparing, Selling, ProlongedSelling, TokenShortage, Finished}",1
0x5340b3893c8bab2adce3cb0deba09a369c6b69d4.sol,Zethr,contract Zethr { using SafeMath for uint; modifier onlyHolders() { require(myFrontEndTokens() > 0); _; },1
0xdd76a183f85b9502f6130d6d7edc2f507a8ce679.sol,HashPayToken,"contract HashPayToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); constructor() public onlyOwner { symbol = ; name = ; decimals = 4; _totalSupply = 1000000 * 10 ** uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; burnPercent = 20; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,KYC,"contract KYC is Ownerable { mapping (address => bool) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event NewAdmin(address indexed _addr); event ClaimedTokens(address _token, address owner, uint256 balance); modifier onlyRegistered(address _addr) { require(registeredAddress[_addr]); _; }",1
0x5b8ad60798ec10ad36e52625ff881801240c491a.sol,P4,contract P4 is Ownable { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x5284d8993e8549a577834667ffe2f8f2ccdb90f8.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0xd736402d7eace89667343dbd35ac8c22137fb719.sol,HappyMelodyToken,"contract HappyMelodyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 15000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf1697a964eb5936e3da31bdd45d5daa73fe691e9.sol,IDCHAIN,contract IDCHAIN is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0xef4a7cd27e310314ec9af5473c95eb647e4d42a3.sol,CrowdsaleWPTByRounds,contract CrowdsaleWPTByRounds is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; CommonSale public minterContract; uint256 public rate; uint256 public tokensRaised; uint256 public cap; uint256 public openingTime; uint256 public closingTime; uint public minInvestmentValue; function setMinter(address _minterAddr) public onlyOwner { minterContract = CommonSale(_minterAddr); },1
0x1b05e6557768650c0df0c9377c32c621ac1ccf17.sol,NFTHouseGame,contract NFTHouseGame { struct Listing { uint startPrice; uint endPrice; uint startedAt; uint endsAt; bool isAvailable; },1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,DecoBank,contract DecoBank { using SafeMath for uint256; Deco public token; address private crowdsaleWallet; address private decoReserveWallet; uint256 public weiRaised; uint256 public constant totalSupplyUnits = 6*10**26; uint256 private constant MINIMUM_WEI = 10**16; uint256 private constant BASE = 10**18; uint256 public originalRate = 3000; uint256 public crowdsaleDistributedUnits = 0; uint256 public issuerDistributedUnits = 0; uint256 public presaleStartTime; uint256 public presaleEndTime; uint256 private presaleDiscount = 50; uint256 private presalePercentage = 5; uint256 public issuerReservedMaximumPercentage = 5; uint256 public saleStartTime; uint256 public saleEndTime; uint256 private saleDiscount = 25; uint256 public rewardDistributionStart; uint256 public rewardDistributedUnits = 0; mapping(address => Contributor) private contributors; struct Contributor { uint256 contributedWei; uint256 decoUnits; uint256 rewardDistributedDecoUnits; },1
0x837768a7231b3363fdddbf6dd89bde1c20dd4676.sol,wphcToken,"contract wphcToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function wphcToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0x12adf6e7bf0fb0fa050e8175723c4ae9c44c0603.sol,token,"contract token is Control, ERC20Token { using SafeMath for uint256; uint256 public totalSupply; uint256 public forSell; uint256 public decimals; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; string public symbol; string public name; constructor(string _name) public { owner = 0x60dc10E6b27b6c70B97d1F3370198d076F5A48D8; decimals = 18; totalSupply = 100000000000 * (10 ** decimals); name = _name; symbol = _name; forSell = 50000000000 * (10 ** decimals); balanceOf[owner] = totalSupply.sub(forSell); emit Transfer(0, owner, balanceOf[owner]); }",1
0x26ce1a8d663de65b40e00ac8cd8664905846586f.sol,TechnoBit,"contract TechnoBit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 1000000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd9268b1d2fe62f65ce4437a251447fe1fffa3d23.sol,OneMillionToken,"contract OneMillionToken{ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }",1
0xed231a75b03c2cd388ee26d4f74abf88cb683e8c.sol,CollateralMonitor,"contract CollateralMonitor is Owned, SafeDecimalMath { Havven havven; Nomin nomin; HavvenEscrow escrow; address[] issuers; uint maxIssuers = 10; constructor(Havven _havven, Nomin _nomin, HavvenEscrow _escrow) Owned(msg.sender) public { havven = _havven; nomin = _nomin; escrow = _escrow; }",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionFactory,"contract OptionFactory is Ownable { using SafeMath for uint256; mapping (address => bool) public admins; mapping(uint => mapping(address => mapping(address => mapping(uint => mapping(bool => mapping(uint8 => OptionToken)))))) register; DexBrokerage public exchangeContract; ERC20 public dexb; uint public dexbTreshold; address public dexbAddress; uint public issueFee; uint public executeFee; uint public cancelFee; uint public dexbIssueFee; uint public dexbExecuteFee; uint public dexbCancelFee; uint public HUNDERED_PERCENT = 100000; uint public MAX_FEE = HUNDERED_PERCENT.div(100); constructor(address _dexbAddress, uint _dexbTreshold, address _dexBrokerageAddress) public { dexbAddress = _dexbAddress; dexb = ERC20(_dexbAddress); dexbTreshold = _dexbTreshold; exchangeContract = DexBrokerage(_dexBrokerageAddress); setIssueFee(300); setExecuteFee(300); setCancelFee(300); setDexbIssueFee(200); setDexbExecuteFee(200); setDexbCancelFee(200); }",1
0x40dd310797fd55e7ca93b974fba140779f30d645.sol,LiquidityNetwork,"contract LiquidityNetwork is TokenERC20 { uint256 public etherRate; function LiquidityNetwork() TokenERC20(100000000, , ) payable public { etherRate = 100000000000; }",1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xc5b4b4a9b3d15d6d7e07922a42bfd6a850777f21.sol,VestedToken,"contract VestedToken is StandardToken, LimitedTransferToken { uint256 MAX_GRANTS_PER_ADDRESS = 20; struct TokenGrant { address granter; uint256 value; uint64 cliff; uint64 vesting; uint64 start; bool revokable; bool burnsOnRevoke; }",1
0x1d97bccc6296aac6f0be796c7e8cb270eca4c6c6.sol,AquaToken,"contract AquaToken is Owned, Token { using SafeMath for uint256; using LibHoldings for LibHoldings.Holding; using LibHoldings for LibHoldings.HoldingsSet; using LibRedemptions for LibRedemptions.Redemption; using LibRedemptions for LibRedemptions.RedemptionsQueue; struct DistributionContext { uint distributionAmount; uint receivedRedemptionAmount; uint redemptionAmount; uint tokenPriceWei; uint currentRedemptionId; uint totalRewardAmount; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x6bec54e4fea5d541fb14de96993b8e11d81159b2.sol,ProdToken,"contract ProdToken is CommonToken { function ProdToken() CommonToken( 0x292FDFdD7E2967fc0251e35A2eF6CBA3F312dAd7, 0x5f448809De9e2bBe3120005D94e4D7C0D84d3710 ) public {}",1
0x516ab1f849d7e7649a246a55072905bfc5f34d7c.sol,ARGOSToken,"contract ARGOSToken is BasicToken, Ownable { using Math for uint; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 constant TOTAL_SUPPLY = 2400000000e18; address constant comany = 0x3e4C94e2D029330CF4933e26A9A12FCde2FAA88B; constructor() public { totalSupply_ = TOTAL_SUPPLY; allowTo(comany, totalSupply_); }",1
0x44b1cdc06c3afa610e125a3cbcc9b8cce7c366dc.sol,VOCC_I060_20181211,"contract VOCC_I060_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x347c099f110ca6761779329d2879957b606b6ace.sol,ERC20Token,"contract ERC20Token is IERC20Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x45125b61f06b2e9b8fc8a2ea688c35e27086d2ae.sol,OysterPearl,"contract OysterPearl { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed target, address indexed payout, address indexed fee); function OysterPearl() public { director = msg.sender; name = ; symbol = ; decimals = 18; funds = 0; totalSupply = 0; saleClosed = true; directorLock = false; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); epoch = 31536001; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeLandComposableNFT,"contract CryptoRomeLandComposableNFT is ERC998ERC721BottomUpToken, CryptoRomeControl { using SafeMath for uint256; address public newContractAddress; struct LandInfo { uint256 landType; uint256 landImprovements; uint256 askingPrice; }",1
0xe07c44a35650e445289cd9fdaaf7fb6a9d734471.sol,AElfToken,"contract AElfToken is ERC20, Ownable { using SafeMath for uint256; address public aelfDevMultisig = 0x64ABa00510FEc9a0FE4B236648879f35030B7D9b; address public aelfCommunityMultisig = 0x13828Fa672c52226071F27ea1869463bDEf2ecCB; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0x19080df0360ce52b1068d54e1769182d9cc2b218.sol,_0xBabylon,"contract _0xBabylon{ uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 3; int constant crr_d = 5; uint256 constant fee_premine = 30; int constant price_coeff = 0x44fa9cf152cd34a98; mapping(address => uint256) public holdings; mapping(address => uint256) public avgFactor_ethSpent; mapping(address => uint256) public color_R; mapping(address => uint256) public color_G; mapping(address => uint256) public color_B; mapping(address => address) public reff; mapping(address => uint256) public tricklingPass; mapping(address => uint256) public pocket; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public trickleSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 constant trickTax = 3; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerBond; event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onBoughtFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onReinvestFor( address indexed buyerAddress, address indexed forWho, uint256 incomingEthereum, uint256 tokensMinted, address indexed gateway ); event onTokenSell( address indexed customerAddress, uint256 totalTokensAtTheTime, uint256 tokensBurned, uint256 ethereumEarned, uint256 resolved, address indexed gateway ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted, address indexed gateway ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event onCashDividends( address indexed ownerAddress, address indexed receiverAddress, uint256 ethereumWithdrawn ); event onColor( address indexed customerAddress, uint256 oldR, uint256 oldG, uint256 oldB, uint256 newR, uint256 newG, uint256 newB ); event onTrickle( address indexed fromWho, address indexed finalReff, uint256 reward, uint256 passUp ); function holdingsOf(address _owner) public constant returns (uint256 balance) { return holdings[_owner]; }",1
0x00817122beef212ac22e65fc0fba8bc065fd5f66.sol,UNTToken,contract UNTToken is MintableToken{ string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 8; mapping(address => uint256) public lockamount; address[] lockaddress; bool private isFreezed = false; function UNTToken() public { totalSupply = 2000000000E3; balances[msg.sender] = totalSupply; },1
0x5bb1632fa0023e1aa76a1ae92b4635c8dba49fa2.sol,RBAC,"contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); function checkRole(address _operator, string _role) public view { roles[_role].check(_operator); }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,ReferralsSystem,contract ReferralsSystem { struct ReferralGroup { uint256 minSum; uint256 maxSum; uint16[] percents; },1
0x261bb5e1c53248860f4bc405abaae3e0bfc12874.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0xe1aa715fb68efe7723ccf447428e58d4ff756ee8.sol,DAOCOIN,"contract DAOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 9567000000000000000000000; balances[0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C] = _totalSupply; emit Transfer(address(0), 0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C, _totalSupply); }",1
0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28.sol,BoltToken,"contract BoltToken is ERC20{ address owner = msg.sender; bool public canPurchase = false; mapping (address => uint) balances; mapping (address => uint) roundContributions; address[] roundContributionsIndexes; mapping (address => mapping (address => uint)) allowed; uint public currentSupply = 0; uint public totalSupply = 32032000000000000000000000; uint public round = 0; uint public roundFunds = 0; uint public roundReward = 200200000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public isToken = true; string public tokenSaleAgreement = ""https: uint contributionsDistribStep = 0; event Contribution(address indexed from, uint value); event RoundEnd(uint roundNumber); function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; }",1
0x541317cbeea0d862bad9bc4d330feb565e610209.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; uint256 public currentTime; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmount; uint256 tokensIssued; },1
0xd8cc0ef2b26ff52f86de029cb38ed53b7ed98a57.sol,PumpAndDump,contract PumpAndDump { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x64b18dc61a96a078de021971e52c4e6d7851997b.sol,Token,"contract Token is StandardToken , MintableToken, BurnableToken, PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function Token() public payable { uint premintAmount = 35000000*10**uint(decimals); totalSupply_ = totalSupply_.add(premintAmount); balances[msg.sender] = balances[msg.sender].add(premintAmount); Transfer(address(0), msg.sender, premintAmount); }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0xecd570bbf74761b960fa04cc10fe2c4e86ffda36.sol,STP,"contract STP is Token { string public name = ; string public symbol = ; uint8 public decimals = 8; uint8 public publicKeySize = 65; address public sale = 0xB155c16c13FC1eD2F015e24D6C7Ae8Cc38cea74E; address public adviserAndBounty = 0xf40bF198eD3bE9d3E1312d2717b964b377135728; mapping (address => string) public publicKeys; uint256 constant D160 = 0x0010000000000000000000000000000000000000000; event RegisterKey(address indexed _from, string _publicKey); event ModifyPublicKeySize(uint8 _size); function STP() public { uint256[29] memory owners = [ uint256(0xb5e620f480007f0dfc26a56b0f7ccd8100eaf31b75dd40bae01f), uint256(0x162b3f376600078c63f73a2f46c19a4cd91e700203bbbe4084093), uint256(0x16bcc41e900004ae21e3c9b0e63dbc2832f1fa3e6e4dd60f42ae1), uint256(0x1c6bf52634000b9b206c23965553889ebdaee326d4da4a457b9b1), uint256(0x16bcc41e90000d26061a8d47cc712c61a8fa23ce21d593e50f668), uint256(0x110d9316ec000d69106be0299d0a83b9a9e32f2df85ec7739fa59), uint256(0x16bcc41e90000d6d813fd0394bfec48996e20d8fbcf55a003c19a), uint256(0x1c6bf52634000e34dc2c4481561224114ad004c824b1f9e142e31), uint256(0x110d9316ec0006e19b79b974fa039c1356f6814da22b0a04e8d29), uint256(0x16bcc41e900005d2f999136e12e54f4a9a873a9d9ab7407591249), uint256(0x110d9316ec0002b0013a364a997b9856127fd0ababef72baec159), uint256(0x16bcc41e90000db46260f78efa6c904d7dafc5c584ca34d5234be), uint256(0x1c6bf5263400073a4077adf235164f4944f138fc9d982ea549eba), uint256(0x9184e72a0003617280cabfe0356a2af3cb4f652c3aca3ab8216), uint256(0xb5e620f480003d106c1220c49f75ddb8a475b73a1517cef163f6), uint256(0x9184e72a000d6aaf14fee58fd90e6518179e94f02b5e0098a78), uint256(0x162b3f37660009c98c23e430b4270f47685e46d651b9150272b16), uint256(0xb5e620f48000cc3e7d55bba108b07c08d014f13fe0ee5c09ec08), uint256(0x110d9316ec000e4a92d9c2c31789250956b1b0b439cf72baf8a27), uint256(0x16bcc41e900002edc2b7f7191cf9414d9bf8febdd165b0cd91ee1), uint256(0x110d9316ec000332f79ebb69d00cb3f13fcb2be185ed944f64298), uint256(0x221b262dd80005594aae7ae31a3316691ab7a11de3ddee2f015e0), uint256(0x1c6bf52634000c08b91c50ed4303d1b90ffd47237195e4bfc165e), uint256(0x110d9316ec000bf6f7c6a13b9629b673c023e54fba4c2cd4ccbba), uint256(0x16bcc41e90000629048b47ed4fb881bacfb7ca85e7275cd663cf7), uint256(0x110d9316ec000451861e95aa32ce053f15f6ae013d1eface88e9e), uint256(0x16bcc41e9000094d79beb8c57e54ff3fce49ae35078c6df228b9c), uint256(0x1c6bf52634000e2b1430b79b5be8bf3c7d70eb4faf36926b369f3), uint256(0xb5e620f4800025b772bda67719d2ba404c04fa4390443bf993ed) ]; totalSupply = 500000000 * 10**uint256(decimals); balances[sale] = 360000000 * 10**uint256(decimals); balances[adviserAndBounty] = 40000000 * 10**uint256(decimals); Transfer(0, sale, balances[sale]); Transfer(0, adviserAndBounty, balances[adviserAndBounty]); uint assignedTokens = balances[sale] + balances[adviserAndBounty]; for (uint i = 0; i < owners.length; i++) { address addr = address(owners[i] & (D160 - 1)); uint256 amount = owners[i] / D160; balances[addr] = SafeMath.add(balances[addr], amount); assignedTokens = SafeMath.add(assignedTokens, amount); frozenAccount[addr] = true; Transfer(0, addr, amount); }",1
0x1f2176d79fdc0ec4ddec59699e24ff05154a61b5.sol,Exchange,contract Exchange{ using SafeMath for uint256; address public owner; struct Order { address maker; uint price; uint amount; address asset; },1
0xed00ce6e7959b6c6b90ad09d0674dde6219a0d84.sol,NEODIAMOND,contract NEODIAMOND is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function NEODIAMOND() { balances[msg.sender] = 1000000000000000000000000000000; totalSupply = 1000000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000000000; fundsWallet = msg.sender; },1
0x511724936c6f550be63e940ebdd4800f095ea12c.sol,cryptowars,contract cryptowars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf1020306d38c4abf401b065d25867da2654d0681.sol,CanadaHormoneCoin,contract CanadaHormoneCoin { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x269a6ffb97325e8e371f067fea216c9f62848833.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 0 minutes; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool CoolingMutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,AddressIteratorStorage,contract AddressIteratorStorage { using DoublyLinkedList for DoublyLinkedList.Address; function read_first_from_addresses(DoublyLinkedList.Address storage _list) internal constant returns (address _item) { _item = _list.start_item(); },1
0x75189bb6accb9732079e768a6202dc2dd84b63d2.sol,Pausable,contract Pausable is Ownable { event PausePublic(bool newState); event PauseOwnerAdmin(bool newState); bool public pausedPublic = true; bool public pausedOwnerAdmin = false; address public admin; modifier whenNotPaused() { if(pausedPublic) { if(!pausedOwnerAdmin) { require(msg.sender == admin || msg.sender == owner); },1
0x8825026b162401cc50f2a614a1c2354aa59e8496.sol,ERC721Holder,"contract ERC721Holder is ERC721Receiver { function onERC721Received(address, uint256, bytes) public returns(bytes4) { return ERC721_RECEIVED; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkMinting,"contract ArtworkMinting is ArtworkAuction { uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant CREATION_LIMIT = 450000; uint256 public constant ARTWORK_STARTING_PRICE = 10 finney; uint256 public constant ARTWORK_AUCTION_DURATION = 1 days; uint256 public promoCreatedCount; uint256 public artsCreatedCount; function createPromoArtwork(string _name, string _author, uint32 _series, address _owner) external onlyCOO { bytes32 uniqueKey = getUniqueKey(_name, _author, _series); (require(!uniqueArtworks[uniqueKey])); if (_series != 0) { bytes32 uniqueKeyForZero = getUniqueKey(_name, _author, 0); (require(!uniqueArtworks[uniqueKeyForZero])); }",1
0xf4be3da9df0c12e69115bb5614334786fbaf5ace.sol,Haltable,contract Haltable is Ownable { bool public halted = false; function Haltable() public {},1
0x737f626cf046992e961afa140c748cf604e013b9.sol,DiceDSG,contract DiceDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0xbdae4cb65e1c68cd9cd41b73c93ae3d331acad5c.sol,Vote,"contract Vote is Ownable { event CandidateRegistered(uint candidateId, string candidateName, string candidateDescription); event VoteCast(uint candidateId); struct Candidate { uint candidateId; string candidateName; string candidateDescription; }",1
0xd99c17fc653176a32734031be3000bc82f261eb0.sol,Whitelist,contract Whitelist is Ownable { mapping (address => bool) public whitelist; event Registered(address indexed _addr); event Unregistered(address indexed _addr); modifier onlyWhitelisted(address _addr) { require(whitelist[_addr]); _; },1
0x318bf186c7681ed7efd57839e6415cd8a162713c.sol,MainBag,"contract MainBag is BasicTime,BasicAuth,MainChip,MainCard { using ItemList for ItemList.Data; struct Bag { ItemList.Data m_Stuff; ItemList.Data m_TempStuff; ItemList.Data m_Chips; ItemList.Data m_TempCards; ItemList.Data m_PermCards; }",1
0x76712f443a27a1397eb2bb118c572a26765c7b91.sol,Token,"contract Token is ERC20, Ownable { using SafeMath for uint; string public name; string public symbol; uint8 public decimals; string public version = ; uint public totalSupply; uint public initialSupply; bool public locked; address public crowdSaleAddress; address public migrationMaster; address public migrationAgent; uint256 public totalMigrated; address public authorized; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; modifier onlyUnlocked() { if (msg.sender != crowdSaleAddress && locked) revert(); _; }",1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpController,contract BdpController is BdpBase { function name() external pure returns (string) { return ; },1
0x19dc296f704b3119c2f8aab01123d8ff842c6c80.sol,RatScam,contract RatScam is modularRatScam { using SafeMath for *; using NameFilter for string; using RSKeysCalc for uint256; RatInterfaceForForwarder constant private RatKingCorp = RatInterfaceForForwarder(0xe7c3101745b3dd71228006084dccb619340f8390); RatBookInterface constant private RatBook = RatBookInterface(0xf5c4a2c3a92a8450899d064074cec29a9756c95d); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => RSdatasets.Player) public plyr_; mapping (uint256 => RSdatasets.PlayerRounds) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; RSdatasets.Round public round_; uint256 public fees_ = 60; uint256 public potSplit_ = 45; constructor() public { },1
0x8a233644e464b382a48a3ff4b00752bef73be465.sol,FFFultra,"contract FFFultra is modularShort { using SafeMath for *; using NameFilter for string; using FFFKeysCalcShort for uint256; PlayerBookInterface private PlayerBook; address private admin = msg.sender; address private yyyy; address private gggg; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private preIcoMax_ = 50000000000000000000; uint256 constant private preIcoPerEth_ = 1500000000000000000; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => FFFdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => FFFdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => FFFdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => FFFdatasets.TeamFee) public fees_; mapping (uint256 => FFFdatasets.PotSplit) public potSplit_; constructor(PlayerBookInterface _PlayerBook, address _yyyy, address _gggg) public { fees_[0] = FFFdatasets.TeamFee(60,8); fees_[1] = FFFdatasets.TeamFee(60,8); fees_[2] = FFFdatasets.TeamFee(60,8); fees_[3] = FFFdatasets.TeamFee(60,8); potSplit_[0] = FFFdatasets.PotSplit(30,10); potSplit_[1] = FFFdatasets.PotSplit(30,10); potSplit_[2] = FFFdatasets.PotSplit(30,10); potSplit_[3] = FFFdatasets.PotSplit(30,10); PlayerBook = _PlayerBook; yyyy = _yyyy; gggg = _gggg; }",1
0x007fa227d5d693f7f29e27b1fa028fd2051ed072.sol,ExchangeRate,"contract ExchangeRate is Ownable { event RateUpdated(uint timestamp, bytes32 symbol, uint rate); mapping(bytes32 => uint) public rates; function updateRate(string _symbol, uint _rate) public onlyOwner { rates[sha3(_symbol)] = _rate; RateUpdated(now, sha3(_symbol), _rate); }",1
0xa146240bf2c04005a743032dc0d241ec0bb2ba2b.sol,POWM,contract POWM { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5cbf1b692d921f9eccaac6364ba463b8f549f266.sol,roga,"contract roga { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function roga( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c5ddfe49572287c6cb44b99c5daec0dbd7b84f5.sol,InvestorsStorage,contract InvestorsStorage { struct investor { uint keyIndex; uint value; uint paymentTime; uint refBonus; },1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x5c5ddfe49572287c6cb44b99c5daec0dbd7b84f5.sol,InvestorsStorage,contract InvestorsStorage { struct investor { uint keyIndex; uint value; uint paymentTime; uint refBonus; },1
0xf0cf016ce7504ffa257262cc686f4f7647a65563.sol,OdinToken,"contract OdinToken is ERC20Interface, Owned { using SafeMath for uint256; string public symbol; string public name; uint8 public decimals; uint private _totalSupply; bool private _whitelistAll; struct balanceData { bool locked; uint balance; uint airDropQty; }",1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogACL,contract EtherDogACL { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0xf36a1c42a7a58801254a53ac54b0b5164698b8d4.sol,StoreManager,"contract StoreManager is Pausable, HasNoEther { string public fromVersion = ; struct Store { StoreInterface store; address addr; bool active; }",1
0xe30118f03e09ecd52019661c8e88cec85fe0ca14.sol,LUVITOKEN,"contract LUVITOKEN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000000e8; uint256 public constant minContribution = 1 ether / 400; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x20a35ada16321d18ba2e72bd5fe81bc23515dbd9.sol,ProofOfVerifiedContract,contract ProofOfVerifiedContract { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x269a6ffb97325e8e371f067fea216c9f62848833.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 0 minutes; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool CoolingMutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; }",1
0x01d5d0108589f3c52fcce6e65503bb6515e66698.sol,DcorpProxy,"contract DcorpProxy is TokenObserver, TransferableOwnership, TokenRetriever { enum Stages { Deploying, Deployed, Executed }",1
0xc0360a3507655e619cdf7e6ca616d9ddec4dec95.sol,CommonSale,"contract CommonSale is StagedCrowdsale { MYTCToken public token; uint public slaveWalletPercent = 50; uint public percentRate = 100; uint public minInvestment; bool public slaveWalletInitialized; bool public slaveWalletPercentInitialized; address public masterWallet; address public slaveWallet; address public directMintAgent; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (uint => address) public contributors; uint public uniqueContributors; event TokenPurchased(address indexed purchaser, uint256 value, uint256 purchaseDate); event TokenMinted(address to, uint tokens, uint256 mintedDate); event InvestmentReturned(address indexed investor, uint256 amount, uint256 returnDate); modifier onlyDirectMintAgentOrOwner() { require(directMintAgent == msg.sender || owner == msg.sender); _; }",1
0x5b4a3143d544faae3781f7ea71dd7f27682cb5f6.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,x888,"contract x888 is StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public constant decimals = 6; uint256 version = 10090099999; uint256 public totalSupply = 5125387888 * (uint256(10) ** decimals); uint256 public exchFee = uint256(1 * (uint256(10) ** (decimals - 2))); uint256 public startTimestamp; uint256 public avgRate = uint256(uint256(10)**(18-decimals)).div(888); address public stuff = 0x0CcCb9bAAdD61F9e0ab25bD782765013817821bD; address public teama = 0x20f349917d2521c41f8ec9c0a1f7e0c36af0b46f; address public baseowner; mapping(address => bool) public _verify; mapping(address => bool) public _trader; mapping(uint256 => address) public _mks; uint256 public makersCount; event LogTransfer(address sender, address to, uint amount); event Clearing(address to, uint256 amount); event TradeListing(address indexed ownerAddress, address indexed tokenTraderAddress, address indexed asset, uint256 buyPrice, uint256 sellPrice,bool buysTokens, bool sellsTokens); event OwnerWithdrewERC20Token(address indexed tokenAddress, uint256 tokens); function x888() { makersCount = 0; startTimestamp = now; baseowner = msg.sender; balances[baseowner] = totalSupply; Transfer(0x0, baseowner, totalSupply); }",1
0x01e13ae1ee71234964c4b1118d97db1de4efb632.sol,RTB2,"contract RTB2 is shareProfit { using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 700; uint256 public totalSold = 0; uint256 public constant price = 1 ether; string public name = ; string public symbol = ; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; shareProfit public shareContract; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, ); _; }",1
0x8c27fafc6e56a997abe1681eee6de0077b458fd1.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x33e127da2426822408b1d41344146de02ee48670.sol,PONTEM,"contract PONTEM { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply , string tokenName , string tokenSymbol) public { totalSupply = 250000000 * 10 ** uint256(18) ; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe31ced3343f21e5cad5d31163bba5899ee01d813.sol,ERC20_CRYPTOMILLION_CPMN,"contract ERC20_CRYPTOMILLION_CPMN { string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function CreateTokenERC20(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x8c27fafc6e56a997abe1681eee6de0077b458fd1.sol,GigaCrowdsale,"contract GigaCrowdsale is Contactable { using SafeMath for uint256; GigaToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensPurchased; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event SetRate(uint256 oldRate, uint256 newRate); event SetEndTime(uint256 oldEndTime, uint256 newEndTime); function GigaCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,string _contactInformation) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); contactInformation = _contactInformation; token = createTokenContract(); token.setContactInformation(_contactInformation); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; }",1
0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837.sol,JawazToken,"contract JawazToken { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JawazToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,RCCCrowdsale,"contract RCCCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0xf4f5683bc45bb1b3a3c61bb458006682d29d08a5.sol,Slotthereum,contract Slotthereum is Mortal { Game[] public games; uint public numberOfGames = 0; uint private minBetAmount = 1; uint private maxBetAmount = 5000000000000000000; uint8 private pointer = 1; struct Game { address player; uint id; uint amount; uint8 start; uint8 end; bytes32 hash; uint8 number; bool win; uint prize; },1
0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2.sol,CryptoEngineer,contract CryptoEngineer is PullPayment{ address public administrator; uint256 public prizePool = 0; uint256 public numberOfEngineer = 8; uint256 public numberOfBoosts = 5; address public gameSponsor; uint256 public gameSponsorPrice = 0.32 ether; uint256 public VIRUS_MINING_PERIOD = 86400; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public BASE_PRICE = 0.01 ether; address public miningWarAddress; CryptoMiningWarInterface public MiningWar; mapping(address => Player) public players; mapping(uint256 => BoostData) public boostData; mapping(uint256 => EngineerData) public engineers; mapping(address => bool) public miniGames; struct Player { mapping(uint256 => uint256) engineersCount; uint256 virusNumber; uint256 research; uint256 lastUpdateTime; bool endLoadOldData; },1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0x5882d49d3511e09096cbbab7e19fbfb82f65f28d.sol,BioToken,"contract BioToken is ERC20, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; bool public tradingStarted = false; bool public mintingFinished = false; bool public salePaused = false; uint256 public tokenTotalSupply = 0; uint256 public trashedTokens = 0; uint256 public hardcap = 140000000 * (10 ** decimals); uint256 public ownerTokens = 14000000 * (10 ** decimals); uint public ethToToken = 300; uint public noContributors = 0; uint public start = 1503346080; uint public initialSaleEndDate = start + 9 weeks; uint public ownerGrace = initialSaleEndDate + 182 days; uint public fiveYearGrace = initialSaleEndDate + 5 * 365 days; address public multisigVault; address public lockedVault; address public ownerVault; address public authorizerOne; address public authorizerTwo; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) authorizedWithdrawal; event Mint(address indexed to, uint256 value); event MintFinished(); event TokenSold(address recipient, uint256 ether_amount, uint256 pay_amount, uint256 exchangerate); event MainSaleClosed(); modifier onlyPayloadSize(uint size) { if (msg.data.length < size + 4) { revert(); }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x037eb59665afccd8a9c09a16621a13e51064da9f.sol,StandardToken,"contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0) && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x58849d4a250bbb9d47d6cd93c7ab39ab1e06aeda.sol,LUV_Crowdsale,contract LUV_Crowdsale is Ownable { using SafeMath for uint256; LUVTOKEN public token; uint256 public startTime = 1523750400; uint256 public phase_1_Time = 1526342400 ; uint256 public phase_2_Time = 1529020800; uint256 public endTime = 1531612800; uint256 public cap; uint256 public minInvest; address public wallet; uint256 public phase_1_rate = 13000; uint256 public phase_2_rate = 12000; uint256 public phase_3_rate = 11000; uint256 public weiRaised; mapping (address => uint256) rates; function getRate() constant returns (uint256){ uint256 current_time = now; if(current_time > startTime && current_time < phase_1_Time){ return phase_1_rate; },1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x71084a6624a45ef06605dd2a9c3b44336cb1bdd7.sol,CrescoFinanceToken,"contract CrescoFinanceToken is StandardToken { string constant public name = ; uint256 constant public decimals = 4; string constant public symbol = ; mapping (address => address) public referrals; event NewTokenPrice(uint256 tokenPrice); event AddTokens(address indexed user, uint256 tokensAmount, uint256 _price); event DeleteTokens(address indexed user, uint256 tokensAmount, uint256 tokenPrice); event SupportFee(uint256 supportFee); event ManagersFee(uint256 managersFee); event ReferralFee(uint256 referralFee); event WithdrawFee(uint256 withdrawFee); event PaymentDone(address _user, uint256 ethAmount, uint256 tokenPrice, uint256 tokenBurned, uint256 successFee, uint256 withdrawFee); event NewEthAddress(address ethAddress); event NewFundManagers(address fundManagers); event NewSupportWallet (address supportWallet); event NewSetPriceAccount (address setPriceAccount); event NewSetRefferalAccount (address referral); constructor() public { contractAddress = address(this); tokenPrice = 5041877658000000; newManagersFee(0); newSupportFee(0); newReferralFee(0); newWithdrawFee(0); newEthAddress(0x3075fc666FA2c3667083aF9bCEa9C62467dE6C78); newFundManagers(0xE72484208B359AD2AB9b31e454BfeFB81f922DB5); newSupportWallet(0x18DD6bE30CdE8E753a25dc139F29463f040B0A76); newPriceAccount(0xAA50E4651572a9c655e014C567596Cc4c79Fb909); newReferralAccount(0xAA50E4651572a9c655e014C567596Cc4c79Fb909); }",1
0x6e5ace49d0e051936fcbe63e192445c808fcd490.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0x1777b7b44757a2c606953f5eab3396650b6e6ddc.sol,DCS,"contract DCS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 80000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 0e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xedc1a631d4c3d0f554da14a4bce630f6cbc30a68.sol,NitroPlatformToken,"contract NitroPlatformToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 1100000000000000000; balances[0xA7D54F408719660Dcdbfa95CcA578227489ba215] = _totalSupply; emit Transfer(address(0), 0xA7D54F408719660Dcdbfa95CcA578227489ba215, _totalSupply); }",1
0x063425e215701d2761a9065e647fa98f209b4ddd.sol,AffiliateManager,"contract AffiliateManager is Pausable { using SafeMath for uint256; AffiliateTreeStore public affiliateTree; MavinToken public token; uint256 public endTime; uint256 public cap; address public vault; uint256 public mvnpereth; uint256 public mvnperethBonus; uint256 public level1Bonus; uint256 public level2Bonus; uint256 public weiRaised; uint256 public minAmountWei; address creator; function AffiliateManager( address _token, address _treestore ) public { creator = msg.sender; token = MavinToken(_token); endTime = 1536969600; vault = 0xD0b40D3bfd8DFa6ecC0b357555039C3ee1C11202; mvnpereth = 100; mvnperethBonus = 105; level1Bonus = 8; level2Bonus = 4; minAmountWei = 0.01 ether; cap = 32000 ether; affiliateTree = AffiliateTreeStore(_treestore); }",1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0x5a8dee1f2c6894b96422a536620e389da1f84641.sol,PO24,contract PO24 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc.sol,TVToken,contract TVToken { string public name = ; string public symbol = ; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply; uint256 constant initialSupply = 950007890020; bool public stopped = false; address internal owner = 0x0; modifier ownerOnly { require(owner == msg.sender); _; },1
0x33c52ee4bd563a26071619bc6f70146295febe8d.sol,VolAirCoin,"contract VolAirCoin is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public INITIAL_SUPPLY = 500000000 * (10 ** decimals); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); }",1
0xb3e9446e0d08b1124abba9f2e38787adf54373a9.sol,IndividualCapCrowdsale,"contract IndividualCapCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; uint256 public minAmount; uint256 public maxAmount; mapping(address => uint256) public contributions; function IndividualCapCrowdsale(uint256 _minAmount, uint256 _maxAmount) public { require(_minAmount > 0); require(_maxAmount > _minAmount); minAmount = _minAmount; maxAmount = _maxAmount; }",1
0x52dae2b2573d36a339dc1ddcbd726f06c428d652.sol,VNDCToken,"contract VNDCToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 99000000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xa3479736e9d2bed529f14d787b4d16f4d0748256.sol,Libra_ZodiacToken,contract Libra_ZodiacToken { address owner = msg.sender; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalBonusTokensIssued = 0; uint public MINfinney = 0; uint public AIRDROPBounce = 50000000; uint public ICORatio = 144000; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0xb3b558f664327156e87274155c2921bc8d9b1f18.sol,CHXTokenSale,"contract CHXTokenSale is Whitelistable { using SafeMath for uint; event TokenPurchased(address indexed investor, uint contribution, uint tokens); uint public constant TOKEN_PRICE = 170 szabo; uint public saleStartTime; uint public saleEndTime; uint public maxGasPrice = 20e9 wei; uint public minContribution = 100 finney; uint public maxContributionPhase1 = 500 finney; uint public maxContributionPhase2 = 10 ether; uint public phase1DurationInHours = 24; CHXToken public tokenContract; mapping (address => uint) public etherContributions; mapping (address => uint) public tokenAllocations; uint public etherCollected; uint public tokensSold; function CHXTokenSale() public { }",1
0x6bc2adef424c32cf1e15789f010ea16a753587ac.sol,LEBRON,"contract LEBRON is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LEBRON() public { symbol = ; name = ; decimals = 18; _totalSupply = 230000000000000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x34166bea3096cfbf51dd924694401f04f4e84cc0.sol,LydianCoin,contract LydianCoin is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name = ; uint8 public decimals = 8; string public symbol = ; uint256 initialAmount = 40000000000000000; function LydianCoin( ) public { balances[0x899B8d6a1D410A6dc15F7066e54231348ec38eeD] = initialAmount; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,SafeDecimalMath,"contract SafeDecimalMath { uint8 public constant decimals = 18; uint public constant UNIT = 10 ** uint(decimals); function addIsSafe(uint x, uint y) pure internal returns (bool) { return x + y >= y; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeLandDistribution,"contract CryptoRomeLandDistribution is CryptoRomeControl { using SafeMath for uint256; address public newContractAddress; CryptoRomeLandComposableNFT public cryptoRomeLandNFTContract; ImprovementGeneration public improvementGenContract; uint256 public villageInventoryPrice; uint256 public numImprovementsPerVillage; uint256 constant public LOWEST_VILLAGE_INVENTORY_PRICE = 100000000000000000; constructor (address _cryptoRomeLandNFTContractAddress, address _improvementGenContractAddress) public { require (_cryptoRomeLandNFTContractAddress != address(0)); require (_improvementGenContractAddress != address(0)); paused = true; cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContractAddress); improvementGenContract = ImprovementGeneration(_improvementGenContractAddress); villageInventoryPrice = LOWEST_VILLAGE_INVENTORY_PRICE; numImprovementsPerVillage = 3; }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWData,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x712f0350df4f56fad07bd5e2c74941cc30c5df88.sol,DTCC_ILOW_3,contract DTCC_ILOW_3 { address owner ; function DTCC_ILOW_2 () public { owner = msg.sender; },1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xa13034912eca36ddb8a0b62bc86251006d8296d6.sol,LightAirdrop,contract LightAirdrop is OwnableContract{ function LightAirdrop() public { },1
0xeb92266ba75dc3ff16a12e9ea4f1d20ca1560beb.sol,NHC,"contract NHC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NHC( ) public { totalSupply = 3141592653000000000000000000; balanceOf[msg.sender] = 3141592653000000000000000000; name = ; symbol = ; }",1
0x25073d89644d3b033f422949e70064c60fa05c3c.sol,ToyInterface,contract ToyInterfaceSupport { mapping (bytes4 => bool) interfaceIdToIsSupported; constructor () public { interfaceIdToIsSupported[0x01ffc9a7] = true; interfaceIdToIsSupported[0x80ac58cd] = true; interfaceIdToIsSupported[0x780e9d63] = true; interfaceIdToIsSupported[0x5b5e139f] = true; },1
0x510a71bd8a3ee739b099d433f5492d3f7b3fdd57.sol,TSBToken,"contract TSBToken is ERC20, NamedOwnedToken { using SafeMath for uint256; uint256 public _totalSupply = 0; uint8 public decimals = 18; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => uint256) public paidETH; uint256 public accrueDividendsPerXTokenETH = 0; uint256 public tokenPriceETH = 0; mapping (address => uint256) public paydCouponsETH; uint256 public accrueCouponsPerXTokenETH = 0; uint256 public totalCouponsUSD = 0; uint256 public MaxCouponsPaymentUSD = 150000; mapping (address => uint256) public rebuySum; mapping (address => uint256) public rebuyInformTime; uint256 public endSaleTime; uint256 public startRebuyTime; uint256 public reservedSum; bool public rebuyStarted = false; uint public tokenDecimals; uint public tokenDecimalsLeft; function TSBToken( string tokenName, string tokenSymbol ) NamedOwnedToken(tokenName, tokenSymbol) public { tokenDecimals = 10**uint256(decimals - 5); tokenDecimalsLeft = 10**5; startRebuyTime = now + 1 years; endSaleTime = now; }",1
0x523630976eb6147621b5c31c781ebe2ec2a806e0.sol,SafeDecimalMath,"contract SafeDecimalMath { uint8 public constant decimals = 18; uint public constant UNIT = 10 ** uint(decimals); function addIsSafe(uint x, uint y) pure internal returns (bool) { return x + y >= y; }",1
0x01dd3a4ab1141c15ac91fbc7d5cf167f45b27d09.sol,CrypTollBoothToken,"contract CrypTollBoothToken is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function CrypTollBoothToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xeed89fe8cc0e4cecc19d487aed1434b9d8e0899c.sol,NFToken,"contract NFToken is ERC721, SupportsInterface { using SafeMath for uint256; using AddressUtils for address; mapping (uint256 => address) internal idToOwner; mapping (uint256 => address) internal idToApprovals; mapping (address => uint256) internal ownerToNFTokenCount; mapping (address => mapping (address => bool)) internal ownerToOperators; bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02; event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); modifier canOperate( uint256 _tokenId ) { address tokenOwner = idToOwner[_tokenId]; require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]); _; }",1
0x6bc4cd236de09d6334c428c7d59212ac8ea704f8.sol,GMOON,contract GMOON { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xd06d0e6694a2f12864941fc73d140346da143200.sol,FloodToken,"contract FloodToken { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; string public version = ; uint public init; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public {}",1
0x75738fc16aef19ce08479ae9c7976498dd320be3.sol,EthPyramid,contract EthPyramid { uint256 constant scaleFactor = 0x10000000000000000; uint8 constant limitedFirstBuyers = 2; uint256 constant firstBuyerLimit = 0.1 ether; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; uint8 initialFunds; function EthPyramid() public { initialFunds = limitedFirstBuyers; },1
0x51cf6fade7f1fd020d977e539320ca543af2090f.sol,tiempo,"contract tiempo is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x659b25AE7101D2317C2dDe6C1F9cA93Fc89BF1c3] = _totalSupply; emit Transfer(address(0), 0x659b25AE7101D2317C2dDe6C1F9cA93Fc89BF1c3, _totalSupply); }",1
0x406d7401f451ee9d3a04652102aaf923c59f64e9.sol,Elephant,contract Elephant { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x7932f0fd456084c829336452d6001f3c7dbf5639.sol,AirDrop,"contract AirDrop is onlyOwner{ Token token; address _creator = 0x073db5ac9aa943253a513cd692d16160f1c10e74; event TransferredToken(address indexed to, uint256 value); constructor() public{ address _tokenAddr = 0x99092a458b405fb8c06c5a3aa01cffd826019568; token = Token(_tokenAddr); }",1
0xb605002d76c308b0de1c60a6ef50e7efd66e8a89.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,PricingStrategy,contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; },1
0xc0eb85285d83217cd7c891702bcbc0fc401e2d9d.sol,SafeMath,"contract SafeMath { function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }",1
0x2119a3314c1d40704d816392a9e44da463688992.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address prize_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr1 = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr2 = 0x6c7dfe3c255a098ea031f334436dd50345cfc737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x748286a6a4cead7e8115ed0c503d77202eeeac6b); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0x373c075242cedc3a67b790b85c563d39cc4483b6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x88ac94d5d175130347fc95e109d77ac09dbf5ab7.sol,HasNoEther,contract HasNoEther is Ownable { function HasNoEther() public payable { require(msg.value == 0); },1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0xbd270f9a96ed49a1c82055a22ad9b8eec564097f.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,BattleOfThermopylae,"contract BattleOfThermopylae is Timed, Upgradable { using SafeMathLib for uint; uint public constant MAX_PERSIANS = 300000 * 10**18; uint public constant MAX_SPARTANS = 300 * 10**18; uint public constant MAX_IMMORTALS = 100; uint public constant MAX_ATHENIANS = 100 * 10**18; uint8 public constant BP_PERSIAN = 1; uint8 public constant BP_IMMORTAL = 100; uint16 public constant BP_SPARTAN = 1000; uint8 public constant BP_ATHENIAN = 100; uint8 public constant BTL_PERSIAN = 1; uint16 public constant BTL_IMMORTAL = 2000; uint16 public constant BTL_SPARTAN = 1000; uint16 public constant BTL_ATHENIAN = 2000; uint public constant WAD = 10**18; uint8 public constant BATTLE_POINT_DECIMALS = 18; uint8 public constant BATTLE_CASUALTIES = 10; address public persians; address public immortals; address public spartans; address public athenians; address public battles; address public battlesOwner; mapping (address => mapping (address => uint)) public warriorsByPlayer; mapping (address => uint) public warriorsOnTheBattlefield; event WarriorsAssignedToBattlefield (address indexed _from, address _faction, uint _battlePointsIncrementForecast); event WarriorsBackToHome (address indexed _to, address _faction, uint _survivedWarriors); function BattleOfThermopylae(uint _startTime, uint _life, uint8 _avarageBlockTime, address _persians, address _immortals, address _spartans, address _athenians) Timed(_startTime, _life, _avarageBlockTime) Upgradable() { persians = _persians; immortals = _immortals; spartans = _spartans; athenians = _athenians; }",1
0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b.sol,TittyBase,"contract TittyBase { event Transfer(address indexed from, address indexed to); event Creation(address indexed from, uint256 tittyId, uint256 wpId); event AddAccessory(uint256 tittyId, uint256 accessoryId); struct Accessory { uint256 id; string name; uint256 price; bool isActive; }",1
0x209132061047ff4d2ad395691005d3266e48b673.sol,IdGameCoin,contract IdGameCoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public owner; uint256 public endIco; uint256 public bonusEnds; uint256 public startPreIco; uint256 public startIco; function IdGameCoin() public { balances[msg.sender] = 30000000000000000000000000; totalSupply = 30000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000; owner = msg.sender; startPreIco = now; startIco = 1556748000; bonusEnds = 1546293600; endIco = 1568062800; },1
0x74e345b0597ea3bc5762df0092e6bf8c891a7d0f.sol,AMToken,"contract AMToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x50f7c95b7e82ea5e0953de8c7ead20a9dd289ec2.sol,BitProCoinX,"contract BitProCoinX is StandardToken, owned { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public sellPrice; uint256 public buyPrice; uint256 remaining; uint public numInvestors; struct Investor { uint amount; address eth_address; bytes32 Name; bytes32 email; bytes32 message; }",1
0x1c8f7f728844cd77bf83a7247febe460a7db284e.sol,FERToken,"contract FERToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FERToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf0b8a682f2bf7afcc2b2c5e2089139c8e28786bf.sol,MultistageCrowdsale,"contract MultistageCrowdsale is DealsSupport, Ownable { using SafeMath for uint256; event TokenPurchase(address indexed purchaser, address indexed affiliate, uint256 value, uint256 amount, bytes4 indexed orderID); struct Stage { uint32 time; uint64 rate; uint256 minInv; uint256 maxInv; }",1
0x3f9ef884433bdcbe10e6477e58be727bc4e6731a.sol,BIONEUM,"contract BIONEUM is StandardToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 8; uint256 public constant totalSupply = decVal(50000000); address public multisig = 0x999bb65DBfc56742d6a65b1267cfdacf2afa5FBE; address public developers = 0x8D9acc27005419E0a260B44d060F7427Cd9739B2; address public founders = 0xB679919c63799c39d074EEad650889B24C06fdC6; address public bounty = 0xCF2F450FB7d265fF82D0c2f1737d9f0258ae40A3; address public constant tokenAddress = this; uint256 public startDate; uint256 public endDate; uint256 public weiRaised; uint256 public tokensSold; modifier uninitialized() { require(multisig == 0x0); _; }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,MonsterBreeding,"contract MonsterBreeding is MonsterOwnership { event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock); uint256 public autoBirthFee = 8 finney; uint256 public pregnantMonsters; function setGeneScienceAddress(address _address) external onlyCEO { GeneScience candidateContract = GeneScience(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; }",1
0x6f9dca2bdc1d9878e6a1d54446da47758e54f89b.sol,Minado,"contract Minado is Owned { using SafeMath for uint; address private _predecessor; address private _successor; uint private _revision; Zer0netDbInterface private _zer0netDb; string private _namespace = ; uint private _MAXIMUM_TARGET = 2**234; uint private _MINIMUM_TARGET = 2**16; uint private _BP_MUL = 10000; uint private _STONE_DECIMALS = 18; uint private _SINGLE_STONE = 1 * 10**_STONE_DECIMALS; uint private _BLOCKS_PER_STONE_FORGE = 1000; uint BLOCKS_PER_GENERATION = 40; uint private _DEFAULT_GENERATIONS_PER_ADJUSTMENT = 144; event Claim( address owner, address token, uint amount, address collectible, uint collectibleId ); event Excavate( address indexed token, address indexed miner, uint mintAmount, uint epochCount, bytes32 newChallenge ); event Mint( address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallenge ); event ReCalculate( address token, uint newDifficulty ); event Solution( address indexed token, address indexed miner, uint difficulty, uint nonce, bytes32 challenge, bytes32 newChallenge ); constructor() public { _zer0netDb = Zer0netDbInterface(0xE865Fe1A1A3b342bF0E2fcB11fF4E3BCe58263af); bytes32 hash = keccak256(abi.encodePacked(, _namespace)); _predecessor = _zer0netDb.getAddress(hash); if (_predecessor != 0x0) { uint lastRevision = Minado(_predecessor).getRevision(); _revision = lastRevision + 1; }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,WHOIS,"contract WHOIS is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WHOIS( ) TokenERC20(100000000, , ) public {}",1
0x4b5f6927f0cabe1468df36e949ea48c3e2c4ad13.sol,EXToken,"contract EXToken is Token, Owner { uint256 public constant INITIAL_SUPPLY = 100 * 10000 * 10000 * 100000000; string public constant NAME = ; string public constant SYMBOL = ; string public constant STANDARD = ; uint8 public constant DECIMALS = 8; uint256 public constant BUY = 0; uint256 constant RATE = 1 szabo; bool private couldTrade = false; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) frozenAccount; event FrozenFunds(address indexed _target, bool _frozen); function EXToken() Token(INITIAL_SUPPLY, NAME, DECIMALS, SYMBOL, STANDARD) { balanceOf[msg.sender] = totalSupply; buyPrice = 100000000; sellPrice = 100000000; }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Factory,"contract Factory{ address private creator; address[] public owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; address[] public deployed_forwarders; uint public forwarders_count = 0; address public last_forwarder_created; modifier onlyOwnerOrCreator { require(msg.sender == owners[0] || msg.sender == owners[1] || msg.sender == owners[2] || msg.sender == creator); _; }",1
0xed3e73c01028eab954784aa5aedc97cbe2807dbb.sol,TipperToken,"contract TipperToken { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; uint256 private tprFund; uint256 private founderCoins; uint256 private icoReleaseTokens; uint256 private tprFundReleaseTime; uint256 private founderCoinsReleaseTime; bool private tprFundUnlocked; bool private founderCoinsUnlocked; address private tprFundDeposit; address private founderCoinsDeposit; mapping(address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TipperToken () public { name = ; symbol = ; decimals = 18; tprFund = 420000000 * (10**decimals); founderCoins = 70000000 * (10**decimals); icoReleaseTokens = 210000000 * (10**decimals); totalSupply = tprFund + founderCoins + icoReleaseTokens; balances[msg.sender] = icoReleaseTokens; Transfer(0, msg.sender, icoReleaseTokens); tprFundDeposit = 0x443174D48b39a18Aae6d7FfCa5c7712B6E94496b; balances[tprFundDeposit] = 0; tprFundReleaseTime = 129600 * 1 minutes; tprFundUnlocked = false; founderCoinsDeposit = 0x703D1d5DFf7D6079f44D6C56a2E455DaC7f2D8e6; balances[founderCoinsDeposit] = 0; founderCoinsReleaseTime = 525600 * 1 minutes; founderCoinsUnlocked = false; }",1
0x6b31a2ef5986d283332e4a3a608adb3c09ffdd13.sol,ERC721,"contract ERC721Holder is IERC721Receiver { function onERC721Received(address, address, uint256, bytes) public returns (bytes4) { return this.onERC721Received.selector; }",1
0x4c1a22be48ef517391a491547389fb5f4f75a885.sol,NEWSOKUCOIN,"contract NEWSOKUCOIN is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 4e10 * 1e18; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function NEWSOKUCOIN() public { balanceOf[msg.sender] = totalSupply; }",1
0x007a422fd7e5b47dd2cb078f250388b406548cd4.sol,PriceUpdate,contract PriceUpdate is Ownable { uint256 public price; function PriceUpdate() { price = 400; },1
0x063425e215701d2761a9065e647fa98f209b4ddd.sol,AffiliateManager,"contract AffiliateManager is Pausable { using SafeMath for uint256; AffiliateTreeStore public affiliateTree; MavinToken public token; uint256 public endTime; uint256 public cap; address public vault; uint256 public mvnpereth; uint256 public mvnperethBonus; uint256 public level1Bonus; uint256 public level2Bonus; uint256 public weiRaised; uint256 public minAmountWei; address creator; function AffiliateManager( address _token, address _treestore ) public { creator = msg.sender; token = MavinToken(_token); endTime = 1536969600; vault = 0xD0b40D3bfd8DFa6ecC0b357555039C3ee1C11202; mvnpereth = 100; mvnperethBonus = 105; level1Bonus = 8; level2Bonus = 4; minAmountWei = 0.01 ether; cap = 32000 ether; affiliateTree = AffiliateTreeStore(_treestore); }",1
0x5270a37951f8c3ff2a99c6fb386cbc2aa63aa709.sol,WTI_301201,"contract WTI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11134262607820500000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4803ead7b2996353373e82f501e1a23a2f892d19.sol,SafeMath,"contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) { if (x > MAX_UINT256 - y) revert(); return x + y; }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0240a41a931a97b5360c0be928a4eadda219bf86.sol,BaseToken,"contract BaseToken is Pausable{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) approvals; event Transfer(address indexed from, address indexed to, uint256 value); event TransferFrom(address indexed approval, address indexed from, address indexed to, uint256 value); event Approval( address indexed owner, address indexed spender, uint value); function BaseToken ( string tokenName, string tokenSymbol ) public { decimals = 18; name = tokenName; symbol = tokenSymbol; }",1
0x0135c9a7bff72aa26e1d105ff5000e454e4dde7a.sol,EthCashonline,contract EthCashonline is Ownable { using SafeMath for uint; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x27de94cb6af1f383430273f44ab4cf4baeb00fc4.sol,METADOLLAR,contract METADOLLAR { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x920c71e8a24dae72a5b30620a348d69f4a1db5bd.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6ac544849414fbafdc0adba7c77bbd73a7d36ac1.sol,KBCC,"contract KBCC is IERC20{ using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; string public name = ; uint8 public decimals = 6; string public symbol = ; uint256 public totalSupply = 1000000000 * (10 ** uint256(decimals)); address private owner; mapping (address => bool) private whiteList; event fallbackTrigged(address indexed _who, uint256 _amount,bytes data); function() public payable {emit fallbackTrigged(msg.sender, msg.value, msg.data);}",1
0x0e72bc5bd98f7a722215c0598bb8d1bb826a745a.sol,WobToken,contract WobToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; bool private changed; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0xf14f06e227c015b398b8069314f4b8d1d7022c9e.sol,Exchange,contract ExchangeCore is ReentrancyGuarded { ERC20 public exchangeToken; ProxyRegistry public registry; mapping(bytes32 => bool) public cancelledOrFinalized; mapping(bytes32 => bool) public approvedOrders; struct Sig { uint8 v; bytes32 r; bytes32 s; },1
0x86b300ef935284a99fa5d148a9a6ccc5103b21a8.sol,CryptoDashtoken,"contract CryptoDashtoken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000000; balances[0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761] = _totalSupply; emit Transfer(address(0), 0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761, _totalSupply); }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,Synthetix,"contract SynthetixState is ISynthetixState, State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; mapping(address => IssuanceData) public issuanceData; uint public totalIssuerCount; uint[] public debtLedger; uint public importedXDRAmount; uint public issuanceRatio = SafeDecimalMath.unit() / 5; uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit(); mapping(address => bytes4) public preferredCurrency; constructor(address _owner, address _associatedContract) State(_owner, _associatedContract) LimitedSetup(1 weeks) public {}",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, withdrawable, Destructible, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x045ce6af36b07f7b1824dfedf43012e60bcc17a1.sol,TCT,"contract TCT is owned, Stopped, MathTCT, TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address from, uint256 value); constructor(string _name, string _symbol) public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _name; symbol = _symbol; }",1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,Treasury,"contract TreasuryEmitter { event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate); event TreasuryWithdrawn(bytes32 userKey, uint value); }",1
0x2733fc7f6a5d5be13b1ffbcfcbcba83241e819c6.sol,MarketplaceCommon,"contract MarketplaceCommon is ResolverClient, ACConditions, DigixConstants { function marketplace_admin_controller() internal constant returns (MarketplaceAdminController _contract) { _contract = MarketplaceAdminController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN)); }",1
0xbd5ff93a6ce6019f0e69227d88d11e5772dc853e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public fundWallet; address public admin; uint256 public rate = 10000; uint256 public amountRaised; bool public crowdsaleOpen; uint256 public cap; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(ERC20 _token, address _fundWallet) public { require(_token != address(0)); require(_fundWallet != address(0)); fundWallet = _fundWallet; admin = msg.sender; token = _token; crowdsaleOpen = true; cap = 20000 * 1 ether; }",1
0xf0186279adcb58b001862bb8df0bd69713b0cdb4.sol,ETH888CrowdsaleS1,"contract ETH888CrowdsaleS1 { using SafeMath for uint256; MintableToken public token; address public wallet; uint256 public rate = 1250; uint public startTimestamp; uint public endTimestamp; uint256 public weiRaised; uint256 public cap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function ETH888CrowdsaleS1(address _wallet) { require(_wallet != 0x0); startTimestamp = 1502409600; endTimestamp = 1506815999; token = createTokenContract(); cap = 8000 ether; wallet = _wallet; }",1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xc599523f90dc823b9c9dbb3859e22774b46bf6ba.sol,DumbCoin,contract DumbCoin { address public owner; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalTokensIssued = 0; uint256 public totalBonusTokensIssued = 0; function name() public constant returns (string) { return ; },1
0x70314cdf964596124f12fa8bd60e5e4668ec75cd.sol,H3D,contract H3D { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,MultiOwnable,contract MultiOwnable { mapping (address => bool) ownerMap; address[] public owners; event OwnerAdded(address indexed _newOwner); event OwnerRemoved(address indexed _oldOwner); modifier onlyOwner() { require(isOwner(msg.sender)); _; },1
0x17c8d8b7659141273a1c2223030c89b96713a44a.sol,XPS,"contract XPS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XPS( ) public { totalSupply = 20000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x189c05c3c191015c694032e1b09c190d5db3fb50.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { using SafeMath for uint256; address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x5b5afaa565aba14833de0cee321e63a807fd407b.sol,TulipMania,"contract TulipMania is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510758000; uint public constant DATE_PRESALE_END = 1511362800; uint public constant DATE_ICO_START = 1511362801; uint public constant DATE_ICO_END = 1513868400; uint public tokensPerEth = 336 * E6; uint public constant BONUS_PRESALE = 100; uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; uint public constant TOKEN_SUPPLY_ICO = 8500000 * E6; uint public constant TOKEN_SUPPLY_MKT = 1500000 * E6; uint public constant PRESALE_ETH_CAP = 750 ether; uint public constant MIN_CONTRIBUTION = 1 ether / 500; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 2 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function TulipMania() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0xc5b4b4a9b3d15d6d7e07922a42bfd6a850777f21.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x65302d3a313cf7b0bc7badbf0b9b07a4f176ed10.sol,CrystalReignShard,contract CrystalReignShard is StandardToken { using SafeMath for uint; string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public preSalePrice; uint256 public preAlphaPrice; uint256 public totalEthInWei; address public fundsWallet; address public dropWallet = 0x88d38F6cb2aF250Ab8f1FA24851ba312b0c48675; address public compWallet = 0xCf794896c1788F799dc141015b3aAae0721e7c27; address public marketingWallet = 0x49cc71a3a8c7D14Bf6a868717C81b248506402D8; uint256 public bonusETH = 0; uint256 public bonusCRS = 0; uint public start = 1519477200; uint public mintCount = 0; function CrystalReignShard() { balances[msg.sender] = 16400000000000000000000000; balances[dropWallet] = 16400000000000000000000000; balances[compWallet] = 16400000000000000000000000; balances[marketingWallet] = 80000000000000000000000; totalSupply = 50000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000; preSalePrice = 2000; preAlphaPrice = 1300; fundsWallet = msg.sender; },1
0x51a5271ec514c3065d9de2d8e95051989f7d53ab.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x40fb95f01d3fa718996107d5bfad0bebd9e8b874); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 12 hours; address constant private reward = 0x6b9E7c45622832A12f728cA87e23FA3A6B512fE2; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0x1acf991d7ced97b558c7a87f4bd7afd75e15fcb7.sol,TIX,"contract TIX is StandardToken, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 3; uint256 internal constant wei_to_token = 10 ** 15; uint256 public rate = 10000; uint256 public minimum = 1 * 10 ** 11; uint256 public wei_raised = 0; uint256 public token_issued = 0; uint256 public start_time = 0; uint256 public end_time = 0; uint256 public period = 0; uint256[] public discount_period; uint256[] public discount; bool public tradeable = false; bool public issuable = false; address internal vault; event LogTokenBought(address indexed sender, address indexed buyer, uint256 value, uint256 tokens, uint256 timestamp); event LogVaultChanged(address indexed new_vault, uint256 timestamp); event LogStarted(uint256 timestamp); event LogTradingEnabled(uint256 timestamp); event LogTradingDisabled(uint256 timestamp); event LogTokenBurned(address indexed burner, uint256 indexed tokens, uint256 timestamp); event LogPreSaled(address indexed buyer, uint256 tokens, uint256 timestamp); event LogDiscountSet(uint256[] indexed period, uint256[] indexed discount, uint256 timestamp); modifier validAddress(address addr) { require(addr != address(0)); _; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,MainBonus,"contract MainBonus is BasicTime,BasicAuth,MainBase,MainCard { uint constant BASERATIO = 10000; struct PlayerBonus { uint m_DrawedDay; uint16 m_DDPermanent; mapping(uint => uint16) m_DayStatic; mapping(uint => uint16) m_DayPermanent; mapping(uint => uint32[]) m_DayDynamic; }",1
0x5c4ed202f136c45509b390b100fae4fddb3c9957.sol,BitQuickpay,contract BitQuickpay is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function BitQuickpay() { balances[msg.sender] = 5000000000000000000000000000; totalSupply = 5000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 20000000; fundsWallet = msg.sender; },1
0xeae2e3259d6d56451f4b3bc957ffbfcfaaebcac4.sol,BasicERC20,"contract BasicERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public isTokenTransferable = true; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function transfer(address _to, uint256 _value) public { assert(isTokenTransferable); assert(balanceOf[msg.sender] >= _value); if (balanceOf[_to] + _value < balanceOf[_to]) throw; balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xe1f2a706155f13b50b5ff79c8ed2bd5e5c4ed817.sol,VexaExchangeToken,"contract VexaExchangeToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd1265bfe57597840f89971b7e67538bac780f9ad.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x2da41c37504ab0509ea4bff4337c92f6a7ba9eb6.sol,GLink,"contract GLink is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 999999999; balances[0x8Ef6628bb931EA2C31c0E591203a9A65A63D22Fd] = _totalSupply; emit Transfer(address(0), 0x8Ef6628bb931EA2C31c0E591203a9A65A63D22Fd, _totalSupply); }",1
0x6c6ee5e31d828de241282b9606c8e98ea48526e2.sol,HoloToken,"contract HoloToken is Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed to, uint256 amount); event MintingFinished(); event Burn(uint256 amount); uint256 public totalSupply; using SafeMath for uint256; mapping(address => uint256) public balances; function transfer(address _to, uint256 _value) public whenMintingFinished returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xf19eac69f9566f0b40660bd0cc16234330f38456.sol,CraftR,"contract CraftRStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function pos() returns (bool); function coinAge() constant returns (uint256); function annualPos() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0xa2f000b776a64770e1a3e1e43e63296f5f029451.sol,chuxinlianContract,"contract chuxinlianContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public CXLExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintCXLToken(msg.sender, (msg.value * CXLExchangeRate * 10**decimals) / etherChange); }",1
0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd.sol,TokenERC20,"contract TokenERC20 is owned{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply=210000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; bool public paused = false; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Seo(address indexed from, uint256 value); function TokenERC20() public { totalSupply = uint256(totalSupply); balanceOf[msg.sender] = totalSupply; name = string(name); symbol = string(symbol); }",1
0xeba4ce0d799fe901f3af52c0e0f088d026b11c81.sol,CFNDCrowdsale,contract CFNDCrowdsale { Token public tokenReward; address public creator; address public owner = 0x56D215183E48881f10D1FaEb9325cf02171B16B7; uint256 private price; modifier isCreator() { require(msg.sender == creator); _; },1
0x28973cb2e33d3cc7401a4d4c35600fe0d81e70e4.sol,EtherGarden,contract EtherGarden{ mapping (uint256 => uint256) public VegetablesTradeBalance; mapping (address => mapping (uint256 => uint256)) public OwnerVegetableStartGrowing; mapping (address => mapping (uint256 => uint256)) public OwnerVegetableFieldSize; mapping (address => address) public Referrals; uint256 VegetableCount=4; uint256 minimum=0.0001 ether; uint256 growingSpeed=86400; uint256 public FreeFieldSize=50; bool public initialized=false; address public coOwner; constructor() public { coOwner=msg.sender; },1
0x26a1cf41dfd4dc609db5a7bf5f8fc53b7c25a396.sol,Owner,contract Owner { address public owner; modifier onlyOwner { require(msg.sender == owner); _;},1
0x2024668c1bbf8f5d381f05d2307daf1f94dcf8df.sol,StagedCrowdsale,contract StagedCrowdsale is Ownable { using SafeMath for uint; struct Milestone { uint period; uint bonus; },1
0x50d751b8705a10bf6636234a279ebf256aac65b5.sol,BigWinToken,"contract BigWinToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public totalDistributedi = 15000000000e8; uint256 public unitsOneEthCanBuy = 20000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x876617584678d5b9a6ef93eba92b408367d9457c.sol,DetherCore,"contract DetherCore is DetherSetup, ERC223ReceivingContract, SafeMath { using BytesLib for bytes; event RegisterTeller(address indexed tellerAddress); event AddFunds(address indexed tellerAddress, uint amount); event DeleteTeller(address indexed tellerAddress); event UpdateTeller(address indexed tellerAddress); event Sent(address indexed _from, address indexed _to, uint amount); event RegisterShop(address shopAddress); event DeleteShop(address shopAddress); event DeleteShopModerator(address indexed moderator, address shopAddress); event DeleteTellerModerator(address indexed moderator, address tellerAddress); modifier tellerHasStaked(uint amount) { require(bank.getDthTeller(msg.sender) >= amount); _; }",1
0x748c6ed3f78f5f06ceb76834f195d3a05b7d628a.sol,POWH33,contract POWH33 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf0790cfb39aca816de8f27069623c40b75db0c31.sol,BurnableCrowdsaleToken,"contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken { function BurnableCrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) { }",1
0x6b683581e66524639cb9444000a7c8b5e10a1a07.sol,Eth5iov_2,"contract Eth5iov_2 { address public advertising; address public admin; address private owner; uint constant public statusFreeEth = 10 finney; uint constant public statusBasic = 50 finney; uint constant public statusVIP = 5 ether; uint constant public statusSVIP = 25 ether; uint constant public dailyPercent = 188; uint constant public dailyFreeMembers = 200; uint constant public denominator = 10000; uint public numerator = 100; uint public dayDepositLimit = 555 ether; uint public freeFund; uint public freeFundUses; uint public round = 0; address[] public addresses; mapping(address => Investor) public investors; bool public resTrigger = true; uint constant period = 5; uint dayDeposit; uint roundStartDate; uint daysFromRoundStart; uint deposit; uint creationDate; enum Status { TEST, BASIC, VIP, SVIP }",1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,SQDExtendedToken,"contract SQDExtendedToken is BurnableToken, UpgradeableToken { string public name; string public symbol; uint8 public decimals; address public owner; bool public mintingFinished = false; mapping(address => uint) public previligedBalances; mapping(address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); event MintFinished(); modifier onlyOwner() { if(msg.sender != owner) revert(); _; }",1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function _burn(address _burner, uint256 _value) internal { require(_value <= balances[_burner]); balances[_burner] = balances[_burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(_burner, _value); Transfer(_burner, address(0), _value); }",1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; EtceteraToken public token; uint256 public startTime; uint256 public endTime; address public fundsWallet; uint256 public rate; uint256 public amountRaised; uint256 public tokenCap; uint256 public bonus; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,EtceteraToken _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = _token; startTime = _startTime; endTime = _endTime; rate = _rate; fundsWallet = _wallet; tokenCap = token.cap(); bonus = 140; }",1
0x46940639ff7122539b71e836eccb08e53b08045d.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0x33d99efc0c3cc4f93da6931ec2cccf19ca874b6d.sol,_0xLitecoinToken,"contract _0xLitecoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; address parentAddress; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xLitecoinToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 4*21000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 27938697607979437428382017032425071986904332731688489302005732; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xb6ed7644c69416d67b522e20bc294a9a9b405b31; }",1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x6f05bf7c8d50079ac864f48480a4e579189de0c6.sol,QIU3D,"contract QIU3Devents { event onNewTicket( address indexed player, uint256 indexed matchId, uint256 indexed ticketId, uint256 fullMatResOpt, uint256 goalsOpt, uint256 gapGoalsOpt, uint256 bothGoalOpt, uint256 halfAndFullMatResOpt, uint256 ticketValue, uint256 cost ); event onNewBet( address indexed player, uint256 indexed matchId, uint256 indexed betId, uint256 option, uint256 odds, uint256 cost ); event onEndMatch( uint256 indexed matchId, uint256 compressData ); event onInvite( address indexed player, address indexed inviter, uint256 profit ); event onWithdraw( address indexed player, uint256 withdraw, uint256 withdrawType ); }",1
0xc7df14a8289efe7a2d3399387302fdf86e7adc4e.sol,IXToken,contract IXToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x5136c98a80811c3f46bdda8b5c4555cfd9f812f0.sol,IndaHashToken,"contract IndaHashToken is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510153200; uint public constant DATE_PRESALE_END = 1510758000; uint public constant DATE_ICO_START = 1511967600; uint public constant DATE_ICO_END = 1513782000; uint public tokensPerEth = 3200 * E6; uint public constant BONUS_PRESALE = 40; uint public constant BONUS_ICO_WEEK_ONE = 20; uint public constant BONUS_ICO_WEEK_TWO = 10; uint public constant TOKEN_SUPPLY_TOTAL = 400 * E6 * E6; uint public constant TOKEN_SUPPLY_ICO = 320 * E6 * E6; uint public constant TOKEN_SUPPLY_MKT = 80 * E6 * E6; uint public constant PRESALE_ETH_CAP = 15000 ether; uint public constant MIN_FUNDING_GOAL = 40 * E6 * E6; uint public constant MIN_CONTRIBUTION = 1 ether / 2; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 90 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function IndaHashToken() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0x41cc97369883a8f58a3e47ec67965d69b302c3a4.sol,Owned,"contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; }",1
0x50d751b8705a10bf6636234a279ebf256aac65b5.sol,BigWinToken,"contract BigWinToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public totalDistributedi = 15000000000e8; uint256 public unitsOneEthCanBuy = 20000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x214f96e84d3c0f2920bb90fec861be4925edf02b.sol,HorseyToken,"contract HorseyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(string _symbol, string _name, uint8 _decimals, uint _totalSupply ) public { symbol = _symbol; name = _name; decimals = _decimals; totalSupply = _totalSupply * 10**uint(_decimals); balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); }",1
0x707784ed2b464474f8fb763c058b33fcf8626db5.sol,Production,contract ProductionBoiler is BasicAuth { struct Boiler { uint m_Expire; uint32[] m_Chips; },1
0x31a240648e2baf4f9f17225987f6f53fceb1699a.sol,SafePromo,"contract SafePromo { string public url = ""https: string public name; string public symbol; address owner; uint256 public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); function SafePromo(string _tokenName, string _tokenSymbol) public { owner = msg.sender; totalSupply = 1; name = _tokenName; symbol = _tokenSymbol; }",1
0x55f93985431fc9304077687a35a1ba103dc1e081.sol,StandardToken,"contract StandardToken is Token,Controlled { function transfer(address _to, uint256 _value) public transferAllowed(msg.sender) returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdb25f211ab05b1c97d595516f45794528a807ad8.sol,AbstractToken,"contract AbstractToken is Token, SafeMath { function AbstractToken () public { }",1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x6ccb56947ea1d6efdc81acfbacd8263ddfa9b202.sol,RKCToken,"contract RKCToken is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; bool public constant TEST_MODE = false; uint public constant atto = 1000000000000000000; uint public constant INITIAL_SUPPLY = 15000000 * atto; address public teamWallet = 0xb79F963f200f85D0e3dD60C82ABB8F80b5869CB9; address public ico_address = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public constant ICO_START_TIME = 1499810400; uint public current_supply = 0; uint public ico_starting_supply = 0; uint public current_price_atto_tokens_per_wei = 0; bool public preSoldSharesDistributed = false; bool public isICOOpened = false; bool public isICOClosed = false; uint[] public premiumPacks; mapping(address => uint) premiumPacksPaid; event ICOOpened(); event ICOClosed(); event PriceChanged(uint old_price, uint new_price); event SupplyChanged(uint supply, uint old_supply); event RKCAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function RKCToken() { distributePreSoldShares(); current_price_atto_tokens_per_wei = calculateCurrentPrice(1); premiumPacks.length = 0; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x01db18f6a474840db3480a6a35227d4d0dfcca37.sol,BPToken,"contract BPToken is SafeMath, Owned, ERC20 { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BPToken() { totalSupply = 2000000000 * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x4720f2468eeb7a795945c5ffbc3b0178e32250e0.sol,PreSale,contract PreSale is EggPurchase { constructor() public { paused = true; },1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0xf04cbb1083138044e84337eb20bb6aef5928a734.sol,CommonCrowdsale,contract CommonCrowdsale is Ownable { using SafeMath for uint256; uint public price = 75000000; uint public constant MIN_INVESTED_ETH = 100000000000000000; uint public constant PERCENT_RATE = 100000000; uint public constant BOUNTY_PERCENT = 1666667; uint public constant REFERER_PERCENT = 500000; address public bountyWallet; address public wallet; uint public start; uint public period; uint public tokensSold; bool isBountyRestriced; GoldMineCoin public token; modifier saleIsOn() { require(now >= start && now < end() && msg.value >= MIN_INVESTED_ETH); require(tokensSold < tokensSoldLimit()); _; },1
0xdcedcc689487b3c767e37cd2f198d40566294b20.sol,TianqibaoTokenERC20,"contract TianqibaoTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TianqibaoTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf04cbb1083138044e84337eb20bb6aef5928a734.sol,CrowdsaleWithNextSaleAgent,contract CrowdsaleWithNextSaleAgent is CommonCrowdsale { address public nextSaleAgent; function setNextSaleAgent(address newNextSaleAgent) public onlyOwner { nextSaleAgent = newNextSaleAgent; },1
0xcf27927ba504d01d7303bc3636b6a7e15d3cffd3.sol,DChat,"contract DChat is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 6000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 2000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd.sol,TokenERC20,"contract TokenERC20 is owned{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply=210000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; bool public paused = false; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Seo(address indexed from, uint256 value); function TokenERC20() public { totalSupply = uint256(totalSupply); balanceOf[msg.sender] = totalSupply; name = string(name); symbol = string(symbol); }",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0xc1456a6bec0b8c8bbe89d5d022fab20b1b3e0e8f.sol,GWCToken,"contract GWCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 900; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x46940639ff7122539b71e836eccb08e53b08045d.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameCore,contract BurnupGameCore is BurnupGameFinance { function BurnupGameCore(address burnupHoldingAddress) public BurnupGameFinance(burnupHoldingAddress) {},1
0x50f0557ae11d55829949bf7af8cd9f69b80a56eb.sol,Pausable,contract Pausable { event Pause(); event Unpause(); bool public paused = false; address public owner; function Pausable(address _owner) { owner = _owner; },1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0b8a682f2bf7afcc2b2c5e2089139c8e28786bf.sol,MultistageCrowdsale,"contract MultistageCrowdsale is DealsSupport, Ownable { using SafeMath for uint256; event TokenPurchase(address indexed purchaser, address indexed affiliate, uint256 value, uint256 amount, bytes4 indexed orderID); struct Stage { uint32 time; uint64 rate; uint256 minInv; uint256 maxInv; }",1
0x0288c13f98d85c817191710be24e96ec75bd9914.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { address[] private _multitokens; AbstractDeployer[] private _deployers; event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); function multitokensCount() public view returns(uint256) { return _multitokens.length; }",1
0x64c14e2c286918803de6d965174ca6bc9048eafa.sol,AuthenticationManager,"contract AuthenticationManager { mapping (address => bool) adminAddresses; mapping (address => bool) accountReaderAddresses; mapping (address => bool) accountMinterAddresses; address[] adminAudit; address[] accountReaderAudit; address[] accountMinterAudit; event AdminAdded(address addedBy, address admin); event AdminRemoved(address removedBy, address admin); event AccountReaderAdded(address addedBy, address account); event AccountReaderRemoved(address removedBy, address account); event AccountMinterAdded(address addedBy, address account); event AccountMinterRemoved(address removedBy, address account); function AuthenticationManager() { adminAddresses[msg.sender] = true; AdminAdded(0, msg.sender); adminAudit.length++; adminAudit[adminAudit.length - 1] = msg.sender; }",1
0x2db426e270cfb46161ffa12e682304a9e442aedd.sol,KYROInv,"contract KYROInv is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 3 * 10**9 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function KYROInv() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0x1f2f65e5fbc46812b058d1979a90abce9734fe24.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; modifier onlyWhileOpen { require( (now >= preICOStartDate && now < preICOEndDate) || (now >= ICOStartDate && now < ICOEndDate) ); _; },1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x35b64d548e00566353d7e60370307619c7c5f408.sol,CoinBundleToken,"contract CoinBundleToken { function add(uint256 x, uint256 y) pure internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x0d15cfff56a4ae7a978955d660bd8e9e5d1d4d9f.sol,VT,"contract VT is owned { string public name; string public symbol; uint8 public decimals=18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x035c5dada99b02a0fbe7bb83012d1edf536f95e5.sol,FastGameMultiplier,"contract FastGameMultiplier { address public support; uint constant public PRIZE_PERCENT = 3; uint constant public SUPPORT_PERCENT = 2; uint constant public MAX_INVESTMENT = 0.2 ether; uint constant public MIN_INVESTMENT = 0.01 ether; uint constant public MIN_INVESTMENT_FOR_PRIZE = 0.02 ether; uint constant public GAS_PRICE_MAX = 20; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public SIZE_TO_SAVE_INVEST = 10; uint constant public TIME_TO_SAVE_INVEST = 5 minutes; uint8[] MULTIPLIERS = [ 115, 120, 125 ]; struct Deposit { address depositor; uint128 deposit; uint128 expect; }",1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4bf32995fe59abc027cc7d3a379ebc2aa0371cb4.sol,RNBToken,"contract RNBToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_PURCHASE = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event StartICO(); event ResetICO(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; bool public icoStart = false; modifier canDistr() { require(!distributionFinished); require(icoStart); _; }",1
0x65302d3a313cf7b0bc7badbf0b9b07a4f176ed10.sol,CrystalReignShard,contract CrystalReignShard is StandardToken { using SafeMath for uint; string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public preSalePrice; uint256 public preAlphaPrice; uint256 public totalEthInWei; address public fundsWallet; address public dropWallet = 0x88d38F6cb2aF250Ab8f1FA24851ba312b0c48675; address public compWallet = 0xCf794896c1788F799dc141015b3aAae0721e7c27; address public marketingWallet = 0x49cc71a3a8c7D14Bf6a868717C81b248506402D8; uint256 public bonusETH = 0; uint256 public bonusCRS = 0; uint public start = 1519477200; uint public mintCount = 0; function CrystalReignShard() { balances[msg.sender] = 16400000000000000000000000; balances[dropWallet] = 16400000000000000000000000; balances[compWallet] = 16400000000000000000000000; balances[marketingWallet] = 80000000000000000000000; totalSupply = 50000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000; preSalePrice = 2000; preAlphaPrice = 1300; fundsWallet = msg.sender; },1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x26b4b55f4d4eea666dfd72998466d3523afc3258.sol,PrivatePreSale,"contract PrivatePreSale is Claimable, KYCWhitelist, Pausable { using SafeMath for uint256; address public constant FUNDS_WALLET = 0xDc17D222Bc3f28ecE7FCef42EDe0037C739cf28f; address public constant TOKEN_WALLET = 0x1EF91464240BB6E0FdE7a73E0a6f3843D3E07601; address public constant TOKEN_ADDRESS = 0x14121EEe7995FFDF47ED23cfFD0B5da49cbD6EB3; address public constant LOCKUP_WALLET = 0xaB18B66F75D13a38158f9946662646105C3bC45D; ERC20 public constant TOKEN = ERC20(TOKEN_ADDRESS); uint256 public constant TOKENS_PER_ETH = 4970; uint256 public constant MAX_TOKENS = 20000000 * (10**18) - 119545639989300000000000; uint256 public constant MIN_TOKEN_INVEST = 4970 * (10**18); uint256 public START_DATE = 1531915200; uint256 public weiRaised; uint256 public tokensIssued; bool public closed; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public { require(TOKENS_PER_ETH > 0); require(FUNDS_WALLET != address(0)); require(TOKEN_WALLET != address(0)); require(TOKEN_ADDRESS != address(0)); require(MAX_TOKENS > 0); require(MIN_TOKEN_INVEST >= 0); }",1
0x58ac2e510e41fd878d81131cf8d87bc09b2a7afd.sol,ExhaustionCoin,"contract ExhaustionCoin is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 500e9 * 1e8; uint256 public distributeAmount = 0; bool public mintingFinished = false; address public Addr1 = 0x68FF231F1AF6e982437a157db8DeddCf91878220; address public Addr2 = 0x97D3b60C2266484F415B7549B8E8fd73a66BF5e7; address public Addr3 = 0xaadA9D72f0b560f47B7e19eE26A6fBB78566CA24; address public Addr4 = 0xE7A55Cf0642A497921b67893D5a7cDF51B389f46; address public Addr5 = 0x55BA76b349669fF87367D98e7767C38396677aA3; address public Addr6 = 0xedF3dC209d58f7C05b7f5dC807F28A2835bC987a; address public Addr7 = 0x19839dC3b6981Fc511dc00fEc42C5aE549Eb51cD; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ExhaustionCoin() public { owner = Addr1; balanceOf[Addr1] = totalSupply.mul(20).div(100); balanceOf[Addr2] = totalSupply.mul(10).div(100); balanceOf[Addr3] = totalSupply.mul(10).div(100); balanceOf[Addr4] = totalSupply.mul(20).div(100); balanceOf[Addr5] = totalSupply.mul(20).div(100); balanceOf[Addr6] = totalSupply.mul(10).div(100); balanceOf[Addr7] = totalSupply.mul(10).div(100); }",1
0xd81ada188331e627567bbef80f91217cd3109592.sol,ExternStateToken,"contract ExternStateToken is SelfDestructible, Proxyable { using SafeMath for uint; using SafeDecimalMath for uint; TokenState public tokenState; string public name; string public symbol; uint public totalSupply; uint8 public decimals; constructor(address _proxy, TokenState _tokenState, string _name, string _symbol, uint _totalSupply, uint8 _decimals, address _owner) SelfDestructible(_owner) Proxyable(_proxy, _owner) public { tokenState = _tokenState; name = _name; symbol = _symbol; totalSupply = _totalSupply; decimals = _decimals; }",1
0x00763473e9d7c82f38ed843f021e2558d7422ad8.sol,Blacklist,"contract Blacklist is BurnableToken, Ownable { mapping (address => bool) public blacklist; event DestroyedBlackFunds(address _blackListedUser, uint _balance); event AddedBlackList(address _user); event RemovedBlackList(address _user); function isBlacklisted(address _maker) public view returns (bool) { return blacklist[_maker]; }",1
0xc094d10e8c0f5f507bb986f01b0c44a83cbf8440.sol,Crowdsale,"contract Crowdsale is Ownable, RateSetter { using SafeMath for uint256; ERC20 public token; CCWhitelist public whitelist; uint256 public startTimePre; uint256 public endTimePre; uint256 public startTimeIco; uint256 public endTimeIco; address public wallet; uint32 public ethEurRate; uint32 public btcEthRate; uint256 public tokensSoldPre; uint256 public tokensSoldIco; uint256 public weiRaised; uint256 public eurRaised; uint256 public contributions; uint256 public preCap; uint8 public preDiscountPercentage; uint256 public icoPhaseAmount1; uint256 public icoPhaseAmount2; uint256 public icoPhaseAmount3; uint256 public icoPhaseAmount4; uint8 public icoPhaseDiscountPercentage1; uint8 public icoPhaseDiscountPercentage2; uint8 public icoPhaseDiscountPercentage3; uint8 public icoPhaseDiscountPercentage4; uint32 public HARD_CAP_EUR = 19170000; uint32 public SOFT_CAP_EUR = 2000000; uint256 public HARD_CAP_IN_TOKENS = 810 * 10**24; mapping (address => uint) public contributors; function Crowdsale(uint256 _startTimePre, uint256 _endTimePre, uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress) { require(_startTimePre >= now); require(_endTimePre >= _startTimePre); require(_startTimeIco >= _endTimePre); require(_endTimeIco >= _startTimeIco); require(_ethEurRate > 0 && _btcEthRate > 0); require(_wallet != address(0)); require(_tokenAddress != address(0)); require(_whitelistAddress != address(0)); startTimePre = _startTimePre; endTimePre = _endTimePre; startTimeIco = _startTimeIco; endTimeIco = _endTimeIco; ethEurRate = _ethEurRate; btcEthRate = _btcEthRate; wallet = _wallet; token = ERC20(_tokenAddress); whitelist = CCWhitelist(_whitelistAddress); preCap = 90 * 10**24; preDiscountPercentage = 50; icoPhaseAmount1 = 135 * 10**24; icoPhaseAmount2 = 450 * 10**24; icoPhaseAmount3 = 135 * 10**24; icoPhaseAmount4 = 90 * 10**24; icoPhaseDiscountPercentage1 = 40; icoPhaseDiscountPercentage2 = 30; icoPhaseDiscountPercentage3 = 20; icoPhaseDiscountPercentage4 = 0; }",1
0xf2f5c8edb8067c514e257470665a8b27615aad85.sol,SafeBlocksFirewall,"contract SafeBlocksFirewall { event AllowTransactionEnquireResult(address sourceAddress, bool approved, address token, uint amount, address destination, string msg); event AllowAccessEnquireResult(address sourceAddress, bool approved, address destination, bytes4 functionSig, string msg); event PolicyChanged(address contractAddress, address destination, address tokenAdress, uint limit); event AccessChanged(address contractAddress, address destination, bytes4 functionSig, bool hasAccess); event ConfigurationChanged(address sender, address newConfiguration, string message); enum PolicyType { Transactions, Access }",1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xf0150cec4fe8477d039c4b4e679c040480763170.sol,HumanRegistry,"contract HumanRegistry { event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data); event _Challenge(bytes32 indexed listingHash, uint challengeID, uint deposit, string data); event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal); event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal); event _ApplicationWhitelisted(bytes32 indexed listingHash); event _ApplicationRemoved(bytes32 indexed listingHash); event _ListingRemoved(bytes32 indexed listingHash); event _ListingWithdrawn(bytes32 indexed listingHash); event _TouchAndRemoved(bytes32 indexed listingHash); event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _RewardClaimed(uint indexed challengeID, uint reward, address voter); event _ListingMigrated(bytes32 indexed listingHash, address newRegistry); using SafeMath for uint; struct Listing { uint applicationExpiry; bool whitelisted; address owner; uint unstakedDeposit; uint challengeID; }",1
0x72fa6623cc0800bc180639d60c33c95426d76576.sol,KassaNetwork,"contract KassaNetwork is Ownable { using SafeMath for uint; string public constant name = ; uint public startTimestamp = now; uint public constant procKoef = 10000; uint public constant perDay = 75; uint public constant ownerFee = 700; uint[3] public bonusReferrer = [500, 200, 100]; uint public constant procReturn = 9000; uint public constant maxDepositDays = 200; uint public constant minimalDeposit = 0.5 ether; uint public constant maximalDepositStart = 30 ether; uint public constant maximalDepositFinish = 100 ether; uint public constant minimalDepositForBonusReferrer = 0.015 ether; uint public constant dayLimitStart = 50 ether; uint public constant progressProcKoef = 100; uint public constant dayLimitProgressProc = 2; uint public constant maxDepositProgressProc = 1; uint public countInvestors = 0; uint public totalInvest = 0; uint public totalPenalty = 0; uint public totalSelfInvest = 0; uint public totalPaid = 0; uint public unlimitedInvest = 3000 ether; bool public isUnlimitedContractInvest = false; bool public isUnlimitedDayInvest = false; event LogInvestment(address _addr, uint _value, bytes _refData); event LogTransfer(address _addr, uint _amount, uint _contactBalance); event LogSelfInvestment(uint _value); event LogPreparePayment(address _addr, uint _totalInteres, uint _paidInteres, uint _amount); event LogSkipPreparePayment(address _addr, uint _totalInteres, uint _paidInteres); event LogPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals, uint _amount); event LogSkipPreparePaymentReferrer(address _addr, uint _totalReferrals, uint _paidReferrals); event LogNewReferralAtLevel(address _addr, uint[3] _levels); event LogMinimalDepositPayment(address _addr, uint _money, uint _totalPenalty); event LogPenaltyPayment(address _addr, uint currentSenderDeposit, uint referrerAdressLength, address _referrer, uint currentReferrerDeposit, uint _money, uint _sendBackAmount, uint _totalPenalty); event LogExceededRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _badDeposit, uint _sendBackAmount, uint _totalPenalty, uint _willDeposit); event LogUsedRestDepositPerDay(address _addr, address _referrer, uint _money, uint _nDay, uint _restDepositPerDay, uint _realDeposit, uint _usedDepositPerDay); event LogCalcBonusReferrer(address _referrer, uint _money, uint _index, uint _bonusReferrer, uint _amountReferrer, address _nextReferrer); struct User { uint balance; uint paidInteres; uint timestamp; uint countReferrals; uint[3] countReferralsByLevel; uint earnOnReferrals; uint paidReferrals; address referrer; }",1
0xe1e83a85c9db1bbd7cfab3e6bffaf255c5013adb.sol,BasicMultiToken,"contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken { using CheckedERC20 for ERC20; ERC20[] public tokens; uint internal inLendingMode; bool public bundlingDenied; event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); event BundlingDenied(bool denied); modifier notInLendingMode { require(inLendingMode == 0, ); _; }",1
0x1eebb0f896a8995aa95954a0870dc520eedc891f.sol,CNYTokenPlus,contract CNYTokenPlus is StandardToken { function () { throw; },1
0xa589fb6491d807d95b6a3750d9faf60a23df78d3.sol,AviciiCoin,contract AviciiCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x4ed792a66f2b4cf51671c42137dff7f8703b0875.sol,EDT,"contract EDT is SafeMath,owned{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); event Burn(address indexed from, uint256 value); function EDT() { decimals = 18; totalSupply = 1000000000 * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1ed3099df8a56c447e7c20d08572413f15fe760e.sol,ECT,contract ECT { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x0f43093b586b011258479e61d41a862e909386e0.sol,PO8BaseToken,"contract PO8BaseToken is ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 totalSupply_; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public{ name = _name; symbol = _symbol; decimals = _decimals; totalSupply_ = _totalSupply; }",1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x18035ee31125a9934de44b0105cd31691cce95d5.sol,BigBoobsToken,"contract BigBoobsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BigBoobsToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5] = _totalSupply; Transfer(address(0), 0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5, _totalSupply); }",1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,CappedCrowdsale,contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; },1
0xc6b48b87106752234343bad751771fec5fe7bdb8.sol,SOLARCHAINToken,"contract SOLARCHAINToken is ERC20 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function SOLARCHAINToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0xd47c54b18731ef523498ff44e5301041b231be7c.sol,LockToken,contract LockToken is BaseToken { struct LockItem { uint256 endtime; uint256 remain; },1
0x32f1c992a32376fa0f723aecaa247119d3f7f8bd.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x4b577405017f82b098cf4ab0de38979b6d2fe5ae.sol,MainContract,contract MainContract { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x64c14e2c286918803de6d965174ca6bc9048eafa.sol,AuthenticationManager,"contract AuthenticationManager { mapping (address => bool) adminAddresses; mapping (address => bool) accountReaderAddresses; mapping (address => bool) accountMinterAddresses; address[] adminAudit; address[] accountReaderAudit; address[] accountMinterAudit; event AdminAdded(address addedBy, address admin); event AdminRemoved(address removedBy, address admin); event AccountReaderAdded(address addedBy, address account); event AccountReaderRemoved(address removedBy, address account); event AccountMinterAdded(address addedBy, address account); event AccountMinterRemoved(address removedBy, address account); function AuthenticationManager() { adminAddresses[msg.sender] = true; AdminAdded(0, msg.sender); adminAudit.length++; adminAudit[adminAudit.length - 1] = msg.sender; }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,KydyAuction,contract KydyAuction is KydySynthesis { SaleAuction public saleAuction; SynthesizingAuction public synthesizingAuction; function setSaleAuctionAddress(address _address) external onlyCEO { SaleAuction candidateContract = SaleAuction(_address); require(candidateContract.isSaleAuction()); saleAuction = candidateContract; },1
0x8ae546782bd5c25715afaffb028ce9ee2cbe7bec.sol,NSCDistributionContract,"contract NSCDistributionContract is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _initialDistribution; uint private _totalSupply; uint256 public unitsOneEthCanBuy; uint256 private totalEthInWei; address private fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NSCDistributionContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); _initialDistribution = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 692; fundsWallet = msg.sender; }",1
0x46b9ad944d1059450da1163511069c718f699d31.sol,CREDITS,"contract CREDITS is Ownable{ string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; uint public TotalHoldersAmount; bool public Frozen=true; bool public CanChange=true; address public Admin; address public AddressForReturn; address[] Accounts; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address => bool) public AccountIsFrozen; mapping(address => bool) public AccountIsNotFrozen; mapping(address => bool) public AccountIsNotFrozenForReturn; mapping(address => uint) public AccountIsFrozenByDate; mapping (address => bool) public isHolder; mapping (address => bool) public isArrAccountIsFrozen; mapping (address => bool) public isArrAccountIsNotFrozen; mapping (address => bool) public isArrAccountIsNotFrozenForReturn; mapping (address => bool) public isArrAccountIsFrozenByDate; address [] public Arrholders; address [] public ArrAccountIsFrozen; address [] public ArrAccountIsNotFrozen; address [] public ArrAccountIsNotFrozenForReturn; address [] public ArrAccountIsFrozenByDate; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint256 value); modifier IsNotFrozen{ require(((!Frozen&&AccountIsFrozen[msg.sender]!=true)||((Frozen)&&AccountIsNotFrozen[msg.sender]==true))&&now>AccountIsFrozenByDate[msg.sender]); _; }",1
0x3779d960261f882750b39c622527822c88c98e13.sol,SafeMath,"contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; require(a == 0 || c / a == b); return c; }",1
0x6970bbe0df628b1e2dce874daaa529c0ceff54ff.sol,XVOToken,"contract XVOToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed = 500000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 10000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsStorage,contract EthernautsStorage is EthernautsAccessControl { function EthernautsStorage() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; },1
0x6b87999be87358065bbde41e8a0fe0b7b1cd2514.sol,TeslaWatt,"contract TeslaWatt is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x36f6a1353a3e1c008782e86bfe551c6f8b8c3370.sol,Shadow3D,contract Shadow3D { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xb4007597da3402a1e2b69c8e1c6dd753d01a8035.sol,FundingManager,"contract FundingManager is ApplicationAsset { ABIFunding FundingEntity; ABITokenManager TokenManagerEntity; ABIToken TokenEntity; ABITokenSCADAVariable TokenSCADAEntity; ABIProposals ProposalsEntity; ABIMilestones MilestonesEntity; uint256 public LockedVotingTokens = 0; event EventFundingManagerReceivedPayment(address indexed _vault, uint8 indexed _payment_method, uint256 indexed _amount ); event EventFundingManagerProcessedVault(address _vault, uint256 id ); mapping (address => address) public vaultList; mapping (uint256 => address) public vaultById; uint256 public vaultNum = 0; function setAssetStates() internal { EntityStates[] = 0; EntityStates[] = 1; EntityStates[] = 2; EntityStates[] = 10; EntityStates[] = 11; EntityStates[] = 12; EntityStates[] = 20; EntityStates[] = 21; EntityStates[] = 22; EntityStates[] = 25; EntityStates[] = 30; EntityStates[] = 31; EntityStates[] = 32; EntityStates[] = 40; EntityStates[] = 41; EntityStates[] = 42; EntityStates[] = 100; EntityStates[] = 101; EntityStates[] = 102; RecordStates[] = 0; }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,Synthetix,"contract SynthetixState is ISynthetixState, State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; mapping(address => IssuanceData) public issuanceData; uint public totalIssuerCount; uint[] public debtLedger; uint public importedXDRAmount; uint public issuanceRatio = SafeDecimalMath.unit() / 5; uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit(); mapping(address => bytes4) public preferredCurrency; constructor(address _owner, address _associatedContract) State(_owner, _associatedContract) LimitedSetup(1 weeks) public {}",1
0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8.sol,DailyDivs,contract DailyDivs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd403cc1e2da3aa7d954e0ad34bef2df2b9a9f238.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Functions,contract Functions { bytes32[] public randomHashes; function fillWithHashes() public { require(randomHashes.length == 0); for (uint i = block.number - 100; i < block.number; i++) { randomHashes.push(blockhash(i)); },1
0x69b5357d893fce82248e83ccd9b0871f5d5d9461.sol,CardboardUnicorns,"contract CardboardUnicorns { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 0; uint public totalSupply = 0; mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; address public owner = msg.sender; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event Minted(address indexed owner, uint value); modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,ERC721BasicToken,contract ERC721BasicToken is ERC721Basic { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; },1
0x70dea95c5e56792a70d357f3e1b2f11e35c4c277.sol,VOCC_I077_20181211,"contract VOCC_I077_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf15f61643eea73be40ad9b72c09ed381fac7a256.sol,FishbankBoosters,contract FishbankBoosters is Ownable { struct Booster { address owner; uint32 duration; uint8 boosterType; uint24 raiseValue; uint8 strength; uint32 amount; },1
0xc398891b43f1b91158dca87c63a88b80d000c248.sol,IBIT,"contract IBIT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000021e8; uint public target0drop = 5000000; uint public progress0drop = 0; address multisig = 0x723D0666908ADdc626C29407F0B5e7C0881b5185; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x20b2ec1fe89c6977f6c1f9e5b7d5475f588186bd.sol,BitGuildTrade,"contract BitGuildTrade is AccessAdmin { BitGuildTokenInterface public tokenContract; CardsInterface public cards ; GameConfigInterface public schema; RareInterface public rare; function BitGuildTrade() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e4c0f93cfa81ce9ab66bf07dd9264957d1ca10c.sol,FomoSuper,"contract FomoSuper is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xB2b3d6feAE1AB2af4a07Cf4C047D69aa01D809Aa); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 8 minutes; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(22,6); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(52,10); fees_[3] = F3Ddatasets.TeamFee(68,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,QuantstampBountyData,contract QuantstampBountyData is Whitelist { using SafeMath for uint256; using LinkedListLib for LinkedListLib.LinkedList; uint256 constant internal NULL = 0; uint256 constant internal HEAD = 0; bool constant internal PREV = false; bool constant internal NEXT = true; uint256 constant internal NUMBER_OF_PHASES = 3; struct Bounty { address submitter; string contractAddress; uint256 size; uint256 minVotes; uint256 duration; uint256 judgeDeposit; uint256 hunterDeposit; uint256 initiationTimestamp; bool remainingFeesWithdrawn; uint256 numApprovedBugs; },1
0x1d97bccc6296aac6f0be796c7e8cb270eca4c6c6.sol,AquaToken,"contract AquaToken is Owned, Token { using SafeMath for uint256; using LibHoldings for LibHoldings.Holding; using LibHoldings for LibHoldings.HoldingsSet; using LibRedemptions for LibRedemptions.Redemption; using LibRedemptions for LibRedemptions.RedemptionsQueue; struct DistributionContext { uint distributionAmount; uint receivedRedemptionAmount; uint redemptionAmount; uint tokenPriceWei; uint currentRedemptionId; uint totalRewardAmount; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,Limited,"contract Limited is Managed { using SafeMath for uint256; mapping(address => uint256) public limitsList; modifier isLimited(address _payee) { require(limitsList[_payee] > 0, ); _; }",1
0xf300cc72613d575a4567405c2a07d2aaf182aebf.sol,StasyqToken,contract StasyqToken is MintableToken { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; address public saleAgent; mapping (address => uint) public locked; mapping(address => bool) public registeredCallbacks; modifier canTransfer() { require(msg.sender == owner || msg.sender == saleAgent || mintingFinished); _; },1
0xa38feb7b0aaad949a1b99ff516d4e3ea2e317bbf.sol,FastBetMultiplier05eth,contract FastBetMultiplier05eth { address public support; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,CappedToken,contract CappedToken is MintableToken { uint256 public cap; function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; },1
0xefab2a9292a10036006e7a68535724ade16a65ca.sol,EOSpace,"contract EOSpace is ERC20 { using SafeMath for uint256; address owner = msg.sender; address EOSContract = 0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x741fc999f5b62c80831cf659aed04c64ac8ef24e.sol,Crowdsale,"contract Crowdsale is SafeMath { address public tokenOwner; uint constant public fundingGoal = 672000000000; uint constant public softCap = 6720000000000; uint constant public maxGoal = 20120000000000; uint public amountRaised; uint public start; uint public end; uint public timeAfterSoftCap; uint public tokensSold = 0; uint constant public rateSoft = 24; uint constant public rateHard = 20; uint constant public rateCoefficient = 100000000000; token public tokenReward; mapping(address => uint) public balanceOf; bool public crowdsaleClosed = false; address msWallet; event GoalReached(address _tokenOwner, uint _amountRaised); event FundTransfer(address backer, uint amount, bool isContribution, uint _amountRaised); function Crowdsale( address _tokenAddr, address _walletAddr, address _tokenOwner, uint _start, uint _end, uint _timeAfterSoftCap) { tokenReward = token(_tokenAddr); msWallet = _walletAddr; tokenOwner = _tokenOwner; require(_start < _end); start = _start; end = _end; timeAfterSoftCap = _timeAfterSoftCap; }",1
0x6ff73ee2255c30e072d35598f9b06795122d4e64.sol,DigitalEnthusiasts,"contract DigitalEnthusiasts is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public decimalsValue = 1e18; uint256 public totalSupply = 1000000000*decimalsValue; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); bool public distributionFinished = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); modifier canDistr() { assert(!distributionFinished); _; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,BinaryOption,"contract BinaryOption { address public namiCrowdSaleAddr; address public escrow; address public namiMultiSigWallet; Session public session; uint public timeInvestInMinute = 30; uint public timeOneSession = 180; uint public sessionId = 1; uint public rate = 190; uint public constant MAX_INVESTOR = 20; event SessionOpen(uint timeOpen, uint indexed sessionId); event InvestClose(uint timeInvestClose, uint priceOpen, uint indexed sessionId); event Invest(address indexed investor, bool choose, uint amount, uint timeInvest, uint indexed sessionId); event SessionClose(uint timeClose, uint indexed sessionId, uint priceClose, uint nacPrice, uint rate); event Deposit(address indexed sender, uint value); function() public payable { if (msg.value > 0) Deposit(msg.sender, msg.value); }",1
0x448019c21743272e40eb8835dac2a7d5474899bf.sol,Pausable,contract Pausable is Ownable { event Unpause(); bool public paused = true; modifier whenNotPaused() { require(!paused); _; },1
0x4d5c907a460b0844cc99b95003819c2aa2b2b77a.sol,RealEstateDirectIncome,"contract RealEstateDirectIncome is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address private admin; bool public transferEnabled = true; function RealEstateDirectIncome() { totalSupply = 32000000000000000000000000000 ; balances[msg.sender] = totalSupply; Transfer(address(0x0), msg.sender, totalSupply); admin = msg.sender; transferOwnership(admin); }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xdb1f3030532a593a733f8ae6fce310aa91ac3a17.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2773c69d7a7e2943f6e27c9947d5ae4e2b853993.sol,EtherDiamond,"contract EtherDiamond is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 28000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x075a5d77e17502aba0388746aa229bb33682f521.sol,TopCoinDistribution,"contract TopCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event TokenSold(address recipient, uint ether_amount, uint pay_amount, uint exchangerate); event AuthorizedCreate(address recipient, uint pay_amount); event TopCoinSaleClosed(); TopCoin public token = new TopCoin(); address public multisigVault; uint public hardcap = 87500 ether; uint public rate = 3600*(10 ** 6); uint totalToken = 2100000000 * (10 ** 6); uint public authorizeMintToken = 210000000 * (10 ** 6); uint public altDeposits = 0; uint public start = 1504008000; address partenersAddress = 0x6F3c01E350509b98665bCcF7c7D88C120C1762ef; address operationAddress = 0xb5B802F753bEe90C969aD27a94Da5C179Eaa3334; address technicalAddress = 0x62C1eC256B7bb10AA53FD4208454E1BFD533b7f0; modifier saleIsOn() { require(now > start && now < start + 28 days); _; }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,I_coin,"contract I_coin is mortal { event EventClear(); I_minter public mint; string public name; uint8 public decimals=18; string public symbol; string public version = ; function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}",1
0xe31ced3343f21e5cad5d31163bba5899ee01d813.sol,ERC20_CRYPTOMILLION_CPMN,"contract ERC20_CRYPTOMILLION_CPMN { string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function CreateTokenERC20(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0xa5816b5fdba5ee1d983a94f156651c9dcc42850a.sol,ANBXToken,"contract ANBXToken is IERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public constant decimals = 18; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 2000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() public { balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x19055b944806fba2717dc694cf0173a1eb2d1604.sol,C3Wallet,"contract C3Wallet is ERC223, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5e10 * 1e8; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; constructor() public { balances[msg.sender] = totalSupply; }",1
0xd634fcd4e073ec169d74fc9b0898d527865ee698.sol,Heaven3D,"contract Heaven3D is modularLong { using SafeMath for *; using NameFilter for string; using H3DKeysCalcLong for uint256; TeamDreamHubInterface public TeamDreamHub_; PlayerBookInterface public PlayerBook; string constant public name = ; string constant public symbol = ; address private owner; uint256 constant private rndExtra_ = 0 hours; uint256 constant private rndGap_ = 0 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndDeciExt_ = 360 seconds; uint256 constant private rndMax_ = 24 hours; uint256 constant private rule_limit_latestPlayersCnt = 10; uint256 constant private rule_limit_heavyPlayersCnt = 10; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; bool public noMoreNextRound_ = false; uint256 public randomDecisionPhase_ = 100; bool private endRoundDecisionResult_ = false; address private address_of_last_rand_gen_source_ = address(0); mapping (uint256 => bool) pPAIDxID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => H3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => H3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => H3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; constructor(address _TeamDreamHubSCaddress, address _PlayerBookSCaddress) public { owner = msg.sender; TeamDreamHub_ = TeamDreamHubInterface(_TeamDreamHubSCaddress); PlayerBook = PlayerBookInterface(_PlayerBookSCaddress); }",1
0x6b609d9095d069c805650234ab67595b3a6ab934.sol,Crowdsale,"contract CrowdsaleProxy is ICrowdsaleProxy { address public owner; ICrowdsale public target; function CrowdsaleProxy(address _owner, address _target) public { target = ICrowdsale(_target); owner = _owner; }",1
0x46b9ad944d1059450da1163511069c718f699d31.sol,CREDITS,"contract CREDITS is Ownable{ string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; uint public TotalHoldersAmount; bool public Frozen=true; bool public CanChange=true; address public Admin; address public AddressForReturn; address[] Accounts; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address => bool) public AccountIsFrozen; mapping(address => bool) public AccountIsNotFrozen; mapping(address => bool) public AccountIsNotFrozenForReturn; mapping(address => uint) public AccountIsFrozenByDate; mapping (address => bool) public isHolder; mapping (address => bool) public isArrAccountIsFrozen; mapping (address => bool) public isArrAccountIsNotFrozen; mapping (address => bool) public isArrAccountIsNotFrozenForReturn; mapping (address => bool) public isArrAccountIsFrozenByDate; address [] public Arrholders; address [] public ArrAccountIsFrozen; address [] public ArrAccountIsNotFrozen; address [] public ArrAccountIsNotFrozenForReturn; address [] public ArrAccountIsFrozenByDate; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint256 value); modifier IsNotFrozen{ require(((!Frozen&&AccountIsFrozen[msg.sender]!=true)||((Frozen)&&AccountIsNotFrozen[msg.sender]==true))&&now>AccountIsFrozenByDate[msg.sender]); _; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,FlowerAuction,contract FlowerAuction is FlowerBreeding { function setSaleAuctionAddress(address _address) external onlyAdministrator { SaleClockAuction candidateContract = SaleClockAuction(_address); require(candidateContract.isSaleClockAuction()); saleAuction = candidateContract; },1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0x5ca7099611020d9234c7191c7b066779128e715c.sol,VanityURL,"contract VanityURL is Ownable,Pausable { Token public tokenAddress; mapping (string => address) vanity_address_mapping; mapping (address => string ) address_vanity_mapping; uint256 public reservePricing; address public transferTokenTo; function VanityURL(address _tokenAddress, uint256 _reservePricing, address _transferTokenTo){ tokenAddress = Token(_tokenAddress); reservePricing = _reservePricing; transferTokenTo = _transferTokenTo; }",1
0xee610919f8c9f2e29464ceceb3176ae1f1922ec4.sol,SingleSourceIdentity,"contract SingleSourceIdentity is SafeMath { event IdentityApproval(address indexed authority, address indexed walletAddress, uint verifiedAttributes); event IdentityRevoke(address indexed authority, address indexed walletAddress); struct KYC { bool verified; address verifiedBy; uint verifiedAt; uint verifiedAttributes; }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,KydyAuction,contract KydyAuction is KydySynthesis { SaleAuction public saleAuction; SynthesizingAuction public synthesizingAuction; function setSaleAuctionAddress(address _address) external onlyCEO { SaleAuction candidateContract = SaleAuction(_address); require(candidateContract.isSaleAuction()); saleAuction = candidateContract; },1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x74a31dc20802cb1e41201af055ce7dfcd31d291d.sol,m10fanclub,"contract m10fanclub is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function m10fanclub() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 12 weeks; endDate = now + 52 weeks; }",1
0x0279f2882d32f19661649535d802a8df9efd7d6f.sol,TeaVoucher,"contract TeaVoucher { mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; using SafeMath for uint256; address public owner; uint256 public _totalSupply = 36936; uint256 public totalSupply = 36936; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint256 public constant RATE = 200; function TeaVoucher( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = 36936; totalSupply = _initialAmount; }",1
0x70965361f143d268342c84b4d6f7c41b438cd5d7.sol,LuckcoinContract,"contract LuckcoinContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public LKCExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintLKCToken(msg.sender, (msg.value * LKCExchangeRate * 10**decimals) / etherChange); }",1
0x8b26a81522747bc66be1261eaac3091c6fff0d6d.sol,Distribution,contract Distribution is Ownable { using SafeMath for uint256; struct Recipient { address addr; uint256 share; uint256 balance; uint256 received; },1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x2e7c2e45eb417a76132b7c1fd0be00875be8a00d.sol,TimeChip,contract TimeChip { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x68e9872cc009179101b97a9533e5c16105e7fafb.sol,BondToken,"contract BondToken is ERC20 { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; address public owner; address public controller; address public airDropManager; event LogBuyForInvestor(address indexed investor, uint value, string txHash); event Burn(address indexed from, uint value); event Mint(address indexed to, uint value); bool public tokensAreFrozen = true; modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,FlowerCore,"contract FlowerCore is FlowerAuction, Ownable { uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; uint256 public constant GEN0_STARTING_PRICE = 10 finney; uint256 public constant GEN0_AUCTION_DURATION = 1 days; uint256 public promoCreatedCount; uint256 public gen0CreatedCount; constructor() public { stopped = true; rootAddress = msg.sender; adminAddress = msg.sender; _createFlower(0, 0, 0, uint256(-1), address(0)); }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,ERC721Holder,"contract ERC721Holder is ERC721TokenReceiver { function onERC721Received(address, address, uint256, bytes) public returns (bytes4) { return this.onERC721Received.selector; }",1
0x518888b328d61d09a92d01d462031f4cf8c550df.sol,HONGMEN,"contract HONGMEN is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000; event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp); function HONGMEN() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; }",1
0xeb2b6b3f3fa0ea711ceb2ed77a23baeaf5ac0796.sol,Ciphs,"contract Ciphs is Standard223Receiver, Standard223Token, Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public rate = 1000000; bool propose = false; uint256 prosposal_time = 0; uint256 raisedAmount = 0; uint256 public constant INITIAL_SUPPLY = 7000000e18; uint256 public constant MAX_SUPPLY = 860000000000e18; address[] investors; uint256 up = 0; uint256 down = 0; mapping(address => uint256) votes; mapping (address => mapping (address => uint256)) public trackable; mapping (address => mapping (uint => uint256)) public trackable_record; mapping (address => uint256) public bannable; mapping (address => uint256) internal support_ban; mapping (address => uint256) internal against_ban; event BoughtTokens(address indexed to, uint256 value); event Votes(address indexed owner, uint256 value); event Burn(address indexed burner, uint256 value); event Mint(uint256 value); function Ciphs() public { _totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0xe0d9460356ee91d224a0c4ec05afb6fb186c3c0e.sol,ChainToken,"contract ChainToken is ERC20,Ownable { using SafeMath for uint256; string public name; string public symbol; uint8 public constant decimals = 18; address[] private walletArr; uint walletIdx = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; event TokenPurchase(address indexed purchaser, uint256 value,uint256 amount); event FundTransfer(address fundWallet, uint256 amount); function ChainToken( ) public { totalSupply = 6000000000*(10**18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; walletArr.push(0x0AD8869081579E72eb4E0B90394079e448E4dF49); }",1
0x6dd071cedf8b1a80a5ed1bd43af2ad53cb0942e5.sol,RaceCoin,"contract RaceCoin is ERC20, AccessAdmin, IRaceCoin { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalRaceCoinProduction; uint256 public bonusDivPercent = 20; uint256 constant refererPercent = 5; address[] public playerList; uint256 public totalEtherPool; uint256[] private totalRaceCoinProductionSnapshots; uint256[] private allocatedRaceCoinSnapshots; uint256[] private totalRaceCoinSnapshots; uint256 public nextSnapshotTime; mapping(address => uint256) private ethBalance; mapping(address => uint256) private raceCoinBalance; mapping(address => uint256) private refererDivsBalance; mapping(address => uint256) private productionBaseValue; mapping(address => uint256) private productionMultiplier; mapping(address => uint256) private attackBaseValue; mapping(address => uint256) private attackMultiplier; mapping(address => uint256) private attackPower; mapping(address => uint256) private defendBaseValue; mapping(address => uint256) private defendMultiplier; mapping(address => uint256) private defendPower; mapping(address => uint256) private plunderBaseValue; mapping(address => uint256) private plunderMultiplier; mapping(address => uint256) private plunderPower; mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots; mapping(address => uint256) private lastRaceCoinSaveTime; mapping(address => uint256) public lastRaceCoinProductionUpdate; mapping(address => uint256) private lastRaceCoinFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address referal, address player, uint256 amount); event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder); mapping (address => bool) actionContracts; function setActionContract(address _actionAddr, bool _useful) external onlyAdmin { actionContracts[_actionAddr] = _useful; }",1
0x266be180f1bdda078b677c5d1c050268929f0da3.sol,CASINO_301201,"contract CASINO_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10990099143654100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0xd9485499499d66b175cf5ed54c0a19f1a6bcb61a.sol,ERC20Token,contract ERC20Token { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x1d556d7fb1af721da8b9c30d44f6d4a52f8e0ba2.sol,Token,"contract TokenI is ERC20Token { string public name; uint8 public decimals; string public symbol; function approveAndCall( address _spender, uint256 _amount, bytes _extraData ) public returns (bool success); function generateTokens(address _owner, uint _amount) public returns (bool); function destroyTokens(address _owner, uint _amount) public returns (bool); }",1
0x03324c5bce64a142f0110040851574903516b2ac.sol,DarkPool1,contract DarkPool1 is DarkPool { constructor() public { hodl = ERC20Basic(0x433e077D4da9FFC4b353C1Bf1eD69DAAc8f78aA5); end = 1524344400; cap = 600 ether; },1
0x4c382f8e09615ac86e08ce58266cc227e7d4d913.sol,SkrillaToken,"contract SkrillaToken is ERC20 { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public totalSupply; uint256 internal constant SUBUNIT_MULTIPLIER = 10 ** uint256(decimals); mapping (address => uint256) tokenSaleBalances; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) whiteList; uint256 internal constant SALE_CAP = 600 * 10**6 * SUBUNIT_MULTIPLIER; uint256 internal constant TEAM_TOKENS = 100 * 10**6 * SUBUNIT_MULTIPLIER; uint256 internal constant GROWTH_TOKENS = 300 * 10**6 * SUBUNIT_MULTIPLIER; uint256 internal constant TOTAL_SUPPLY_CAP = SALE_CAP + TEAM_TOKENS + GROWTH_TOKENS; address internal withdrawAddress; uint256 public ethRaised; address internal owner; address internal growth; address internal team; uint256[7] public saleStageStartDates; uint16[6] public tokens = [3000,2500,0,2400,2200,2000]; function tokenSaleBalanceOf(address _owner) public constant returns (uint256 balance) { balance = tokenSaleBalances[_owner]; }",1
0xd8fce619d059c5506301f6e6271aff1202aebd20.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x03358425ada4620246dd703dc1f2246b8e148d22.sol,BoomerangLiquidity,contract BoomerangLiquidity is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0xe07c44a35650e445289cd9fdaaf7fb6a9d734471.sol,AElfToken,"contract AElfToken is ERC20, Ownable { using SafeMath for uint256; address public aelfDevMultisig = 0x64ABa00510FEc9a0FE4B236648879f35030B7D9b; address public aelfCommunityMultisig = 0x13828Fa672c52226071F27ea1869463bDEf2ecCB; struct TokensWithLock { uint256 value; uint256 blockNumber; }",1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x58a3520d738b268c2353ecee518a1ad8e28e4ae5.sol,BasicToken,"contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => bool) public allowedAddresses; mapping(address => bool) public lockedAddresses; bool public locked = true; function allowAddress(address _addr, bool _allowed) public onlyOwner { require(_addr != owner); allowedAddresses[_addr] = _allowed; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0x41dab199a4aa0e14434473f689aecfcb1c8e520c.sol,MultiSigERC20Token,"contract MultiSigERC20Token { uint constant public MAX_OWNER_COUNT = 50; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address[] public owners; uint256 public required; uint public transactionCount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => MetaTransaction) public transactions; mapping (address => uint256) public withdrawalLimit; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; struct MetaTransaction { address source; address destination; uint value; bool executed; uint operation; string reason; }",1
0xbd549cf879c6cd3ee8a98b018fce13e5d64f3819.sol,Room1,"contract Room1 is Ownable { event TicketPurchased(address lotAddr, uint lotIndex, uint ticketNumber, address player, uint ticketPrice); event TicketWon(address lotAddr, uint lotIndex, uint ticketNumber, address player, uint win); event ParametersUpdated(uint lotIndex, address feeWallet, uint feePercent, uint starts, uint duration, uint interval, uint ticketPrice); using SafeMath for uint; uint diffRangeCounter = 0; uint public LIMIT = 100; uint public RANGE = 100000; uint public PERCENT_RATE = 100; enum LotState { Accepting, Processing, Rewarding, Finished }",1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsPreSale,contract EthernautsPreSale is EthernautsLogic { function EthernautsPreSale() public EthernautsLogic() {},1
0x37ac9987c288835a96d0fc58245ed3ae1e9e1950.sol,EcomethToken,"contract EcomethToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 5000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x40b10014a17e997e8e55594cbfb4f085c5ec815b.sol,MultiSig,"contract MultiSig is owned { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x25df2edc10a16f05e579d127a902cac6fdff940e.sol,Sale,"contract SaleCallbackInterface { function handleSaleCompletionCallback(uint256 _tokens) external payable returns (bool); function handleSaleClaimCallback(address _recipient, uint256 _tokens) external returns (bool); }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x02992370df72da5b039c3a6249beb27c487e63cb.sol,Exchange,"contract Exchange is SafeMath, Admin { mapping( address => mapping( address => uint )) public tokens; mapping( address => mapping( bytes32 => bool )) public orders; mapping( bytes32 => mapping( address => uint )) public ordersBalance; event Deposit( address token, address user, uint amount, uint balance ); event Withdraw( address token, address user, uint amount, uint balance ); event Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder ); event HashOutput(bytes32 hash); constructor( address _admin, address _feeAccount, uint _feeTake, string _version) public { admin = _admin; feeAccount = _feeAccount; feeTake = _feeTake; orderEnd = false; version = _version; pause = false; }",1
0x0384b55dacd00f2aa740fe125a1ed5ebb01a5c6d.sol,ERC721BasicToken,"contract ERC721BasicToken is ERC721Basic, Pausable { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; }",1
0x56a7d37b5252b057aebce6d65d2f87e49f1e1dcd.sol,EnnaMaEppadi,contract EnnaMaEppadi { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 4; int constant crr_d = 5; int constant price_coeff = -0x678adeacb985cb06; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; function EnnaMaEppadi() public {},1
0x0f520115112f79c7aeaaac47e0b2513814c85b77.sol,AbabPreICOToken,"contract AbabPreICOToken is ERC20Token { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public STARTDATE; uint256 public ENDDATE; uint256 public BUYPRICE; uint256 public CAP; function AbabPreICOToken() { STARTDATE = 1499951593; ENDDATE = 1817029631; BUYPRICE = 3333; CAP = 2500*1 ether; InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x2EDE66ED71E557CC90B9A76C298185C09591991B, 0.25 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x56B8729FFCC28C4BB5718C94261543477A4EB4E5, 0.5 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x56B8729FFCC28C4BB5718C94261543477A4EB4E5, 0.5 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xCC89FB091E138D5087A8742306AEDBE0C5CF8CE6, 0.15 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xCC89FB091E138D5087A8742306AEDBE0C5CF8CE6, 0.35 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x5FB3DC3EC639F33429AEA0773ED292A37B87A4D8, 1 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xD428F83278B587E535C414DFB32C24F7272DCFE9, 1 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xFD4876F2BEDFEAE635F70E010FC3F78D2A01874C, 2.9 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xC2C319C7E7C678E060945D3203F46E320D3BC17B, 3.9 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xCD4A005339CC97DE0466332FFAE0215F68FBDFAF, 10 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x04DA469D237E85EC55A4085874E1737FB53548FD, 9.6 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x8E32917F0FE7D9069D753CAFF946D7146FAC528A, 5 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0x72EC91441AB84639CCAB04A31FFDAC18756E70AA, 7.4 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xE5389809FEDFB0225719D136D9734845A7252542, 2 ether); InitBalanceFrom961e593b36920a767dad75f9fda07723231d9b77(0xE1D8D6D31682D8A901833E60DA15EE1A870B8370, 5 ether); }",1
0x4c2e198cf5ee4ca4d6e9e0c1b2b954f9101c7fc1.sol,GFCToken,"contract GFCToken is owned, token { uint256 public sellPrice = 1; uint256 public buyPrice = 1; bool public closeBuy = false; bool public closeSell = false; address public commissionGetter = 0xCd8bf69ad65c5158F0cfAA599bBF90d7f4b52Bb0; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event LogDeposit(address sender, uint amount); event LogWithdrawal(address receiver, uint amount); function GFCToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) public token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x01805928b325078683818329526dab3f74865e10.sol,AumICO,"contract AumICO is usingOraclize, SafeMath { struct OperationInQueue { uint operationStartTime; uint depositedEther; address receiver; bool closed; }",1
0x25e1779f5f2fbdd378ced1a338f6c26aeb3d6ad0.sol,SpiderFarm,"contract SpiderFarm{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=50; uint256 PSN=10000; uint256 PSNH=5000; uint256 startTime; bool public initialized=false; address public ceoAddress; address public owner; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; uint256 public snailmasterReq=100000; function becomeSnailmaster() public{ uint256 hasEggs=getMyEggs(); uint256 eggCount=SafeMath.div(hasEggs,EGGS_TO_HATCH_1SHRIMP); require(initialized); require(msg.sender != ceoAddress); require(eggCount>=snailmasterReq); claimedEggs[msg.sender]=0; snailmasterReq=SafeMath.add(snailmasterReq,100000); ceoAddress=msg.sender; }",1
0x178ab5b0ff6db1e0cbe569c091607d8f5d6e4c6c.sol,FinPro,contract FinPro is Ownable { using SafeMath for uint256; string private constant name = ; string private constant version = ; uint256[] private fplowerlim; uint256[] private fplocktime; uint256[] private fpinterest; uint256 private fpcount; ERC20Token private token; struct investedData { uint256 fpnum; uint256 buytime; uint256 unlocktime; uint256 value; bool withdrawn; },1
0xf0e7fb59c4e362c16c6b736e2b4bef9c4aa934a2.sol,CTSCoin,"contract CTSCoin is EIP20Interface,Ownable,SafeMath,Pausable{ string public constant name =; string public constant symbol = ; uint8 public constant decimals = 18; string public version = ; uint256 public constant initialSupply = 500000000; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; mapping (address => uint) public jail; mapping (address => uint256) public updateTime; mapping (address => uint256) public LockedToken; uint256 public finaliseTime; address public walletOwnerAddress; uint256 public rate; event WithDraw(address indexed _from, address indexed _to,uint256 _value); event BuyToken(address indexed _from, address indexed _to, uint256 _value); function CTSCoin() public { totalSupply = initialSupply*10**uint256(decimals); balances[msg.sender] = totalSupply; walletOwnerAddress = msg.sender; rate = 1500; }",1
0xef58491224958d978facf55d2120c55a24516b98.sol,Util,contract Util { function upper(string _base) internal pure returns (string) { bytes memory _baseBytes = bytes(_base); for (uint i = 0; i < _baseBytes.length; i++) { bytes1 b1 = _baseBytes[i]; if (b1 >= 0x61 && b1 <= 0x7A) { b1 = bytes1(uint8(b1)-32); },1
0xe0c0f5ce4e746eaa048ae5db5c61b6b1ef3b56ed.sol,CryptoSim,contract CryptoSim{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=10; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function CryptoSim() public{ ceoAddress=msg.sender; },1
0x516903f26659d24bb968a28d875476048fdd7639.sol,AtomUX,"contract AtomUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7.sol,RewardsGiftToken,"contract RewardsGiftToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RewardsGiftToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x40b41a2d4c5fb2da3e08b0a1bbd361b5dd1f7bdd.sol,ERC721,"contract ERC721 is ERC165, IERC721 { using SafeMath for uint256; using Address for address; bytes4 private constant _ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) private _tokenOwner; mapping (uint256 => address) private _tokenApprovals; mapping (address => uint256) private _ownedTokensCount; mapping (address => mapping (address => bool)) private _operatorApprovals; bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd; constructor() public { _registerInterface(_InterfaceId_ERC721); }",1
0x560a20eddeddf84217221aef0d5ca7d7ae7ae798.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0xc4e11c711d126925920a0312350444a2c80c8281.sol,AdvancedToken,"contract AdvancedToken is BasicToken, ERC20 { mapping (address => mapping (address => uint256)) allowances; function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) { require(allowances[_from][msg.sender] >= _amount && balances[_from] >= _amount); allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; }",1
0xb3b558f664327156e87274155c2921bc8d9b1f18.sol,CHXToken,"contract CHXToken is BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; bool public isRestricted = true; address public tokenSaleContractAddress; function CHXToken() public { totalSupply = 200000000e18; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xbfb7eee5dbc373433a97431fd5a3010b53e16378.sol,DDAContract,contract DDAContract is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 10**26; mapping (address => uint) public balances; mapping (address => mapping (address => uint256)) public allowed; address dedeAddress; function totalSupply() constant returns (uint totalSupply){ return _totalSupply; },1
0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc0a2185031ecf89f091a39c63c2857a7d5c301a.sol,Arbitrator,"contract Arbitrator is Owned { Realitio public realitio; mapping(bytes32 => uint256) public arbitration_bounties; uint256 dispute_fee; mapping(bytes32 => uint256) custom_dispute_fees; string public metadata; event LogRequestArbitration( bytes32 indexed question_id, uint256 fee_paid, address requester, uint256 remaining ); event LogSetRealitio( address realitio ); event LogSetQuestionFee( uint256 fee ); event LogSetDisputeFee( uint256 fee ); event LogSetCustomDisputeFee( bytes32 indexed question_id, uint256 fee ); constructor() public { owner = msg.sender; }",1
0x6cc1b4600858ef6ef320960e558adac01d0b9da8.sol,StandardToken,"contract StandardToken is ERC20, ERC223 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function StandardToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0xaa9b22f0e3e1e3dc88aa868571b4b0daa60f446b.sol,ECT,contract ECT { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x7865956684839906f0432a4fc47516f00ab5f58c.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 value) public returns (bool) { balanceOf[msg.sender] = balanceOf[msg.sender].sub(value); totalSupply = totalSupply.sub(value); emit Burn(msg.sender, value); return true; }",1
0xdda9bcd985b1169607546b52910a0269dff5baf1.sol,GooGameConfig,contract GooGameConfig { mapping(uint256 => Unit) private unitInfo; mapping(uint256 => Upgrade) private upgradeInfo; mapping(uint256 => Rare) private rareInfo; uint256 public constant currentNumberOfUnits = 14; uint256 public constant currentNumberOfUpgrades = 42; uint256 public constant currentNumberOfRares = 2; struct Unit { uint256 unitId; uint256 baseGooCost; uint256 gooCostIncreaseHalf; uint256 ethCost; uint256 baseGooProduction; uint256 attackValue; uint256 defenseValue; uint256 gooStealingCapacity; },1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x293438bc8656c99abb4fce8b08a5f40fb3b8c931.sol,Vineyard,contract Vineyard{ uint256 constant public GRAPE_SECS_TO_GROW_VINE = 86400; uint256 constant public STARTING_VINES = 300; uint256 constant public VINE_CAPACITY_PER_LAND = 1000; bool public initialized=false; address public ceoAddress; address public ceoWallet; mapping (address => uint256) public vineyardVines; mapping (address => uint256) public purchasedGrapes; mapping (address => uint256) public lastHarvest; mapping (address => address) public referrals; uint256 public marketGrapes; mapping (address => uint256) public landMultiplier; mapping (address => uint256) public totalVineCapacity; mapping (address => uint256) public wineInCellar; mapping (address => uint256) public wineProductionRate; uint256 public grapesToBuildWinery = 43200000000; uint256 public grapesToProduceBottle = 3456000000; address constant public LAND_ADDRESS = 0x2C1E693cCC537c8c98C73FaC0262CD7E18a3Ad60; LandInterface landContract; function Vineyard(address _wallet) public{ require(_wallet != address(0)); ceoAddress = msg.sender; ceoWallet = _wallet; landContract = LandInterface(LAND_ADDRESS); },1
0x74731ce1bf0ac7f89f1d4161e1fd57b11b287e4a.sol,ETH_Silver_White,contract ETH_Silver_White { using SafeMath for uint; address owner; mapping (address => uint) deposit; mapping (address => uint) withdrawn; mapping (address => uint) lastTimeWithdraw; function transferOwnership(address _newOwner) external { require(msg.sender == owner); require(_newOwner != address(0)); owner = _newOwner; },1
0x6e3990c89bd13397f3c080500805863275cc85ec.sol,POSV,contract POSV { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0c12caccab54c41b2b9fb5e80546aa1b758fabc4.sol,LTC,contract LTC { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint public _totalSupply = 30011000000000000000; uint256 public RATE = 1; bool public isMinting = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,PreSaleGuardian,"contract PreSaleGuardian is PreSaleCastle { event GuardianSaleCreate(uint indexed saleId, uint indexed guardianId, uint indexed price, uint race, uint level, uint starRate); event BuyGuardian(uint indexed saleId, uint guardianId, address indexed buyer, uint indexed currentPrice); event GuardianOfferSubmit(uint indexed saleId, uint guardianId, address indexed bidder, uint indexed price); event GuardianOfferAccept(uint indexed saleId, uint guardianId, address indexed newOwner, uint indexed newPrice); event SetGuardianSale(uint indexed saleId, uint indexed price, uint race, uint starRate, uint level); event GuardianAuctionCreate(uint indexed auctionId, uint indexed guardianId, uint indexed startPrice, uint race, uint level, uint starRate); event GuardianAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer); event VendingGuardian(uint indexed vendingId, address indexed buyer); event GuardianVendOffer(uint indexed vendingId, address indexed bidder, uint indexed offer); event GuardianVendAccept(uint indexed vendingId, address indexed newOwner, uint indexed newPrice); event SetGuardianVend(uint indexed priceId, uint indexed price); mapping (uint => address) public GuardianSaleToBuyer; mapping (uint => bool) GuardianIdToIfCreated; mapping (uint => uint) public GuardianVendToOffer; mapping (uint => address) public GuardianVendToBidder; mapping (uint => uint) public GuardianVendToTime; struct GuardianSale { uint guardianId; uint race; uint starRate; uint level; uint price; bool ifSold; address bidder; uint offerPrice; uint timestamp; }",1
0x5576250692275701efde5eeb51596e2d9460790b.sol,UserDataManager,contract UserDataManager { using NameFilter for string; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; struct Player { address addr; bytes32 name; uint256 laff; },1
0xc599523f90dc823b9c9dbb3859e22774b46bf6ba.sol,DumbCoin,contract DumbCoin { address public owner; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalTokensIssued = 0; uint256 public totalBonusTokensIssued = 0; function name() public constant returns (string) { return ; },1
0x1d462811562cc3675375a6d00c1618a370c27836.sol,TheLibertyCoin,"contract TheLibertyCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 20000000000e18; uint256 public totalDistributed = 10000000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x7052ad9bbc671804616e2280059fb3113dcd735b.sol,SilentNotaryTokenStorage,"contract SilentNotaryTokenStorage is SafeMath, Ownable { struct FrozenPortion { uint unfreezeTime; uint portionPercent; uint portionAmount; bool isUnfrozen; }",1
0x0cfa27cfd97134aaa8ae4a2f6753094dfab96393.sol,PonziBaseProcessor,"contract PonziBaseProcessor is SafeMath, AccessMgr, UserMgr, ItemMgr { uint256 public mHostFee = 0; event ItemCreated(address host, uint256 itemId); event ItemBought(address buyer, uint256 itemId, uint256 number, uint256 price, uint256 refund); function PonziBaseProcessor() public { mOwner = msg.sender; }",1
0xa1d12a357746fd44f282571d746d300eb85232ca.sol,ETHCutter,contract ETHCutter { using SafeMath for uint256; using AddressUtils for address; address public adminWallet; uint256 constant public DEPOSIT_MIN = 10 finney; uint256 constant public DEPOSIT_MAX = 10 ether; uint256 constant public DEPOSIT_PERIOD = 5 days; uint256 constant public TOTAL_PERCENT = 120; uint256 constant public UPLINE_PERCENT = 6; uint256 constant public EXPENSES_PERCENT = 15; uint256 public totalDeposited = 0; uint256 public totalWithdrawn = 0; uint256 public usersCount = 0; uint256 public depositsCount = 0; uint256 public expenses = 0; mapping(address => User) public users; mapping(uint256 => Deposit) public deposits; struct Deposit { uint256 createdAt; uint256 endAt; uint256 amount; uint256 accrued; uint256 totalForAccrual; bool active; },1
0x64c54463be7f529ab69e9df33f603c242aed1a85.sol,PVCCrowdsale,"contract PVCCrowdsale is Ownable{ using SafeMath for uint256; TokenInterface public token; uint256 public startTime; uint256 public endTime; uint256 public ratePerWei = 1000; uint256 public weiRaised; uint256 public TOKENS_SOLD; uint256 maxTokensToSale; uint256 TokensForTeamVesting; uint256 TokensForAdvisorVesting; uint256 bonusInPreSalePhase1; uint256 bonusInPreSalePhase2; uint256 bonusInPublicSalePhase1; uint256 bonusInPublicSalePhase2; uint256 bonusInPublicSalePhase3; uint256 bonusInPublicSalePhase4; uint256 bonusInPublicSalePhase5; uint256 bonusInPublicSalePhase6; bool isCrowdsalePaused = false; uint256 totalDurationInDays = 145 days; mapping(address=>bool) isAddressWhiteListed; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PVCCrowdsale(uint256 _startTime, address _wallet, address _tokenAddress) public { require(_wallet != 0x0); startTime = _startTime; endTime = startTime + totalDurationInDays; require(endTime >= startTime); owner = _wallet; maxTokensToSale = 32500000 * 10 ** 18; TOKENS_SOLD = 346018452900000000000; weiRaised = 285373570000000000; bonusInPreSalePhase1 = 30; bonusInPreSalePhase2 = 25; bonusInPublicSalePhase1 = 20; bonusInPublicSalePhase2 = 25; bonusInPublicSalePhase3 = 20; bonusInPublicSalePhase4 = 15; bonusInPublicSalePhase5 = 10; bonusInPublicSalePhase6 = 5; TokensForTeamVesting = 7000000 * 10 ** 18; TokensForAdvisorVesting = 3000000 * 10 ** 18; token = TokenInterface(_tokenAddress); }",1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,RelayerModule,contract RelayerModule is Module { uint256 constant internal BLOCKBOUND = 10000; mapping (address => RelayerConfig) public relayer; struct RelayerConfig { uint256 nonce; mapping (bytes32 => bool) executedTx; },1
0xf0ef703a04cf96212031b51d373e8469687f308e.sol,ESCToken,contract ESCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ESCToken () { owner = msg.sender; },1
0xf10574791a6e0112f416a55fbcd7803a4d3b1517.sol,DeliverToken,"contract DeliverToken is ERC20, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 initialSupply; uint256 totalSupply_; mapping(address => uint256) balances; mapping(address => bool) internal locks; mapping(address => mapping(address => uint256)) internal allowed; function DeliverToken() public { name = ; symbol = ; decimals = 18; initialSupply = 10000000000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; Transfer(address(0), owner, totalSupply_); }",1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x56b86b434ab199316ff6c549d2a76b010a793557.sol,EOBIToken,"contract EOBIToken is standardToken,Owned { using SafeMath for uint; string public name=; string public symbol=; uint256 public decimals=18; uint256 public totalSupply = 0; uint256 public topTotalSupply = 35*10**8*10**decimals; uint256 public privateTotalSupply = percent(10); uint256 public privateSupply = 0; address public walletAddress; uint256 public exchangeRate = 10**5; bool public ICOStart; function() public payable { if(ICOStart){ depositToken(msg.value); }",1
0x9200f1be36761dab295673279afb09d4f2b2531c.sol,ExtendedQuantstampSale,"contract ExtendedQuantstampSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingCap; uint public minContribution; bool public fundingCapReached = false; bool public saleClosed = false; mapping(address => bool) public registry; mapping(address => uint256) public cap; uint public startTime; uint public endTime; uint public amountRaised; bool private rentrancy_lock = false; mapping(address => uint256) public balanceOf; QuantstampSale public previousContract; event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event RegistrationStatusChanged(address target, bool isRegistered, uint c); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x732c6f4f1cf13d850d71e9dad229997db0818a52.sol,DateTime,contract DateTime { struct TDateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0xd8fce619d059c5506301f6e6271aff1202aebd20.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0xd6647d2d40b1ee8ab766dec0822ec756985fc1b3.sol,Mummy3D,"contract Mummy3D { modifier pyramidConstruct(bool applyLimits) { address _customerAddress = msg.sender; if (onlyAmbassadors && _customerAddress == _MummyAccount) { require( ambassadorsEthLedger_[_MummyAccount] < 2 ether && SafeMath.add(ambassadorsEthLedger_[_MummyAccount], msg.value) <= 2 ether ); }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,KydyAccessControl,contract KydyAccessControl { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x1e23eb7b5dc701b6ef35e8a953266696e29f6862.sol,KGC,"contract KGC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 2000; bool public crowdsaleClosed; bool public transferEnabled = true; uint constant DAY = 1 days; uint constant D112019 = 1567987200; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x57bcc647eb77dfe185ede00a2720443c004f298a.sol,LFSTYLToken,contract LFSTYLToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LFSTYLToken () { owner = msg.sender; },1
0x2758cf73421a81f09acdbffec2ebdc3125de0433.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x3612d93f91c8fdb5f158a7c35dd7f87c63ad3f9b.sol,MobaBase,contract MobaBase { address public owner = 0x0; bool public isLock = false; constructor () public { owner = msg.sender; },1
0x2da4bb51e59d0b156b5e19bb3f8eff0279e1ffa2.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath3 for uint; uint public tokensIssuedTotal = 0; mapping(address => uint) balances; mapping(address => mapping (address => uint)) internal allowed; function totalSupply() constant public returns (uint) { return tokensIssuedTotal; }",1
0x6c6b3fd123d575cbeb1670a1fcc9c8fd603357a3.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0xdd6eef0507f10d21f716e36d8b1aae76a4fa3f62.sol,CashexGlobalCoin,contract CashexGlobalCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 1000000000000000000; function name() public constant returns (string) { return ; },1
0x72636c350431895fc6ee718b92bcc5b4fbd70304.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public saleAgent; modifier canMint() { require(!mintingFinished); _; }",1
0x18365e32f5e5615fe73592f7c2dbfa73538708c6.sol,PreSaleI,"contract PreSaleI is Whitelist { using SafeMath for uint256; uint256 public exchangeRate; uint256 public minValue; uint256 public maxTotal; uint256 public maxPerAddress; uint256 public startTimestamp; uint256 public endTimestamp; bool public enabled; address public wallet; ERC20 public token; uint256 public accumulatedAmount = 0; uint256 public accumulatedAmountExternal = 0; mapping (address => uint256) public buyAmounts; address[] public addresses; constructor(ERC20 _token, address _wallet, uint256 _exchangeRate, uint256 _minValue, uint256 _maxTotal, uint256 _maxPerAddress, uint256 _startTimestamp, uint256 _endTimestamp) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; exchangeRate = _exchangeRate; minValue = _minValue; maxTotal = _maxTotal; maxPerAddress = _maxPerAddress; startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; enabled = false; }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0x346af19ea0db192328ca37dd5579f46bc4456a30.sol,CyberMovieFlix,"contract CyberMovieFlix is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_PURCHASE = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x1e93fa20fa1a8e99c30dfc3ea644b8e13534169c.sol,FYC,"contract FYC is ERC20,Ownable{ using SafeMath for uint256; string public constant name=; string public constant symbol=; string public constant version = ; uint256 public constant decimals = 18; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public constant MAX_SUPPLY=1000000000000*10**decimals; uint256 public constant INIT_SUPPLY=500000000000*10**decimals; uint256 public constant autoAirdropAmount=1000*10**decimals; uint256 public constant MAX_AUTO_AIRDROP_AMOUNT=1000000*10**decimals; uint256 public constant MAX_FUNDING_SUPPLY=499999000000*10**decimals; uint256 public totalFundingSupply; uint256 public rate=1; uint256 public alreadyAutoAirdropAmount; mapping(address => bool) touched; struct epoch { uint256 endTime; uint256 amount; }",1
0x741a26104530998f625d15cbb9d58b01811d2ca7.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x5b2db92a43aa86fff2d9a3696a7ee264d03fc907.sol,Proposals,contract Proposals is ApplicationAsset { ApplicationEntityABI public Application; ABIListingContract public ListingContractEntity; ABIFunding public FundingEntity; ABIFundingManager public FundingManagerEntity; ABITokenManager public TokenManagerEntity; ABIToken public TokenEntity; ABIMilestones public MilestonesEntity; function getRecordState(bytes32 name) public view returns (uint8) { return RecordStates[name]; },1
0xbe585e9ae9d7e3277b2541dbac105c4ed540f806.sol,CoinEJP,"contract CoinEJP { address public admin_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; address public account_address = 0x5d9CC08eb47aE51069ED64BFAfBcF3a8e531f881; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 initSupply = 880000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; }",1
0x02307ee1ab299f40bb8bf7260e1f25610e3e654e.sol,BTT,"contract BTT is EIP20Interface,Ownable,SafeMath,Pausable{ string public constant name =; string public constant symbol = ; uint8 public constant decimals = 18; string public version = ; uint256 public constant initialSupply = 1010101010; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; constructor() public{ totalSupply = initialSupply*10**uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x541ac3dbde0712b1a121bdd5e8c506ae594a4631.sol,XPTToken,contract XPTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XPTToken () { owner = msg.sender; },1
0x3664be8ec8a66e8dab9dfa48e5092f576edab746.sol,FoMo3Dshort,"contract FoMo3Dshort is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x454b6ee7e3847d51456b4146f7ae2664dbc35af4); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 seconds; uint256 private rndGap_ = 1 seconds; uint256 constant private rndInit_ = 2400 hours; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 2400 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x841d34af2018d9487199678edd47dd46b140690b.sol,BURNToken,"contract BURNToken is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1 * 10**uint(decimals); balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xc8507d914d21d50c1763288da6539f6a0f5a0916.sol,yiDaooToken,"contract yiDaooToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaooToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xc70be5b7c19529ef642d16c10dfe91c58b5c3bf0.sol,ERC721BasicToken,contract ERC721BasicToken is ERC721Basic { using Maths for uint256; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; },1
0x72088c9767f55504157159fab3fa1de8d79bbe3e.sol,TemporaryPyramid,contract TemporaryPyramid { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; function TemporaryPyramid() public {},1
0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol,EthPyramid,contract EthPyramid { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; mapping(address => uint256) public tokenBalance; mapping(address => int256) public payouts; uint256 public totalSupply; int256 totalPayouts; uint256 earningsPerToken; uint256 public contractBalance; bool open = false; address admin = 0xD2E6B3BFE990fdede2380885d9d83Ca9364E717E; modifier OnlyOpen(){ require(open || (msg.sender==admin)); _; },1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x074661068c2cbca51dde811871554d2fa5bae312.sol,BountyHunterToken,"contract BountyHunterToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BountyHunterToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x523630976eb6147621b5c31c781ebe2ec2a806e0.sol,HavvenEscrow,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0xedaa8b44833f363e0221f91df2e9b8ad0768039a.sol,StdToken,"contract StdToken is Token { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; uint public supply; function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); uint previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; emit Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); }",1
0x1dfa4bb783b3aeea55b712b4acb4b7dd1a8fe928.sol,ERC20Token,contract ERC20Token is ERC20 { using SafeMath for uint256; mapping (address => uint) balances; mapping (address => mapping (address => uint256)) allowed; modifier onlyPayloadSize(uint size) { require(msg.data.length >= (size + 4)); _; },1
0x3672a1d8a362c9a50db70df219e05ea3cab60df9.sol,SUGARToken,contract SUGARToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,FollowCoinTokenSale,"contract FollowCoinTokenSale is Haltable { using SafeMath for uint256; address public beneficiary; address public multisig; uint public tokenLimitPerWallet; uint public hardCap; uint public amountRaised; uint public totalTokens; uint public tokensSold = 0; uint public investorCount = 0; uint public startTimestamp; uint public deadline; uint public tokensPerEther; FollowCoin public tokenReward; mapping(address => uint256) public balances; event FundTransfer(address backer, uint amount, bool isContribution); function FollowCoinTokenSale( address multiSigWallet, uint icoTokensLimitPerWallet, uint icoHardCap, uint icoStartTimestamp, uint durationInDays, uint icoTotalTokens, uint icoTokensPerEther, address addressOfTokenUsedAsReward ) { multisig = multiSigWallet; owner = multiSigWallet; hardCap = icoHardCap; deadline = icoStartTimestamp + durationInDays * 1 days; startTimestamp = icoStartTimestamp; totalTokens = icoTotalTokens; tokenLimitPerWallet = icoTokensLimitPerWallet; tokensPerEther = icoTokensPerEther; tokenReward = FollowCoin(addressOfTokenUsedAsReward); beneficiary = multisig; }",1
0x41c0d6a6e1b7932db04adc900bed73b4ce59f231.sol,Keepis,"contract Keepis is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 150000000000000000000000000000; balances[0x829443e486d70A26DAad750f6Ea19733D219bdd1] = _totalSupply; emit Transfer(address(0), 0x829443e486d70A26DAad750f6Ea19733D219bdd1, _totalSupply); }",1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0x4ce68b018062cfccd66c7fbbb2cc1f0161d22150.sol,BOWTERC20,"contract BOWTERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BOWTERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0xd850942ef8811f2a866692a623011bde52a462c1.sol,VENSale,"contract VENSale is Owned{ enum Stage { NotCreated, Created, Initialized, Early, Normal, Closed, Finalized }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0xec82fffd7c1961904fdbb4cbd98f06d9dd0870a8.sol,DeltaChainToken,"contract DeltaChainToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 30000000000e8; uint256 public totalDistributed = 8000000000e8; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 300000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x419b8ed155180a8c9c64145e76dad49c0a4efb97.sol,DefaultToken,"contract DefaultToken is MintableToken, TokenPolicy, ApproveAndCallToken { using SafeMath for uint; string public name; string public ticker; uint public decimals; function DefaultToken(string _name, string _ticker, uint _decimals, address _registry) ApproveAndCallToken() MintableToken() TokenPolicy(_registry) public { name = _name; ticker = _ticker; decimals = _decimals; }",1
0x51b0dfd23f45e0700c598bbb91bee60e0a175c1b.sol,FriendsCoin,"contract FriendsCoin is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 initialSupply; uint256 totalSupply_; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; function FriendsCoin() public { name = ; symbol = ; decimals = 18; initialSupply = 30000000000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; Transfer(address(0), owner, totalSupply_); }",1
0x4bdf685f6949161ccdccab524bf69aa0ae7b640d.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 100*10**(decimals+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { balanceOf[0x8900679eeFEf58D15FC849134E68577a17561155] = 30*10**(decimals+8); balanceOf[0x6C3409625a31D5C5122E4130eBCAFeCd1487a43a] = 70*10**(decimals+8); }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0x83ff9580519f9746bc73a1d8048a2f8a8c8c4ca8.sol,ERC20,"contract ERC20Interface{ string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to,uint256 _value) returns(bool success); function transferFrom(address _from,address _to,uint256 _value) returns(bool success); function approve(address _spender,uint256 _value) returns(bool success); function allowance(address _owner,address _spender) view returns(uint256 remaining); event Transfer(address indexed _from,address indexed _to,uint256 _value); event Approval(address indexed _owner,address indexed _spender,uint256 _value); }",1
0x1dc211ed642733da8badeed7d529e9b67295593b.sol,ergo,"contract ergo { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public initialSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ergo( ) public { totalSupply = 81000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; unitsOneEthCanBuy = 810; }",1
0x68fcb1f0d07000a84b569ccb647dd8fe320cddaa.sol,owContract,"contract owContract is initLib { function owContract(address _token, address _cmc) public { tokenAddress = _token; ow_owner = msg.sender; cmcAddress = _cmc; }",1
0xa5e5916a380fea1e633df88d7b5e1835a85b8262.sol,BrewerscoinToken,"contract BrewerscoinToken is owned, IERC20 { using SafeMath for uint256; uint256 private constant base = 1e18; uint256 constant MAX_UINT = 2**256 - 1; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply = 1e26; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 tokenAmount); event Approval(address indexed tokenHolder, address indexed spender, uint256 tokenAmount); event Burn(address indexed from, uint256 tokenAmount); string private constant NOT_ENOUGH_TOKENS = ; string private constant NOT_ENOUGH_ETHER = ; string private constant NOT_ENOUGH_ALLOWANCE = ; string private constant ADDRESS_0_NOT_ALLOWED = ; constructor() public { balances[msg.sender] = totalSupply; allowance[this][msg.sender] = MAX_UINT; }",1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x4efd3bf84f40eda370e52df162eccc394cfc8834.sol,Zhoan,"contract Zhoan { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; address private admin_add; uint private present_money=0; event Transfer(address indexed from, address indexed to, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowances; constructor(uint256 limit,string token_name,string token_symbol,uint8 token_decimals) public { admin_add=msg.sender; name=token_name; symbol=token_symbol; totalSupply=limit * 10 ** uint256(decimals); decimals=token_decimals; balanceOf[admin_add]=totalSupply; }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,DaoStakeStorage,"contract DaoStakeStorage is ResolverClient, DaoConstants, AddressIteratorStorage { using DoublyLinkedList for DoublyLinkedList.Address; mapping (address => uint256) public lockedDGDStake; mapping (address => uint256) public actualLockedDGD; uint256 public totalLockedDGDStake; uint256 public totalModeratorLockedDGDStake; DoublyLinkedList.Address allParticipants; DoublyLinkedList.Address allModerators; mapping (address => bool) public redeemedBadge; mapping (address => bool) public carbonVoteBonusClaimed; constructor(address _resolver) public { require(init(CONTRACT_STORAGE_DAO_STAKE, _resolver)); }",1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,BitBonus,"contract BitBonus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x633A5cD23D95c26f750B802A03A82490C00Da802] = _totalSupply; emit Transfer(address(0), 0x633A5cD23D95c26f750B802A03A82490C00Da802, _totalSupply); }",1
0xc0223d4411440a5d7d4083e2ebbf6f2a27ac8d9f.sol,Trextoken,"contract Trextoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_PURCHASE = 1 ether / 100000000; uint256 public tokensPerEth = 500000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpImage,contract BdpImageStorage is BdpBase { using SafeMath for uint256; struct Image { address owner; uint256 regionId; uint256 currentRegionId; mapping(uint16 => uint256[1000]) data; mapping(uint16 => uint16) dataLength; uint16 partsCount; uint16 width; uint16 height; uint16 imageDescriptor; uint256 blurredAt; },1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x6c558a4976e751391fb73dd61fa6a72c318d80b5.sol,BitQ,"contract BitQ is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitQ() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000; balances[0x74205dece41e14DCE4fD94da4Dcfb255f3A69059] = _totalSupply; Transfer(address(0), 0x74205dece41e14DCE4fD94da4Dcfb255f3A69059, _totalSupply); }",1
0x711256406c2e9072fbaee5b67d5a893f66a3e707.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); address public ELIX_ADDRESS; uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x3329a13218b9b311a7ee468dfe100f72c08ee2da.sol,PRECOE,"contract PRECOE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public devFeesAddr = 0x36Bdc3B60dC5491fbc7d74a05709E94d5b554321; address tierAdmin; uint256 public totalSupply = 71433000000000000000000; uint256 public mineableTokens = totalSupply; uint public tierLevel = 1; uint256 public fiatPerEth = 3.85E25; uint256 public circulatingSupply = 0; uint maxTier = 132; uint256 public devFees = 0; uint256 fees = 10000; bool public receiveEth = false; bool payFees = true; bool public canExchange = true; bool addTiers = true; bool public initialTiers = false; mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping(uint => uint256) public scheduleTokens; mapping(uint => uint256) public scheduleRates; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event TokensExchanged(address indexed _owningWallet, address indexed _with, uint256 _value); function PRECOE() { owner = msg.sender; balances[owner] = add(balances[owner],4500000000000000000000); Transfer(this, owner, 4500000000000000000000); circulatingSupply = add(circulatingSupply, 4500000000000000000000); mineableTokens = sub(mineableTokens,4500000000000000000000); }",1
0x1a7208627ffe43a69f13f3c393a41712fa4a7831.sol,WarToken,"contract WarToken is ERC721, AccessAdmin { struct Fashion { uint16 protoId; uint16 quality; uint16 pos; uint16 health; uint16 atkMin; uint16 atkMax; uint16 defence; uint16 crit; uint16 isPercent; uint16 attrExt1; uint16 attrExt2; uint16 attrExt3; }",1
0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d.sol,CB_BANK,"contract CB_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x6d6db51e3e4838369676508ce25db64f4ca7e5e4.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,PublicBank,"contract PublicBank is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PublicBank() TokenERC20(21000000, , ) public { }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Marketplace,contract Marketplace is Ownable { struct Ad { uint price; address exchanger; bool exists; bool active; },1
0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3.sol,CoinifinexToken,"contract CoinifinexToken { uint256 constant public TOTAL_TOKEN = 10 ** 9; uint256 constant public TOKEN_FOR_ICO = 650 * 10 ** 6; uint256 constant public TOKEN_FOR_COMPANY = 200 * 10 ** 6; uint256 constant public TOKEN_FOR_BONUS = 50 * 10 ** 6; mapping (address => uint256) public tokenForTeam; mapping (address => uint256) public tokenForTeamGet; address[] public teamAddress; uint public startTime; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinifinexToken( ) public { totalSupply = TOTAL_TOKEN * 10 ** uint256(decimals); name = ; symbol = ; startTime = 1538265600; tokenForTeam[0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x040440286a443822211dDe0e7E9DA3F49aF2EBC7] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xc456aC342f17E7003A03479e275fDA322dE38681] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24] = 300 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x88311485647e19510298d7Dbf0a346D5B808DF03] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe387125f1b24E59f7811d26fbb26bdA1c599b061] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xC5b644c5fDe01fce561496179a8Bb7886349bD75] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF] = 5 * 10 ** 6 * 10 ** uint256(decimals); teamAddress.push(0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0); teamAddress.push(0x040440286a443822211dDe0e7E9DA3F49aF2EBC7); teamAddress.push(0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71); teamAddress.push(0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D); teamAddress.push(0xc456aC342f17E7003A03479e275fDA322dE38681); teamAddress.push(0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24); teamAddress.push(0x88311485647e19510298d7Dbf0a346D5B808DF03); teamAddress.push(0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F); teamAddress.push(0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1); teamAddress.push(0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb); teamAddress.push(0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77); teamAddress.push(0xe387125f1b24E59f7811d26fbb26bdA1c599b061); teamAddress.push(0xC5b644c5fDe01fce561496179a8Bb7886349bD75); teamAddress.push(0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78); teamAddress.push(0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae); teamAddress.push(0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF); uint arrayLength = teamAddress.length; for (uint i=0; i<arrayLength; i++) { tokenForTeamGet[teamAddress[i]] = tokenForTeam[teamAddress[i]] * 1 / 10; balanceOf[teamAddress[i]] = tokenForTeamGet[teamAddress[i]]; tokenForTeam[teamAddress[i]] -= tokenForTeamGet[teamAddress[i]]; }",1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,RelayerModule,contract RelayerModule is Module { uint256 constant internal BLOCKBOUND = 10000; mapping (address => RelayerConfig) public relayer; struct RelayerConfig { uint256 nonce; mapping (bytes32 => bool) executedTx; },1
0x293ed09bfc80b93cdf5a64306aaedcfad3c64955.sol,Halo3DShrimpFarmer,contract Halo3DShrimpFarmer is AcceptsHalo3D { uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function Halo3DShrimpFarmer(address _baseContract) AcceptsHalo3D(_baseContract) public{ ceoAddress=msg.sender; },1
0x021dd0713bd2532ba532084fe9569d55f8c1f09b.sol,HWCToken,"contract HWCToken is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x8c2d1d6259afd282ada6812d040f7173d83873ef.sol,LittleStoreERC20Token,"contract LittleStoreERC20Token { mapping (address => bool) public agents; address public addressERC20Token; InterfaceERC20Token internal ERC20Token; bool public sale; uint public price; uint public bonusLine; uint public bonusSize; event ChangePermission (address indexed _called, address indexed _to, bool _permission); event ChangeSaleSettings (address indexed _called, address indexed _token, uint _price, uint _bonusLine, uint _bonusSize); event Buy (address indexed _called, address indexed _token, uint _count, uint _bonusCount, uint _value); event Donate (address indexed _from, uint _value); function LittleStoreERC20Token () public { agents[msg.sender] = true; sale = true; }",1
0x02992370df72da5b039c3a6249beb27c487e63cb.sol,Admin,contract Admin { address public admin; address public feeAccount; address public nextVersionAddress; bool public orderEnd; string public version; uint public feeTake; bool public pause; modifier assertAdmin() { if ( msg.sender != admin ) { revert(); },1
0xd342c20428de073c6da0cd3b249b16b3f2ae80fe.sol,DildoToken,"contract DildoToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public supplyMultiplier = 6900000000; uint256 public buyPrice = 69000000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function DildoToken() public { totalSupply = supplyMultiplier * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0xea96e2b3d17fbb7f36d90a3bccd6705c98af5f0b.sol,ERC223Mixin,"contract ERC223Mixin is StandardToken { event Transfer(address indexed from, address indexed to, uint256 value, bytes data); function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { bytes memory empty; return transferFrom( _from, _to, _value, empty); }",1
0x9290cc8fec6e7524bc9c57ff3e5cd8de18bf961f.sol,Percent1200,"contract Percent1200 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 100; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 2 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xdb3f0abff87b0d71c45424b1db6fc92f8a76967a.sol,WANGSUToken,"contract WANGSUToken is Ownable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function WANGSUToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3329a13218b9b311a7ee468dfe100f72c08ee2da.sol,PRECOE,"contract PRECOE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public devFeesAddr = 0x36Bdc3B60dC5491fbc7d74a05709E94d5b554321; address tierAdmin; uint256 public totalSupply = 71433000000000000000000; uint256 public mineableTokens = totalSupply; uint public tierLevel = 1; uint256 public fiatPerEth = 3.85E25; uint256 public circulatingSupply = 0; uint maxTier = 132; uint256 public devFees = 0; uint256 fees = 10000; bool public receiveEth = false; bool payFees = true; bool public canExchange = true; bool addTiers = true; bool public initialTiers = false; mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping(uint => uint256) public scheduleTokens; mapping(uint => uint256) public scheduleRates; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event TokensExchanged(address indexed _owningWallet, address indexed _with, uint256 _value); function PRECOE() { owner = msg.sender; balances[owner] = add(balances[owner],4500000000000000000000); Transfer(this, owner, 4500000000000000000000); circulatingSupply = add(circulatingSupply, 4500000000000000000000); mineableTokens = sub(mineableTokens,4500000000000000000000); }",1
0x345288da52e8c1fa5385a39abeada510f24f8222.sol,Exodus21,"contract Exodus21{ using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public minimum = 10000000000000000; uint256 public step = 21; address public ownerWallet; address public owner; address public bountyManager; address promoter = 0x4553d99872248020CC4C37519a4156167170E3C6; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor(address _bountyManager) public { owner = msg.sender; ownerWallet = msg.sender; bountyManager = _bountyManager; }",1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,FansChainToken,"contract FansChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FansChainToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x86789b2de83b9a93f89f8c2cb14d622cd73515e9.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Ownable { using SafeMath for uint256; address public crowdsale; mapping (address => uint256) public waiting; uint256 public saled; event Sale(address indexed to, uint256 value); event Release(address indexed to); event Reject(address indexed to); event SetCrowdsale(address indexed addr); function setCrowdsale(address _addr) onlyOwner public { crowdsale = _addr; SetCrowdsale(_addr); }",1
0x85271a19708e4378dfcc5bb60e8f50ce878620a2.sol,GAM,"contract GAM is Ownable, ERC20Interface { using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 private _unmintedTokens = 300000000 * uint(10) ** decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed _address, uint256 _value); event Mint(address indexed _address, uint256 _value); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xd3970927a9fc6dd00628368f7e72fd8ac90823a1.sol,Token,contract Token is ERC20 { uint8 public constant decimals = 9; uint256 public constant initialSupply = 10 * (10 ** 8) * (10 ** uint256(decimals)); string public constant name = ; string public constant symbol = ; function() public { revert(); },1
0xf1d8fd82da98ed93bca83adbb6ab4dd3c44b35ea.sol,GOG,"contract GOG is owned { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public frozenFunds; event FrozenFunds(address target, uint256 funds); event UnFrozenFunds(address target, uint256 funds); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function GOG() public { totalSupply = 10000000000000000; balances[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa5816b5fdba5ee1d983a94f156651c9dcc42850a.sol,ANBXToken,"contract ANBXToken is IERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public constant decimals = 18; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 2000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() public { balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,ESOP,"contract ESOPTypes { enum EmployeeState { NotSet, WaitingForSignature, Employed, Terminated, OptionsExercised }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x127a78da95f02d9139db64ea7d3f6de355975494.sol,DACToken,contract DACToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 30000000000000000; bool public stopped = false; address owner = 0x1e113613C889C76b792AdfdcbBd155904F3310a5; modifier isOwner { assert(owner == msg.sender); _; },1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,BurnableCrowdsaleToken,"contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken { function BurnableCrowdsaleToken(string _name, string _symbol, uint _decimals) CrowdsaleToken(_name, _symbol, _decimals) BurnableToken(){ }",1
0x4d6445c92ae02748105c73ee97e8327e726e465c.sol,FMLY,"contract FMLY is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 8; function FMLY() public { owner = msg.sender; totalSupply=8100000000000000; balances[owner]=totalSupply; }",1
0xc12d4719478955201ae62637c54b7e2ca8899702.sol,RocketBase,"contract RocketBase { event ContractAdded ( address indexed _newContractAddress, uint256 created ); event ContractUpgraded ( address indexed _oldContractAddress, address indexed _newContractAddress, uint256 created ); uint8 public version; RocketStorageInterface rocketStorage = RocketStorageInterface(0); modifier onlyOwner() { roleCheck(, msg.sender); _; }",1
0xbf607a809f785449fb389188e51af98d5c33bc20.sol,Vasacoin,"contract Vasacoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 200; uint256 public tokensPerEth = 15000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf3253e09e8d47327ef355fea674d166dc5827460.sol,UNC,"contract UNC is Pausable, DetailedERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function UNC() DetailedERC20(, , 18) public { totalSupply = 50000000 * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x50f0557ae11d55829949bf7af8cd9f69b80a56eb.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; },1
0x1a4f7a5208c7dd4cf24633ac4d42e41b21e3d5f7.sol,CrocsFarmer,contract CrocsFarmer{ uint256 public EGGS_TO_HATCH_1CROCS=86400; uint256 public STARTING_CROCS=10; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryCrocs; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function CrocsFarmer() public{ ceoAddress=msg.sender; },1
0xb55ea1e1bb44dd75753a5ad4311d190f021d8ab9.sol,BitCloudNetworkToken,"contract BitCloudNetworkToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 12000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x50a0be7e38f2580ad3eafac20b923cccee673ce3.sol,EthCalendar,contract EthCalendar { uint256 constant initialDayPrice = 3000000000000000 wei; address contractOwner; mapping(address => uint256) pendingWithdrawals; mapping(uint16 => Day) dayStructs; event DayBought(uint16 dayId); struct Day { address owner; string message; uint256 sellprice; uint256 buyprice; },1
0x47c5ee9d1993a6d83c3ca28e3046d9cebf72b48a.sol,TokenSale,"contract TokenSale is PSTRToken { enum State { ICO_FIRST, ICO_SECOND, STOPPED, CLOSED }",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; bool public checkDate; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public tokenRaised; bool public isFinalized = false; event Finalized(); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; checkDate = false; }",1
0x4ef76ae870979cc9a4c5c0a54a2099c67dcfa15c.sol,MyIdolCoinToken,"contract MyIdolCoinToken is StandardToken, BurnableToken, Airdrop { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 100000000000000000; function MyIdolCoinToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xc834a06943efac6b6129641f15191fcb033db515.sol,RoboTC,"contract RoboTC is SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping(address => uint256) public balanceOf; mapping(address => uint256) public freezeOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function RoboTC() { balanceOf[msg.sender] = 4500000000000000000; totalSupply = 4500000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xce242dfca2b3499af28de3074083c3acdcd2d0f6.sol,VOCC_I084_20181211,"contract VOCC_I084_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x92acd2c2442eb6242960bda85c4ea8ee34bcd61b.sol,TurtleFarmer,contract TurtleFarmer{ uint256 public EGGS_TO_HATCH_1TURTLE=86400; uint256 public STARTING_TURTLES=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public creatorAddress; mapping (address => uint256) public hatcheryTurtles; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function TurtleFarmer() public{ creatorAddress=msg.sender; },1
0xdc47e1a1147522b5024ed29c82301bcbfda90849.sol,EtherusPreSale,"contract EtherusPreSale is Ownable { using SafeMath for uint; uint private constant fractions = 1e18; uint private constant millions = 1e6*fractions; uint private constant CAP = 15*millions; uint private constant SALE_CAP = 5*millions; uint private constant ETR_USD_PRICE = 400; uint public ethPrice = 40000; event AltBuy(address holder, uint tokens, string txHash); event Buy(address holder, uint tokens); event RunSale(); event PauseSale(); event FinishSale(); event PriceSet(uint USDPerETH); MintableToken public token; address authority; address robot; bool public isOpen = false; function EtherusPreSale(address _token, address _multisig, address _authority, address _robot) public { token = MintableToken(_token); authority = _authority; robot = _robot; transferOwnership(_multisig); }",1
0x2a92f24bfad42b04cfe5c000be404c2a84ca5b71.sol,CryptoSuperGirlfriend,"contract CryptoSuperGirlfriend { using SafeMath for uint256; address private addressOfOwner; event Add (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private priceInit = 0.01 ether; uint256 private idStart = 10001; uint256 private idMax = 10191; struct OwnerInfo{ string ownerName; string ownerWords; string ownerImg; string ownerNation; }",1
0x0cf84a5dc7af17f6fb3e0c21d9f03398644a42d6.sol,IOXDistribution,contract IOXDistribution { address public owner; mapping(uint256 => bool) public claimers; token public ioxToken; event Signer(address signer); function IOXDistribution(address tokenAddress) public { owner = msg.sender; ioxToken = token(tokenAddress); },1
0x582b2489710a4189ad558b6958641789587fcc27.sol,PonziUnlimited,contract PonziUnlimited { modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x52be514d0193ebec233e5f4191f1ba3926e262f9.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); }",1
0x5befe0f9a29ba63aec7664e7f5e9c198e5be113b.sol,DSTToken,"contract DSTToken is ERC20, Ownable, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public tokensPerEther = 1500; address public DSTMultisig; address dstWalletLMNO; bool public startStop = false; mapping (address => uint256) public walletA; mapping (address => uint256) public walletB; mapping (address => uint256) public walletC; mapping (address => uint256) public walletF; mapping (address => uint256) public walletG; mapping (address => uint256) public walletH; mapping (address => uint256) public releasedA; mapping (address => uint256) public releasedB; mapping (address => uint256) public releasedC; mapping (address => uint256) public releasedF; mapping (address => uint256) public releasedG; mapping (address => uint256) public releasedH; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct WalletConfig{ uint256 start; uint256 cliff; uint256 duration; }",1
0x0e3de3b0e3d617fd8d1d8088639ba877feb4d742.sol,IceRockPay,"contract IceRockPay is ERC20Basic, Ownable { event Payout(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint256 totalSupply_; uint8 public constant decimals = 18; enum States { Sale, Stop }",1
0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals = 8; uint256 internal _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) internal _allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply(); name = tokenName; symbol = tokenSymbol; }",1
0x581a653c16ed7ae3f3fa86b549aba090abd42e8b.sol,BYB,"contract BYB{ string public name =; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply =100000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BYB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x287fe6172eec4cde6e76dd85e65e5b3ea4760972.sol,Ownable,"contract Ownable { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor () internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }",1
0x20b3d3f8a3e4f7b23382d844f2ca1d7026d69479.sol,Gorgona,contract Gorgona { address public owner; uint constant PAYOUT_PER_INVESTOR_INTERVAL = 10 minutes; uint constant INTEREST = 3; uint private PAYOUT_CUMULATIVE_INTERVAL = 10 minutes; uint private MINIMUM_INVEST = 10000000000000000 wei; uint depositAmount; uint investorCount; uint public payoutDate; struct investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x7148b1c9154bcf273a2c7d7b90e3edc6fee395e6.sol,ContractRegistry,"contract ContractRegistry is IContractRegistry, Owned, Utils { struct RegistryItem { address contractAddress; uint256 nameIndex; bool isSet; }",1
0x1e403f8ce554f2ffa6e5560d3db112dfc0ed24d2.sol,Controlled,contract Controlled is Ownable{ constructor() public { setExclude(msg.sender); },1
0x462adf63904054f21e2b9f217d639446536b5743.sol,HOT,"contract HOT { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenSupply = 177619433541; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function HOT() public { totalSupply = tokenSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x4c1ed91da2edd5f86c0f4adb8562466f202f0a0a.sol,BelottoCoin,"contract BelottoCoin is ERC20Interface, Owned{ using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BelottoCoin(address _owner) public{ symbol = ; name = ; decimals = 18; owner = _owner; _totalSupply = totalSupply(); balances[owner] = _totalSupply; emit Transfer(address(0),owner,_totalSupply); }",1
0x25a06d4e1f804ce62cf11b091180a5c84980d93a.sol,Treasure,contract Treasure { modifier onlybelievers () { require(myTokens() > 0); _; },1
0x5138e7b13e56ac9b15654cc2824a28e5355af4b4.sol,EtherDice,contract EtherDice { address public constant OWNER = 0x8026F25c6f898b4afE03d05F87e6c2AFeaaC3a3D; address public constant MANAGER = 0xD25BD6c44D6cF3C0358AB30ed5E89F2090409a79; uint constant public FEE_PERCENT = 1; uint public minBet; uint public maxBet; uint public currentIndex; uint public lockBalance; uint public betsOfBlock; uint entropy; struct Bet { address player; uint deposit; uint block; },1
0x8c27fafc6e56a997abe1681eee6de0077b458fd1.sol,GigaCrowdsale,"contract GigaCrowdsale is Contactable { using SafeMath for uint256; GigaToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensPurchased; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event SetRate(uint256 oldRate, uint256 newRate); event SetEndTime(uint256 oldEndTime, uint256 newEndTime); function GigaCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,string _contactInformation) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); contactInformation = _contactInformation; token = createTokenContract(); token.setContactInformation(_contactInformation); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; }",1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,BulleonCrowdsale,"contract BulleonCrowdsale is Claimable, CanReclaimToken { using SafeMath for uint256; event AddedToBlacklist(address wallet); event RemovedFromBlacklist(address wallet); string public version = ; address public withdrawWallet = 0xAd74Bd38911fE4C19c95D14b5733372c3978C2D9; uint256 public endDate = 1546300799; BulleonToken public rewardToken; uint256[] public tokensRate = [ 1000, 800, 600, 400, 200, 100, 75, 50, 25, 10 ]; uint256[] public tokensCap = [ 760000, 760000, 760000, 760000, 760000, 760000, 760000, 760000, 760000, 759000 ]; mapping(address=>bool) public isBlacklisted; uint256 public totalSold = 329406072304513072322000; uint256 public soldOnStage = 329406072304513072322000; uint8 public currentStage = 0; uint256 public bonus = 0; uint256 constant BONUS_COEFF = 1000; mapping(address=>uint256) public investmentsOf; function isActive() public view returns (bool) { return !(availableTokens() == 0 || now > endDate); }",1
0x6cc8ae9b7c8ce86276d1062b2e837684400e6c37.sol,Lwcoin,contract Lwcoin is ERC20Interface { uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10 ** 16; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0xdb27fd0813568f9e911ebdf645716ef02a07eb20.sol,GRCToken,"contract GRCToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant TOKEN_UNIT = 10 ** uint256(decimals); uint256 private constant INITIAL_SUPPLY = (10 ** 9) * TOKEN_UNIT; uint256 private constant PRIVATE_SALE_SUPPLY = INITIAL_SUPPLY * 35 / 100; uint256 private constant COMMUNITY_REWARDS_SUPPLY = INITIAL_SUPPLY * 20 / 100; uint256 private constant COMMERCIAL_PLAN_SUPPLY = INITIAL_SUPPLY * 20 / 100; uint256 private constant FOUNDATION_SUPPLY = INITIAL_SUPPLY * 15 / 100; uint256 private constant TEAM_SUPPLY = INITIAL_SUPPLY * 10 / 100; struct VestingGrant { address beneficiary; uint256 start; uint256 duration; uint256 amount; uint256 transfered; uint8 releaseCount; }",1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,Crowdsale,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ProfitDelivered(address fetcher, uint profit); event ProfitLoaded(address owner, uint profit); string public name; string public symbol; uint8 public decimals; uint loadedProfit; bool ditributingProfit; uint profitDistributed; uint loadedProfitAvailable; mapping (address => bool) public hasFetchedProfit; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0xe0c0f5ce4e746eaa048ae5db5c61b6b1ef3b56ed.sol,CryptoSim,contract CryptoSim{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=10; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function CryptoSim() public{ ceoAddress=msg.sender; },1
0xf4fe43df5179fae6ebd1337c62d68bb2606f5a40.sol,CryptFillToken,contract CryptFillToken is StandardToken { using SafeMath for uint256; function () { throw; },1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,ExpiringMarket,"contract ExpiringMarket is DSAuth, SimpleMarket { uint64 public close_time; bool public stopped; modifier can_offer { require(!isClosed()); _; }",1
0x654dddc32f6734a33b9cea0901c47f9a00336c1e.sol,VisperNetwork,contract VisperNetwork is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**18; function name() public constant returns (string) { return ; },1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,PlatformTeamCoinVer01,"contract PlatformTeamCoinVer01 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf14f06e227c015b398b8069314f4b8d1d7022c9e.sol,ExchangeCore,contract ExchangeCore is ReentrancyGuarded { ERC20 public exchangeToken; ProxyRegistry public registry; mapping(bytes32 => bool) public cancelledOrFinalized; mapping(bytes32 => bool) public approvedOrders; struct Sig { uint8 v; bytes32 r; bytes32 s; },1
0x2931853a0551f9327d5b18a4fc9f3afcef0a1a91.sol,SYMTOKEN,"contract SYMTOKEN is BurnableToken, PausableToken, MintableToken, CappedToken { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 44396844 * (10 ** uint256(decimals)); function burn(uint256 _value) whenNotPaused public { super.burn(_value); }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,SRNMagicBox,"contract SRNMagicBox is ServerControl, TokenReceiver { GirlOps girlOps; GenesFactory genesFactory; SRNG SRNGInstance; string public name; uint public keyRequired; address public keyAddress; address public prizePoolAddress; uint public boxPrice; uint[] public prizeIndex; uint[] public prizeRange; uint[] public NCards; uint[] public RCards; uint[] public SRCards; uint[] public SSRCards; event SendGirlFail(address _to, uint _type); constructor(string _name, address _girlAddress, address _SRNGAddress, address _genesFactoryAddress, address _prizePoolAddress, address _keyAddress, uint _keyRequired, uint _boxPrice) public { name = _name; girlOps = GirlOps(_girlAddress); SRNGInstance = SRNG(_SRNGAddress); genesFactory = GenesFactory(_genesFactoryAddress); prizePoolAddress = _prizePoolAddress; keyAddress = _keyAddress; keyRequired = _keyRequired; boxPrice = _boxPrice; }",1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINNDTokenContract,"contract VINNDTokenContract is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public icoContract = 0x0; modifier onlyIcoContract() { require(msg.sender == icoContract); _; }",1
0xd8da7f0155cd4ccaa9f26eb406a0587a4ecf8587.sol,Edpstest,"contract Edpstest is PausableToken { string public name; string public symbol; uint8 public constant decimals = 12; uint256 public totalSupply; mapping (address => bool) public frozenAccount; event Burn(address indexed _burner, uint _value); event FrozenFunds(address indexed _target, bool _frozen); modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; }",1
0xf030b8fbe57c4498298449fc78a0f7054a5ef76d.sol,ArkToken,"contract ArkToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; mapping (uint256 => Animal) public arkData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => uint256) public babies; mapping (uint256 => uint256[2]) public babyMommas; mapping (uint256 => uint256) public mates; mapping (uint256 => uint256) public babyMakinPrice; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public birtherBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Birth(address indexed _birther, uint256 indexed _mom, uint256 _dad, uint256 indexed _baby); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 1.5 ether; uint256 private finalCap = 3.0 ether; struct Animal { uint256 price; uint256 lastPrice; address owner; address birther; uint256 birtherPct; uint8 gender; }",1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf15683e987915ed27ebf4dd8bd3d383a076f2a3e.sol,CCH_LLV_FIFA_1,contract CCH_LLV_FIFA_1 { address owner ; function CCH_LLV_FIFA_1 () public { owner = msg.sender; },1
0x18420e17f0ee1b32d1174f673c7eaa946a180b63.sol,StrongHold,contract StrongHold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x539bff788404c395117dd2dfdcc3d5e00a72d3b7.sol,EdenwToken,"contract EdenwToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EdenwToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,CollectibleToken,contract CollectibleToken is ERC721YC { uint256 private constant STARTING_PRICE = 0.001 ether; uint256 private constant FIRST_STEP_LIMIT = 0.053613 ether; uint256 private constant SECOND_STEP_LIMIT = 0.564957 ether; uint private constant MASTER_TOKEN_ID = 0; function CollectibleToken() public { balances[msg.sender] = 10000000000000000000; totalSupply = 10000000000000000000; },1
0x6ba29728e955ff970c94d7ab0a4ff17c628f325a.sol,requiringAuthorization,contract requiringAuthorization is mortal { mapping(address => bool) public authorized; mapping(address => bool) public allowedReceiver; modifier onlyAuthorized { require(authorized[msg.sender]); _; },1
0xc65afcd87cd78f6864278ef52421ab57e1751afc.sol,DdexAngelToken,contract DdexAngelToken is IERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 private _totalSupply; uint public decimals = 0; uint public INITIAL_SUPPLY = 9999; address public admin; bool public transferEnabled = false; mapping (address => bool) public whiteList; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; modifier canTransfer() { require(transferEnabled || msg.sender == admin || whiteList[msg.sender] == true); _; },1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0x28e860cb89e705de876f858671cb757f650fdae2.sol,WEPAYCOIN,"contract WEPAYCOIN { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2ea8b410188a5ebc30f61aa598f534f6c7ad4f7e.sol,CubegoPlastic,"contract CubegoPlastic is IERC20, BasicAccessControl { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; mapping (address => mapping (address => uint256)) private _allowed; uint public mId = 0; CubegoCoreInterface public cubegoCore; function setConfig(address _cubegoCoreAddress, uint _mId) onlyModerators external { cubegoCore = CubegoCoreInterface(_cubegoCoreAddress); mId = _mId; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,Claimable,contract Claimable is Ownable { address public pendingOwner; modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; },1
0x5155a0722a45905dacf49598a02eff3777340acd.sol,SecurityToken,"contract SecurityToken is StandardToken, DetailedERC20, ReentrancyGuard, RegistryUpdater { using SafeMath for uint256; TokenLib.InvestorDataStorage investorData; struct SemanticVersion { uint8 major; uint8 minor; uint8 patch; }",1
0xf028adee51533b1b47beaa890feb54a457f51e89.sol,BMToken,"contract BMToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 _supply = 0; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); address ico_contract; address public owner; function BMToken(){ ico_contract = address(0x0); owner = msg.sender; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0xde08bee9240f2a57eab416302e3a6271fbd3f9de.sol,DrAgentToken,"contract DrAgentToken is StandardToken, Owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 10**28; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DrAgentToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x009449c99a2822914d68691d87b0177292fb5a6c.sol,HeartBoutPreICO,"contract HeartBoutPreICO is CappedCrowdsale, Ownable { using SafeMath for uint256; address public token; uint256 public minCount; function HeartBoutPreICO(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minCount) public CappedCrowdsale(_startTime, _endTime, _rate, _wallet, _cap) { token = 0x00f5b36df8732fb5a045bd90ab40082ab37897b841; minCount = _minCount; }",1
0xef56166bfc23489b224a1c6b330b3bbd94e3af0c.sol,BLTCoin,"contract BLTCoin is ERC20Interface, Owned{ using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; uint256 public rate; uint256 public weiRaised; uint value; uint _ICOTokensLimit; uint _ownerTokensLimit; uint public bonusPercentage; bool public icoOpen; bool public bonusCompaignOpen; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyWhileOpen { require(icoOpen); _; }",1
0xebc71036a37451e87cc43af8ae7ac123aa750dcb.sol,CEYStandardToken,"contract CEYStandardToken is CeyronToken, Ownable { using CEYMaths for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }",1
0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x5b366f606dab2a1e221da2588f62bfe454760e78.sol,CryptoRichmanToken,contract CryptoRichmanToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogBreeding,"contract EtherDogBreeding is EtherDogOwnership { event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 matronCooldownEndBlock, uint256 sireCooldownEndBlock); uint256 public autoBirthFee = 2 finney; uint256 public pregnantEtherDogs; GeneScienceInterface public geneScience; function setGeneScienceAddress(address _address) external onlyCEO { GeneScienceInterface candidateContract = GeneScienceInterface(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; }",1
0x340085ed7d6c18dcf4c8b661fba6bd95916c8644.sol,BoostPax,"contract BoostPax { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x55dd6348b0f97ba5417cc3c3d9d98c36e14b7d44.sol,Tablow,"contract Tablow is ERC223Token { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; uint256 _MaxDistribPublicSupply = 0; uint256 _OwnerDistribSupply = 0; uint256 _CurrentDistribPublicSupply = 0; uint256 _FreeTokens = 0; uint256 _Multiplier1 = 2; uint256 _Multiplier2 = 3; uint256 _LimitMultiplier1 = 4e15; uint256 _LimitMultiplier2 = 8e15; uint256 _HighDonateLimit = 5e16; uint256 _BonusTokensPerETHdonated = 0; address _DistribFundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool IsDistribRunning = false; bool DistribStarted = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => bool) public Claimed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x0e1bebe6b75595d3c7fb99550757e310bc2edf2a.sol,LLV_v30_12,contract LLV_v30_12 { address owner ; function LLV_v30_12 () public { owner = msg.sender; },1
0x44af572f32ac5ae87c779dc39f008627b13a128e.sol,Startex,"contract Startex is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 11111111111e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 44444444e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5c6a2ece543d3038f98cea1a2a5f0759fbceb8b1.sol,IERC20Token,contract IERC20Token { function name() public constant returns (string) {},1
0xdc7109afb8a3cc28f2429bf4a35f959a567a2610.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x194524355f26af663468d4996f207a918c73e013.sol,StandardBurnableToken,"contract StandardBurnableToken is BurnableToken, StandardToken { function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); }",1
0xb3aac808b10eb65b74b59deb4f1998b52327bd1a.sol,InsightsNetwork2Base,"contract InsightsNetwork2Base is DetailedERC20(, , 18), PausableToken, CappedToken{ uint256 constant ATTOTOKEN_FACTOR = 10**18; address public predecessor; address public successor; uint constant MAX_PURCHASES = 64; mapping (address => uint256[]) public lockedBalances; mapping (address => uint256[]) public unlockTimes; mapping (address => bool) public imported; event Import(address indexed account, uint256 amount, uint256 unlockTime); function InsightsNetwork2Base() public CappedToken(300*1000000*ATTOTOKEN_FACTOR) { paused = true; mintingFinished = true; }",1
0xce3708924a9a44aee5e7caad22881fdda816fd16.sol,NatureX,"contract NatureX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 8000000e8; uint256 public constant minContribution = 1 ether / 200; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d722c159eaacd74eb3fc8ce65832706cf294b33.sol,CoinFlipper,contract CoinFlipper{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x1d1ff336189f16fcb5aea6f00398c06bec5fd0cc.sol,casinoProxy,contract casinoProxy is casinoBank{ mapping(address => bool) public authorized; mapping(address => mapping(address => bool)) public authorizedByUser; mapping(address => mapping(address => uint8)) public lockedByUser; address[] public casinoGames; mapping(address => uint) public count; modifier onlyAuthorized { require(authorized[msg.sender]); _; },1
0x83dc8423170e95ee18b770bbdd6b3becb73c9c30.sol,STC,contract STC is StandardToken { string public name = ; string public symbol = ; uint256 public decimals = 18; string public version = ; uint256 public tokenCap = 100000000 * 10**18; uint256 public fundingStartTime; uint256 public fundingEndTime; address public vestingContract; bool private vestingSet = false; address public fundWallet; address public controlWallet; uint256 public waitTime = 1 hours; bool public halted = false; bool public tradeable = false; uint256 public previousUpdateTime = 0; Price public currentPrice; uint256 public minAmount = 0.04 ether; uint256 public OfferTime = 2592000; mapping (address => Withdrawal) public withdrawals; mapping (uint256 => Price) public prices; mapping (address => bool) public whitelist; struct Price { uint256 numerator; uint256 denominator; },1
0x3a741c9eb3f506f203ebb7d422fd011a5c4fa6fa.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x836f95d2a2f5150200c76f45a0b0679542ab6bbd.sol,BANK_IV_PFII_883,"contract BANK_IV_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 426401924563853000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x47da42696a866cdc61a4c809a515500a242909c1.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x5548003c0610a9be74eecd469db94e947601209a.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; admins[contractCreator] = true; },1
0xd9913f9823fa526840869f1cb8f515bb69e6a51c.sol,DinosaurFarmer,contract DinosaurFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; function DinosaurFarmer() public{ ceoAddress=msg.sender; },1
0x3632c27273a5d928d0f09407380dc0d8164a8ac5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x20a33ce1255611686ab11afecc8eaab1c612ac11.sol,BlackDogCrowdsale,contract BlackDogCrowdsale is owned{ using SafeMath for uint256; address public beneficiary; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public preSalePrice; uint256 public price; uint256 public fundTransferred; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; constructor() public{ beneficiary = 0x382468fb5070Ae19e9D82ec388e79AE4e43d890D; preSaleStartdate = 1563760800; preSaleDeadline = 1564711199; mainSaleStartdate = 1564711200; mainSaleDeadline = 1567648799; preSalePrice = 0.000001 ether; price = 0.00000111 ether; tokenReward = token(0xf3d56969bc1a60bebff7c1a49290f7990d29ba57); },1
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; address public miningWarAddress; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x58aa8050d56a3cc49bf37b54474174a81e4b2a24.sol,SaleToken,"contract SaleToken is MintableToken, BurnableToken { using SafeMath for uint256; uint256 public price = 300000000000000000; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 constant level = 10 ** uint256(decimals); uint256 public totalSupply = 10000 * level; event Payment(uint256 _give, uint256 _get); function setPrice(uint256 newPrice) onlyOwner { price = newPrice; }",1
0xc37a236c1b27b7a3d8b8d57b9c770b70d8ccc566.sol,OriginToken,"contract OriginToken is BurnableToken, MintableToken, WhitelistedPausableToken, DetailedERC20 { event AddCallSpenderWhitelist(address enabler, address spender); event RemoveCallSpenderWhitelist(address disabler, address spender); mapping (address => bool) public callSpenderWhitelist; constructor(uint256 _initialSupply) DetailedERC20(, , 18) public { owner = msg.sender; mint(owner, _initialSupply); }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f.sol,CarbonExchangeCoinToken,"contract CarbonExchangeCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CarbonExchangeCoinToken() public { owner = msg.sender; totalSupply = 50000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0x5585f99a9af13b73a6210ea9c8ca98b69f4a4b31.sol,PlumberCollector,contract PlumberCollector{ uint256 public POOH_TO_CALL_1PLUMBER=86400; uint256 public STARTING_POOH=100; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryPlumber; mapping (address => uint256) public claimedPoohs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketPoohs; constructor() public { ceoAddress=msg.sender; },1
0xd3970927a9fc6dd00628368f7e72fd8ac90823a1.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; },1
0x91cdb5bb5969bfed2373e97378354052bbc606f2.sol,DRCToken,"contract DRCToken is BurnableToken, MintableToken, PausableToken, Claimable, Autonomy { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 0; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenAmount; event FrozenFunds(address indexed _target, bool _frozen); event FrozenFundsPartialy(address indexed _target, bool _frozen, uint256 _value); event BurnFrom(address from, address burner, uint256 value); function DRCToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x521ed218348577fa2915b9454b72712024d350d2.sol,TokenSale,"contract TokenSale is Ownable { using SafeMath for uint; uint private constant millions = 1e6; uint private constant CAP = 15*millions; uint private constant SALE_CAP = 12*millions; uint private constant SOFT_CAP = 1400000; uint private constant TEAM_CAP = 3000000; uint public price = 0.001 ether; address[] contributors; mapping(address => uint) contributions; event AltBuy(address holder, uint tokens, string txHash); event Buy(address holder, uint tokens); event RunSale(); event PauseSale(); event FinishSale(); event PriceSet(uint weiPerNYX); bool public presale; NYXToken public token; address authority; address robot; bool public isOpen = true; function TokenSale(){ token = new NYXToken(msg.sender); authority = msg.sender; robot = msg.sender; transferOwnership(msg.sender); }",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0xf302c73a4ea09e9c7967386c4044496c0bf6f1af.sol,PausableToken,"contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }",1
0x1a2e39e6e166cfb3f249f727dd5098a1055f457d.sol,ERC865,"contract ERC865 is CheckpointToken { mapping(bytes => bool) signatures; event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee); event Debug(address from, bytes32 hash); function transferPreSigned( bytes _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce ) public returns (bool) { require(_to != address(0)); require(signatures[_signature] == false); bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce); address from = recover(hashedTx, _signature); require(from != address(0)); _value = verifyTransaction(from, _to, _value); _fee = verifyTransaction(from, msg.sender, _fee); transferInternal(from, _to, _value); transferInternal(from, msg.sender, _fee); signatures[_signature] = true; TransferPreSigned(from, _to, msg.sender, _value, _fee); Transfer(from, _to, _value); Transfer(from, msg.sender, _fee); return true; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0xbc078bfb16e155fc18f9648a2c92a4c46a853728.sol,coco,contract coco is ERC20Interface { address public admin; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { totalSupply = 100000000000000000000000000; name = ; symbol = ; decimals = 18; balanceOf[msg.sender] = totalSupply; admin = msg.sender; },1
0x840086881facb1e8c222fa5deb2f93f238b0ba95.sol,TokenRDC,"contract TokenRDC is BurnableToken, StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 60000000 * (10 ** uint256(decimals)); address public currentCrowdsale; function TokenRDC( address _foundation, address _team, address _BAP ) public { require( _foundation != address(0x0)); require( _team != address(0x0)); require( _BAP != address(0x0)); uint256 dec = 10 ** uint256(decimals); totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; transfer( _foundation, 12000000 * dec ); transfer( _team, 6000000 * dec ); transfer( _BAP, 2400000 * dec ); }",1
0xf2bea87df174bee8a862e1395fc97084ac6e6e56.sol,Treasure,"contract Treasure is PlayerBook { uint private seed = 18; uint[3] public gameRound = [1, 1, 1]; uint[3] public maxKeys = [1200, 12000, 60000]; uint[3] public keyLimits = [100, 1000, 5000]; uint public keyPrice = 10 finney; uint public devFee = 10; uint public laffFee1 = 10; uint public laffFee2 = 1; address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5; mapping(uint => mapping(uint => RoundInfo)) public gameInfo; mapping(uint => mapping(uint => mapping(uint => uint))) public userAff; struct RoundInfo { uint module; uint rd; uint count; uint keys; uint maxKeys; uint keyLimits; uint award; address winner; bool isEnd; mapping(uint => uint) userKeys; mapping(uint => uint) userId; }",1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x72acaab5b211b9a69bf71f4a6bb1f56546451509.sol,GlobalCapitalGroup,"contract GlobalCapitalGroup { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5438b0938fb88a979032f45b87d2d1aeffe5cc28.sol,Gifto,contract Gifto is ERC20Interface { uint public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; address public owner; mapping(address => uint256) balances; mapping(address => bool) approvedInvestorList; mapping(address => uint256) deposit; address[] buyers; uint _icoPercent = 10; uint public _icoSupply = _totalSupply * _icoPercent / 100; uint public _minimumBuy = 10 ** 17; uint public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0xd89d6e3b1115743b3dc481f6afdb5bc2958031d6.sol,POWM,contract POWM { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6b609d9095d069c805650234ab67595b3a6ab934.sol,Crowdsale,"contract CrowdsaleProxy is ICrowdsaleProxy { address public owner; ICrowdsale public target; function CrowdsaleProxy(address _owner, address _target) public { target = ICrowdsale(_target); owner = _owner; }",1
0xdf100fa9a871669f1c99649fe7852ff45228a83b.sol,Star3Dlong,"contract Star3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using Star3DKeysCalcLong for uint256; string constant public name = ; string constant public symbol = ; uint256 private pID_ = 0; uint256 private rndExtra_ = 1 hours; uint256 private rndGap_ = 1 seconds; uint256 constant private rndInit_ = 10 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public registrationFee_ = 10 finney; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Star3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Star3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => Star3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => Star3Ddatasets.TeamFee) public fees_; mapping (uint256 => Star3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = Star3Ddatasets.TeamFee(32, 48, 10); fees_[1] = Star3Ddatasets.TeamFee(45, 35, 10); fees_[2] = Star3Ddatasets.TeamFee(50, 30, 10); fees_[3] = Star3Ddatasets.TeamFee(40, 40, 10); potSplit_[0] = Star3Ddatasets.PotSplit(20, 30); potSplit_[1] = Star3Ddatasets.PotSplit(15, 35); potSplit_[2] = Star3Ddatasets.PotSplit(25, 25); potSplit_[3] = Star3Ddatasets.PotSplit(30, 20); }",1
0x6ad5e4ecc18d36c7315a244ba342ccf3eda19ab7.sol,CanReclaimToken,"contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; function reclaimToken(ERC20Basic _token) external onlyOwner { uint256 balance = _token.balanceOf(this); _token.safeTransfer(owner, balance); }",1
0xddaf60dbc930cc44af8b1b85cacfc866e2eed23d.sol,MultiCertifier,"contract MultiCertifier is Owned, Certifier { modifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }",1
0x41f8d4d01ba8505111794e3fa3deb3ed8cbaa8ee.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 10; address public addressA = 0x82914CFc37c46fbbb830150cF2330B80DAADa2D5; function founder() private { owner = msg.sender; },1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,ERC721YC,"contract ERC721YC is YouCollectBase { string public constant NAME = ; string public constant SYMBOL = ; uint256[] public tokens; mapping (uint256 => address) public tokenIndexToOwner; mapping (uint256 => address) public tokenIndexToApproved; mapping (uint256 => uint256) public tokenIndexToPrice; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); function approveToken( address _to, uint256 _tokenId ) public returns (bool) { require(_ownsToken(msg.sender, _tokenId)); tokenIndexToApproved[_tokenId] = _to; Approval(msg.sender, _to, _tokenId); return true; }",1
0xde4f1f39242e779f4ae6324e06fb30ba3e14e377.sol,CrowdsaleKYC,"contract CrowdsaleKYC is Pausable, Whitelistable, KYCBase { using AddressUtils for address; using SafeMath for uint256; event LogStartBlockChanged(uint256 indexed startBlock); event LogEndBlockChanged(uint256 indexed endBlock); event LogMinDepositChanged(uint256 indexed minDeposit); event LogTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 indexed amount, uint256 tokenAmount); event AddedSenderAllowed(address semder); event RemovedSenderAllowed(address semder); MintableToken public token; uint256 public startBlock; uint256 public endBlock; uint256 public rate; uint256 public raisedFunds; uint256 public soldTokens; mapping (address => uint256) public balanceOf; uint256 public minDeposit; mapping (address => bool) public isAllowedSender; function checkSoldout() internal returns (bool isSoldout); function setNextPhaseBlock() internal; function startNextPhase(uint256 _startBlock) internal; modifier beforeStart() { require(block.number < startBlock, ); _; }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x9ae0d181e5724d89c230e92418c53adecd4f665a.sol,Evenhanded,contract Evenhanded is StandardToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public INITIAL_SUPPLY = 5.19*10**8*10**18; function Evenhanded() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x6cf9af470571026bafc48d5dd23b0521e9595394.sol,fortunes,contract fortunes { string public standard = ; string public name; string public symbol; uint8 public decimals; address owner; uint public max_fortunes; uint public unopened_bid; bytes32[] public ur_luck; struct fortune { address original_owner; address original_minter; address current_owner; uint32 number; uint8 level; bytes32[144] img; bytes32 str_luck; bytes32 str_name; bool has_img; bool opened; bool forsale; uint current_bid; address current_bidder; uint bid_cnt; uint auction_end; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,ESportsMainCrowdsale,"contract ESportsMainCrowdsale is ESportsConstants, RefundableCrowdsale { uint constant OVERALL_AMOUNT_TOKENS = 60000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant TEAM_BEN_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant TEAM_PHIL_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant COMPANY_COLD_STORAGE_TOKENS = 12000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant INVESTOR_TOKENS = 3000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant BONUS_TOKENS = 3000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant BUFFER_TOKENS = 6000000 * TOKEN_DECIMAL_MULTIPLIER; uint constant PRE_SALE_TOKENS = 12000000 * TOKEN_DECIMAL_MULTIPLIER; address constant TEAM_BEN_ADDRESS = 0x2E352Ed15C4321f4dd7EdFc19402666dE8713cd8; address constant TEAM_PHIL_ADDRESS = 0x4466de3a8f4f0a0f5470b50fdc9f91fa04e00e34; address constant INVESTOR_ADDRESS = 0x14f8d0c41097ca6fddb6aa4fd6a3332af3741847; address constant BONUS_ADDRESS = 0x5baee4a9938d8f59edbe4dc109119983db4b7bd6; address constant COMPANY_COLD_STORAGE_ADDRESS = 0x700d6ae53be946085bb91f96eb1cf9e420236762; address constant PRE_SALE_ADDRESS = 0xcb2809926e615245b3af4ebce5af9fbe1a6a4321; address btcBuyer = 0x1eee4c7d88aadec2ab82dd191491d1a9edf21e9a; ESportsBonusProvider public bonusProvider; bool private isInit = false; function ESportsMainCrowdsale( uint32 _startTime, uint32 _endTime, uint _softCapWei, address _wallet, address _token ) RefundableCrowdsale( _startTime, _endTime, RATE, OVERALL_AMOUNT_TOKENS, _wallet, _token, _softCapWei ) { }",1
0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,MainSale,"contract MainSale is Ownable { using SafeMath for uint256; event TokensPurchased(address indexed buyer, uint256 ether_amount); event MainSaleClosed(); HeroOrigenToken public token = new HeroOrigenToken(); address public multisigVault = 0x1706024467ef8C9C4648Da6FC35f2C995Ac79CF6; uint256 public totalReceived = 0; uint256 public hardcap = 250000 ether; uint256 public minimum = 10 ether; uint256 public altDeposits = 0; uint256 public start = 1511178900; bool public saleOngoing = true; modifier isSaleOn() { require(start <= now && saleOngoing); _; }",1
0x729b59c57f3aadf114daeec77d19168b1b1c6b11.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); string public name = ; string public symbol = ; uint256 public decimals = 18; bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,MNTP,contract MNTP is StdToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public creator = 0x0; address public icoContractAddress = 0x0; bool public lockTransfers = false; uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * (1 ether / 1 wei); modifier onlyCreator() { require(msg.sender == creator); _; },1
0x036570162bc64a4e1201f1ba4a3fcd87e35b0b2f.sol,LANDRegistry,"contract LANDRegistry is Storage, Ownable, FullAssetRegistry, ILANDRegistry { bytes4 constant public GET_METADATA = bytes4(keccak256()); function initialize(bytes) external { _name = ; _symbol = ; _description = ; }",1
0x0e7c28fb8ed4f5f63aabd022deaeeba40ecc335c.sol,EtherCenter,contract EtherCenter { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f.sol,token123,contract token123 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token123() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x6552b02716bc7400fd97e5cab13e43607b5e63c3.sol,WorldEthereumSupremeToken,contract WorldEthereumSupremeToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol,BATMO,"contract BATMO is FOMOEvents { using SafeMath for *; using NameFilter for string; using KeysCalc for uint256; PlayerBookInterface private PlayerBook; OBOK public ObokContract; address private admin = msg.sender; address private admin2; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 2 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => BATMODatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => BATMODatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => BATMODatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => BATMODatasets.TeamFee) public fees_; mapping (uint256 => BATMODatasets.PotSplit) public potSplit_; constructor(address otherAdmin, address token, address playerbook) public { admin2 = otherAdmin; ObokContract = OBOK(token); PlayerBook = PlayerBookInterface(playerbook); fees_[0] = BATMODatasets.TeamFee(47,10); potSplit_[0] = BATMODatasets.PotSplit(15,10); }",1
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol,FoMo3DLight,"contract FoMo3DLight is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; uint256 public pID_ = 4; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 20 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(49,2); fees_[1] = F3Ddatasets.TeamFee(49,2); fees_[2] = F3Ddatasets.TeamFee(49,2); fees_[3] = F3Ddatasets.TeamFee(49,2); potSplit_[0] = F3Ddatasets.PotSplit(38,2); potSplit_[1] = F3Ddatasets.PotSplit(38,2); potSplit_[2] = F3Ddatasets.PotSplit(38,2); potSplit_[3] = F3Ddatasets.PotSplit(38,2); }",1
0x77e38daa72e92ac366aaa7dcf1696b397f303609.sol,HotToken,"contract HotToken is CappedToken, PausableToken, BurnableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 20 * 10000 * 10000 * (10 ** uint256(decimals)); uint256 public constant MAX_SUPPLY = 20 * 10000 * 10000 * (10 ** uint256(decimals)); constructor() CappedToken(MAX_SUPPLY) public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogBreeding,"contract EtherDogBreeding is EtherDogOwnership { event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 matronCooldownEndBlock, uint256 sireCooldownEndBlock); uint256 public autoBirthFee = 2 finney; uint256 public pregnantEtherDogs; GeneScienceInterface public geneScience; function setGeneScienceAddress(address _address) external onlyCEO { GeneScienceInterface candidateContract = GeneScienceInterface(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; }",1
0x41ab75435668919bb507f871dd01e9762c2d173a.sol,SafeMath,"contract SafeMath { function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x56c388df7f4e0947014705f7d61bdc6ebb128ad0.sol,SAF,contract SAF is StandardToken { function () { throw; },1
0x40f4991411ac5377675c421e87378e10470134a3.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0x010a1a80541018e3ca4b38aaf47e2e64567afbac.sol,TweedentityManager,"contract TweedentityManager is Pausable, HasNoEther { string public version = ; struct Store { ITweedentityStore store; address addr; }",1
0x0079a404c09ddd8950cd3dab6244f0c1bd96e126.sol,FindBitToken,contract FindBitToken is PausableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; struct Schedule { uint256 amount; uint256 start; uint256 cliff; uint256 duration; uint256 released; uint256 lastReleased; },1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,Crowdsale,"contract Crowdsale{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 60 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 0 days; uint256 constant BURN_TOKENS_TIME = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xedabc2a993cd24d01fe68a200b98190250969714.sol,TokenERC20,"contract TokenERC20 is owned { address public deployer; string public name =; string public symbol = ; uint8 public decimals = 4; uint256 public totalSupply = 1000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { deployer = msg.sender; }",1
0x036570162bc64a4e1201f1ba4a3fcd87e35b0b2f.sol,LANDRegistry,"contract LANDRegistry is Storage, Ownable, FullAssetRegistry, ILANDRegistry { bytes4 constant public GET_METADATA = bytes4(keccak256()); function initialize(bytes) external { _name = ; _symbol = ; _description = ; }",1
0xd736402d7eace89667343dbd35ac8c22137fb719.sol,HappyMelodyToken,"contract HappyMelodyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 15000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,Goldmint,"contract GoldmintUnsold is SafeMath { address public creator; address public teamAccountAddress; address public icoContractAddress; uint64 public icoIsFinishedDate; MNTP public mntToken; function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){ creator = msg.sender; teamAccountAddress = _teamAccountAddress; mntToken = MNTP(_mntTokenAddress); }",1
0x5b813a2f4b58183d270975ab60700740af00a3c9.sol,CrystalAirdropGame,contract CrystalAirdropGame { using SafeMath for uint256; address public administrator; uint256 public MINI_GAME_TIME_DEFAULT = 60 * 5; uint256 public MINI_GAME_PRIZE_CRYSTAL = 100; uint256 public MINI_GAME_BETWEEN_TIME = 8 hours; uint256 public MINI_GAME_ADD_TIME_DEFAULT = 15; address public miningWarContractAddress; uint256 public miniGameId = 0; uint256 public noRoundMiniGame; CryptoMiningWarInterface public MiningWarContract; uint256 public MINI_GAME_BONUS = 100; mapping(uint256 => MiniGame) public minigames; mapping(address => PlayerData) public players; struct MiniGame { uint256 miningWarRoundNumber; bool ended; uint256 prizeCrystal; uint256 startTime; uint256 endTime; address playerWin; uint256 totalPlayer; },1
0x6d0a11c04edf666e92777634ddb72f152a798369.sol,BlocHipo,"contract BlocHipo is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping(address=>bool) public frozenAccount; event FrozenFunds(address target, bool frozen); uint256 public constant initialSupply = 2000000000 * 10**18; uint8 public constant decimalUnits = 18; string public tokenName = ; string public tokenSymbol = ; function BlocHipo() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x17b1df92e60ba24539ee2674d8017e9ea6e02e86.sol,AdifyToken,"contract AdifyToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**uint256(decimals); function AdifyToken() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseCrowdsale,"contract StarbaseCrowdsale is Ownable { event CrowdsaleEnded(uint256 endedAt); event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage); event StarbasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data); event CnyEthRateUpdated(uint256 cnyEthRate); event CnyBtcRateUpdated(uint256 cnyBtcRate); event QualifiedPartnerAddress(address qualifiedPartner); AbstractStarbaseToken public starbaseToken; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; uint256 constant public MIN_INVESTMENT = 1; uint256 constant public MAX_CAP = 67000000; string public constant PURCHASE_AMOUNT_UNIT = ; struct CrowdsalePurchase { address purchaser; uint256 amount; uint256 rawAmount; uint256 purchasedAt; string data; uint256 bonus; }",1
0x1b27c2c096ae7e408eef72731fa5ea7e753054de.sol,SUSIToken,"contract SUSIToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SUSIToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6dd5b09acda78b05d0356483fe05eb0768352945.sol,SponseeTokenModelSolaCoin,"contract SponseeTokenModelSolaCoin is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public totalSupply = 500000000 * (10 ** uint256(decimals)); uint public cap = 1000000000 * (10 ** uint256(decimals)); uint public minimumSupport = 500; uint public etherRatioForInvestor = 10; address public sponseeAddress; bool public isPayableEnabled = true; RBInformationStore public rbInformationStore; Rate public rate; event LogReceivedEther(address indexed from, address indexed to, uint etherValue, string tokenName); event LogBuy(address indexed from, address indexed to, uint indexed value, uint paymentId); event LogRollbackTransfer(address indexed from, address indexed to, uint value); event LogExchange(address indexed from, address indexed token, uint value); event LogIncreaseCap(uint value); event LogDecreaseCap(uint value); event LogSetRBInformationStoreAddress(address indexed to); event LogSetName(string name); event LogSetSymbol(string symbol); event LogMint(address indexed to, uint value); event LogChangeSponseeAddress(address indexed to); event LogChangeIsPayableEnabled(bool flag); modifier onlyAccountAddressForSponsee() { require(rbInformationStore.accountAddressForSponsee() == msg.sender); _; }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0xcff681c07541b6921aac59fee73f1bab7b29d7b7.sol,UnilotBonusTailEther,contract UnilotBonusTailEther is BaseUnilotGame { mapping (address => TicketLib.Ticket[]) public tickets; mapping (address => uint) _prize; uint16 numTickets; uint64 winnerIndex; function UnilotBonusTailEther(address calculatorContractAddress) public payable { state = State.ACTIVE; administrator = msg.sender; calculator = UnilotPrizeCalculator(calculatorContractAddress); GameStarted(0); },1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,AppealableArbitrator,"contract AppealableArbitrator is CentralizedArbitrator, Arbitrable { struct AppealDispute { uint rulingTime; Arbitrator arbitrator; uint appealDisputeID; }",1
0x4d887f2c22cbaba11ab094050b37b0c6efd73700.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x34ddcc255d2f3f2e2d85a2a11e314670e73b24d4.sol,lottrygame,"contract lottrygame{ uint256 public people; uint numbers; uint256 public tickamount = 100; uint256 public winnergetETH1 = 0.05 ether; uint256 public winnergetETH2 = 0.03 ether; uint256 public winnergetETH3 = 0.02 ether; uint public gamecount = 0; uint public inputsbt = 100; uint black=1; uint red=2; uint yellow=3; address[] public tickplayers; address public owner; address tokenAddress = 0x503F9794d6A6bB0Df8FBb19a2b3e2Aeab35339Ad; address poolwallet; bool public tickgamelock = true; bool public full = true; event tickwinner(uint,address,address,address,uint,uint,uint); event ticksell(uint gettick,uint paytick); modifier ownerOnly() { require(msg.sender == owner); _; }",1
0x5ab5dded8c5c384015c8f3a27d59bf71b952a3a4.sol,PearlBonus,contract PearlBonus { address public pearlContract = 0x1844b21593262668B7248d0f57a220CaaBA46ab9; OysterPearl pearl = OysterPearl(pearlContract); address public director; address public partner; uint8 public share; uint256 public funds; bool public saleClosed; function PearlBonus() public { director = msg.sender; partner = 0x5F5E3bc34347e1f10C7a0E932871D8DbFBEF9f87; share = 10; funds = 0; saleClosed = false; },1
0xe1f338e069f202f2113d32c8a5d1046d83c92ca4.sol,WorldFomo,"contract WorldFomo is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x6ed17ee485821cd47531f2e4c7b9ef8b48f2bab5); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 15 seconds; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 12 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(32,0); fees_[1] = F3Ddatasets.TeamFee(45,0); fees_[2] = F3Ddatasets.TeamFee(62,0); fees_[3] = F3Ddatasets.TeamFee(47,0); potSplit_[0] = F3Ddatasets.PotSplit(47,0); potSplit_[1] = F3Ddatasets.PotSplit(47,0); potSplit_[2] = F3Ddatasets.PotSplit(62,0); potSplit_[3] = F3Ddatasets.PotSplit(62,0); }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaData,contract EtheramaData { address constant public TOKEN_CONTRACT_ADDRESS = 0x83cee9e086A77e492eE0bB93C2B0437aD6fdECCc; uint256 constant public TOKEN_PRICE_INITIAL = 0.0023 ether; uint64 constant public PRICE_SPEED_PERCENT = 5; uint64 constant public PRICE_SPEED_INTERVAL = 10000; uint64 constant public EXP_PERIOD_DAYS = 365; mapping(address => bool) private _administrators; uint256 private _administratorCount; uint64 public _initTime; uint64 public _expirationTime; uint256 public _tokenOwnerReward; uint256 public _totalSupply; int128 public _realTokenPrice; address public _controllerAddress = address(0x0); EtheramaCore public _core; uint256 public _initBlockNum; bool public _hasMaxPurchaseLimit = false; IStdToken public _token; modifier onlyController() { require(msg.sender == _controllerAddress); _; },1
0x6a5e59fbaea3e07737fbafceb600cbde5a295f24.sol,Escrow,"contract Escrow is Ownable { using SafeMath for uint256; event Deposited(address indexed payee, uint256 weiAmount); event Withdrawn(address indexed payee, uint256 weiAmount); mapping(address => uint256) private deposits; function depositsOf(address _payee) public view returns (uint256) { return deposits[_payee]; }",1
0x30f6a7dff2afba419677ede86d121d5675d67622.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; address public multisig; ERC20 public token; uint rate; uint priceETH; mapping (address => bool) whitelist; event Purchased(address indexed _addr, uint _amount); function getRateCentUsd() public view returns(uint) { if (block.timestamp >= 1539550800 && block.timestamp < 1541019600) { return(70); }",1
0x0cf1125c00b054044aa4f0fc8c4807ec98216fbb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0xf2867370cb077c1fa0cac37759b1cb9dc66acdd3.sol,TokenMigration,"contract TokenMigration is Registry { address public MTUV1; mapping(address => bool) public Migrated; constructor(address prevMTUAddress, address rAddress) public { MTUV1 = prevMTUAddress; RegistryAddress = rAddress; }",1
0x022c635044ba01ced1e098bc32e62a954147f2de.sol,BasicAccessControl,contract BasicAccessControl { address public owner; uint16 public totalModerators = 0; mapping (address => bool) public moderators; bool public isMaintaining = false; function BasicAccessControl() public { owner = msg.sender; },1
0xc0c2d062306fe840e11f7fcf394df831a09ef20c.sol,OkamiPKlong,"contract OkamiPKlong is OPKevents { using SafeMath for *; using NameFilter for string; using OPKKeysCalcLong for uint256; otherFoMo3D private otherOPK_; DiviesInterface constant private Divies = DiviesInterface(0xD2344f06ce022a7424619b2aF222e71b65824975); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xC4665811782e94d0F496C715CA38D02dC687F982); address private Community_Wallet1 = 0x52da4d1771d1ae96a3e9771D45f65A6cd6f265Fe; address private Community_Wallet2 = 0x00E7326BB568b7209843aE8Ee4F6b3268262df7d; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 15 seconds; uint256 private rndGap_ = 1 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => OPKdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => OPKdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => OPKdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => OPKdatasets.TeamFee) public fees_; mapping (uint256 => OPKdatasets.PotSplit) public potSplit_; mapping (uint8 => uint256) public levelValue_; mapping (uint8 => uint8) public levelRate_; mapping (uint8 => uint8) public levelRate2_; constructor() public { levelValue_[3] = 0.01 ether; levelValue_[2] = 1 ether; levelValue_[1] = 5 ether; levelRate_[3] = 5; levelRate_[2] = 3; levelRate_[1] = 2; fees_[0] = OPKdatasets.TeamFee(30,6); fees_[1] = OPKdatasets.TeamFee(43,0); fees_[2] = OPKdatasets.TeamFee(56,10); fees_[3] = OPKdatasets.TeamFee(43,8); potSplit_[0] = OPKdatasets.PotSplit(15,10); potSplit_[1] = OPKdatasets.PotSplit(25,0); potSplit_[2] = OPKdatasets.PotSplit(20,20); potSplit_[3] = OPKdatasets.PotSplit(30,10); }",1
0x31a3b3c80109d0cccc260b3710dd77c968e43ae0.sol,RBAC,"contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); function checkRole(address _operator, string _role) public view { roles[_role].check(_operator); }",1
0x410ae03db747b8c8d4478a4d52092859529307be.sol,Remyt,"contract Remyt is StandardToken, Ownable { string public name = ; string public symbol = ; string public version = ; uint8 public decimals = 18; uint256 INITIAL_SUPPLY = 5500000e18; event Burn(address indexed burner, uint256 value); function Remyt() public { totalSupply_ = INITIAL_SUPPLY; balances[this] = totalSupply_; allowed[this][msg.sender] = totalSupply_; emit Approval(this, msg.sender, balances[this]); }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWData,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0xcdd6e4a8af49493ed5984d57e5e5c292feb9596d.sol,DSMath,"contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); }",1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,ElepigCrowdsale,"contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess { using SafeMath for uint256; enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 }",1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc7df0158f29ff6725cec6a3ac71d26bd08b90ff6.sol,MyTokenEVC,"contract MyTokenEVC is owned { string _name; string _symbol; uint8 _decimals = 18; uint256 _totalSupply; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) _allowance; mapping (address => bool) _frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(_decimals); _balanceOf[msg.sender] = _totalSupply; _name = ; _symbol = ; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,TokenVault,"contract TokenVault is Ownable { address self = address(this); function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) { return Token(token).transfer(to, amount); }",1
0x715423a818f1f9a85c66d81d2809e0a4dadf07f3.sol,Token,"contract TokenI is ERC20Token, Controlled { string public name; uint8 public decimals; string public symbol; function approveAndCall( address _spender, uint256 _amount, bytes _extraData ) public returns (bool success); function generateTokens(address _owner, uint _amount) public returns (bool); function destroyTokens(address _owner, uint _amount) public returns (bool); }",1
0x520308ffce2feaf394be1f23997312dede3ef541.sol,KMBToken,"contract KMBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MediCrowdsale,"contract MediCrowdsale is Ownable { using SafeMath for uint256; MB public token; uint256 public startTime = 1507540345; uint256 public endTime = 1511222399; address public wallet; uint256 public rate = 4000; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function MediCrowdsale(address tokenContractAddress, address _walletAddress) { wallet = _walletAddress; token = MB(tokenContractAddress); }",1
0xe8c7ecb55a88bfd682fb3ad67eb68e3c88840334.sol,DistrictsCore,"contract DistrictsCore is DistrictsAdmin { event NarcoArrived(uint8 indexed location, uint256 indexed narcoId); event NarcoLeft(uint8 indexed location, uint256 indexed narcoId); event TravelBust(uint256 indexed narcoId, uint16 confiscatedWeed, uint16 confiscatedCoke); event Hijacked(uint256 indexed hijacker, uint256 indexed victim , uint16 stolenWeed , uint16 stolenCoke); event HijackDefended(uint256 indexed hijacker, uint256 indexed victim); event EscapedHijack(uint256 indexed hijacker, uint256 indexed victim , uint8 escapeLocation); uint256 public airLiftPrice = 0.01 ether; uint256 public hijackPrice = 0.008 ether; uint256 public travelPrice = 0.002 ether; uint256 public spreadPercent = 5; uint256 public devFeePercent = 2; uint256 public currentDevFees = 0; uint256 public bustRange = 10; function setAirLiftPrice(uint256 _price) public onlyOwner{ airLiftPrice = _price; }",1
0xd40167646c0f5f3b52d3c9b49bd5383a02feef4b.sol,TokenERC20,"contract TokenERC20 is SafeMath { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26dee175b1fbc390fca7e689e6cd1543580175a2.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; constructor(uint256 totalSupply) public { totalSupply_ = totalSupply; balances[msg.sender] = totalSupply_; },1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) public returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0x137099bdc97fa0c487612466333d2b28bf0c2aa4.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0xd69834f67b2f5a760617cc9a9bf5ae3a3bb256c2.sol,Ownable,contract Ownable { address public owner; function Ownable() public { owner = msg.sender; },1
0x0317ada015cf35244b9f9c7d1f8f05c3651833ff.sol,Token,"contract TokenAbout is Controlled { event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); function isContract(address _addr) constant internal returns (bool) { if (_addr == 0) { return false; }",1
0xdbe13bf528ca21bb6c306539109c21a304191f72.sol,HISToken,contract HISToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xda83c0a8587c705122434e8baa50db67ef049263.sol,ICORP,"contract ICORP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ICORP() public { symbol = ; name = ; decimals = 8; _totalSupply = 6700000000000000; balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply; Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply); }",1
0x4e9b6e88e6b83453e3ec6a1ffa0c95f289cf81d5.sol,DailyRoi,contract DailyRoi { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpDataStorage,contract BdpDataStorage is BdpBase { using SafeMath for uint256; struct Region { uint256 x1; uint256 y1; uint256 x2; uint256 y2; uint256 currentImageId; uint256 nextImageId; uint8[128] url; uint256 currentPixelPrice; uint256 blockUpdatedAt; uint256 updatedAt; uint256 purchasedAt; uint256 purchasedPixelPrice; },1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,SimpleMarket,"contract SimpleMarket is owned, WithdrawalContract { uint public startPrice; uint public fixPrice = 0.1 ether; uint internal decimals = 0; bytes32 public productId = 0x0; struct UserStruct { uint userListPointer; bytes32[] productKeys; bytes32 userEmail; bytes32 userName; mapping(bytes32 => uint) productKeyPointers; }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x1aced77b121ed465a95fb5471e3d409fd2d4ede6.sol,ICOToken,"contract ICOToken is BaseToken { uint256 public icoRatio; uint256 public icoBegintime; uint256 public icoEndtime; address public icoSender; address public icoHolder; event ICO(address indexed from, uint256 indexed value, uint256 tokenValue); event Withdraw(address indexed from, address indexed holder, uint256 value); function ico() public payable { require(now >= icoBegintime && now <= icoEndtime); uint256 tokenValue = (msg.value * icoRatio * 10 ** uint256(decimals)) / (1 ether / 1 wei); if (tokenValue == 0 || balanceOf[icoSender] < tokenValue) { revert(); }",1
0x5890ef4e676cd051e59a348b46e0b3e73601f34d.sol,HIW,"contract HIW { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HIW() { owner = 0x878479357C54d993be99bD332b2649A146da41C0; name = ; symbol = ; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[owner] = 10000000000000000000000000000; }",1
0x189394dcd1824c3af35f664d8d47119875278330.sol,yolecoin,contract yolecoin { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 yoleEthRate = 10 ** decimals; uint256 yoleSupply = 1000000000; uint256 public totalSupply = yoleSupply * yoleEthRate; uint256 public freezeDuration = 30 days; bool public running = true; address owner; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public whitelist; mapping (address => uint256) whitelistLimit; struct BalanceInfo { uint256 balance; uint256[] freezeAmount; uint256[] releaseTime; },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,CTCSale,"contract CTCSale is CappedCrowdsale, RefundableCrowdsale { using SafeMath for uint; uint constant private exa = 10 ** 18; uint public minBuy; event WalletChanged(address _wallet); function CTCSale(uint _start,uint _end,uint _rate,uint _cap,address _wallet,CommunityCoin _tokenAddress,uint _goal,uint _minBuy) Crowdsale(_start, _end,_rate,_wallet) CappedCrowdsale(_cap * exa) RefundableCrowdsale(_goal * exa) public { token = CommunityCoin(_tokenAddress); minBuy = _minBuy; }",1
0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1.sol,Crowdsale,"contract Crowdsale is Owned, Stateful { uint public etherPriceUSDWEI; address public beneficiary; uint public totalLimitUSDWEI; uint public minimalSuccessUSDWEI; uint public collectedUSDWEI; uint public crowdsaleStartTime; uint public crowdsaleFinishTime; struct Investor { uint amountTokens; uint amountWei; }",1
0xa3d48af5b7541658e7b663905f11433f1b4074f5.sol,OysterPearl,"contract OysterPearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public funds = 0; address public owner; bool public saleClosed = false; bool public ownerLock = false; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed payout, address indexed fee); function OysterPearl() public { owner = msg.sender; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); }",1
0x088674acdb4f6ac52fa46f8334955e34b00b0b36.sol,CCD_KOHLE_10_20190411,"contract CCD_KOHLE_10_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1b6089efb8932f5fd47d98c8a5eabd77ed7e8107.sol,YoLoChips,"contract YoLoChips is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100000; uint256 public tokensPerEth = 100000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0x4726bf61c3a8df967b6f2c805659810e8d343218.sol,Agriss,contract Agriss { uint8 public decimals = 18; mapping (address => uint256) public balanceOf; constructor ( uint256 initialSupply ) public { balanceOf[msg.sender] = initialSupply * 10 ** uint256(decimals); },1
0x1844b21593262668b7248d0f57a220caaba46ab9.sol,OysterPearl,"contract OysterPearl { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Bury(address indexed _target, uint256 _value); event Claim(address indexed _target, address indexed _payout, address indexed _fee); function OysterPearl() public { director = msg.sender; name = ; symbol = ; decimals = 18; saleClosed = true; directorLock = false; funds = 0; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 8000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); epoch = 31536000; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x404a639086eda1b9c8aba3e34a5f8145b4b04ea5.sol,Silver,"contract Silver is BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public constant initialSupply = 100000000000 * (10 ** uint256(decimals)); function Silver () { totalSupply = initialSupply; balances[msg.sender] = initialSupply; }",1
0xdda9bcd985b1169607546b52910a0269dff5baf1.sol,Goo,contract Goo is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalGooProduction; address public owner; bool public gameStarted; uint256 public totalEtherGooResearchPool; uint256[] public totalGooProductionSnapshots; uint256[] public allocatedGooResearchSnapshots; uint256 public nextSnapshotTime; uint256 private MAX_PRODUCTION_UNITS = 999; uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000; mapping(address => uint256) private ethBalance; mapping(address => uint256) private gooBalance; mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; mapping(address => uint256) private lastGooSaveTime; mapping(address => uint256) public lastGooProductionUpdate; mapping(address => uint256) private lastGooResearchFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(uint256 => uint256)) private unitsOwned; mapping(address => mapping(uint256 => bool)) private upgradesOwned; mapping(uint256 => address) private rareItemOwner; mapping(uint256 => uint256) private rareItemPrice; mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; mapping(address => mapping(uint256 => uint256)) private unitAttackIncreases; mapping(address => mapping(uint256 => uint256)) private unitAttackMultiplier; mapping(address => mapping(uint256 => uint256)) private unitDefenseIncreases; mapping(address => mapping(uint256 => uint256)) private unitDefenseMultiplier; mapping(address => mapping(uint256 => uint256)) private unitGooStealingIncreases; mapping(address => mapping(uint256 => uint256)) private unitGooStealingMultiplier; mapping(address => mapping(address => uint256)) private allowed; mapping(address => bool) private protectedAddresses; struct TicketPurchases { TicketPurchase[] ticketsBought; uint256 numPurchases; uint256 raffleRareId; },1
0x4d4ce166009ce46a73bca189f144e9c5fae25cc6.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) public whitelistedAddress; modifier onlyIfWhitelisted(address _address) { require(whitelistedAddress[_address]); _; },1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xf0f9569413d99964ec01bd900126e90c70edda6a.sol,Rollercoaster,contract Rollercoaster { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x651efeba62be2911f211b9e39ae7dcf3094bd758.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; bool public teamStakesFrozen = true; mapping(address => uint256) balances; address public owner; function BasicToken() public { owner = msg.sender; },1
0x74c3bad428ed6511da87df578d6577d5a75392ef.sol,KunlunToken,"contract KunlunToken is Ownable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function KunlunToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8b6c0dbc499eaf97f54b54fe0019a4c676db534a.sol,BYT,contract BYT is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 100 * (10**8) * (10**8); balances[msg.sender] = totalSupply; name = ; decimals = 8; symbol = ; },1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x69d2779533a4d2c780639713558b2cc98c46a9b7.sol,VNT,"contract VNT is SafeMath { string constant tokenName = ; string constant tokenSymbol = ; uint8 constant decimalUnits = 8; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply = 100 * (10**8) * (10**8); address public owner; mapping(address => bool) restrictedAddresses; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier onlyOwner { assert(owner == msg.sender); _; }",1
0x56434ad1e38a564e76eae08c7118e5e7b450aa6c.sol,PlayerToken,"contract PlayerToken is ERC20 { address public owner; bool public paused = false; event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol); event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol); using SafeMath for uint256; uint256 public initialTokenPrice_; uint256 public incrementalTokenPrice_; string public name; string public symbol; uint8 public constant decimals = 0; address public exchangeContract_; BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F); uint256 public playerId_; address public originalOwner_; uint8 constant internal processingFee_ = 5; uint8 constant internal originalOwnerFee_ = 2; uint8 internal dividendBuyPoolFee_ = 15; uint8 internal dividendSellPoolFee_ = 20; uint8 constant internal referrerFee_ = 1; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; address[] public tokenHolders; mapping(address => uint256) public addressToTokenHolderIndex; mapping(address => int256) public totalCost; uint256 totalSupply_; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x32a44d9d49a05f9049cd7f8eb0e3d19c90dd2421.sol,DragonDistributions,contract DragonDistributions { address public dragon; uint256 public clock; address public prime; address public film; address public northadvisor; address public southadvisor; uint public filmamount; bool public filmpaid; mapping ( address => uint256 ) public balanceOf; mapping ( address => bool ) public distributionOne; mapping ( address => bool ) public distributionTwo; mapping ( address => bool ) public distributionThree; mapping ( address => bool ) public advisors; uint256 public awardAmount = 45000000000000; uint256 public awardAmountPrime = 100000000000000; function DragonDistributions () { dragon = 0x814F67fA286f7572B041D041b1D99b432c9155Ee; prime = 0x243098c1e16973c7e3e969c289c5b87808e359c1; film = 0xdFCf69C8FeD25F5150Db719BAd4EfAb64F628d31; northadvisor = 0x74Fc8fA4F99b6c19C250E4Fc6952051a95F6060D; southadvisor = 0xCC3c6A89B5b8a054f21bCEff58B6429447cd8e5E; clock = now; filmamount = 2500000000000; balanceOf[ film ] = awardAmount + filmamount; balanceOf[ northadvisor ] = awardAmount; balanceOf[ southadvisor ] = awardAmount; balanceOf[ prime ] = awardAmountPrime; advisors [ film ] = true; advisors [ northadvisor ] = true; advisors [ southadvisor ] = true; filmpaid = false; },1
0x4072e3eeaf72433f83059e792249eeb868ca693c.sol,Gateway,contract Gateway is Ownable{ using SafeMath for uint; address public feeAccount1 = 0x1eB58eb6c0b145537e921bd63701993cAE5f5f36; address public feeAccount2 = 0x00ff115Ec2A28b6fE9Ad9D434b290300bd91FaD4; address public feeAccountToken = 0x23fB9004Ee9a931e9AC64850615852f626C27902; struct BuyInfo { address buyerAddress; address sellerAddress; uint value; address currency; },1
0x28863b9534af2a4c3d912e9a3b76b0b7b4fe2046.sol,ViberateBuyer,"contract ViberateBuyer { mapping (address => uint256) public balances; uint256 public buy_bounty; uint256 public withdraw_bounty; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4; uint256 public earliest_buy_time = 1504612800; uint256 public eth_cap = 10000 ether; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0x1806b3527c18fb532c46405f6f014c1f381b499a.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); event cardChange( uint256 indexed search_token_id, address indexed search_owner, uint256 token_id, address owner, uint256 changeType, bytes32 data, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x54ad74edeab48e09ccc43ee324f2603071dad72b.sol,DTOPToken,"contract DTOPToken is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x33d1a1a2d781d395eace70e69423c594e52f1a8b.sol,Token,"contract Token is MultiOwner, ERC20, ERC223{ using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 3; uint256 public totalSupply = 888888888 * 10 ** uint256(decimals); uint256 public EthPerToken = 800000; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,TokenL,"contract TokenL is Pausable, BlockedToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public unpausedWallet; bool public mintingFinished = false; uint256 public totalMigrated; address public migrationAgent; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Mint(address indexed to, uint256 amount); event MintFinished(); event Migrate(address indexed _from, address indexed _to, uint256 _value); modifier canMint() { require(!mintingFinished); _; }",1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0x708373572be20a1c4891083097d68a58970f6ec9.sol,LikaCrowdsale,"contract LikaCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x35b6a52663a7bf34ea4e2b693da2cca2bc4f7588.sol,NDD_NFX_I_883,"contract NDD_NFX_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 4250507023558140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x510a4ab35fcb498f798a0da8187012d78be3bd72.sol,JNTStorage,contract JNTStorage is JCashCrydrStorage { function JNTStorage() JCashCrydrStorage() public {},1
0x8633e144f2d9b9b8bdd12ddb58e4bef1e163a0ce.sol,Yellow,"contract Yellow { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Yellow( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e.sol,CustodianCanBeReplaced,contract CustodianCanBeReplaced is Zamok { struct CustodianChangeRequest { address proposedNew; },1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,ERC721dAppCaps,"contract ERC721dAppCaps is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721, Ownable, Fallback { event BoughtToken(address indexed buyer, uint256 tokenId); string public constant company = ; string public constant contact = ""https: string public constant author = ; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MAX_LENGTH = 100000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescriptions; mapping(uint256 => string) specialQualities; mapping(uint256 => string) tokenClasses; mapping(uint256 => string) iptcKeywords; constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0xdb2fb534e111e57e1a97adae7fdb83d92062e3c1.sol,EAB,"contract EAB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EAB( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0x6a33c2c807124eae26f6188877c15675d3889ca3.sol,TUNEZ,contract TUNEZ is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function TUNEZ() { balances[msg.sender] = 2400000000000000000000000000; totalSupply = 2400000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000000; fundsWallet = msg.sender; },1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8.sol,DailyDivs,contract DailyDivs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd850942ef8811f2a866692a623011bde52a462c1.sol,VENSale,"contract VENSale is Owned{ enum Stage { NotCreated, Created, Initialized, Early, Normal, Closed, Finalized }",1
0x586bf07847618b7c28ee5aca68b1c455c7c5172d.sol,Refundable,"contract Refundable is Ownable { event RefundETH(address indexed owner, address indexed payee, uint256 amount); event RefundERC20(address indexed owner, address indexed payee, address indexed token, uint256 amount); function Refundable() public payable { }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Synthetix,"contract SynthetixState is State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; struct IssuanceData { uint initialDebtOwnership; uint debtEntryIndex; }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,BattleOfThermopylae,"contract BattleOfThermopylae is Timed, Upgradable { using SafeMathLib for uint; uint public constant MAX_PERSIANS = 300000 * 10**18; uint public constant MAX_SPARTANS = 300 * 10**18; uint public constant MAX_IMMORTALS = 100; uint public constant MAX_ATHENIANS = 100 * 10**18; uint8 public constant BP_PERSIAN = 1; uint8 public constant BP_IMMORTAL = 100; uint16 public constant BP_SPARTAN = 1000; uint8 public constant BP_ATHENIAN = 100; uint8 public constant BTL_PERSIAN = 1; uint16 public constant BTL_IMMORTAL = 2000; uint16 public constant BTL_SPARTAN = 1000; uint16 public constant BTL_ATHENIAN = 2000; uint public constant WAD = 10**18; uint8 public constant BATTLE_POINT_DECIMALS = 18; uint8 public constant BATTLE_CASUALTIES = 10; address public persians; address public immortals; address public spartans; address public athenians; address public battles; address public battlesOwner; mapping (address => mapping (address => uint)) public warriorsByPlayer; mapping (address => uint) public warriorsOnTheBattlefield; event WarriorsAssignedToBattlefield (address indexed _from, address _faction, uint _battlePointsIncrementForecast); event WarriorsBackToHome (address indexed _to, address _faction, uint _survivedWarriors); function BattleOfThermopylae(uint _startTime, uint _life, uint8 _avarageBlockTime, address _persians, address _immortals, address _spartans, address _athenians) Timed(_startTime, _life, _avarageBlockTime) Upgradable() { persians = _persians; immortals = _immortals; spartans = _spartans; athenians = _athenians; }",1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0x3665d085e997bb00d59c1ece3e1189f1a1a47302.sol,KM,"contract KM is owned{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public lockValue; mapping (address => uint256) public lockTime; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Lock(address indexed ac, uint256 value, uint256 time); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,Creator,contract Creator{ Token public token = new Token(); RefundVault public refund = new RefundVault(); function createToken() external returns (Token) { token.transferOwnership(msg.sender); return token; },1
0x219fa49440c6c7d9f21c0f2c87d638b35382ab5a.sol,TradeableToken,"contract TradeableToken is LockableToken { address internal publicOfferingAddress = 0xdC23333Acb4dAAd88fcF66D2807DB7c8eCDFa6dc; uint256 public exchangeRate = 100000; function buy(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != 0x0); require(publicOfferingAddress != 0x0); require(exchangeRate > 0x0); require(_weiAmount > 0x0); uint256 exchangeToken = _weiAmount.mul(exchangeRate); exchangeToken = exchangeToken.div(1 * 10 ** 12); publicOfferingAddress.transfer(_weiAmount); super.transferInternal(publicOfferingAddress, _beneficiary, exchangeToken); }",1
0xb3bbc0cc040413a3e68dcaa8f2b6eac2957c5ce0.sol,PLATPriceOracle,contract PLATPriceOracle { mapping (address => bool) admins; uint256 public ETHPrice = 60000000000000000000000; event PriceChanged(uint256 newPrice); constructor() public { admins[msg.sender] = true; },1
0x7192bb75777dab47ef6fbf6f6c0e4bcbb2294f38.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[4] public lastGen0SalePrices; function SaleClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x515ced0695fdcb330ff7ef72e1844e48d496f2c2.sol,DividableAsset,"contract DividableAsset is AssetHashToken, ERC20Interface { using SafeMath for uint; ERC20Interface stableToken; string public name; string public symbol; uint8 public decimals; uint public _totalSupply; address operator; uint collectPrice; address[] internal allowners; mapping (address => uint) public indexOfowner; mapping (address => uint) public balances; mapping (address => mapping (address => uint)) public allowed; modifier onlySplitted { require(isSplitted == true, ); _; }",1
0x00763473e9d7c82f38ed843f021e2558d7422ad8.sol,SmartToken,"contract SmartToken is BurnableToken, CappedToken, PausableToken { constructor(uint256 _cap) public CappedToken(_cap) {}",1
0x2e98a6804e4b6c832ed0ca876a943abd3400b224.sol,Bela,"contract Bela is MintableToken, HasNoEther { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public ownerTimeLastMinted; uint public ownerMintRate; uint private globalMintRate; uint public totalBelaStaked; struct TokenStakeData { uint initialStakeBalance; uint initialStakeTime; uint initialStakePercentage; address stakeSplitAddress; }",1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,SmartHomeCoin,"contract SmartHomeCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartHomeCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2119a3314c1d40704d816392a9e44da463688992.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address prize_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr1 = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr2 = 0x6c7dfe3c255a098ea031f334436dd50345cfc737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x748286a6a4cead7e8115ed0c503d77202eeeac6b); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x7050f87ca2691761f996c5060530c38c2a1288fa.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x8b548505babfd983fc45210499b44e340bb85d76.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256 public totalHedgelyWinnings; uint256 public totalHedgelyInvested; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event EndSession( uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; }",1
0x31cf75e0839a79c8914569465b6ce9e3d6fc9959.sol,CardConfig,"contract CardConfig { enum Type {Monster, Spell}",1
0x2cddb55c7f453394526c0712d559fe82cde9260b.sol,QCSTToken,"contract QCSTToken is Token, Owner { uint256 public constant INITIAL_SUPPLY = 20 * 10000 * 10000 * 1 ether; string public constant NAME = ; string public constant SYMBOL = ; string public constant STANDARD = ; uint8 public constant DECIMALS = 18; uint256 public constant BUY = 0; uint256 constant RATE = 1 szabo; bool private couldTrade = false; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) frozenAccount; event FrozenFunds(address indexed _target, bool _frozen); function QCSTToken() Token(INITIAL_SUPPLY, NAME, DECIMALS, SYMBOL, STANDARD) { balanceOf[msg.sender] = totalSupply; buyPrice = 100000000; sellPrice = 100000000; }",1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,SupportsInterfaceWithLookup,contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) internal supportedInterfaces; constructor() public { _registerInterface(InterfaceId_ERC165); },1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Lotthereum,"contract Lotthereum is Mortal, SafeMath { Game[] private games; mapping (address => uint) private balances; struct Game { uint id; uint pointer; uint maxNumberOfBets; uint minAmountByBet; uint prize; uint currentRound; Round[] rounds; }",1
0x2119a3314c1d40704d816392a9e44da463688992.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address prize_addr = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr1 = 0xfd76dB2AF819978d43e07737771c8D9E8bd8cbbF; address activate_addr2 = 0x6c7dfe3c255a098ea031f334436dd50345cfc737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x748286a6a4cead7e8115ed0c503d77202eeeac6b); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x89b5eaec2702ab0ff33ca397b3e66c7d925d5144.sol,Soccer,"contract Soccer { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; struct Token { address owner; uint256 price; }",1
0x5b366f606dab2a1e221da2588f62bfe454760e78.sol,CryptoRichmanToken,contract CryptoRichmanToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x12b470a5c9055d312e1af0259b65976dce608e5d.sol,Lighthouse,"contract Lighthouse { address public auth = msg.sender; Searcher seeker; uint value; uint maxAge; modifier onlyAuth { require(auth == msg.sender, ); _; }",1
0xdac15794f0fadfdcf3a93aeaabdc7cac19066724.sol,GreenX,"contract GreenX is Owner { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 constant public totalSupply = 375000000 * 10 ** 18; mapping(address => uint256) internal balances; mapping(address => mapping (address => uint256)) internal allowed; address public portalAddress; address public adminAddress; address public walletAddress; address public founderAddress; address public teamAddress; mapping(address => bool) public privateList; mapping(address => bool) public whiteList; mapping(address => uint256) public totalInvestedAmountOf; uint constant lockPeriod1 = 180 days; uint constant lockPeriod2 = 1 years; uint constant lockPeriod3 = 2 years; uint constant NOT_SALE = 0; uint constant IN_PRIVATE_SALE = 1; uint constant IN_PRESALE = 2; uint constant END_PRESALE = 3; uint constant IN_1ST_ICO = 4; uint constant IN_2ND_ICO = 5; uint constant IN_3RD_ICO = 6; uint constant END_SALE = 7; uint256 public constant salesAllocation = 187500000 * 10 ** 18; uint256 public constant bonusAllocation = 37500000 * 10 ** 18; uint256 public constant reservedAllocation = 90000000 * 10 ** 18; uint256 public constant founderAllocation = 37500000 * 10 ** 18; uint256 public constant teamAllocation = 22500000 * 10 ** 18; uint256 public constant minInvestedCap = 2500 * 10 ** 18; uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; uint saleState; uint256 totalInvestedAmount; uint public icoStartTime; uint public icoEndTime; bool public inActive; bool public isSelling; bool public isTransferable; uint public founderAllocatedTime = 1; uint public teamAllocatedTime = 1; uint256 public privateSalePrice; uint256 public preSalePrice; uint256 public icoStandardPrice; uint256 public ico1stPrice; uint256 public ico2ndPrice; uint256 public totalRemainingTokensForSales; uint256 public totalReservedAndBonusTokenAllocation; uint256 public totalLoadedRefund; uint256 public totalRefundedAmount; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event ModifyWhiteList(address investorAddress, bool isWhiteListed); event ModifyPrivateList(address investorAddress, bool isPrivateListed); event StartPrivateSales(uint state); event StartPresales(uint state); event EndPresales(uint state); event StartICO(uint state); event EndICO(uint state); event SetPrivateSalePrice(uint256 price); event SetPreSalePrice(uint256 price); event SetICOPrice(uint256 price); event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); event RevokeTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint256 txFee); event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); event Refund(address investorAddress, uint256 etherRefundedAmount, uint256 tokensRevokedAmount); modifier isActive() { require(inActive == false); _; }",1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x714d13c3bebfbf1097db48141471e78f9035dca5.sol,ETD,"contract ETD{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ETD() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x21751800ce87a89acd6c0edd4c181dced679288e.sol,EasySmartolutionProcessor,contract EasySmartolutionProcessor { address constant public smartolution = 0x2628E13a3CBDC52Ed96b4B8D6b1041D3EF3A409e; constructor () public { },1
0x40e1633a5e639270b3ba33c3f3a23dcc2e7c54fb.sol,HKTToken,"contract HKTToken is StandardToken { address public administror; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public INITIAL_SUPPLY = 30000000000*10**8; mapping (address => uint256) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed target, uint256 value); constructor() public { totalSupply_ = INITIAL_SUPPLY; administror = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x1a8b802d4d89f763e940f93e885a86a41ee89c9d.sol,EUROPEANMONEY,contract EUROPEANMONEY { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint public _totalSupply = 90000000000000000; uint256 public RATE = 1; bool public isMinting = true; bool public isExchangeListed = false; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x50430b6201c9859c91a5590ac71700cc71499a0e.sol,GetPaid,"contract GetPaid is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 2; uint256 public totalSupply = 30000000000e2; uint256 public totalDistributed = 0; uint256 public totalValue = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 100000e2; uint256 public tokensPerEth = 10000000e2; uint256 public constant minContribution = 1 ether / 100; uint256 public constant maxTotalValue = 15000000000e2; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event Distr0(address indexed to, uint256 amount); event DistrFinished(); event ZeroEthFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; bool public zeroDistrFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3a7ebc138fd59ccce16b7968199c2ac7b013bbc0.sol,NewToken,contract NewToken { function NewToken() { totalSupply = 1000000000000000000; name = ; decimals = 9; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; address public miningWarAddress; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0xc5fdd0f8cb5706ff35d62b16885c222574c295b2.sol,Contributions,"contract Contributions is RBAC, Ownable { using SafeMath for uint256; string public constant ROLE_OPERATOR = ; modifier onlyOperator () { checkRole(msg.sender, ROLE_OPERATOR); _; }",1
0x2a062a343b53bb8fcee929d50f14ce4b418f455b.sol,DTCStandardToken,"contract DTCStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xdda9bcd985b1169607546b52910a0269dff5baf1.sol,GooGameConfig,contract GooGameConfig { mapping(uint256 => Unit) private unitInfo; mapping(uint256 => Upgrade) private upgradeInfo; mapping(uint256 => Rare) private rareInfo; uint256 public constant currentNumberOfUnits = 14; uint256 public constant currentNumberOfUpgrades = 42; uint256 public constant currentNumberOfRares = 2; struct Unit { uint256 unitId; uint256 baseGooCost; uint256 gooCostIncreaseHalf; uint256 ethCost; uint256 baseGooProduction; uint256 attackValue; uint256 defenseValue; uint256 gooStealingCapacity; },1
0xc4ffe62c0aaf8e4e0beb5b08f662591550997f80.sol,ENAToken,contract ENAToken is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public totalSupply = 990 * 1000 * 1000 ether; function ENAToken() public { balances[msg.sender] = totalSupply; },1
0x1d6c596bb5022a4338b6b8651f3acd4d836ef574.sol,Custody,"contract Custody { using SafeMath for uint; BBODServiceRegistry public bbodServiceRegistry; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor(address _serviceRegistryAddress, address _owner) public { bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress); owner = _owner; }",1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x77faed976e187f26b49e78be8418ab074a341f26.sol,ERC20Token,contract ERC20Token is Owned { using SafeMath for uint; uint256 _totalSupply = 100000000.000000000000000000; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function totalSupply() constant returns (uint256 totalSupply) { totalSupply = _totalSupply; },1
0xa35f8ec479ba1f8113b27636f1dfa3ae30c3eeae.sol,DogecoinPrivate,"contract DogecoinPrivate is BaseToken, AirdropToken, ICOToken { function DogecoinPrivate() public { totalSupply = 3000000000000000000; name = ; symbol = ; decimals = 8; balanceOf[0x699314d7f6b59C9a2B1e1a8D87C0f37D4024F14E] = totalSupply; Transfer(address(0), 0x699314d7f6b59C9a2B1e1a8D87C0f37D4024F14E, totalSupply); airAmount = 100000000; airBegintime = 1530198000; airEndtime = 1530198300; airSender = 0x699314d7f6b59C9a2B1e1a8D87C0f37D4024F14E; airLimitCount = 1; icoRatio = 20000000; icoBegintime = 1530198000; icoEndtime = 1535500740; icoSender = 0x08b0a02C08eab4a000236b2B9606cCf21e4E075E; icoHolder = 0x08b0a02C08eab4a000236b2B9606cCf21e4E075E; }",1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0x587e276dc7f2c97d986e8adf9b82d3f14d6cd8d2.sol,Fysical,contract Fysical is StandardToken { using SafeMath for uint256; struct Uri { string value; },1
0x6ba29728e955ff970c94d7ab0a4ff17c628f325a.sol,CasinoBank,"contract CasinoBank is chargingGas { uint public playerBalance; mapping(address => uint) public balanceOf; mapping(address => uint) public withdrawAfter; mapping(address => uint) public withdrawCount; uint public maxDeposit; uint public maxWithdrawal; uint public waitingTime; address public predecessor; event Deposit(address _player, uint _numTokens, uint _gasCost); event Withdrawal(address _player, address _receiver, uint _numTokens, uint _gasCost); function CasinoBank(uint depositLimit, address predecessorAddr) internal { maxDeposit = depositLimit * oneEDG; maxWithdrawal = maxDeposit; waitingTime = 24 hours; predecessor = predecessorAddr; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,Crowdsale,"contract Crowdsale is Pausable, TokenVesting { using SafeMath for uint; address public multisigETH; address public commissionAddress; uint public tokensForTeam; uint public ethReceivedPresale; uint public ethReceivedMain; uint public totalTokensSent; uint public tokensSentMain; uint public tokensSentPresale; uint public tokensSentDev; uint public startBlock; uint public endBlock; uint public maxCap; uint public minCap; uint public minContributionMainSale; uint public minContributionPresale; uint public maxContribution; bool public crowdsaleClosed; uint public tokenPriceWei; uint public refundCount; uint public totalRefunded; uint public campaignDurationDays; uint public firstPeriod; uint public secondPeriod; uint public thirdPeriod; uint public firstBonus; uint public secondBonus; uint public thirdBonus; uint public multiplier; uint public status; Step public currentStep; address[] public holdersIndex; address[] public devIndex; enum Step { FundingPreSale, FundingMainSale, Refunding }",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5aad8436ec6320e846084aa4e6e6231387e8950a.sol,Artwork,"contract Artwork { address public owner; bytes32 public SHA256ofArtwork; uint256 editionSize; string title; string fileLink; string public proofLink; string public customText; uint256 public ownerCommission; uint256 public lowestAskPrice; address public lowestAskAddress; uint256 public lowestAskTime; bool public pieceForSale; uint256 public highestBidPrice; address public highestBidAddress; uint256 public highestBidTime; uint public activationTime; bool public pieceWanted; event newLowestAsk (uint256 price, address seller); event newHighestBid (uint256 price, address bidder); event pieceTransfered (uint256 amount, address from, address to); event pieceSold (address from, address to, uint256 price); event Transfer (address indexed _from, address indexed _to, uint256 _value); event Approval (address indexed _owner, address indexed _spender, uint256 _value); event Burn (address indexed _owner, uint256 _amount); bool proofSet; uint256 ethartAward; mapping (address => uint256) public piecesOwned; mapping (address => mapping (address => uint256)) allowed; address registrar = 0x562b85ACEEE81876D27252B7dc06f03F6A2565fc; function Artwork ( bytes32 _SHA256ofArtwork, uint256 _editionSize, string _title, string _fileLink, string _customText, uint256 _ownerCommission, address _owner ) { if (_ownerCommission > 9750 || _ownerCommission <0) {throw;}",1
0xf2c853703ce87bfc0db38323364fa6551efbd710.sol,PEXToken,contract PEXToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 200000000 * (10 ** uint256(decimals)); function PEXToken() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0x4c17c61ce6edd113346d993aed193dda7ae57b9e.sol,PeerLicensing,contract PeerLicensing{ uint256 constant scaleFactor = 0x10000000000000000; uint256 constant trickTax = 3; uint256 constant tricklingUpTax = 6; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = 0x2793DB20E4C20163A; mapping(address => uint256) public bondHoldings; mapping(address => uint256) public averageBuyInPrice; mapping(address => address) public reff; mapping(address => uint256) public tricklePocket; mapping(address => uint256) public trickling; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public tricklingSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerToken; uint256 public contractBalance; function PeerLicensing() public { },1
0x178ab5b0ff6db1e0cbe569c091607d8f5d6e4c6c.sol,FinPro,contract FinPro is Ownable { using SafeMath for uint256; string private constant name = ; string private constant version = ; uint256[] private fplowerlim; uint256[] private fplocktime; uint256[] private fpinterest; uint256 private fpcount; ERC20Token private token; struct investedData { uint256 fpnum; uint256 buytime; uint256 unlocktime; uint256 value; bool withdrawn; },1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70673d36178f17ac064747c7bdd026240be194b5.sol,UNIQ,"contract UNIQ { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function UNIQ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b5afaa565aba14833de0cee321e63a807fd407b.sol,TulipMania,"contract TulipMania is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510758000; uint public constant DATE_PRESALE_END = 1511362800; uint public constant DATE_ICO_START = 1511362801; uint public constant DATE_ICO_END = 1513868400; uint public tokensPerEth = 336 * E6; uint public constant BONUS_PRESALE = 100; uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; uint public constant TOKEN_SUPPLY_ICO = 8500000 * E6; uint public constant TOKEN_SUPPLY_MKT = 1500000 * E6; uint public constant PRESALE_ETH_CAP = 750 ether; uint public constant MIN_CONTRIBUTION = 1 ether / 500; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 2 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function TulipMania() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleManager,contract CrowdsaleManager is Manageable { using SafeMath for uint256; uint256 public constant decimals = 18; CrowdsaleToken public token; Crowdsale public sale1; Crowdsale public sale2; Crowdsale public sale3; address public constant tokenReserved1Deposit = 0x6EE96ba492a738BDD080d7353516133ea806DDee; address public constant tokenReserved2Deposit = 0xAFBcB72fE97A5191d03E328dE07BB217dA21EaE4; address public constant tokenReserved3Deposit = 0xd7118eE872870040d86495f13E61b88EE5C93586; address public constant tokenReserved4Deposit = 0x08ce2b3512aE0387495AB5f61e6B0Cf846Ae59a7; address public constant withdrawWallet1 = 0xf8dafE5ee19a28b95Ad93e05575269EcEE19DDf2; address public constant withdrawWallet2 = 0x6f4aF515ECcE22EA0D1AB82F8742E058Ac4d9cb3; address public constant withdrawWallet3 = 0xd172E0DEe60Af67dA3019Ad539ce3190a191d71D; uint256 public constant tokenSale = 750000000 * 10**decimals + 3000 * 1000 * 10**decimals; uint256 public constant tokenReserved1 = 150000000 * 10**decimals - 3000 * 1000 * 10**decimals; uint256 public constant tokenReserved2 = 270000000 * 10**decimals; uint256 public constant tokenReserved3 = 105000000 * 10**decimals; uint256 public constant tokenReserved4 = 225000000 * 10**decimals; function CrowdsaleManager() public { },1
0x3612d93f91c8fdb5f158a7c35dd7f87c63ad3f9b.sol,MobaBase,contract MobaBase { address public owner = 0x0; bool public isLock = false; constructor () public { owner = msg.sender; },1
0x720608228bda773fe22e816ee72463040f11c19e.sol,KITToken,"contract KITToken is StandardToken, Ownable { using SafeMath for uint256; event Mint(address indexed to, uint256 amount); event MintFinished(); string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; bool public mintingFinished = false; address public saleAgent; modifier notLocked() { require(msg.sender == owner || msg.sender == saleAgent || mintingFinished); _; }",1
0xd9ff8cc0433c995f3a9711f1400329cd6a40387f.sol,EtherKnightGame,"contract EtherKnightGame { HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882); using SafeMath for uint256; using SafeMath128 for uint128; event OwnershipTransferred( address previousOwner, address nextOwner, uint256 timeStamp ); event HDXcontractChanged( address previous, address next, uint256 timeStamp ); event onWithdrawGains( address customerAddress, uint256 ethereumWithdrawn, uint256 timeStamp ); event onNewRound( uint256 gRND, uint32 turnRound, uint32 eventType, uint32 eventTarget, uint32[4] persoEnergy, uint32[4] persoDistance, uint32[4] powerUpSpeed, uint32[4] powerUpShield, uint256 blockNumberTimeout, uint256 treasureAmountFind, address customerAddress ); event onNewRace( uint256 gRND, uint8[4] persoType, uint256 blockNumber ); event onBuyShare( address customerAddress, uint256 gRND, uint32 perso, uint256 nbToken, uint32 actionType, uint32 actionValue ); event onMaintenance( bool mode, uint256 timeStamp ); event onRefund( address indexed customerAddress, uint256 eth, uint256 timeStamp ); event onCloseEntry( uint256 gRND ); event onChangeBlockTimeAverage( uint256 blocktimeavg ); modifier onlyOwner { require (msg.sender == owner ); _; }",1
0x18b32c25af3b6069c8e911e031bf519da69a9014.sol,TimeLockToken,"contract TimeLockToken is Ownable, MintableToken{ using SafeMath for uint256; struct LockedBalance { uint256 releaseTime; uint256 amount; }",1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,CrowdsaleTokenController,"contract CrowdsaleTokenController is Ownable, AddressWhitelist, TokenController { bool public whitelistOff; Bounty0xToken public token; function CrowdsaleTokenController(Bounty0xToken _token) public { token = _token; }",1
0x18a60cc53101d8aae343acc9357d347bc79c6549.sol,SupportsInterfaceWithLookup,contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; mapping(bytes4 => bool) internal supportedInterfaces; constructor() public { _registerInterface(InterfaceId_ERC165); },1
0x537607e30d7a4343fe555d3087ec4762f9002a2c.sol,eBitcoincash,contract eBitcoincash is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function eBitcoincash() { balances[msg.sender] = 30000000000000000000000000000; totalSupply = 30000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000000; fundsWallet = msg.sender; },1
0x2758cf73421a81f09acdbffec2ebdc3125de0433.sol,AqwireToken,"contract AqwireToken is StandardBurnableToken, Whitelist { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 250000000 * (10 ** uint256(decimals)); uint256 public unlockTime; constructor() public{ totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); addAddressToWhitelist(msg.sender); }",1
0xede8792712d075abf085b49ebb4d80a0d2ed888d.sol,Ecosystem,contract Ecosystem is Ownable{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0xd8866cc3e8426511b756045f2d7c7c20797b9a0a.sol,MintableTokenExt,"contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; }",1
0x6a02e1a01e24007c80d3c377ce8ea624bf2a22c6.sol,Fomo60Min,"contract Fomo60Min is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xe9f984847c8bd1c8842d108e2755be0d4eac7dba); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 1 hours; uint256 constant private preIcoMax_ = 100000000000000000000; uint256 constant private preIcoPerEth_ = 1000000000000000000; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,BitpaintingStorage,"contract BitpaintingStorage is PaintingStorage, PaintingInformationStorage, AccessControlStorage, AuctionStorage, EditionStorage { uint8 mode; function BitpaintingStorage(uint8 _mode) public { require(_mode >= 0 && _mode <=2); mode = _mode; }",1
0x54c14fcb13772f6c56d09264e8fc3b050a458cdb.sol,ApolloSeptemCrowdsale,"contract ApolloSeptemCrowdsale is ApolloSeptemCappedCrowdsale, Ownable { bool public isFinalized = false; bool public isStarted = false; event ApolloSeptemStarted(); event ApolloSeptemFinalized(); function ApolloSeptemCrowdsale(address _wallet,address _tokensAddress) public ApolloSeptemCappedCrowdsale() ApolloSeptemBaseCrowdsale(_wallet,_tokensAddress) { }",1
0x510a4ab35fcb498f798a0da8187012d78be3bd72.sol,Pausable,contract PausableInterface { event PauseEvent(); event UnpauseEvent(); function pauseContract() public; function unpauseContract() public; function getPaused() public constant returns (bool); modifier whenContractNotPaused() { require(getPaused() == false); _; },1
0x7012a5ada4cee1d0bfb9f93d0f4ced094d6e8577.sol,SpringNFT,"contract SpringNFT is NFToken{ event RecipientUpdate(bytes32 indexed recipientId, bytes32 updateId); modifier recipientExists(bytes32 id) { require(recipients[id].exists, ); _; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public mintAddress; modifier canMint() { require(!mintingFinished); _; }",1
0xd2946be786f35c3cc402c29b323647abda799071.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c4ca515f04722d079862a03dec1e5c011491e12.sol,ToadFarmer,contract ToadFarmer { uint256 public EGGS_TO_HATCH_1TOAD = 43200; uint256 TADPOLE = 10000; uint256 PSNHTOAD = 5000; bool public initialized = false; address public ceoAddress; mapping (address => uint256) public hatcheryToad; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; constructor() public { ceoAddress = msg.sender; },1
0x2fafd7504c1e4a03b49016159bc6dc07a07536ac.sol,KKOGToken,contract KKOGToken is StandardToken { function () { throw; },1
0xec8da70adbaea0379744a26ed18b4616c02f0fc5.sol,PeekePrivateTokenCoupon,contract PeekePrivateTokenCoupon is ERC223 { using SafeMath for uint; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 155000000 * (10**18); constructor(PeekePrivateTokenCoupon) public { balances[msg.sender] = totalSupply; },1
0xf3fb69ef211c6d1e838a5c2223ef54fed4f24090.sol,Cookie,"contract CookieStandard { uint256 public stakeStartTime; uint256 public stakeMinAge; uint256 public stakeMaxAge; function mint() returns (bool); function coinAge() constant returns (uint256); function annualInterest() constant returns (uint256); event Mint(address indexed _address, uint _reward); }",1
0x6a51a98b75d047758c1834ef66b46e7f2c1b88ea.sol,VEToken,"contract VEToken is MintableToken, PausableToken { event VETransfer(address indexed _from, address indexed _to, uint256 _value, bytes32 data); uint256 public constant decimals = 18; string public constant name = ; string public constant symbol = ; function VEToken () public MintableToken() { }",1
0x05bc1d3454405d4767960efeb3cec216a0dd15f3.sol,POCN,contract POCN { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x27bc53596dc0ea71de3c65c799d8e6c96c1dda98.sol,YunJiaMiToken,contract YunJiaMiToken is Ownable{ using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply = 800000000000 ether; uint256 public currentTotalSupply = 0; uint256 startBalance = 100000 ether; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function YunJiaMiToken() public { balances[msg.sender] = startBalance * 6000000; currentTotalSupply = balances[msg.sender]; },1
0x897d6c6772b85bf25b46c6f6da454133478ea6ab.sol,Neutrino81,contract Neutrino81 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x1ebd04228ae2900ccad55193233492ddc3b09de9.sol,Sales,"contract Sales is Owned { address public wallet; HumanStandardToken public token; Locked public locked; uint public price; uint public startBlock; uint public freezeBlock; bool public frozen = false; uint256 public cap = 0; uint256 public sold = 0; uint created; event PurchasedTokens(address indexed purchaser, uint amount); modifier saleHappening { require(block.number >= startBlock); require(block.number <= freezeBlock); require(!frozen); require(sold < cap); _; }",1
0x2024668c1bbf8f5d381f05d2307daf1f94dcf8df.sol,Mainsale,contract Mainsale is InspemCommonSale { address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; function setFoundersTokensPercent(uint newFoundersTokensPercent) public onlyOwner { foundersTokensPercent = newFoundersTokensPercent; },1
0x54d445898cbafb7cf48597e495251183207767ae.sol,FasterProfit,contract FasterProfit { address constant private PROMO = 0xA93c13B3E3561e5e2A1a20239486D03A16d1Fc4b; uint constant public MULTIPLIER = 110; uint constant public MAX_DEPOSIT = 1 ether; uint public currentReceiverIndex = 0; uint public MIN_DEPOSIT = 0.01 ether; uint public txnCount = 0; uint private PROMO_PERCENT = 0; uint constant public LAST_DEPOSIT_PERCENT = 20; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0xd468cb0faf54b8a383f8df78b0c34d825b5246f7.sol,DeDeTokenContract,"contract DeDeTokenContract is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = (25 ether) * (10 ** 7); mapping (address => uint) public balances; mapping (address => mapping (address => uint256)) public allowed; address public dedeNetwork; bool public installed = false; function DeDeTokenContract(address _dedeNetwork){ require(_dedeNetwork != 0); balances[_dedeNetwork] = (_totalSupply * 275) / 1000; balances[this] = _totalSupply - balances[_dedeNetwork]; Transfer(0, _dedeNetwork, balances[_dedeNetwork]); Transfer(0, this, balances[this]); dedeNetwork = _dedeNetwork; }",1
0x3fbf67bab8461d59e49b1560a6375968f3c3a9a6.sol,DASABI_IO_Contract,"contract DASABI_IO_Contract is ERC20Token, Owned{ string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public ExchangeRate; uint256 public CandyRate; bool public crowdsaleIsOpen; bool public CandyDropIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; mapping (address => bool) public blacklist; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); if (msg.value > 0) { mintDSBCToken(msg.sender, (msg.value * ExchangeRate * 10**decimals) / etherChange); }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,MainCrowdsale,"contract MainCrowdsale is usingConsts, FinalizableCrowdsale { function hasStarted() public constant returns (bool) { return now >= startTime; }",1
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol,FoMo3DLight,"contract FoMo3DLight is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; uint256 public pID_ = 4; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 20 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(49,2); fees_[1] = F3Ddatasets.TeamFee(49,2); fees_[2] = F3Ddatasets.TeamFee(49,2); fees_[3] = F3Ddatasets.TeamFee(49,2); potSplit_[0] = F3Ddatasets.PotSplit(38,2); potSplit_[1] = F3Ddatasets.PotSplit(38,2); potSplit_[2] = F3Ddatasets.PotSplit(38,2); potSplit_[3] = F3Ddatasets.PotSplit(38,2); }",1
0x4763768d6938353c9c8849115c58a32142b0f9ea.sol,DeLottery,"contract DeLottery is Pausable { using SafeMath for uint256; uint32 public constant QUORUM = 3; address[] gamblers; uint public ticketPrice = 1 ether; uint public prizeFund = 0; uint public nextTicketPrice = 0; uint public stage; uint public maxTickets = 100; mapping(address => mapping(address => uint)) prizes; mapping(address => bool) lotteryRunners; event Win(uint indexed stage, uint ticketsCount, uint ticketNumber, address indexed winner, uint prize); modifier canRunLottery() { require(lotteryRunners[msg.sender]); _; }",1
0x37aa63c4cbd06a57f1ea35bceee4e46f0a7ce924.sol,UniContract,"contract UniContract is StandardToken, owned { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 0; address public multisig; address public founder; uint public start; uint public end; uint public launch; uint256 public PRICE = 217135; uint256 public OVERALLSOLD = 3148890; uint256 public MAXTOKENSOLD = 85000000; function UniContract() onlyOwner { founder = 0x204244062B04089b6Ef55981Ad82119cEBf54F88; multisig= 0x9FA2d2231FE8ac207831B376aa4aE35671619960; start = 1507543200; end = 1509098400; launch = 1509534000; balances[founder] = balances[founder].add(18148890); }",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(transfersEnabled); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x0355e20c49de30e04c7c693911694ba2450e5564.sol,InvoizChain,"contract InvoizChain is ERC20 { using SafeMath for uint256; address owner = 0xBc4b57D2789a0EfF23662F08A4210351909Aa4B0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 1e28; uint256 public tokenPerETH = 1e27; uint256 public valueToGive = 9e19; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1dc994010375d1b6c0421f825c05c75f426031ec.sol,Grass,contract Grass is Math { uint256 public availableTokens; uint256 currentTokenPriceInDollar; uint256 public lastUpdateEtherPrice; uint256 public etherPriceInDollarIn; uint256 public etherPriceInDollarOut; function getCurrentTokenPrice() public constant returns (uint256) { uint256 today = getToday(); return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today]; },1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x02b8b5d2c2f05c074850c5bdffdb711edbcd8704.sol,CodeMailStamp,"contract CodeMailStamp is StandardToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; function CodeMailStamp() public { totalSupply_ = 500000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,ActionAuction,"contract ActionAuction is AccessNoWithdraw { using SafeMath for uint256; event AuctionCreate(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionSold(uint256 indexed index, address indexed seller, address indexed buyer, uint256 tokenId, uint256 price); event AuctionCancel(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionPriceChange(uint256 indexed index, address indexed seller, uint256 tokenId, uint64 newGwei); struct Auction { address seller; uint64 tokenId; uint64 price; uint64 tmStart; uint64 tmSell; }",1
0x83fe7cbb33c1927d5b8201f829562ee435819039.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x400bb3cab5164f42a14b24e1c90bc018eb68423a.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0xd4de05944572d142fbf70f3f010891a35ac15188.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => bool) users; uint256 totalSupply_; uint virtualBalance = 365000000000000000000; address public dex; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0xc03b0dbd201ee426d907e367f996706cf53b8028.sol,HODLerParadise,contract HODLerParadise{ struct User{ address hodler; bytes32 passcode; uint hodling_since; },1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,BaseDINOToken,"contract BaseDINOToken { using SafeMath for uint256; address public owner; mapping(address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 internal totalSupply_; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Mint(address indexed to, uint256 amount); modifier onlyOwner() { require(msg.sender == owner,); _; }",1
0x0500d5751bb0341e3e8173869cd4e04bc4ad6dd7.sol,MGU,contract MGU is StandardToken { function () { throw; },1
0x516f02475acf19bad0352ce3759c42adaac0000f.sol,Fund,"contract Fund is ICrowdsaleFund, SafeMath, MultiOwnable { enum FundState { Crowdsale, CrowdsaleRefund, TeamWithdraw, Refund }",1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8545f796587f83a865b509d14115a5831121cefc.sol,Choicemining,"contract Choicemining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 25 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 11000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 50; uint256 public tokensPerEth = 25000e18; uint public target0drop = 4500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdd423af7c0a2f88e6aa135c512f101fd35403801.sol,LE,"contract LE is Token { string public name; uint8 public decimals; string public symbol; constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x27de94cb6af1f383430273f44ab4cf4baeb00fc4.sol,METADOLLAR,contract METADOLLAR { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Referral,"contract Referral is Declaration, Ownable { using SafeMath for uint; WealthBuilderToken private token; Data private data; Investors private investors; uint public investorsBalance; uint public ethUsdRate; constructor(uint _ethUsdRate, address _token, address _data, address _investors, uint _investorsBalance) public { ethUsdRate = _ethUsdRate; token = WealthBuilderToken(_token); data = Data(_data); investors = Investors(_investors); investorsBalance = _investorsBalance; }",1
0x34364bee11607b1963d66bca665fde93fca666a8.sol,YOUToken,"contract YOUToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant TOKEN_UNIT = 10 ** uint256(decimals); uint256 private constant INITIAL_SUPPLY = 32 * (10 ** 8) * TOKEN_UNIT; uint256 private constant ANGEL_SUPPLY = INITIAL_SUPPLY * 10 / 100; uint256 private constant PRIVATE_SUPPLY = INITIAL_SUPPLY * 20 / 100; uint256 private constant TEAM_SUPPLY = INITIAL_SUPPLY * 15 / 100; uint256 private constant FOUNDATION_SUPPLY = INITIAL_SUPPLY * 25 / 100; uint256 private constant COMMUNITY_SUPPLY = INITIAL_SUPPLY * 30 / 100; uint256 private constant ANGEL_SUPPLY_VESTING = ANGEL_SUPPLY * 80 / 100; struct VestingGrant { address beneficiary; uint256 start; uint256 duration; uint256 amount; uint256 transfered; uint8 releaseCount; }",1
0x796185713e10d704cd834fd7b00aacb2b81d3003.sol,CECNaypyidaw,contract CECNaypyidaw is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,AccessNoWithdraw,contract AccessNoWithdraw is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xdabd08643935a02fdf49cd6264f8d4de8e1feb69.sol,DAX,"contract DAX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAX( ) public { totalSupply = 200000000000000000000000000; balanceOf[msg.sender] = 200000000000000000000000000; name = ; symbol = ; }",1
0x6b8c8bec2d3e3e583eabbb29913cc6b929cdfacc.sol,LxtBonusDistribution,"contract LxtBonusDistribution is Owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); enum AllocationType { WHITE_LISTING, BOUNTY, AIRDROP, REFERRAL }",1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd883209c4dcd497f24633c627a4e451013424841.sol,dPonzi,contract dPonzi { address public manager; struct PlayerStruct { uint key; uint food; uint idx; uint gametime; uint flag; },1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x554c20b7c486beee439277b4540a434566dc4c02.sol,DecisionToken,"contract DecisionToken is MintableToken, Claimable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; string public constant version = ; uint8 public constant decimals = 18; uint256 public triggerTime = 0; modifier onlyWhenReleased() { require(now >= triggerTime); _; }",1
0x6c24a2934a0255c4dce7ae619ed2b285f06477a0.sol,BighubToken,"contract BighubToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BighubToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1400000000000000000000000000; balances[0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A] = _totalSupply; emit Transfer(address(0), 0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A, _totalSupply); }",1
0xf238c5c35298ff6a5bb7e9bb1e8a731d58ffa623.sol,OSPN,"contract OSPN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 30000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e.sol,CustodianCanBeReplaced,contract CustodianCanBeReplaced is Zamok { struct CustodianChangeRequest { address proposedNew; },1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x007a422fd7e5b47dd2cb078f250388b406548cd4.sol,BLTToken,"contract BLTToken is StandardToken, Ownable, PriceUpdate, Pausable, SalePausable { using SafeMath for uint256; mapping(address => uint256) balances; uint256 public totalSupply; uint256 public totalCap = 100000000000000000000000000; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; address public bltRetainedAcc = 0x48259a35030c8dA6aaA1710fD31068D30bfc716C; address public bltOwnedAcc = 0x1CA33C197952B8D9dd0eDC9EFa20018D6B3dcF5F; address public bltMasterAcc = 0xACc2be4D782d472cf4f928b116054904e5513346; uint256 public bltRetained = 15000000000000000000000000; uint256 public bltOwned = 15000000000000000000000000; uint256 public bltMaster = 70000000000000000000000000; function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }",1
0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68.sol,ERC721,"contract ERC721 is ERC165, IERC721 { using SafeMath for uint256; using Address for address; bytes4 private constant _ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) private _tokenOwner; mapping (uint256 => address) private _tokenApprovals; mapping (address => uint256) private _ownedTokensCount; mapping (address => mapping (address => bool)) private _operatorApprovals; bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd; constructor() public { _registerInterface(_InterfaceId_ERC721); }",1
0xd29decbfd29766d8aba8215587f915162c5bd8d8.sol,ICBB,"contract ICBB is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2a0937dedadf8fe3f16a779c56524739ef77f149.sol,TEL_AVIV_Portfolio_I_883,"contract TEL_AVIV_Portfolio_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 742949791335499000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1c6c8e0c6b93b81c0ab3ca4e16eac96f02175f73.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; address public multisig; ERC20 public token; uint public startTime; uint public endTime; uint256 public hardcap; uint public rate; uint public bonusPercent; uint256 public tokensSold = 0; uint256 public weiRaised = 0; uint public investorCount = 0; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct Promo { uint bonus; uint EndTime; },1
0xf122b5793980d865bcbfd59c641ff60a460523d3.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4c9382454cb0553aee069d302c3ef2e48b0d7852); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 10 minutes; uint256 constant private rndInc_ = 60 seconds; uint256 constant private rndMax_ = 10 minutes; address constant private reward = 0x0e4AF6199f2b92d6677c44d7722CB60cD46FCef6; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(31,0); fees_[1] = F3Ddatasets.TeamFee(38,0); fees_[2] = F3Ddatasets.TeamFee(61,0); fees_[3] = F3Ddatasets.TeamFee(46,0); potSplit_[0] = F3Ddatasets.PotSplit(15,0); potSplit_[1] = F3Ddatasets.PotSplit(15,0); potSplit_[2] = F3Ddatasets.PotSplit(30,0); potSplit_[3] = F3Ddatasets.PotSplit(30,0); }",1
0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f.sol,HEART,"contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3e9e677e82d989445ba7d6a564b616a3171bbfb.sol,QWHappy,"contract QWHappy{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; address owner = 0x0; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 public currentTotalSupply = 0; uint256 airdropNum = 100000000; mapping(address => bool) touched; uint256 public currentTotalSupply2 = 0; function QWHappy() public payable{ balances[msg.sender] = 20000000000000; totalSupply = 20000000000000; name = ; decimals =4; symbol = ; owner=msg.sender; }",1
0x50f0557ae11d55829949bf7af8cd9f69b80a56eb.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; },1
0x0ce6d5a093d4166237c7a9ff8e0553b0293214a1.sol,InfoBurnableToken,"contract InfoBurnableToken is BurnableToken, StandardToken { string message = ; address public manager; event NoFunds(address _who, string _message); modifier onlyManager() { require(msg.sender == manager); _; }",1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x26607f9bf9d62a37b0c78e1d3719fcd1fa32bef9.sol,GoldenFleeceToken,"contract GoldenFleeceToken is StandardToken, Ownable{ string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; function GoldenFleeceToken(uint256 _total) { totalSupply = _total; balances[owner] = _total; }",1
0x409ec1fcd524480b3cadf4331af21a2cb3db68c9.sol,Propvesta,"contract Propvesta is BurnableToken { string public website = ; function Propvesta() public { name = ; symbol = ; decimals = 18; totalSupply = 10000000000e18; balances[owner] = 7000000000e18; Transfer(address(this), owner, 7000000000e18); balances[0x304f970BaA307238A6a4F47caa9e0d82F082e3AD] = 2000000000e18; Transfer(address(this), 0x304f970BaA307238A6a4F47caa9e0d82F082e3AD, 2000000000e18); balances[0x19294ceEeA1ae27c571a1C6149004A9f143e1aA5] = 1000000000e18; Transfer(address(this), 0x19294ceEeA1ae27c571a1C6149004A9f143e1aA5, 1000000000e18); }",1
0xedab39dfc1bfe9706d6f9739acf4553f7882fba4.sol,Terminable,contract Terminable is Ownable { bool isTerminated = false; event Terminated(); modifier whenLive() { require(!isTerminated); _; },1
0x581a653c16ed7ae3f3fa86b549aba090abd42e8b.sol,BYB,"contract BYB{ string public name =; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply =100000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BYB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xedc1936bbe9fee2abc523ad237aa62a3a3722177.sol,RealLandCrowdSale,"contract RealLandCrowdSale is TokenController, Ownable { using SafeMath for uint; MiniMeToken public tokenContract; uint public PRICE = 10; uint public MIN_PURCHASE = 10**17; uint public decimals = 8; uint etherRatio = SafeMath.div(1 ether, 10**decimals); uint256 public saleStartTime = 1512475200; uint256 public saleEndTime = 1517832000; uint256 public totalSupply = 70000000 * 10**decimals; address public team = 0x03c3CD159170Ab0912Cd00d7cACba79694A32127; address public marketting = 0x135B6526943e15fD68EaA05be73f24d641c332D8; address public ipoPlatform = 0x8A8eCFDf0eb6f8406C0AD344a6435D6BAf3110e4; uint256 public teamPercentage = 25000000000000000000; uint256 public markettingPercentage = 25000000000000000000; uint256 public ipoPlatformPercentage = 50000000000000000000; bool public tokensAllocated = false; modifier saleOpen { require((getNow() >= saleStartTime) && (getNow() < saleEndTime)); _; }",1
0x6c1a692ea7c92ae76cbfdda122830698c950f0ff.sol,CursedToken,contract CursedToken is ERC20 { string public symbol = ; string public name = ; uint8 public decimals = 0; uint public totalSupply = 0; address public owner = 0x55516b579E56C1287f0700eddDa352C2d2c5b3b6; address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CursedToken() public { },1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,DataEquip,"contract DataEquip is AccessService, IDataEquip { event EquipChanged(address indexed _target); RaceToken public tokenContract; IRaceCoin public raceCoinContract; mapping (address => uint256[]) public slotlist; mapping (uint256 => uint256) public carSlot; mapping (uint256 => uint256) public slotEngine; mapping (uint256 => uint256) public slotTurbine; mapping (uint256 => uint256) public slotBodySystem; mapping (uint256 => uint256) public slotPipe; mapping (uint256 => uint256) public slotSuspension; mapping (uint256 => uint256) public slotNO2; mapping (uint256 => uint256) public slotTyre; mapping (uint256 => uint256) public slotTransmission; function DataEquip(address _nftTokenAddr) public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; tokenContract = RaceToken(_nftTokenAddr); }",1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,Registry,"contract Registry { event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant); event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger); event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner); event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner); event _ApplicationWhitelisted(bytes32 indexed listingHash); event _ApplicationRemoved(bytes32 indexed listingHash); event _ListingRemoved(bytes32 indexed listingHash); event _ListingWithdrawn(bytes32 indexed listingHash, address indexed owner); event _TouchAndRemoved(bytes32 indexed listingHash); event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens); event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter); event _ExitInitialized(bytes32 indexed listingHash, uint exitTime, uint exitDelayEndDate, address indexed owner); using SafeMath for uint; struct Listing { uint applicationExpiry; bool whitelisted; address owner; uint unstakedDeposit; uint challengeID; uint exitTime; uint exitTimeExpiry; }",1
0x063425e215701d2761a9065e647fa98f209b4ddd.sol,AffiliateManager,"contract AffiliateManager is Pausable { using SafeMath for uint256; AffiliateTreeStore public affiliateTree; MavinToken public token; uint256 public endTime; uint256 public cap; address public vault; uint256 public mvnpereth; uint256 public mvnperethBonus; uint256 public level1Bonus; uint256 public level2Bonus; uint256 public weiRaised; uint256 public minAmountWei; address creator; function AffiliateManager( address _token, address _treestore ) public { creator = msg.sender; token = MavinToken(_token); endTime = 1536969600; vault = 0xD0b40D3bfd8DFa6ecC0b357555039C3ee1C11202; mvnpereth = 100; mvnperethBonus = 105; level1Bonus = 8; level2Bonus = 4; minAmountWei = 0.01 ether; cap = 32000 ether; affiliateTree = AffiliateTreeStore(_treestore); }",1
0x48094ebe2266cb1cbe5d3ec81933784e2e9561d8.sol,Goldofir,contract Goldofir { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint public _totalSupply = 100000000000000000; uint256 constant public DECIMAL_ZEROS = 100000000; uint256 public RATE = 500; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x404803e04be686f70f69ea2c2bbd59c33fbb4db2.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; bool public saleClosed = false; bool public transferFreeze = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; }",1
0x84b6241ed47e935597bc5a14d5e9ef9fb53e77de.sol,UserWallet,contract UserWallet { AbstractSweeperList sweeperList; function UserWallet(address _sweeperlist) { sweeperList = AbstractSweeperList(_sweeperlist); },1
0x700f5b6fbef95f3fbd4f50233e6d05d4eab6dd03.sol,socibit,"contract socibit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 300000000e18; uint256 public totalDistributed = 150000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 10000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4b9d8e37bd266fe27adc45a31a6e1c2b9ca18737.sol,E_GAME,contract E_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xd6c6018fb3c25c214ab938d3b574cf7b6954af62.sol,apexTWO,contract apexTWO { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorLender,contract BancorLender { struct BorrowAgreement { address lender; address borrower; uint256 tokenAmount; uint256 collateralAmount; uint32 collateralRatio; uint expiration; },1
0xeb41d9b0326b787a7c767478cfc4d060c6aa9dbd.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0x71402645d25196842b0434a1805726b7c0eef426.sol,BlueChips,contract BlueChips { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xd3e525c18a10252b3c6b1d82451a0d4585d27a9c.sol,BlissExchangeToken,"contract BlissExchangeToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 25000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17aeb3c181365bc4a386d8dc6ecbe2a96a379088.sol,CipherPlayToken,contract CipherPlayToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 24000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xa5c463308e36e0ef97004e6e88e032c16a2e09d1.sol,apexGOLD,contract apexGOLD { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,WPTokensBaskets,"contract WPTokensBaskets is Ownable, Enums { mapping (address => BasketType) internal types; address public team; address public foundation; address public arr; address public advisors; address public bounty; function WPTokensBaskets( address _team, address _foundation, address _arr, address _advisors, address _bounty ) public { setTeam(_team); setFoundation(_foundation); setARR(_arr); setAdvisors(_advisors); setBounty(_bounty); }",1
0x47145e4aaa53cbfabacecbd1364372c916416853.sol,BKC,"contract BKC is ownerYHT,Erc20Token { string public name= ; string public symbol = ; uint8 public decimals = 18; uint256 public moneyTotal = 230000000; uint256 public moneyFreeze = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; constructor() public { totalSupply = (moneyTotal - moneyFreeze) * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x56a9a9b7de3f4a6ffe1f61319aa33b49ede13590.sol,AllocatedCrowdsaleMixin,contract AllocatedCrowdsaleMixin is CrowdsaleBase { address public beneficiary; function AllocatedCrowdsaleMixin(address _beneficiary) { beneficiary = _beneficiary; },1
0x8bf98ad0e7d8d4924c6a52f6e4b87f96d3a278fa.sol,DOTON,"contract DOTON is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOTON() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,Zethr,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b.sol,TittyBase,"contract TittyBase { event Transfer(address indexed from, address indexed to); event Creation(address indexed from, uint256 tittyId, uint256 wpId); event AddAccessory(uint256 tittyId, uint256 accessoryId); struct Accessory { uint256 id; string name; uint256 price; bool isActive; }",1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0xedc7e8ca35a00674c3b83c965591a75f700cc590.sol,Extradecoin,"contract Extradecoin is Owner { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 constant public totalSupply = 250000000 * 10 ** 18; mapping(address => uint256) internal balances; mapping(address => mapping (address => uint256)) internal allowed; address public adminAddress; address public walletAddress; address public founderAddress; address public advisorAddress; mapping(address => uint256) public totalInvestedAmountOf; uint constant lockPeriod1 = 3 years; uint constant lockPeriod2 = 1 years; uint constant lockPeriod3 = 90 days; uint constant NOT_SALE = 0; uint constant IN_ICO = 1; uint constant END_SALE = 2; uint256 public constant salesAllocation = 125000000 * 10 ** 18; uint256 public constant founderAllocation = 37500000 * 10 ** 18; uint256 public constant advisorAllocation = 25000000 * 10 ** 18; uint256 public constant reservedAllocation = 62500000 * 10 ** 18; uint256 public constant minInvestedCap = 6000 * 10 ** 18; uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; uint saleState; uint256 totalInvestedAmount; uint public icoStartTime; uint public icoEndTime; bool public inActive; bool public isSelling; bool public isTransferable; uint public founderAllocatedTime = 1; uint public advisorAllocatedTime = 1; uint256 public icoStandardPrice; uint256 public totalRemainingTokensForSales; uint256 public totalAdvisor; uint256 public totalReservedTokenAllocation; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event StartICO(uint state); event EndICO(uint state); event SetICOPrice(uint256 price); event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); event AllocateTokensForAdvisor(address advisorAddress, uint256 advisorAllocatedTime, uint256 tokenAmount); event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); event AllocateSalesTokens(address salesAllocation, uint256 tokenAmount); modifier isActive() { require(inActive == false); _; }",1
0x72907f5d1417404d9e4963d53107ddd4237aa10d.sol,ecothereum,"contract ecothereum is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ecothereum ( ) public { totalSupply = 41000000 * 10e17; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeb108d7c4ab669beea11e3f2422348c5fd19d021.sol,AxeMining,"contract AxeMining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 9000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0x4e9b6e88e6b83453e3ec6a1ffa0c95f289cf81d5.sol,DailyRoi,contract DailyRoi { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x6f96a88c7d3f695de27d091d2173a9dfd82f5177.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x211238ddea3cd78e2def070e62d405d9eea45857.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x74bbed9bd87e339ad23b52ba8dd91b4cd216d080.sol,RadicalPixels,"contract RadicalPixels is HarbergerTaxable, ERC721Token { using SafeMath for uint256; uint256 public xMax; uint256 public yMax; uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000; uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff; uint256 constant factor = 0x100000000000000000000000000000000; struct Pixel { bytes32 id; address seller; uint256 x; uint256 y; uint256 price; bytes32 auctionId; bytes32 contentData; }",1
0x51c6a6ef1352578ff01b078313e6779b88bdcb1e.sol,DMINT,"contract DMINT { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; uint public miningReward = 1000000000000000000; uint private divider; uint private randomNumber; mapping (address => uint256) public balanceOf; mapping (address => uint256) public successesOf; mapping (address => uint256) public failsOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function DMINT() public { balanceOf[msg.sender] = totalSupply; divider -= 1; divider /= 1000000000; }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileICO,contract AgileICO { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x4072e3eeaf72433f83059e792249eeb868ca693c.sol,Gateway,contract Gateway is Ownable{ using SafeMath for uint; address public feeAccount1 = 0x1eB58eb6c0b145537e921bd63701993cAE5f5f36; address public feeAccount2 = 0x00ff115Ec2A28b6fE9Ad9D434b290300bd91FaD4; address public feeAccountToken = 0x23fB9004Ee9a931e9AC64850615852f626C27902; struct BuyInfo { address buyerAddress; address sellerAddress; uint value; address currency; },1
0x406d7401f451ee9d3a04652102aaf923c59f64e9.sol,Elephant,contract Elephant { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,Etherumble,contract Etherumble { struct PlayerBets { address addPlayer; uint amount; },1
0xeeae9c7a726f5c9d52c45494577221054a2805b2.sol,Bingo,"contract Bingo { using SafeMath for uint; MegaballInterface constant public megaballContract = MegaballInterface(address(0x3Fe2B3e8FEB33ed523cE8F786c22Cb6556f8A33F)); DiviesInterface constant private Divies = DiviesInterface(address(0xc7029Ed9EBa97A096e72607f4340c34049C7AF48)); uint256 constant public AGENT_END_BLOCK = 232; uint256 constant public ICO_BLOCK = 200; uint256 constant public ICO_TIME = 3600; event CardCreated(address indexed ticketOwner, uint indexed playerTicket, uint indexed stage); event Payment(address indexed customerAddress, uint indexed stage); event NumberCalled(uint indexed number, uint indexed stage, uint indexed total); event OnWithdraw(address indexed customerAddress, uint256 ethereumWithdrawn); event StageCreated(uint indexed stageNumber); modifier hasBalance() { require(bingoVault[msg.sender] > 0); _; }",1
0x6bec54e4fea5d541fb14de96993b8e11d81159b2.sol,CommonToken,"contract CommonToken is StandardToken, MultiOwnable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public saleLimit; uint256 public teamTokens; address public teamWallet; uint public unlockTeamTokensTime = now + 1 years; address public seller; uint256 public tokensSold; uint256 public totalSales; bool public locked = true; event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value); event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller); event Burn(address indexed _burner, uint256 _value); event Unlock(); function CommonToken( address _seller, address _teamWallet ) MultiOwnable() public { totalSupply = 998400000 ether; saleLimit = 848640000 ether; teamTokens = 69888000 ether; seller = _seller; teamWallet = _teamWallet; uint sellerTokens = totalSupply - teamTokens; balances[seller] = sellerTokens; Transfer(0x0, seller, sellerTokens); balances[teamWallet] = teamTokens; Transfer(0x0, teamWallet, teamTokens); }",1
0x4e9b6e88e6b83453e3ec6a1ffa0c95f289cf81d5.sol,DailyRoi,contract DailyRoi { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x511724936c6f550be63e940ebdd4800f095ea12c.sol,cryptowars,contract cryptowars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5c7b19f83ac93d8268da02cc06cb61089d6d952a.sol,ERC721BasicToken,"contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721, Pausable{ bytes4 public constant InterfaceId_ERC721 = 0x80ac58cd; bytes4 public constant InterfaceId_ERC721Exists = 0x4f558e79; using SafeMath for uint256; using AddressUtils for address; bytes4 public constant ERC721_RECEIVED = 0x150b7a02; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(_ownerOf(_tokenId) == msg.sender,); _; }",1
0x4bb301e545a3e948b20ea9a0f02d3948af6fe6db.sol,TarynToken,contract TarynToken is AccessControlled { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public totalSupply; mapping(address => uint256) balances; mapping(uint256 => address) public addresses; mapping(address => uint256) public indexes; uint public index = 1; function TarynToken() public { totalSupply = INITIAL_SUPPLY; },1
0x065d6fccf3bcc50e37e875479511f5ca656b98d8.sol,B42Token,contract B42Token is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 42000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function B42Token () { owner = msg.sender; },1
0xd44dbf7e6aa11b3a9e16890f57eb6a6dc74ee94d.sol,ERC20TOKEN,"contract ERC20TOKEN is owned, token { uint256 public sellPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ERC20TOKEN ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) payable token (initialSupply, tokenName, tokenSymbol) public { if(centralMinter != 0 ) owner = centralMinter; sellPrice = 2; }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x65731ac534bc0d3fdf3f4bdd2b09cf05044920bc.sol,MetadollarFund,contract MetadollarFund { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xaaa73b4a5411a4249b723722cb1bdabfaed495c2.sol,Moon,contract Moon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x922c650a44d6b2f9ab761792f8cf60bd944fdcce.sol,DPC,"contract DPC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DPC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9299ccef011d2d8faf76b214c8549c14bc918035.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0xbcbfc1be2343dc642026e5b2da07460a8484a79d.sol,Bounty,contract Bounty is Ownable { LamdenTau public lamdenTau; function Bounty(address _tokenContractAddress) public { require(_tokenContractAddress != address(0)); lamdenTau = LamdenTau(_tokenContractAddress); },1
0x316ee6b10479576e908e5272458c789c3f4d2a47.sol,DuanZiToken,contract DuanZiToken is ERC223 { using SafeMath for uint256; using SafeMath for uint; address public owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => uint) public increase; mapping (address => uint256) public unlockUnixTime; uint public maxIncrease=20; address public target; string internal name_= ; string internal symbol_ = ; uint8 internal decimals_= 18; uint256 internal totalSupply_= 2000000000e18; uint256 public toGiveBase = 5000e18; uint256 public increaseBase = 500e18; uint256 public OfficalHold = totalSupply_.mul(18).div(100); uint256 public totalRemaining = totalSupply_; uint256 public totalDistributed = 0; bool public canTransfer = true; uint256 public etherGetBase=5000000; bool public distributionFinished = false; bool public finishFreeGetToken = false; bool public finishEthGetToken = false; modifier canDistr() { require(!distributionFinished); _; },1
0x12ac8d8f0f48b7954bcda736af0576a12dc8c387.sol,OPL,"contract OPL { string public name; string public symbol; uint8 public decimals = 18; bool public adminVer = false; address public owner; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Emission(address indexed from, uint256 value); function OPL() public { totalSupply = 210000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; owner = msg.sender; }",1
0x5b5afaa565aba14833de0cee321e63a807fd407b.sol,TulipMania,"contract TulipMania is ERC20Token { uint constant E6 = 10**6; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; address public wallet; address public adminWallet; uint public constant DATE_PRESALE_START = 1510758000; uint public constant DATE_PRESALE_END = 1511362800; uint public constant DATE_ICO_START = 1511362801; uint public constant DATE_ICO_END = 1513868400; uint public tokensPerEth = 336 * E6; uint public constant BONUS_PRESALE = 100; uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; uint public constant TOKEN_SUPPLY_ICO = 8500000 * E6; uint public constant TOKEN_SUPPLY_MKT = 1500000 * E6; uint public constant PRESALE_ETH_CAP = 750 ether; uint public constant MIN_CONTRIBUTION = 1 ether / 500; uint public constant MAX_CONTRIBUTION = 300 ether; uint public constant COOLDOWN_PERIOD = 2 days; uint public constant CLAWBACK_PERIOD = 2 days; uint public icoEtherReceived = 0; uint public tokensIssuedIco = 0; uint public tokensIssuedMkt = 0; uint public tokensClaimedAirdrop = 0; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; mapping(address => bool) public airdropClaimed; mapping(address => bool) public refundClaimed; mapping(address => bool) public locked; event WalletUpdated(address _newWallet); event AdminWalletUpdated(address _newAdminWallet); event TokensPerEthUpdated(uint _tokensPerEth); event TokensMinted(address indexed _owner, uint _tokens, uint _balance); event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed); event Refund(address indexed _owner, uint _amount, uint _tokens); event Airdrop(address indexed _owner, uint _amount, uint _balance); event LockRemoved(address indexed _participant); function TulipMania() { require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL ); wallet = owner; adminWallet = owner; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDLogic,contract BitSTDLogic { address public owner; BitSTDData private data; constructor(address dataAddress) { data = BitSTDData(dataAddress); owner = msg.sender; },1
0x33a56a411b6908b06dc2497eb3dfac1d96db22f2.sol,FECT,"contract FECT is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FECT() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xd44dbf7e6aa11b3a9e16890f57eb6a6dc74ee94d.sol,ERC20TOKEN,"contract ERC20TOKEN is owned, token { uint256 public sellPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ERC20TOKEN ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) payable token (initialSupply, tokenName, tokenSymbol) public { if(centralMinter != 0 ) owner = centralMinter; sellPrice = 2; }",1
0xd2354acf1a2f06d69d8bc2e2048aabd404445df6.sol,MNYTiers,contract MNYTiers is Ownable { using SafeMath for uint256; uint public offset = 10**8; struct Tier { uint mny; uint futrx; uint rate; },1
0x72a73495b769682d7b09a9641fa1a95e308fbe08.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0xeffdda4220a61bb62d7bff9d89615e05b3f156e8.sol,CommunityToken,"contract CommunityToken { using SafeMath for uint256; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) balances; uint256 public totalSupply; uint256 public decimals; address public owner; bytes32 public symbol; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); function CommunityToken() { totalSupply = 1000000; symbol = ; owner = 0xd21Ef1Fb710c17cA568380f20a3ceE46c254d315; balances[owner] = totalSupply; decimals = 0; }",1
0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 200; uint256 public blocksBeforeTargetShoot = 800; event death(address indexed player); event semiShot(address indexed player); event targetShot(address indexed player); constructor() public { },1
0xefa4a1ef3dd8f230c7d14e88f77dede0efdc2e7e.sol,LongevityCrowdsale,contract LongevityCrowdsale { using SafeMath for uint256; LongevityToken public token; address public wallet; mapping (address => bool) public owners; mapping (address => bool) public bots; uint256 public rateUSDcETH; mapping (uint => Phase) phases; uint public totalPhases = 0; struct Phase { uint256 startTime; uint256 endTime; uint256 bonusPercent; },1
0x838df5c03147f0b038c24b18af5bb5dee1ffd446.sol,Edgecoin,"contract Edgecoin is SafeMath, DateTime, EdgeSmartToken { address owner; uint private totalCollected = 0; uint private preSaleCollected = 0; uint private ICOCollected = 0; uint256 public totalTokensCap = (50000000 * 10**_decimals); uint public preSaleTokensLimit = (10000000 * 10**_decimals); uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); uint public icoSaleHardCap = (25000000 * 10**_decimals); uint256 private preSaleTokenPrice = (10000 * 10**_decimals); uint256 private ICOTokenPrice = (5000 * 10**_decimals); bool ICOActive = true; uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0); uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); uint256 private tokensToBuy; mapping (address => bool) private isOwner; mapping (address => bool) private isConfirmed; mapping (uint => address) private ownersArr; uint public nonce; uint public threshold = 3; uint public pendingAmount; address public pendingAddress; uint public confirmedTimesByOwners = 0; constructor() public { owner = msg.sender; isOwner[0x512B431fc06855C8418495ffcc570D246B654f6E] = true; isOwner[0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48] = true; isOwner[0x9016f6fb21F454F294A78AdeFbD700f4B6795C91] = true; ownersArr[0] = 0x512B431fc06855C8418495ffcc570D246B654f6E; ownersArr[2] = 0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48; ownersArr[3] = 0x9016f6fb21F454F294A78AdeFbD700f4B6795C91; totalCollected = 366536727590000000000000; preSaleCollected = 265029930140000000000000; ICOCollected = 101506797450000000000000; }",1
0x24626fd95ad815bab2136d6f91ca10562161cda3.sol,Dao,contract DaoConstants { using SafeMath for uint256; bytes32 EMPTY_BYTES = bytes32(0x0); address EMPTY_ADDRESS = address(0x0); bytes32 PROPOSAL_STATE_PREPROPOSAL = ; bytes32 PROPOSAL_STATE_DRAFT = ; bytes32 PROPOSAL_STATE_MODERATED = ; bytes32 PROPOSAL_STATE_ONGOING = ; bytes32 PROPOSAL_STATE_CLOSED = ; bytes32 PROPOSAL_STATE_ARCHIVED = ; uint256 PRL_ACTION_STOP = 1; uint256 PRL_ACTION_PAUSE = 2; uint256 PRL_ACTION_UNPAUSE = 3; uint256 COLLATERAL_STATUS_UNLOCKED = 1; uint256 COLLATERAL_STATUS_LOCKED = 2; uint256 COLLATERAL_STATUS_CLAIMED = 3; bytes32 INTERMEDIATE_DGD_IDENTIFIER = ; bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = ; bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = ; bytes32 CONTRACT_DAO = ; bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = ; bytes32 CONTRACT_DAO_STAKE_LOCKING = ; bytes32 CONTRACT_DAO_VOTING = ; bytes32 CONTRACT_DAO_VOTING_CLAIMS = ; bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = ; bytes32 CONTRACT_DAO_IDENTITY = ; bytes32 CONTRACT_DAO_REWARDS_MANAGER = ; bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = ; bytes32 CONTRACT_DAO_ROLES = ; bytes32 CONTRACT_DAO_FUNDING_MANAGER = ; bytes32 CONTRACT_DAO_WHITELISTING = ; bytes32 CONTRACT_DAO_INFORMATION = ; bytes32 CONTRACT_SERVICE_ROLE = ; bytes32 CONTRACT_SERVICE_DAO_INFO = ; bytes32 CONTRACT_SERVICE_DAO_LISTING = ; bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = ; bytes32 CONTRACT_STORAGE_DAO = ; bytes32 CONTRACT_STORAGE_DAO_COUNTER = ; bytes32 CONTRACT_STORAGE_DAO_UPGRADE = ; bytes32 CONTRACT_STORAGE_DAO_IDENTITY = ; bytes32 CONTRACT_STORAGE_DAO_POINTS = ; bytes32 CONTRACT_STORAGE_DAO_SPECIAL = ; bytes32 CONTRACT_STORAGE_DAO_CONFIG = ; bytes32 CONTRACT_STORAGE_DAO_STAKE = ; bytes32 CONTRACT_STORAGE_DAO_REWARDS = ; bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = ; bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = ; bytes32 CONTRACT_DGD_TOKEN = ; bytes32 CONTRACT_DGX_TOKEN = ; bytes32 CONTRACT_BADGE_TOKEN = ; uint8 ROLES_ROOT = 1; uint8 ROLES_FOUNDERS = 2; uint8 ROLES_PRLS = 3; uint8 ROLES_KYC_ADMINS = 4; uint256 QUARTER_DURATION = 90 days; bytes32 CONFIG_MINIMUM_LOCKED_DGD = ; bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = ; bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = ; bytes32 CONFIG_LOCKING_PHASE_DURATION = ; bytes32 CONFIG_QUARTER_DURATION = ; bytes32 CONFIG_VOTING_COMMIT_PHASE = ; bytes32 CONFIG_VOTING_PHASE_TOTAL = ; bytes32 CONFIG_INTERIM_COMMIT_PHASE = ; bytes32 CONFIG_INTERIM_PHASE_TOTAL = ; bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = ; bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = ; bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = ; bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = ; bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = ; bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = ; bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = ; bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = ; bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = ; bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = ; bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = ; bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = ; bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = ; bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = ; bytes32 CONFIG_MINIMAL_QUARTER_POINT = ; bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = ; bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = ; bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = ; bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = ; bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = ; bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = ; bytes32 CONFIG_QUARTER_POINT_VOTE = ; bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = ; bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = ; bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = ; bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = ; bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = ; bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = ; bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = ; bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = ; bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = ; bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = ; bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = ; bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = ; bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = ; bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = ; bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = ; bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = ; bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = ; bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = ; bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = ; bytes32 CONFIG_DRAFT_VOTING_PHASE = ; bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = ; bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = ; bytes32 CONFIG_PREPROPOSAL_COLLATERAL = ; bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = ; bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = ; bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = ; bytes32 CONFIG_PROPOSAL_DEAD_DURATION = ; bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = ; },1
0xf238f55ede5120915b36715b0fffe20ff57f8134.sol,BytesToTypes,"contract BytesToTypes { function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) }",1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeLandDistribution,"contract CryptoRomeLandDistribution is CryptoRomeControl { using SafeMath for uint256; address public newContractAddress; CryptoRomeLandComposableNFT public cryptoRomeLandNFTContract; ImprovementGeneration public improvementGenContract; uint256 public villageInventoryPrice; uint256 public numImprovementsPerVillage; uint256 constant public LOWEST_VILLAGE_INVENTORY_PRICE = 100000000000000000; constructor (address _cryptoRomeLandNFTContractAddress, address _improvementGenContractAddress) public { require (_cryptoRomeLandNFTContractAddress != address(0)); require (_improvementGenContractAddress != address(0)); paused = true; cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContractAddress); improvementGenContract = ImprovementGeneration(_improvementGenContractAddress); villageInventoryPrice = LOWEST_VILLAGE_INVENTORY_PRICE; numImprovementsPerVillage = 3; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,PreSaleAssets,"contract PreSaleAssets is PreSaleDisciple { event BuyDiscipleItem(address indexed buyer, uint indexed rarity, uint indexed number, uint currentPrice); event BuyGuardianRune(address indexed buyer, uint indexed rarity, uint indexed number, uint currentPrice); event SetDiscipleItem(uint indexed rarity, uint indexed price); event SetGuardianRune(uint indexed rarity, uint indexed price); mapping (address => uint) PlayerOwnRareItem; mapping (address => uint) PlayerOwnEpicItem; mapping (address => uint) PlayerOwnLegendaryItem; mapping (address => uint) PlayerOwnUniqueItem; mapping (address => uint) PlayerOwnRareRune; mapping (address => uint) PlayerOwnEpicRune; mapping (address => uint) PlayerOwnLegendaryRune; mapping (address => uint) PlayerOwnUniqueRune; uint[4] public DiscipleItem = [ 0.68 ether, 1.98 ether, 4.88 ether, 9.98 ether ]; uint[4] public GuardianRune = [ 1.18 ether, 4.88 ether, 8.88 ether, 13.88 ether ]; uint itemTimeStamp; uint runeTimeStamp; function buyDiscipleItem(uint _rarity, uint _num, uint _brokerId, uint _subBrokerId) public payable whenNotPaused { require(_rarity >= 0 && _rarity <= 4); uint currentPrice; if(pricePause == true) { if(itemTimeStamp != 0 && itemTimeStamp != endTime) { uint timePass = safeSub(endTime, startTime); DiscipleItem[0] = _computePrice(DiscipleItem[0], DiscipleItem[0]*raiseIndex[2], preSaleDurance, timePass); DiscipleItem[1] = _computePrice(DiscipleItem[1], DiscipleItem[1]*raiseIndex[2], preSaleDurance, timePass); DiscipleItem[2] = _computePrice(DiscipleItem[2], DiscipleItem[2]*raiseIndex[2], preSaleDurance, timePass); DiscipleItem[3] = _computePrice(DiscipleItem[3], DiscipleItem[3]*raiseIndex[2], preSaleDurance, timePass); itemTimeStamp = endTime; }",1
0x518f575e145347aa550534f1dacf7dab8dcf5738.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; }",1
0x0dabaea13982b659ffa03c02307ce1e5a04dc657.sol,ERC20TOKEN,"contract ERC20TOKEN is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x529e322a80b04ad336297ac8bc40a5ba58273983.sol,Moongang,contract Moongang { using SafeMath for uint256; modifier onlyOwner { require(msg.sender == owner); _; },1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0xf0ba84690b9bdec4c3175557446dddf6384eec1d.sol,NBAONLINE,"contract NBAONLINE is Functional,Owned,ERC721{ using SafeMath for uint256; enum STATUS { NOTFOUND, PLAYING, PROCESSING, PAYING, REFUNDING }",1
0x64ef6612a67de3fa96accb645ae46a3c09227928.sol,Economeme,"contract Economeme is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; uint256 public submissionPool; uint256 public submissionPrice; uint256 public endingBalance; mapping (uint256 => Meme) public memeData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public creatorBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Creation(address indexed _creator, uint256 _tokenId, uint256 _timestamp); uint256 private firstCap = 0.02 ether; uint256 private secondCap = 0.5 ether; uint256 private thirdCap = 2.0 ether; uint256 private finalCap = 5.0 ether; struct Meme { uint256 price; address owner; address creator; }",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x581c9ba7a3de3944e051c585c273974ee4570502.sol,OxyToken,"contract OxyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x568a693e1094b1e51e8053b2fc642da7161603f5.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6cdd4f8e44395c598c90947223211ab62b04a7d2.sol,JanKenPon,"contract JanKenPon is modularLong { using SafeMath for *; using NameFilter for string; using J3DKeysCalcLong for uint256; JIincForwarderInterface constant private Jekyll_Island_Inc = JIincForwarderInterface(0x7f546aC4261CA5dE2D5e12E16Ae0F1B5c479b0c2); PlayerBookInterface private PlayerBook = PlayerBookInterface(0x0183f4E77F21b232F60fAf6898D6a8FE899489CB); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 30; uint256 constant private rndInit_ = 3 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public gasPriceLimit_ = 500000000000; uint256 public rID_; uint256 public janPot_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => J3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => J3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => J3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => J3Ddatasets.TeamFee) public fees_; mapping (uint256 => J3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = J3Ddatasets.TeamFee(50,25,15,5,5); fees_[1] = J3Ddatasets.TeamFee(50,25,15,5,5); fees_[2] = J3Ddatasets.TeamFee(50,25,15,5,5); fees_[3] = J3Ddatasets.TeamFee(50,25,15,5,5); potSplit_[0] = J3Ddatasets.PotSplit(30,50,10,10); potSplit_[1] = J3Ddatasets.PotSplit(30,50,10,10); potSplit_[2] = J3Ddatasets.PotSplit(30,50,10,10); potSplit_[3] = J3Ddatasets.PotSplit(30,50,10,10); }",1
0x275c62ee45c7d4d7fc71af52d3fe0019f414e5dc.sol,TalaRCrowdsale,"contract TalaRCrowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for IERC20; IERC20 private _token; address private _wallet; uint256 private _rate; uint256 private _bonusRate; uint256 private _bonusCap; uint256 private _weiRaised; uint256 private _openingTime; uint256 private _bonusEndTime; uint256 private _closingTime; uint256 private constant MINIMAL_CONTRIBUTION = 50000000000000000; event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 rate, uint256 bonusRate, uint256 bonusCap, uint256 openingTime, uint256 bonusEndTime, uint256 closingTime, address wallet, IERC20 token) public { require(rate > 0); require(bonusRate > 0); require(bonusCap > 0); require(openingTime >= block.timestamp); require(bonusEndTime >= openingTime); require(closingTime >= bonusEndTime); require(wallet != address(0)); _rate = rate; _bonusRate = bonusRate; _bonusCap = bonusCap; _wallet = wallet; _token = token; _openingTime = openingTime; _closingTime = closingTime; _bonusEndTime = bonusEndTime; }",1
0xce3708924a9a44aee5e7caad22881fdda816fd16.sol,NatureX,"contract NatureX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 8000000e8; uint256 public constant minContribution = 1 ether / 200; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,DecoBank,contract DecoBank { using SafeMath for uint256; Deco public token; address private crowdsaleWallet; address private decoReserveWallet; uint256 public weiRaised; uint256 public constant totalSupplyUnits = 6*10**26; uint256 private constant MINIMUM_WEI = 10**16; uint256 private constant BASE = 10**18; uint256 public originalRate = 3000; uint256 public crowdsaleDistributedUnits = 0; uint256 public issuerDistributedUnits = 0; uint256 public presaleStartTime; uint256 public presaleEndTime; uint256 private presaleDiscount = 50; uint256 private presalePercentage = 5; uint256 public issuerReservedMaximumPercentage = 5; uint256 public saleStartTime; uint256 public saleEndTime; uint256 private saleDiscount = 25; uint256 public rewardDistributionStart; uint256 public rewardDistributedUnits = 0; mapping(address => Contributor) private contributors; struct Contributor { uint256 contributedWei; uint256 decoUnits; uint256 rewardDistributedDecoUnits; },1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,MemoryFactoryInterface,contract MemoryFactoryInterface { uint256 public factoryTotal; function setFactoryToal(uint256 ) public {},1
0x2eb067b839bb553e109eeeb215a08fe8cc799080.sol,FidelityHouseToken,"contract FidelityHouseToken is DetailedERC20, RBACMintableToken, BurnableToken, ERC1363BasicToken, TokenRecover { uint256 public lockedUntil; mapping(address => uint256) internal lockedBalances; modifier canTransfer(address _from, uint256 _value) { require( mintingFinished, ); require( _value <= balances[_from].sub(lockedBalanceOf(_from)), ); _; }",1
0xeb5405e21d07fa5e3b6644d0ae7f391b47f17e27.sol,ERC721BasicToken,contract ERC721BasicToken is ERC721Basic { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; },1
0x50584a9bdfab54b82e620b8a14cc082b07886841.sol,ProvidenceCasinoToken,"contract ProvidenceCasinoToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping(address=>bool) public frozenAccount; event FrozenFunds(address target, bool frozen); uint256 public constant initialSupply = 200000000 * 10**18; uint8 public constant decimalUnits = 18; string public tokenName = ; string public tokenSymbol = ; function ProvidenceCasinoToken() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,I_minter,"contract I_minter { event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventBankrupt(); function Leverage() constant returns (uint128) {}",1
0x92eddd9a441ad85a97ddf52aadf853ba8026494e.sol,DecentralizedAdultToken,"contract DecentralizedAdultToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd48f07d942a075fbba9836a2898dda2702c7ffda.sol,UpgradeableToken,"contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}",1
0xd9485499499d66b175cf5ed54c0a19f1a6bcb61a.sol,PausableToken,"contract PausableToken is StandardToken, Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; }",1
0xeed3856ecbcb09b20cba1b3f5d448fed860483ba.sol,DappleAirdrops,"contract DappleAirdrops is Ownable { using SafeMath for uint256; mapping (address => uint256) public bonusDropsOf; mapping (address => uint256) public ethBalanceOf; mapping (address => bool) public tokenIsBanned; mapping (address => uint256) public trialDrops; uint256 public rate; uint256 public dropUnitPrice; uint256 public bonus; uint256 public maxDropsPerTx; uint256 public maxTrialDrops; string public constant website = ; event BonusCreditGranted(address indexed to, uint256 credit); event BonusCreditRevoked(address indexed from, uint256 credit); event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit); event AirdropInvoked(address indexed by, uint256 creditConsumed); event BonustChanged(uint256 from, uint256 to); event TokenBanned(address indexed tokenAddress); event TokenUnbanned(address indexed tokenAddress); event EthWithdrawn(address indexed by, uint256 totalWei); event RateChanged(uint256 from, uint256 to); event MaxDropsChanged(uint256 from, uint256 to); event RefundIssued(address indexed to, uint256 totalWei); event ERC20TokensWithdrawn(address token, address sentTo, uint256 value); function DappleAirdrops() public { rate = 10000; dropUnitPrice = 1e14; bonus = 20; maxDropsPerTx = 100; maxTrialDrops = 100; }",1
0xa2795a7bf26de447a2e83d0779bab6badffb1a3b.sol,DrupeICO,"contract DrupeICORef { address _referrer; DrupeICO _ico; constructor(address referrer, DrupeICO ico) public { _referrer = referrer; _ico = ico; }",1
0x4b577405017f82b098cf4ab0de38979b6d2fe5ae.sol,MainContract,contract MainContract { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x03966330e7f60c95d2d8dd043735eea901c5e4e0.sol,Ownable,"contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }",1
0xd736402d7eace89667343dbd35ac8c22137fb719.sol,HappyMelodyToken,"contract HappyMelodyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 15000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,FollowCoinTokenSale,"contract FollowCoinTokenSale is Haltable { using SafeMath for uint256; address public beneficiary; address public multisig; uint public tokenLimitPerWallet; uint public hardCap; uint public amountRaised; uint public totalTokens; uint public tokensSold = 0; uint public investorCount = 0; uint public startTimestamp; uint public deadline; uint public tokensPerEther; FollowCoin public tokenReward; mapping(address => uint256) public balances; event FundTransfer(address backer, uint amount, bool isContribution); function FollowCoinTokenSale( address multiSigWallet, uint icoTokensLimitPerWallet, uint icoHardCap, uint icoStartTimestamp, uint durationInDays, uint icoTotalTokens, uint icoTokensPerEther, address addressOfTokenUsedAsReward ) { multisig = multiSigWallet; owner = multiSigWallet; hardCap = icoHardCap; deadline = icoStartTimestamp + durationInDays * 1 days; startTimestamp = icoStartTimestamp; totalTokens = icoTotalTokens; tokenLimitPerWallet = icoTokensLimitPerWallet; tokensPerEther = icoTokensPerEther; tokenReward = FollowCoin(addressOfTokenUsedAsReward); beneficiary = multisig; }",1
0x40658db197bddea6a51cb576fe975ca488ab3693.sol,EthereumLottery,contract EthereumLottery { uint constant GAS_LIMIT_DEPOSIT = 300000; uint constant GAS_LIMIT_AFFILIATE = 35000; struct Lottery { uint jackpot; int decidingBlock; uint numTickets; uint numTicketsSold; uint ticketPrice; uint affiliateCut; int winningTicket; address winner; uint finalizationBlock; address finalizer; string message; mapping (uint => address) tickets; int nearestKnownBlock; int nearestKnownBlockHash; },1
0xbe6486dbccc61f3e2a221ea3a5200948ca6593bb.sol,DESToken,"contract DESToken is StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint public HardCapEthereum = 66666000000000000000000 wei; mapping (address => bool) public noTransfer; uint constant public TimeStart = 1511956800; uint public TimeEnd = 1514375999; uint public TimeWeekOne = 1512561600; uint public TimeWeekTwo = 1513166400; uint public TimeWeekThree = 1513771200; uint public TimeTransferAllowed = 1516967999; uint public PoolPreICO = 0; uint public PoolICO = 0; uint public PoolTeam = 0; uint public PoolAdvisors = 0; uint public PoolBounty = 0; uint public PriceWeekOne = 1000000000000000 wei; uint public PriceWeekTwo = 1250000000000000 wei; uint public PriceWeekThree = 1500000000000000 wei; uint public PriceWeekFour = 1750000000000000 wei; uint public PriceManual = 0 wei; bool public ICOPaused = false; bool public ICOFinished = false; uint public StatsEthereumRaised = 0 wei; uint public StatsTotalSupply = 0; event Buy(address indexed sender, uint eth, uint fbt); event TokensSent(address indexed to, uint value); event ContributionReceived(address indexed to, uint value); event PriceChanged(string _text, uint _tokenPrice); event TimeEndChanged(string _text, uint _timeEnd); event TimeTransferAllowanceChanged(string _text, uint _timeAllowance); address public owner = 0x0; address public wallet = 0x0; function DESToken(address _owner, address _wallet) payable { owner = _owner; wallet = _wallet; balances[owner] = 0; balances[wallet] = 0; }",1
0x38d389c300357a26beec198f3893fba54fde69c5.sol,PayUSD,"contract PayUSD is ERC20, ERC20Detailed, ERC20Mintable, ERC20Burnable, ERC20Pausable { address public staker; uint256 public transferFee = 10; uint256 public mintFee = 10; uint256 public feeDenominator = 10000; event ChangeStaker(address indexed addr); event ChangeStakingFees (uint256 transferFee, uint256 mintFee, uint256 feeDenominator); constructor(address _staker) ERC20Burnable() ERC20Mintable() ERC20Pausable() ERC20Detailed(, , 18) ERC20() public { staker = _staker; }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,CrydrViewERC20Mintable,"contract CrydrViewERC20MintableInterface { event MintEvent(address indexed owner, uint256 value); event BurnEvent(address indexed owner, uint256 value); function emitMintEvent(address _owner, uint256 _value) external; function emitBurnEvent(address _owner, uint256 _value) external; }",1
0xee97c0e0bcb326065432db2c2230fab369a0a1b0.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RntCrowdsale,"contract RntCrowdsale is Pausable { using SafeMath for uint256; enum Status {Unknown, Presale, ICO, Finalized}",1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x6eb1eee8dcb041e2d3b2130ce124c3005dc3d6a7.sol,owned,contract owned { address public owner; function owned() { owner = msg.sender; },1
0xc5e1510dfb5942f0af172af9c3ef3eef46e945c2.sol,TMRToken,"contract TMRToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TMRToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 600000000000000000000000000; balances[0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01] = _totalSupply; Transfer(address(0), 0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01, _totalSupply); }",1
0x3967f481031f78a3fcbfe5c6a1079ec9f8426432.sol,Kongtou,contract Kongtou { address public owner; constructor() payable public { owner = msg.sender; },1
0x177efc15bd9d09757d11bd01a7f33d0376aece38.sol,MNToken,contract MNToken is StandardToken { function () { throw; },1
0x5b8c347b2ed372342532f5f7e0d97b02fb3f898b.sol,Ultron,"contract Ultron is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) lockdata; mapping (address => mapping (uint256 => uint256)) locktime; mapping (address => mapping (uint256 => uint256)) lockday; string public constant name = ; string public constant symbol = ; uint public constant decimals = 3; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x588f4ee97a2085c95420a45684a898d4b5906ba1.sol,SPAM,contract SPAM is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public SPAMed; event Message(string message); function SPAM() public { owner = msg.sender; totalSupply = 9999 * 1e18; stdBalance = 9999 * 1e18; SPAMed = true; },1
0x1c3aa36b021c7038d65643295c4bd24e0b9a317b.sol,SellENSFactory,contract SellENSFactory { struct SellENSInfo { string label; uint price; address owner; },1
0x73e5451bcf4f7c47946abe89c772f3e6576909c3.sol,DragonCrowdsaleCore,"contract DragonCrowdsaleCore is Ownable, DragonPricing { using SafeMath for uint; address public beneficiary; address public charity; address public advisor; address public front; bool public advisorset; uint public tokensSold; uint public etherRaised; uint public presold; uint public presoldMax; uint public crowdsaleCounter; uint public advisorTotal; uint public advisorCut; Dragon public tokenReward; mapping ( address => bool ) public alreadyParticipated; modifier onlyFront() { if (msg.sender != front) { throw; }",1
0x540dc09d343835ce0aef9bc3c3007de936c72b81.sol,TemplateCrowdsale,"contract TemplateCrowdsale is Consts, MainCrowdsale , RefundableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(175 * TOKEN_DECIMAL_MULTIPLIER, 0x97c78dB18D54fC94897C1b114A3F1D7785d98C5E, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1544792160) CappedCrowdsale(382857142857142857142857) RefundableCrowdsale(45714285714285714285714) { }",1
0x5bf5f85480848eb92af31e610cd65902bcf22648.sol,LescovexERC20,contract LescovexERC20 is Ownable { using SafeMath for uint256; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => timeHold) holded; struct timeHold{ uint256[] amount; uint256[] time; uint256 length; },1
0x74902714d325e794f50f7e07bd802aa61b5f450d.sol,ERC20Base,"contract ERC20Base is ERC20Interface , ReentrancyGuard{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; constructor() public { uint256 initialSupply = 10000000000; totalSupply = initialSupply.mul(1 ether); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,EC,"contract EC { uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798; uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8; uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F; uint256 constant public a = 0; uint256 constant public b = 7; function _jAdd( uint256 x1, uint256 z1, uint256 x2, uint256 z2) public pure returns(uint256 x3, uint256 z3) { (x3, z3) = ( addmod( mulmod(z2, x1, n), mulmod(x2, z1, n), n ), mulmod(z1, z2, n) ); }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,MyMillions,"contract MyMillions is Ownable, Improvements, ReferralsSystem, LeaderSystem { using SafeMath for uint256; event CreateUser(uint256 _index, address _address, uint256 _balance); event ReferralRegister(uint256 _refferalId, uint256 _userId); event ReferrerDistribute(uint256 _userId, uint256 _referrerId, uint256 _sum); event Deposit(uint256 _userId, uint256 _value); event PaymentProceed(uint256 _userId, uint256 _factoryId, FactoryType _factoryType, uint256 _price); event CollectResources(FactoryType _type, uint256 _resources); event LevelUp(uint256 _factoryId, uint8 _newLevel, uint256 _userId, uint256 _price); event Sell(uint256 _userId, uint8 _type, uint256 _sum); bool isSetted = false; uint256 public minSumDeposit = 0.01 ether; struct User { address addr; uint256 balance; uint256 totalPay; uint256 referrersReceived; uint256[] resources; uint256[] referrersByLevel; mapping (uint8 => uint256[]) referralsByLevel; }",1
0x1ed7ae1f0e2fa4276dd7ddc786334a3df81d50c0.sol,FourtySevenTokenCrowdsale,contract FourtySevenTokenCrowdsale is Ownable { using SafeMath for uint256; struct TimeBonus { uint256 bonusPeriodEndTime; uint percent; bool isAmountDependent; },1
0xd5dfe9e9e6df35d2aefdb0ce6d3e91b6890923d6.sol,VOCC_I062_20181211,"contract VOCC_I062_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x554c20b7c486beee439277b4540a434566dc4c02.sol,DecisionTokenSale,"contract DecisionTokenSale is Claimable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public constant presaleTokenRate = 3750; uint256 public constant earlyBirdTokenRate = 3500; uint256 public constant secondStageTokenRate = 3250; uint256 public constant thirdStageTokenRate = 3000; uint256 public constant tokenCap = 10**9 * 10**18; uint256 public constant tokenReserve = 4 * (10**8) * 10**18; DecisionToken public token; address public wallet; mapping (address => bool) whiteListedForPresale; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); event LogUserAddedToWhiteList(address indexed user); event LogUserUserRemovedFromWhiteList(address indexed user); function DecisionTokenSale(uint256 _startTime, address _wallet) { require(_startTime >= now); require(_wallet != 0x0); startTime = _startTime; endTime = startTime.add(14 days); wallet = _wallet; token = createTokenContract(); token.mint(owner, tokenReserve); }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterAuction,contract MonsterAuctionBase { MonsterOwnership public nonFungibleContract; ChainMonstersCore public core; struct Auction { address seller; uint256 price; uint64 startedAt; uint256 id; },1
0x862adb061a28df5b314bd7753e5caca27de94509.sol,Document,"contract Document is ERC721Token, Ownable { event BoughtToken(address indexed buyer, uint256 tokenId); uint8 constant TITLE_MIN_LENGTH = 1; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MIN_LENGTH = 1; uint256 constant DESCRIPTION_MAX_LENGTH = 10000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescription; constructor() ERC721Token(, ) public { }",1
0xf0d20ae17804be1e5fd400f04991aeb0ffed5a03.sol,PowH3DToken,contract PowH3DToken { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalBonusTokensIssued = 0; uint256 public totalSupply = 0; bool public purchasingAllowed = true; address owner = msg.sender; function name() constant returns (string) { return ; },1
0x02b6700c0282a687d66f3e09723bed55f23d5b83.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 99000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 0; }",1
0x20c77f3dc45bb8fe8b22b84e28466265265ce8ad.sol,StrongHoldNetwork,"contract StrongHoldNetwork is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 50 * 10**7 * (10**uint256(decimals)); uint256 public weiRaised; uint256 public tokenAllocated; address public owner; bool public saleToken = true; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event Transfer(address indexed _from, address indexed _to, uint256 _value); function StrongHoldNetwork() public { totalSupply = INITIAL_SUPPLY; owner = msg.sender; balances[owner] = INITIAL_SUPPLY; tokenAllocated = 0; transfersEnabled = true; }",1
0xf2740c75f221788cf78c716b953a7f1c769d49b9.sol,Wrapped_Ether,"contract Wrapped_Ether { using SafeMath for uint256; string public name = ; uint public total_supply; mapping(address => uint) internal balances; mapping(address => mapping (address => uint)) internal allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event StateChanged(bool _success, string _message); function createToken() public payable { require(msg.value > 0); balances[msg.sender] = balances[msg.sender].add(msg.value); total_supply = total_supply.add(msg.value); }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0x4be28e4b7dd6a8d5a4fa059382175dad781b51e8.sol,TrainingToken,contract TrainingToken is Interfacetrt{ using SafeMath for uint256; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 public totalSupply; string public name = ; uint8 public decimals = 18; string public symbol = ; address private _owner; mapping (address => bool) public _notransferible; mapping (address => bool) private _administradores; constructor() public{ _owner = msg.sender; totalSupply = 100000000000000000000000000000; _balances[_owner] = totalSupply; _administradores[_owner] = true; },1
0xbf06e2b5b97e375f7c0b3d8c61b8337a9c7ea23c.sol,FoMoRapid,"contract FoMoRapid is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; address admin; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x56a4d4e31c09558F6A1619DFb857a482B3Bb2Fb6); string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); admin = msg.sender; }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0xa58d43ea838b318d297248fc7b172c17e207d229.sol,BCT,"contract BCT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BCT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,Crowdsale,"contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, BurnableToken { event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint8 public decimals; function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable) public UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); }",1
0x20b504802dbce474b4dc59c9474f9270c85b94d8.sol,DaRiCpAy,"contract DaRiCpAy is StandardToken { using SafeMath for uint256; event CreatedIRC(address indexed _creator, uint256 _amountOfIRC); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; uint256 public maxPresaleSupply; uint256 public constant preSaleStartTime = 1516406400; uint256 public constant preSaleEndTime = 1518220800 ; uint256 public saleStartTime = 1518267600 ; uint256 public saleEndTime = 1522429200; uint256 public lowEtherBonusLimit = 5 * 1 ether; uint256 public lowEtherBonusValue = 110; uint256 public midEtherBonusLimit = 24 * 1 ether; uint256 public midEtherBonusValue = 115; uint256 public highEtherBonusLimit = 50 * 1 ether; uint256 public highEtherBonusValue = 120; uint256 public highTimeBonusLimit = 0; uint256 public highTimeBonusValue = 115; uint256 public midTimeBonusLimit = 1036800; uint256 public midTimeBonusValue = 110; uint256 public lowTimeBonusLimit = 3124800; uint256 public lowTimeBonusValue = 105; uint256 public constant IRC_PER_ETH_PRE_SALE = 10000; uint256 public constant IRC_PER_ETH_SALE = 8000; address public constant ownerAddress = 0x88ce817Efd0dD935Eed8e9d553167d08870AA6e7; bool public allowInvestment = true; uint256 public totalWEIInvested = 0; uint256 public totalIRCAllocated = 0; mapping (address => uint256) public WEIContributed; function DaRiCpAy() { require(msg.sender == ownerAddress); totalSupply = 20*1000000*1000000000000000000; uint256 totalIRCReserved = totalSupply.mul(20).div(100); maxPresaleSupply = totalSupply*8/1000 + totalIRCReserved; balances[msg.sender] = totalIRCReserved; totalIRCAllocated = totalIRCReserved; }",1
0x775a86858b77cbe7950bb307525a6459d6b01411.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x6f89544bc460f15315086f411b9c1fe5c8cfb1f1.sol,Crowdsale,contract Crowdsale { using SafeMath for uint256; token public vppToken; address public owner; address public wallet; uint256 public rate; uint256 public weiRaised; modifier onlyOwner() { require (msg.sender == owner); _; },1
0xf3620846825ba198be14cdbc5f2b41bbff788d67.sol,UECToken,"contract UECToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,RefundableCrowdsale,contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; RefundVault public vault; constructor(uint256 _goal) public { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; },1
0xe1dc467ca40fea1a9b9002592e6a15d4d4fc6521.sol,TimeChainToken,contract TimeChainToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 6; uint public INITIAL_SUPPLY = 100000000000000; constructor() { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; },1
0xa1cb45a734151b63679e1aed48e4c3deb8d1908d.sol,GuardianGoldToken,"contract GuardianGoldToken is BasicToken, Ownable, RBAC { string public name = ; string public symbol = ; uint8 public decimals = 18; string public constant ADMIN_ROLE = ; uint256 constant internal magnitude = 2**64; uint public maxTokens = 5000e18; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal referralBalance_; mapping(address => mapping (address => uint256)) allowed; uint public goldAccount = 0; uint public operationsAccount = 0; uint256 internal profitPerShare_; address[] public transfers; uint public constant INITIAL_SUPPLY = 62207e15; uint public totalSupply = 62207e15; uint public totalGoldReserves = 62207e15; uint public pendingGold = 0; uint public totalETHReceived = 57.599 ether; bool public isTransferable = true; bool public toggleTransferablePending = false; address public transferToggleRequester = address(0); uint public tokenPrice = 0.925925 ether; uint public goldPrice = 0.390185 ether; uint public tokenSellDiscount = 950; uint public referralFee = 30; uint minGoldPrice = 0.2 ether; uint maxGoldPrice = 0.7 ether; uint minTokenPrice = 0.5 ether; uint maxTokenPrice = 2 ether; uint public dividendRate = 150; uint public minPurchaseAmount = 0.1 ether; uint public minSaleAmount = 1e18; uint public minRefStake = 1e17; bool public allowBuy = false; bool public allowSell = false; bool public allowRedeem = false; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; addRole(msg.sender, ADMIN_ROLE); emit Transfer(address(this), msg.sender, INITIAL_SUPPLY); }",1
0xf3a4d8e3f5bfbab3b2d42e46d23c461eb866d16e.sol,BasicMultiToken,"contract BasicMultiToken is Ownable, StandardToken, DetailedERC20, ERC1003Token, IBasicMultiToken { using CheckedERC20 for ERC20; using CheckedERC20 for DetailedERC20; uint internal inLendingMode; bool public bundlingEnabled = true; event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); event BundlingStatus(bool enabled); modifier notInLendingMode { require(inLendingMode == 0, ); _; }",1
0x03410a55d072c79c586ff7b079a4de0359a45bd5.sol,VSmart,contract VSmart { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint public _totalSupply = 500000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0x4c17c61ce6edd113346d993aed193dda7ae57b9e.sol,PeerLicensing,contract PeerLicensing{ uint256 constant scaleFactor = 0x10000000000000000; uint256 constant trickTax = 3; uint256 constant tricklingUpTax = 6; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = 0x2793DB20E4C20163A; mapping(address => uint256) public bondHoldings; mapping(address => uint256) public averageBuyInPrice; mapping(address => address) public reff; mapping(address => uint256) public tricklePocket; mapping(address => uint256) public trickling; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public tricklingSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerToken; uint256 public contractBalance; function PeerLicensing() public { },1
0x4d49849dcc51ea1675140cb007d9f6897ae53260.sol,CrowdsaleExt,contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; string public name; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; },1
0xe1f2a706155f13b50b5ff79c8ed2bd5e5c4ed817.sol,VexaExchangeToken,"contract VexaExchangeToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,RoT,"contract RoT is Ownable { address public ESOPAddress; event ESOPAndCompanySet(address ESOPAddress, address companyAddress); function setESOP(address ESOP, address company) public onlyOwner { ESOPAddress = ESOP; transferOwnership(company); ESOPAndCompanySet(ESOP, company); }",1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (bytes32 => uint64) internal chains; mapping (bytes32 => uint) internal freezings; mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; }",1
0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f.sol,POTJ,contract POTJ { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x761341ca3b8186323e55c7e801ecbe9b5df41ad0.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = _totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcf5d889e2336d0f35f6121718f6c25e0650d4b25.sol,CryptloDex,"contract CryptloDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function CryptloDex(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,Owner,contract Owner { address public owner; constructor() public { owner = msg.sender; },1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x72c3a4fc3b3330e36fdf575e5c8b16e5a77856f6.sol,PackSale,"contract PackSale is Pausable { event Sold(address buyer, uint256 sku, uint256 totalPrice); event Hatched(address buyer, uint256 amount); uint256 constant PRESALE_START_TIME = 1542484800; uint256 constant NUM_UNIT_TYPES = 30; Token token; function setTokenContractAddress(address newAddress) onlyOwner public { token = Token(newAddress); }",1
0x0326ade59900f4e99e029362a076063a6d542a58.sol,Hedgely,contract Hedgely is Ownable { uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 150000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xef7149290d68db4ae877c8fa32e89f99939eb2bd.sol,ETHERCOIN,"contract ETHERCOIN{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public ETHERCOINSupply = 21000000; uint256 public buyPrice = 4000000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function ETHERCOIN() public { totalSupply = ETHERCOINSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x5b6acebad8f9e969d54bbe7c6efdc8674f8c7e76.sol,GemstoneToken,"contract GemstoneToken is owned, SafeMath { string public EthernetCashWebsite = ""https: address public EthernetCashAddress = this; address public creator = msg.sender; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 19999999986000000000000000000; uint256 public buyPrice = 18000000; uint256 public sellPrice = 18000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function GemstoneToken() public { balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0xf1a47b728439730e9f83054d7c352575bf13f0b4.sol,RPTCrowdsale,"contract RPTCrowdsale { using SafeMath for uint256; RPTToken public token; uint256 public totalWeiRaised; uint32 public exchangeRate = 3000; uint256 public preDistriToAcquiantancesStartTime = 1510876801; uint256 public preDistriToAcquiantancesEndTime = 1511827199; uint256 public presaleStartTime = 1511827200; uint256 public presaleEndTime = 1513036799; uint256 public crowdfundStartTime = 1513036800; uint256 public crowdfundEndTime = 1515628799; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; address public beneficiaryAddress; enum State { Acquiantances, PreSale, CrowdFund, Closed }",1
0xa3feedc649f1742f0f7aee3d1a4f9111757c87d6.sol,LicotestToken,"contract LicotestToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10*10**26; balances[0x266cC4b523078A71818700FaDA37eEFB885532fd] = _totalSupply; emit Transfer(address(0), 0x266cC4b523078A71818700FaDA37eEFB885532fd, _totalSupply); }",1
0xebaa1766c577a1ea5833f0502bd9984aef22c61f.sol,DadiSale,contract DadiSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint256 pledged; uint index; },1
0xa3eb3ee2dd6d0d0c78f7447a3e150cf462872c67.sol,SportXToken,"contract SportXToken is DetailedERC20, PausableToken, CappedToken,BurnableToken { using SafeMath for uint256; uint256 private constant TOKEN_UNIT = 10 ** uint256(4); uint256 public constant TOTAL_SUPPLY = 1000 * (10 ** 6) * TOKEN_UNIT; mapping (address => TokenTimelock) private timelock; function SportXToken() public DetailedERC20(, , 4) CappedToken(TOTAL_SUPPLY) { }",1
0x00fc2e075bc935c7c4283d277b90e6b9c822a105.sol,SmartPool,"contract SmartPool { uint currAmount; uint ticketPrice; uint startDate; uint endDate; uint startBlock; uint endBlock; uint duration; uint ticketCount; bool ended; bool terminated; bool moneySent; uint constant blockDuration = 15; uint constant minWaitDuration = 240; address[] players; address winner; address poolManager; function SmartPool(uint _ticketPrice, uint _ticketCount, uint _duration) public { require(_ticketPrice > 0 && (_ticketCount > 0 || _duration > blockDuration)); require(now + _duration >= now); if (_ticketCount == 0) { _ticketCount = (2 ** 256 - 1) / _ticketPrice; }",1
0xee8d611d2decc2acb30191353a8e04496fc02090.sol,CRYPTOVENO,"contract CRYPTOVENO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0x32166f7492c3bdd428dcc8d38c6c9e89e7f46101.sol,CrowdsaleExt,"contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; event Deposit (address recipient, uint value); bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; }",1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,NDUXBase,"contract NDUXBase is BasicToken, Ownable { string public constant name = ; string public constant symbol = ; uint constant maxTotalSupply = 75000000; function NDUXBase() public { mint(this, maxTotalSupply); }",1
0x18088625f914468a3fcc5904ce24920a3ed87c1a.sol,GOOREO,"contract GOOREO is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; string public constant AAcontributors = ; uint8 public decimals = 18; uint256 public totalSupply = 1e9 * 1e18; uint256 public distributeAmount = 0; bool public mintingFinished = true; address public founder = 0x6dba8b5a592e7eFD2904440664609f64f9Ee107C; address public developingFund = 0x3A21c8d4f3f9C9FD116Ca9ad9c684bD549E76692; address public activityFunds = 0xFFc6AB72FD5ba166a4E81dDa2e7d20892aC6d0bB; address public lockedFundsForthefuture = 0xE51E486B6493C77c372F477d501b009280e8253a; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function GOOREO() public { owner = founder; balanceOf[founder] = totalSupply.mul(25).div(100); balanceOf[developingFund] = totalSupply.mul(55).div(100); balanceOf[activityFunds] = totalSupply.mul(10).div(100); balanceOf[lockedFundsForthefuture] = totalSupply.mul(10).div(100); }",1
0x71fbecb11e291f824fd5dc9e760f56a5239e4702.sol,HodlDAO,contract HodlDAO { string public version = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => withdrawalRequest) public withdrawalRequests; struct withdrawalRequest { uint sinceTime; uint256 amount; },1
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol,PrivateSale,"contract PrivateSale is ContractReceiver { using SafeMath for uint256; Token tokContract; TimedEscrow escrow; address owner; uint256 rate; uint256 end; uint256 lockend1; uint256 lockend2; uint256 mincontrib; uint256 numerator; uint256 denominator; event Contribution(address from, uint256 eth, uint256 tokens); constructor(address _tokContract, address _escrowContract, uint256 _end, uint256 _lockend1, uint256 _lockend2, uint256 _numerator, uint256 _denominator, uint256 _mincontrib, uint256 _rate) public { tokContract = Token(_tokContract); escrow = TimedEscrow(_escrowContract); owner = msg.sender; end = _end; require(_rate > 0); rate = _rate; numerator = _numerator; require(_denominator > 0); denominator = _denominator; lockend1 = _lockend1; lockend2 = _lockend2; mincontrib = _mincontrib; }",1
0x55e7f93c7746877b1e6a1a1e789a8e37b03172cb.sol,CCD_EUROSIBENERGO_20190326_7,"contract CCD_EUROSIBENERGO_20190326_7 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x00214120d3469a74ca586bc9557c0ff8fb09b157.sol,TrueToken,"contract TrueToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 20000000000e18; uint256 public totalDistributed = 10000000000e18; uint256 public constant MIN_CONTRIBUTION = 1 ether / 1000; uint256 public tokensPerEth = 20000000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2666f6a7873fac3160db60ca15fd911e7ff7394e.sol,BlockMobaToken,contract BlockMobaToken is ERC223Token { constructor () public { uint256 initialSupply = 1000000000; name = ; symbol = ; decimals = 6; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; },1
0x006b4425ba57148466c0c54af1c484348a14a8a4.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0xe319847f14624ad62a99c7eb5e6d738f61fcf185.sol,EtherPaint,"contract EtherPaint { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; mapping(address => uint256[16]) public tokenBalance; uint256[128][128] public colorPerCoordinate; uint256[16] public colorPerCanvas; event colorUpdate(uint8 posx, uint8 posy, uint8 colorid); event priceUpdate(uint8 colorid); event tokenUpdate(uint8 colorid, address who); event dividendUpdate(); event pushuint(uint256 s); mapping(address => int256[16]) public payouts; uint256[16] public totalSupply; uint256 public allTotalSupply; int256[16] totalPayouts; uint256[16] earningsPerToken; uint256[16] public contractBalance; address public owner; uint256 public ownerFee; function EtherPaint() public { owner = msg.sender; colorPerCanvas[0] = 128*128; pushuint(1 finney); }",1
0x5a85092211fca2eb379824207b1a7b8059bf009a.sol,SafeMath,"contract SafeMath { function safeSub(uint a, uint b) pure internal returns (uint) { assert(b <= a); return a - b; }",1
0x18162474734b1eabd795b25d978558c09f9e1807.sol,BaconCoin,"contract BaconCoin is BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public constant initialSupply = 2200000000 * (10 ** uint256(decimals)); struct Wallet { uint256 balance; uint256 tokenBalance; mapping(address => bool) authed; uint64 seedNonce; uint64 withdrawNonce; }",1
0xf67451dc8421f0e0afeb52faa8101034ed081ed9.sol,Token,contract Token is ERC20 { function () { require(false); },1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x0692de52a966c107021e8a84db8486b4be57ecf1.sol,OQToken,contract OQToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function OQToken () { owner = msg.sender; },1
0x1ed73dcc7400b90b895379956b4b29e555f4fba0.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onReceiveAirdrop(address indexed hodler, uint256 amount, uint256 datetime); event onAddContractAddress(address indexed hodler, address indexed contracthodler, uint256 Currentprice, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed hodler, address indexed Tokenairdrop, uint256 HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(address indexed hodler, uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(address indexed hodler, uint256 amount, uint256 newbalance, uint256 datetime); struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7.sol,Bgc,"contract Bgc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bgc( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x175744fb0849584129fa3d0e6350c00206d95d2f.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x515ced0695fdcb330ff7ef72e1844e48d496f2c2.sol,verifiable,contract verifiable { struct Signature { uint8 v; bytes32 r; bytes32 s; },1
0x340d2bde5eb28c1eed91b2f790723e3b160613b7.sol,BlockvToken,"contract BlockvToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; PoolBLock public poolBLock; PoolCLock public poolCLock; PoolDLock public poolDLock; uint256 public constant totalAmountOfTokens = 3646271241200255205023407108; uint256 public constant amountOfTokensPoolA = 1276194934420089321758192488; uint256 public constant amountOfTokensPoolB = 911567810300063801255851777; uint256 public constant amountOfTokensPoolC = 911567810300063801255851777; uint256 public constant amountOfTokensPoolD = 546940686180038280753511066; address public migrationMaster; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); function BlockvToken(address _migrationMaster) Pausable(_migrationMaster) { require(_migrationMaster != 0); migrationMaster = _migrationMaster; totalSupply = totalAmountOfTokens; balances[msg.sender] = amountOfTokensPoolA; Transfer(0x0, msg.sender, amountOfTokensPoolA); poolBLock = new PoolBLock(this); poolCLock = new PoolCLock(this); poolDLock = new PoolDLock(this); balances[poolBLock] = amountOfTokensPoolB; balances[poolCLock] = amountOfTokensPoolC; balances[poolDLock] = amountOfTokensPoolD; Transfer(0x0, poolBLock, amountOfTokensPoolB); Transfer(0x0, poolCLock, amountOfTokensPoolC); Transfer(0x0, poolDLock, amountOfTokensPoolD); }",1
0x3ab2ab661311501f4b3c9b17d40e3d95f9bc577f.sol,PoolOwners,"contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; itmap.itmap private ownerMap; mapping(address => mapping(address => uint256)) allowance; mapping(address => bool) public tokenWhitelist; mapping(address => bool) public whitelist; mapping(address => uint256) public distributionMinimum; uint256 public totalContributed = 0; bool public distributionActive = false; uint256 public precisionMinimum = 0.04 ether; bool public locked = false; address public wallet; bool private contributionStarted = false; uint256 private valuation = 4000 ether; uint256 private hardCap = 1000 ether; uint private distribution = 1; address private dToken = address(0); event Contribution(address indexed sender, uint256 share, uint256 amount); event TokenDistributionActive(address indexed token, uint256 amount, uint256 amountOfOwners); event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount); event TokenDistributionComplete(address indexed token, uint amount, uint256 amountOfOwners); modifier onlyPoolOwner() { require(ownerMap.get(uint(msg.sender)) != 0, ); _; }",1
0xc83355ef25a104938275b46cffd94bf9917d0691.sol,FUTR,"contract FUTR { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 MAX_SUBMITTED = 500067157619455000000000; uint256 _totalSupply = 0; uint256[] levels = [ 8771929824561400000000, 19895525330179400000000, 37350070784724800000000, 64114776667077800000000, 98400490952792100000000, 148400490952792000000000, 218400490952792000000000, 308400490952792000000000, 415067157619459000000000, 500067157619455000000000 ]; uint256[] ratios = [ 114, 89, 55, 34, 21, 13, 8, 5, 3, 2 ]; uint256 _submitted = 0; uint256 public tier = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event Mined(address indexed _miner, uint _value); event WaitStarted(uint256 endTime); event SwapStarted(uint256 endTime); event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time); event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time); string public name = ; uint8 public decimals = 18; string public symbol = ; bool public swap = false; bool public wait = false; bool public extended = false; uint256 public endTime; uint256 swapTime; uint256 swapEndTime; uint256 endTimeExtended; uint256 swapTimeExtended; uint256 swapEndTimeExtended; uint256 public payRate = 0; uint256 submittedFeesPaid = 0; uint256 penalty = 0; uint256 reservedFees = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () external payable { require(msg.sender != address(0) && tier != 10 && swap == false && wait == false); uint256 issued = mint(msg.sender, msg.value); Mined(msg.sender, issued); Transfer(this, msg.sender, issued); }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsAccessControl,contract EthernautsAccessControl is EthernautsBase { event ContractUpgrade(address newContract); address public ceoAddress; address public ctoAddress; address public cooAddress; address public oracleAddress; bool public paused = false; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x9c76c260d4e72b87b398635313d3fab11e83b7b3.sol,CompetitionCompliance,"contract CompetitionCompliance is ComplianceInterface, DBC, Owned { address public competitionAddress; function CompetitionCompliance(address ofCompetition) public { competitionAddress = ofCompetition; }",1
0x3478c2e4ed6f64db0be9c483b87f70ff6ab0d65a.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,Crowdsale,"contract Crowdsale is Pausable, TokenVesting { using SafeMath for uint; address public multisigETH; address public commissionAddress; uint public tokensForTeam; uint public ethReceivedPresale; uint public ethReceivedMain; uint public totalTokensSent; uint public tokensSentMain; uint public tokensSentPresale; uint public tokensSentDev; uint public startBlock; uint public endBlock; uint public maxCap; uint public minCap; uint public minContributionMainSale; uint public minContributionPresale; uint public maxContribution; bool public crowdsaleClosed; uint public tokenPriceWei; uint public refundCount; uint public totalRefunded; uint public campaignDurationDays; uint public firstPeriod; uint public secondPeriod; uint public thirdPeriod; uint public firstBonus; uint public secondBonus; uint public thirdBonus; uint public multiplier; uint public status; Step public currentStep; address[] public holdersIndex; address[] public devIndex; enum Step { FundingPreSale, FundingMainSale, Refunding }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x7613b207ef1cd3ca38adb0c539e5aa56caf4254b.sol,TokenERC223,contract TokenERC223 is Owned{ using SafeMath for uint256; string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=1000000000; address[] public littHolders; uint256 public buyRate=10000; bool public saleIsOn=true; struct Admin{ bool isAdmin; address beAdmin; },1
0x2706165b57e8d91f0282a4fa919b810e8103ab86.sol,Babylon,contract BabyloniaToken is MintAndBurnToken { string public name = ; string public symbol = ; uint8 public decimals = 18; },1
0xd082e94b1fcad2a083ed817618b24b14399439ec.sol,ERC20_ICO,"contract ERC20_ICO is owned, Killable { ERC20 public token; uint256 public startsAt = 1528489000; uint256 public endsAt = 1530000000; uint256 public TokenPerETH = 5600; bool public finalized = false; uint256 public tokensSold = 0; uint256 public weiRaised = 0; uint256 public investorCount = 0; uint256 public Soft_Cap = 40000000000000000000000000; uint256 public Hard_Cap = 140000000000000000000000000; mapping (address => uint256) public investedAmountOf; event Invested(address investor, uint256 weiAmount, uint256 tokenAmount); event StartsAtChanged(uint256 startsAt); event EndsAtChanged(uint256 endsAt); event RateChanged(uint256 oldValue, uint256 newValue); event Refund(address investor, uint256 weiAmount); constructor (address _token) public { token = ERC20(_token); }",1
0xf12b9b6956b719a2c07873154f9e56bd13dfa24e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) public whitelist; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; },1
0x0eee3715d385ecefc6afd9fbf30ddee725be3de1.sol,REL,"contract REL is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function REL( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x54b9eaee92a9bff63cd445a65bd19078116fe927.sol,WalletsPercents,"contract WalletsPercents is Ownable { address[] public wallets; mapping (address => uint) percents; function addWallet(address wallet, uint percent) public onlyOwner { wallets.push(wallet); percents[wallet] = percent; }",1
0x5ca4568d54ecfc15902a425fd6ac64095a9a51a3.sol,MultiTransfer,"contract MultiTransfer { event Deposited(address from, uint value, bytes data); event Transacted( address msgSender, address toAddress, uint value ); function() public payable { if (msg.value > 0) { emit Deposited(msg.sender, msg.value, msg.data); }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x6ef02644549af0e3761ae1a88fe02fe1d7016aea.sol,BlueChipGame,contract BlueChipGame { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,Referral,"contract Referral is Declaration, Ownable { using SafeMath for uint; WealthBuilderToken private token; Data private data; Investors private investors; uint public investorsBalance; uint public ethUsdRate; function Referral(uint _ethUsdRate, address _token, address _data, address _investors) public { ethUsdRate = _ethUsdRate; token = WealthBuilderToken(_token); data = Data(_data); investors = Investors(_investors); investorsBalance = 0; }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,Proxyable,"contract Proxyable is Owned { Proxy public proxy; address messageSender; constructor(address _proxy, address _owner) Owned(_owner) public { proxy = Proxy(_proxy); emit ProxyUpdated(_proxy); }",1
0x4c29be83d5dc0bb45faffa6af3f35a7b5862ff54.sol,CustomToken,"contract CustomToken is BaseToken, BurnToken { function CustomToken() public { totalSupply = 1000000000000000000000000000; name = ; symbol = ; decimals = 18; balanceOf[0xe5076a492a2bd8d8d8bdf4c4d6dda87fe46484e7] = totalSupply; Transfer(address(0), 0xe5076a492a2bd8d8d8bdf4c4d6dda87fe46484e7, totalSupply); }",1
0xc4a0ab20f1901c24740e06966cca9d5f2e5d5e79.sol,FabotCoin,"contract FabotCoin is Token, LockBalance { function FabotCoin() public { name = ; symbol = ; decimals = 18; uint256 initialSupply = 4000000000; totalSupply = initialSupply * 10 ** uint(decimals); user[owner].balance = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0xee74a44343dc255d260eab6b221d020d957f41dd.sol,FILAToken,"contract FILAToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 55555555555e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 555555555e8; uint256 public constant minContribution = 1 ether / 1000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c17c61ce6edd113346d993aed193dda7ae57b9e.sol,PeerLicensing,contract PeerLicensing{ uint256 constant scaleFactor = 0x10000000000000000; uint256 constant trickTax = 3; uint256 constant tricklingUpTax = 6; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = 0x2793DB20E4C20163A; mapping(address => uint256) public bondHoldings; mapping(address => uint256) public averageBuyInPrice; mapping(address => address) public reff; mapping(address => uint256) public tricklePocket; mapping(address => uint256) public trickling; mapping(address => int256) public payouts; uint256 public totalBondSupply; int256 totalPayouts; uint256 public tricklingSum; uint256 public stakingRequirement = 1e18; address public lastGateway; uint256 public withdrawSum; uint256 public investSum; uint256 earningsPerToken; uint256 public contractBalance; function PeerLicensing() public { },1
0xcda652b4a836657b69491997fcf4de0dd7a2ff88.sol,Protecthor,contract Protecthor { using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 1000000000 * 10 ** uint256(decimals); address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() Protecthor() public { owner = msg.sender; balances[owner] = _totalSupply; },1
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,Johnsonville,contract Johnsonville { address owner; address patronOne; address patronTwo; address patronThree; bool patronOneWd; bool patronTwoWd; bool patronThreeWd; modifier onlyOwner { if(msg.sender != owner) throw; _; },1
0x020e0638aa7d98b40d2a3a7ebd37ebdfc5cba2fd.sol,EtherBags,"contract EtherBags { event BagSold( uint256 bagId, uint256 multiplier, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner ); address public contractOwner; uint256 public timeout = 4 hours; uint256 public startingPrice = 0.005 ether; Bag[] private bags; struct Bag { address owner; uint256 level; uint256 multiplier; uint256 purchasedAt; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x047547a016486e5c81961d71a1231e7478580b29.sol,IETToken,"contract IETToken is BurnableToken, MintableToken, PausableToken { string public name; string public symbol; uint256 public decimals; constructor ( string _name, string _symbol, uint256 _decimals, uint256 _initSupply) public { name = _name; symbol = _symbol; decimals = _decimals; owner = msg.sender; totalSupply_ = _initSupply * 10 ** decimals; balances[owner] = totalSupply_; }",1
0x1bb0a576936bce5d983e676073ac48ba49f12e05.sol,ERRLCoin,"contract ERRLCoin is StandardToken, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 constant public ERRL_UNIT = 10 ** 18; uint256 public INITIAL_SUPPLY = 1000000000000 * ERRL_UNIT; uint256 public totalAllocated = 0; uint256 public remaintokens=0; uint256 public factor=35; uint256 constant public maxOwnerSupply = 16000000000 * ERRL_UNIT; uint256 constant public DeveloperSupply = 2000000000 * ERRL_UNIT; address public constant OWNERSTAKE = 0xea38f5e13FF11A4F519AC1a8a9AE526979750B01; address public constant DEVSTAKE = 0x625151089d010F2b1B7a72d16Defe2390D596dF8; event Burn(address indexed from, uint256 value); function ERRLCoin() { totalAllocated+=maxOwnerSupply+DeveloperSupply; remaintokens=INITIAL_SUPPLY-totalAllocated; totalSupply = INITIAL_SUPPLY; balances[OWNERSTAKE] = maxOwnerSupply; balances[DEVSTAKE] = DeveloperSupply; balances[msg.sender] = remaintokens; }",1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; constructor(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x323ec3eea0c301cca228bb5e92a3ccf6e6dae669.sol,RBACMixin,"contract RBACMixin { string constant FORBIDDEN = ; mapping (address => bool) public owners; mapping (address => bool) public minters; event AddOwner(address indexed who); event DeleteOwner(address indexed who); event AddMinter(address indexed who); event DeleteMinter(address indexed who); constructor () public { _setOwner(msg.sender, true); }",1
0x0df55c565881b253d307e9a8a95c907dfa228283.sol,BalanceVerifier,"contract BalanceVerifier { event BlockCreated(uint blockNumber, bytes32 rootHash, string ipfsHash); mapping (uint => bytes32) public blockHash; function onVerifySuccess(uint blockNumber, address account, uint balance) internal; function onCommit(uint blockNumber, bytes32 rootHash, string ipfsHash) internal; function commit(uint blockNumber, bytes32 rootHash, string ipfsHash) external { require(blockHash[blockNumber] == 0, ); string memory _hash = ipfsHash; onCommit(blockNumber, rootHash, _hash); blockHash[blockNumber] = rootHash; emit BlockCreated(blockNumber, rootHash, _hash); }",1
0x6e5db36f85492b20153eb8165e19dea1387345df.sol,POWM,contract POWM { address didyoucopy_questionmark = 0x20C945800de43394F70D789874a4daC9cFA57451; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5693a4616fa3b5370bf5563853bcbf929d554890.sol,CAIDToken,"contract CAIDToken is Ownable { using SafeMath for uint; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 100000000*(uint(10).pow(decimals)); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function totalSupply() public view returns (uint256) { return _totalSupply; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x6f9ef4d30498f23e7d3116e272b855597fba83bd.sol,P3DRaffle,contract P3DRaffle is Owned { using SafeMath for uint; HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); function harvestabledivs() view public returns(uint256) { return ( P3Dcontract_.dividendsOf(address(this))) ; },1
0x1806b3527c18fb532c46405f6f014c1f381b499a.sol,PlanetCryptoToken,"contract PlanetCryptoToken is ERC721Full_custom{ using Percent for Percent.percent; event referralPaid(address indexed search_to, address to, uint256 amnt, uint256 timestamp); event issueCoinTokens(address indexed searched_to, address to, uint256 amnt, uint256 timestamp); event landPurchased(uint256 indexed search_token_id, address indexed search_buyer, uint256 token_id, address buyer, bytes32 name, int256 center_lat, int256 center_lng, uint256 size, uint256 bought_at, uint256 empire_score, uint256 timestamp); event taxDistributed(uint256 amnt, uint256 total_players, uint256 timestamp); event cardBought( uint256 indexed search_token_id, address indexed search_from, address indexed search_to, uint256 token_id, address from, address to, bytes32 name, uint256 orig_value, uint256 new_value, uint256 empireScore, uint256 newEmpireScore, uint256 now); event cardChange( uint256 indexed search_token_id, address indexed search_owner, uint256 token_id, address owner, uint256 changeType, bytes32 data, uint256 now); address owner; address devBankAddress; address tokenBankAddress; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x0d7b2ea059bbfdc99ee6ae6289939d84397e5b78.sol,NortontokenERC20,"contract NortontokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NortontokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8ab7404063ec4dbcfd4598215992dc3f8ec853d7.sol,UpgradeabilityProxy,contract UpgradeabilityProxy is Proxy { event Upgraded(address implementation); bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3; constructor(address _implementation) public { assert(IMPLEMENTATION_SLOT == keccak256()); _setImplementation(_implementation); },1
0xf26c7cd79aa1ed2466e7e81a0e0541709ddd050b.sol,BTC20Token,"contract BTC20Token is BasicToken,Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 21000000; event Debug(string message, address addr, uint256 number); function BTC20Token(address wallet) public { owner = msg.sender; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = totalSupply; }",1
0xc8507d914d21d50c1763288da6539f6a0f5a0916.sol,yiDaooToken,"contract yiDaooToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaooToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x02e582682aa7b4dcc3f7574c468ef61b29545404.sol,CloneWars,"contract CloneWars { using SafeMath for uint; event MarketBoost( uint amountSent ); event NorsefireSwitch( address from, address to, uint price ); uint256 public clones_to_create_one_idea = 2 days; uint256 public starting_clones = 232; uint256 PSN = 10000; uint256 PSNH = 5000; address actualNorse = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae; uint256 public marketIdeas; uint256 public norsefirePrice; bool public initialized; address public currentNorsefire; mapping (address => uint256) public arrayOfClones; mapping (address => uint256) public claimedIdeas; mapping (address => uint256) public lastDeploy; mapping (address => address) public referrals; constructor () public { initialized = false; norsefirePrice = 0.1 ether; currentNorsefire = 0x1337a4aEfd5ec486E6e97b1d0aE055FAC8D879dE; }",1
0x1844b21593262668b7248d0f57a220caaba46ab9.sol,OysterPearl,"contract OysterPearl { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Bury(address indexed _target, uint256 _value); event Claim(address indexed _target, address indexed _payout, address indexed _fee); function OysterPearl() public { director = msg.sender; name = ; symbol = ; decimals = 18; saleClosed = true; directorLock = false; funds = 0; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 8000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); epoch = 31536000; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x0d4d61d5b3e4f46c54d175935881d0faa356fca1.sol,RobocallsTokenSale,contract RobocallsTokenSale is Owned { uint public startDate; uint public bonusEnds; uint public endDate; address public main_addr; address public tokenOwner; Robocalls r; constructor() public { bonusEnds = now + 8 weeks; endDate = now + 8 weeks; startDate = now; main_addr = 0xAD7615B0524849918AEe77e6c2285Dd7e8468650; tokenOwner = 0x6ec4dd24d36d94e96cc33f1ea84ad3e44008c628; r = Robocalls(main_addr); },1
0x188ff41cc7960dd51b3aa802fcb17ba17c41276d.sol,DataKnowYourCustomer,"contract DataKnowYourCustomer is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public totalSupply = 10000000000 * 10**decimals; string public version = ; address public etherProceedsAccount; uint256 public constant CAP = 100000000000 * 10**decimals; function DataKnowYourCustomer(address _etherProceedsAccount) { etherProceedsAccount = _etherProceedsAccount; balances[etherProceedsAccount] += CAP; Transfer(this, etherProceedsAccount, CAP); }",1
0x1ee464894bfa36751d1cf84126e4ff24c06b9360.sol,PLCRVoting,"contract PLCRVoting { event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter); event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter, uint salt); event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator); event _VotingRightsGranted(uint numTokens, address indexed voter); event _VotingRightsWithdrawn(uint numTokens, address indexed voter); event _TokensRescued(uint indexed pollID, address indexed voter); using AttributeStore for AttributeStore.Data; using DLL for DLL.Data; using SafeMath for uint; struct Poll { uint commitEndDate; uint revealEndDate; uint voteQuorum; uint votesFor; uint votesAgainst; mapping(address => bool) didCommit; mapping(address => bool) didReveal; mapping(address => uint) voteOptions; }",1
0x06badfdacd3e80e4974e8419153114f6159e4851.sol,CLOUDTOKEN,"contract CLOUDTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CLOUDTOKEN() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1] = _totalSupply; Transfer(address(0), 0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1, _totalSupply); }",1
0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Proxyable,contract Proxyable is Owned { Proxy public proxy; address messageSender; function Proxyable(address _owner) Owned(_owner) public { },1
0x58c3069023ed736f430d585003715058c2e3c671.sol,PaymentFallbackReceiver,"contract PaymentFallbackReceiver { BTCPaymentI public payment; enum SaleType { pre, main }",1
0x2773c69d7a7e2943f6e27c9947d5ae4e2b853993.sol,EtherDiamond,"contract EtherDiamond is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 28000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2dd09c71d951148bba0f25be7f76ba401fe8ef84.sol,GoToken,"contract GoToken is StandardToken { string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; uint256 constant multiplier = 10 ** (decimals); event Deployed(uint256 indexed _total_supply); function GoToken(address auction_address, address wallet_address, uint256 initial_supply) public { require(auction_address != 0x0); require(wallet_address != 0x0); require(initial_supply > multiplier); totalSupply = initial_supply; balances[auction_address] = initial_supply / 2; balances[wallet_address] = initial_supply / 2; Transfer(0x0, auction_address, balances[auction_address]); Transfer(0x0, wallet_address, balances[wallet_address]); Deployed(totalSupply); assert(totalSupply == balances[auction_address] + balances[wallet_address]); }",1
0xd1415d6456cce5ffeb9e77cf4d144f82f4e3c4e3.sol,Puttu,contract Puttu is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function Puttu() { balances[msg.sender] = 30000000000000000000000000000; totalSupply = 30000000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000000; fundsWallet = msg.sender; },1
0x88a3e4f35d64aad41a6d4030ac9afe4356cb84fa.sol,preToken,"contract preToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 public constant maxSupply = 1000000000e18; uint256 public constant initialSupply = 250000000e18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; address public owner; address public crowdsaleAddress; uint public unlockDate = 1512018000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,MonsterOwnership,"contract MonsterOwnership is MonsterBase, ERC721 { string public constant name = ; string public constant symbol = ; ERC721Metadata public erc721Metadata; bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256()); bytes4 constant InterfaceSignature_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function supportsInterface(bytes4 _interfaceID) external view returns (bool) { return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721)); }",1
0x41e7f88f5a4580bf62b10bac098f45979e3c86e0.sol,Whim,contract Whim { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint public _totalSupply = 120000000000000000; uint256 public RATE = 1; bool public isMinting = true; string public constant generatedBy = ; using SafeMath for uint256; address public owner; modifier onlyOwner() { if (msg.sender != owner) { throw; },1
0xde5de899b79417a170172a7d1b120af4ff4896bd.sol,TrueUSD,"contract TrueUSD is PausableToken, BurnableToken, NoOwner, Claimable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhitelist; AddressList public canBurnWhiteList; AddressList public blackList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public insurer; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); function TrueUSD(address _canMintWhiteList, address _canBurnWhiteList, address _blackList) public { totalSupply_ = 0; canReceiveMintWhitelist = AddressList(_canMintWhiteList); canBurnWhiteList = AddressList(_canBurnWhiteList); blackList = AddressList(_blackList); insurer = msg.sender; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x4cba96e12b8085fd9bc17fb37290b6bf9a213863.sol,EtherKebab,contract EtherKebab{ uint256 public KEBABER_TO_MAKE_1KEBAB=86400; uint256 public STARTING_KEBAB=150; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress = 0xdf4703369ecE603a01e049e34e438ff74Cd96D66; uint public ceoEtherBalance; mapping (address => uint256) public workingKebaber; mapping (address => uint256) public claimedKebabs; mapping (address => uint256) public lastKebab; mapping (address => address) public referrals; uint256 public marketKebabs; function makeKebabs(address ref) public { require(initialized); if(referrals[msg.sender]==0 && referrals[msg.sender]!=msg.sender) { referrals[msg.sender]=ref; },1
0x1afafc35b364595f06e89a0429c5762452eb7ffd.sol,CXTCContract,contract CXTCContract is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant freeSupply = 21000000 * (10 ** uint256(decimals)); uint256 public constant frozenSupply = 189000000 * (10 ** uint256(decimals)); address[] parterAcc; struct ArtInfo { string idtReport; string evtReport; string escReport; string regReport; },1
0x552b00454a23e5f118e5419cc84f82100ed1bd38.sol,SATEToken,"contract SATEToken is EIP20Interface, SafeMath { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string constant public name = ; uint8 constant public decimals = 18; string constant public symbol = ; mapping (address => uint256) public addressType; mapping (address => uint256[3]) public releaseForSeed; mapping (address => uint256[5]) public releaseForTeamAndAdvisor; event AllocateToken(address indexed _to, uint256 _value, uint256 _type); address public owner; uint256 public finaliseTime; function SATEToken() public { totalSupply = 20*10**26; balances[msg.sender] = totalSupply; owner = msg.sender; }",1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,SafeMath,"contract SafeMath { uint constant DAY_IN_SECONDS = 86400; uint constant BASE = 1000000000000000000; uint constant preIcoPrice = 4101; uint constant icoPrice = 2255; function mul(uint256 a, uint256 b) constant internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0xc7df0158f29ff6725cec6a3ac71d26bd08b90ff6.sol,MyTokenEVC,"contract MyTokenEVC is owned { string _name; string _symbol; uint8 _decimals = 18; uint256 _totalSupply; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) _allowance; mapping (address => bool) _frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(_decimals); _balanceOf[msg.sender] = _totalSupply; _name = ; _symbol = ; }",1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x5409fcd56836e0e0459c12ab45e7ef23c6094bed.sol,RedExchange,contract RedExchange { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6ccb56947ea1d6efdc81acfbacd8263ddfa9b202.sol,RKCToken,"contract RKCToken is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; bool public constant TEST_MODE = false; uint public constant atto = 1000000000000000000; uint public constant INITIAL_SUPPLY = 15000000 * atto; address public teamWallet = 0xb79F963f200f85D0e3dD60C82ABB8F80b5869CB9; address public ico_address = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public constant ICO_START_TIME = 1499810400; uint public current_supply = 0; uint public ico_starting_supply = 0; uint public current_price_atto_tokens_per_wei = 0; bool public preSoldSharesDistributed = false; bool public isICOOpened = false; bool public isICOClosed = false; uint[] public premiumPacks; mapping(address => uint) premiumPacksPaid; event ICOOpened(); event ICOClosed(); event PriceChanged(uint old_price, uint new_price); event SupplyChanged(uint supply, uint old_supply); event RKCAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function RKCToken() { distributePreSoldShares(); current_price_atto_tokens_per_wei = calculateCurrentPrice(1); premiumPacks.length = 0; }",1
0x72112ee2f2cfb1f8494e78e0c3166a77fb6a2d24.sol,DSTokenBase,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => uint256) _frozens; mapping (address => mapping (address => uint256)) _approvals; constructor(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; address public miningWarAddress; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0xd44fb08008d35e1310319b17aef355a432edd123.sol,Contributions,"contract Contributions is RBAC, Ownable { using SafeMath for uint256; string public constant ROLE_OPERATOR = ; modifier onlyOperator () { checkRole(msg.sender, ROLE_OPERATOR); _; }",1
0xf12b9b6956b719a2c07873154f9e56bd13dfa24e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) public whitelist; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; },1
0x1818403c06ed28c55d533b526ae8566ec31d87d3.sol,DAOPlayMarketTokenCrowdsale,"contract DAOPlayMarketTokenCrowdsale is Haltable, SafeMath, Killable { DAOPlayMarketToken public token; address public multisigWallet; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; bool public finalized; uint public CAP; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; address public cryptoAgent; mapping (uint => mapping (address => uint256)) public tokenAmountOfPeriod; struct Stage { uint start; uint end; uint period; uint price1; uint price2; uint price3; uint price4; uint cap; uint tokenSold; }",1
0xf45ee2519203fe8b77c1f05de75cf5f405bf9011.sol,token,"contract token { string public standard = 'https: string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0xcf9a1a3a30d859ab8964e6db596a8d2edd449c0b.sol,TimeLockedController,"contract TimeLockedController is HasNoEther, HasNoTokens, Claimable { using SafeMath for uint256; uint public constant blocksDelay = 24*60*60/15; struct MintOperation { address to; uint256 amount; address admin; uint deferBlock; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x6b0f6038c7c2d9e9ed89a87c1f100579fbe46373.sol,MBCH,"contract MBCH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 230000000000000000000000000; balances[0xaA3E0E0d07f169C7247d822e844AEB502725c29E] = _totalSupply; emit Transfer(address(0), 0xaA3E0E0d07f169C7247d822e844AEB502725c29E, _totalSupply); }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0x5041d5c444c2d730b406ae5ec9199cd8e47e463c.sol,POHMO,"contract POHMO is PoHEVENTS { using SafeMath for *; using NameFilter for string; using KeysCalc for uint256; PlayerBookInterface private PlayerBook; POHCONTRACT private POHToken; address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 seconds; uint256 private rndGap_ = 1 seconds; uint256 private rndInit_ = 6 hours; uint256 constant private rndInc_ = 10 seconds; uint256 private rndMax_ = 6 hours; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => POHMODATASETS.Player) public plyr_; mapping (uint256 => mapping (uint256 => POHMODATASETS.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => POHMODATASETS.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => POHMODATASETS.TeamFee) public fees_; mapping (uint256 => POHMODATASETS.PotSplit) public potSplit_; constructor(address token, address playerbook) public { POHToken = POHCONTRACT(token); PlayerBook = PlayerBookInterface(playerbook); fees_[0] = POHMODATASETS.TeamFee(47,12); potSplit_[0] = POHMODATASETS.PotSplit(15,10); }",1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xbe7750c8aac1c99f7ee2c19a9654a479601d549f.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x1e26b3d07e57f453cae30f7ddd2f945f5bf3ef33.sol,ClearCoin,contract ClearCoin is IERC20 { uint public constant _totalSupply = 100000000000000000; string public constant symbol =; string public constant name = ; uint8 public constant decimals = 8; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function ClearCoin() { balances[msg.sender] = _totalSupply; },1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,ESOP,"contract ESOPTypes { enum EmployeeState { NotSet, WaitingForSignature, Employed, Terminated, OptionsExercised }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x70fa1a3b14a6dcc4228a3d2674d86b6d482b5f71.sol,Bluechipstoken,"contract Bluechipstoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 25000000e8; uint256 public constant minContribution = 1 ether / 1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe31ced3343f21e5cad5d31163bba5899ee01d813.sol,ERC20_CRYPTOMILLION_CPMN,"contract ERC20_CRYPTOMILLION_CPMN { string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function CreateTokenERC20(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x6abf810730a342add1374e11f3e97500ee774d1f.sol,BCFAuction,contract BCFAuction is Pausable { struct CardAuction { address seller; uint128 startPrice; uint128 endPrice; uint64 duration; uint64 startedAt; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0xd5107e77d5f3b0035d152413c89851cbeafa9a60.sol,PresaleToken,"contract PresaleToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public constant PRICE = 598; uint public constant TOKEN_SUPPLY_LIMIT = 2392000 * (1 ether / 1 wei); enum State{ Init, Running, Paused, Migrating, Migrated }",1
0xf14f06e227c015b398b8069314f4b8d1d7022c9e.sol,Exchange,contract ExchangeCore is ReentrancyGuarded { ERC20 public exchangeToken; ProxyRegistry public registry; mapping(bytes32 => bool) public cancelledOrFinalized; mapping(bytes32 => bool) public approvedOrders; struct Sig { uint8 v; bytes32 r; bytes32 s; },1
0xda4b5761e044a13a84816736540838cf95295d08.sol,Bitscret,"contract Bitscret is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 8000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 8000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x516d81a212ad95e6fc9eaa586b7e12e58d5129a9.sol,getfreetoken,"contract getfreetoken { address sender; address fatherr; address NEO = 0xc55a13e36d93371a5b036a21d913a31CD2804ba4; uint num; constructor(address _father,address _sender) public { fatherr = _father; sender = _sender; }",1
0x6ed680055bd5a04c194c954f71019ee90145001c.sol,Game,contract Game is FixedSupplyToken { HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); struct Village { address owner; uint defending; uint lastcollect; uint beginnerprotection; },1
0xef19256160e4107b1de93b1753b25e3c4e889caa.sol,OKEXTOKEN,"contract OKEXTOKEN { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 90000000000; balanceOf[msg.sender] = totalSupply; name =; symbol = ; }",1
0x449c640b6c7fce4f8ad2e3dcd900d13be40174af.sol,StandardToken,"contract StandardToken is ERC20, ERC223, Ownable { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function StandardToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x54e041006817d582232e921dfda32dd79a34a767.sol,Alice,"contract Alice { enum DealState { Uninitialized, Initialized, PaymentSentToBob, PaymentSentToAlice }",1
0x1ca0a2632519021798cb0e0a073371c8ddfcdde5.sol,DukeOfEther,contract DukeOfEther is Ownable { address m_addrShareHolder = 0; uint m_deployedAtBlock = 0; uint m_nOwnersMoney = 0; uint m_nNewCountryPrice = 1 ether; uint m_nMinDukePrice = 1 finney; uint m_nDeterioration = 3; uint m_nDaysBeforeDeteriorationStarts = 60; uint m_NextDukePaymentIncrease = 150; uint m_nNumberOfActiveCountries = 0; struct Country { bool m_bIsDestroyed; string m_strNickName; uint m_nLastDukeRiseDate; address m_addrCurrentDuke; uint m_nCurrentDukePaid; string m_strCountry; },1
0x38897c62a4ddcd66a77bfc94e0f93fd4525b7d84.sol,IFcoin,contract IFcoin { uint private constant _totalSupply = 2500000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function IFcoin() { balances[msg.sender] = _totalSupply; },1
0xf296fbc18ebce3eeb1026abbb4c9ee406f7c4467.sol,PowerOfCommunity,contract PowerOfCommunity { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc4e56f0553872dbdb0a639ec512baa085689ce69.sol,ERC20,"contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; string private _name = ; string private _symbol = ; uint8 private _decimals = 18; uint256 private _totalSupply; constructor () public { _mint(msg.sender, 80000000000 ether); }",1
0xeed2b7756e295a9300e53dd049aeb0751899bae3.sol,DOGToken,contract DOGToken is StandardToken { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; uint256 public totalSupply; uint256 public maxSupply; function DOGToken(uint256 _maxSupply){ maxSupply = _maxSupply.mul(10**decimals); },1
0x334425ef9a828e31ff27e0754a3198edb714c57b.sol,Genesis,"contract Genesis is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint public decimals; uint private _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 20000000000000000; balances[0xcd6EDD53E16454eab857391eaB31a8731516253D] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x1dbe49b5020b97de4823012320ee6b80c9328bbb.sol,TokenLiquidityMarket,contract TokenLiquidityMarket { using SafeMath for uint256; address public platform; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xc0d72d45cca854e0f2fe3cd2d4bab91e772fe4c0.sol,Pixereum,contract Pixereum { struct Pixel { address owner; string message; uint256 price; bool isSale; },1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,SignatoryPausable,"contract SignatoryPausable is SignatoryOwnable { bool public paused; address public pauseProposer; function SignatoryPausable(address signatory0, address signatory1, address signatory2) SignatoryOwnable(signatory0, signatory1, signatory2) internal {}",1
0xd0020a0f0fb926910aa26c4bee922ab961c5393f.sol,Random,"contract Random { uint256 _seed; function maxRandom() public returns (uint256 randomNumber) { _seed = uint256(keccak256( _seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty )); return _seed; }",1
0x7697c5015c195ff2ff55576ab96360e298bfba1f.sol,EtheremonMonsterToken,"contract EtheremonMonsterTokenBasic is ERC721, SupportsInterface, BasicAccessControl { using SafeMath for uint256; using AddressUtils for address; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0x52a6ade96e2571aef35215997a8516e52f9016ab.sol,DSMath,"contract DSMath { function add(uint256 x, uint256 y) pure internal returns (uint256 z) { assert((z = x + y) >= x); }",1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,Haltable,contract Haltable is Ownable { bool public halted; modifier stopInEmergency { require(!halted); _; },1
0x54ad74edeab48e09ccc43ee324f2603071dad72b.sol,DTOPToken,"contract DTOPToken is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0xdca82e4dfbce4442b19a85df47fd64aeaaf55d9f.sol,RouletteRules,contract RouletteRules { uint8[5809] payoutTable; address developer; constructor() public { developer = msg.sender; },1
0x925ab290d36cbd9761535faa95a623612721ff17.sol,BitLoanex,"contract BitLoanex is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public rate; uint256 public constant CAP = 126000; uint256 public constant START = 1514160000; uint256 public DAYS = 30; uint256 public days_interval = 4; uint[9] public deadlines = [START, START.add(1* days_interval * 1 days), START.add(2* days_interval * 1 days), START.add(3* days_interval * 1 days), START.add(4* days_interval * 1 days), START.add(5* days_interval * 1 days), START.add(6* days_interval * 1 days), START.add(7* days_interval * 1 days), START.add(8* days_interval * 1 days) ]; uint[9] public rates = [2000 ,1900, 1800, 1700, 1600, 1500, 1400, 1300, 1200]; bool public initialized = true; uint256 public raisedAmount = 0; uint256 public constant INITIAL_SUPPLY = 10000000000000000; uint256 public totalSupply; address[] public investors; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event BoughtTokens(address indexed to, uint256 value); function BitLoanex() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x2f5e078353e781ef9a9b17c2e8e30d3652d6cb83.sol,GoldenUnitToken,"contract GoldenUnitToken is StandardToken { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 100000 * 1 ether; address public CrowdsaleAddress; event Mint(address indexed to, uint256 amount); constructor(address _CrowdsaleAddress) public { CrowdsaleAddress = _CrowdsaleAddress; totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundableCrowdsale,contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal = 5000 ether; RefundVault public vault; function RefundableCrowdsale(address _escrow) { vault = new RefundVault(_escrow); },1
0xaa6da59f02ac6335ff0dbb896323181a8431a675.sol,BizCoin,"contract BizCoin is owned, TokenERC20 { uint256 public sendOnRequest = 10000 * (10 ** uint256(decimals)); mapping (address => bool) public hasRequested; function BizCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xede8792712d075abf085b49ebb4d80a0d2ed888d.sol,Crowdsale,"contract Crowdsale is Injii, Pausable { using SafeMath for uint256; uint256 public startBlock; uint256 public constant durationCrowdSale = 25 days; uint256 public constant gapInPrimaryCrowdsaleAndSecondaryCrowdsale = 2 years; uint256 public endBlock; uint256 public constant maxCapCompanyInventory = 250e6; uint256 public constant maxCap = 500e6; uint256 public constant maxCapEcosystem = 250e6; uint256 public constant numberOfTokensToAvail50PercentDiscount = 2e6; uint256 public constant numberOfTokensToAvail25percentDiscount = 5e5; uint256 public constant minimumNumberOfTokens = 2500; uint256 public targetToAchieve; bool public inventoryLocked = false; uint256 public totalSupply; uint256 public totalSupplyForCrowdsaleAndMint = 0; address public coinbase; uint256 public ETHReceived; uint256 public totalSupplyFromInventory; uint256 public totalRemainInInventory; uint256 public getPrice; uint256 public crowdsaleStatus; uint8 public crowdSaleType; event ReceivedETH(address addr, uint value); event MintAndTransferIAC(address addr, uint value, bytes32 comment); event SuccessfullyTransferedFromCompanyInventory(address addr, uint value, bytes32 comment); event TokenSupplied(address indexed beneficiary, uint256 indexed tokens, uint256 value); event StateChanged(bool changed); Metadata private objMetada; Ecosystem private objEcosystem; CompanyInventory private objCompanyInventory; address private ecosystemContractAddress; uint256 constant ecosystemContractID = 1; uint256 constant private crowdsaleContractID = 2; uint256 constant private inventoryContractID = 3; function Crowdsale() public { address _metadataContractAddr = 0x8A8473E51D7f562ea773A019d7351A96c419B633; startBlock = 0; endBlock = 0; crowdSaleType = 1; totalSupply = maxCapEcosystem; crowdsaleStatus=0; coinbase = 0xA84196972d6b5796cE523f861CC9E367F739421F; owner = msg.sender; totalSupplyFromInventory=0; totalRemainInInventory = maxCapCompanyInventory; getPrice = 2778; objMetada = Metadata(_metadataContractAddr); ecosystemContractAddress = objMetada.getAddress(ecosystemContractID); assert(ecosystemContractAddress != address(0)); objEcosystem = Ecosystem(ecosystemContractAddress); objMetada.addAddress(crowdsaleContractID, this); balances[ecosystemContractAddress] = maxCapEcosystem; targetToAchieve = (50000*100e18)/(12*getPrice); }",1
0x25a06d4e1f804ce62cf11b091180a5c84980d93a.sol,Treasure,contract Treasure { modifier onlybelievers () { require(myTokens() > 0); _; },1
0x6e8b54e99807e53b271dc02e02cc32f143ca108a.sol,ETHOS,contract ETHOS is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 2200000000 * 10**8; function name() public constant returns (string) { return ; },1
0xc45865b235a7c6693b9db5fed46ea8a3022d9b07.sol,DcorpCrowdsaleProxy,"contract DcorpCrowdsaleProxy is IDcorpCrowdsaleProxy, Ownership, TokenObserver, TokenRetriever { enum Stages { Deploying, Attached, Deployed }",1
0x52fb36c83ad33c1824912fc81071ca5eeb8ab390.sol,FideliumToken,"contract FideliumToken is owned, TOKENERC20 { event ApprovedFunds(address target, bool approved); function FideliumToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) TOKENERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x9224016462b204c57eb70e1d69652f60bcaf53a8.sol,SetStepFunctionWrapper,"contract SetStepFunctionWrapper is Withdrawable { SetStepFunctionInterface public rateContract; function SetStepFunctionWrapper(address admin, address operator) public { addOperator(operator); transferAdminQuickly(admin); }",1
0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127.sol,Etherama,contract EtheramaCommon { mapping(address => bool) private _administrators; mapping(address => bool) private _managers; modifier onlyAdministrator() { require(_administrators[msg.sender]); _; },1
0x77b3106417d4cf3138882cc21d4710c71183b707.sol,Brave3d,contract Brave3d { struct Stage { uint8 cnt; uint256 blocknumber; bool isFinish; uint8 deadIndex; mapping(uint8 => address) playerMap; },1
0x1b8a506a1fc508f840a05ff0a4c665a4579c4e75.sol,SelfllerySaleFoundation,"contract SelfllerySaleFoundation is Ownable { using SafeMath for uint; mapping (address => uint) public paidEther; mapping (address => uint) public preSaleParticipantTokens; mapping (address => uint) public sentTokens; address public selflleryManagerWallet; ERC20 public token; uint public tokenCents; uint public tokenPriceWei; uint public saleTokensCents; uint public currentCapTokens; uint public currentCapEther; uint public startDate; uint public bonusEndDate; uint public endDate; uint public hardCapTokens; uint public minimumPurchaseAmount; uint8 public bonusPercent; event PreSalePurchase(address indexed purchasedBy, uint amountTokens); event Purchase(address indexed purchasedBy, uint amountTokens, uint etherWei); modifier onlyDuringICODates() { require(now >= startDate && now <= endDate); _; }",1
0xed2f35867a1afc19eeff7f0fbd7cd30c0c8c288a.sol,AcceptsEtheropoly,contract AcceptsEtheropoly { Etheropoly public tokenContract; function AcceptsEtheropoly(address _tokenContract) public { tokenContract = Etheropoly(_tokenContract); },1
0x05bc1d3454405d4767960efeb3cec216a0dd15f3.sol,POCN,contract POCN { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xdbe16aa3c77ff1bc391f2b311152b86610de1494.sol,IDCToken,"contract IDCToken is PausableToken, MintableToken, BurnableToken { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public weiRaised; uint256 public tokenSelled; address public creator; address public wallet; mapping(address => address) whiteList; mapping(address => uint256) tokensBuyed; uint256 public capPerAddress; event SellTokens(address indexed recipient, uint sellTokens, uint payEther, uint ratio); function IDCToken ( string _tokenName, string _tokenSymbol, uint256 _tokenDecimals, uint256 _startTime, uint256 _endTime, uint256 _totalSupply, uint256 _rate, uint256 _capPerAddress, address _wallet ) public { require(_endTime >= _startTime); require(_startTime >= now); require(_totalSupply > 0); require(_capPerAddress > 0); require(_wallet != address(0)); name = _tokenName; symbol = _tokenSymbol; decimals = _tokenDecimals; startTime = _startTime; endTime = _endTime; totalSupply = _totalSupply; rate = _rate; capPerAddress = _capPerAddress; wallet = _wallet; balances[msg.sender] = totalSupply; creator = msg.sender; }",1
0x012fd5049a203df08c02fb2e0ed15ceed10d9ed4.sol,_0xLitecoinToken,"contract _0xLitecoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xLitecoinToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 84000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0xf04436b2edaa1b777045e1eefc6dba8bd2aebab8.sol,TokenSale,contract TokenSaleConfig { uint public constant EXA = 10 ** 18; uint256 public constant PUBLIC_START_TIME = 1515542400; uint256 public constant END_TIME = 1518220800; uint256 public constant CONTRIBUTION_MIN = 0.1 ether; uint256 public constant CONTRIBUTION_MAX = 2500.0 ether; uint256 public constant COMPANY_ALLOCATION = 40 * 10 ** 6 * EXA; Tranche[4] public tranches; struct Tranche { uint untilToken; uint tokensPerEther; },1
0xceb43cc2625db7eb86c3a3a69a97d3da1931a9a3.sol,ChainStarBase,"contract ChainStarBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ChainStarBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x6ded330704d6b4734de6dc82b609765006dde197.sol,CryptoStrippers,contract CryptoStrippers{ uint256 public COINS_TO_HATCH_1STRIPPERS = 86400; uint256 public STARTING_STRIPPERS = 500; uint256 PSN = 10000; uint256 PSNH = 5000; bool public initialized = true; address public ceoAddress; mapping (address => uint256) public hatcheryStrippers; mapping (address => uint256) public claimedCoins; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketCoins; function CryptoStrippers() public{ ceoAddress = msg.sender; },1
0xd7e16112f5f9cfa0527ca355c9219f7056d8c2a9.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; address public multisig; address public tokenHolder; ERC20 public token; uint256 rate; uint256 rateInUsd; uint256 priceETH; uint256 startIco; uint256 periodIco; uint256 periodPreIco; uint256 indCap; mapping (address => uint256) tokens; address[] addresses; uint256 index; event Purchased(address _buyer, uint256 _amount); constructor(address _AS, address _multisig, address _tokenHolder, uint256 _priceETH, uint256 _startIcoUNIX, uint256 _periodPreIcoSEC, uint256 _periodIcoSEC) public { require(_AS != 0 && _priceETH != 0); token = ERC20(_AS); multisig = _multisig; tokenHolder = _tokenHolder; startIco = _startIcoUNIX; periodPreIco = _periodPreIcoSEC; periodIco = _periodIcoSEC; rateInUsd = 10; setRate(_priceETH); }",1
0x4c517cfda3b326317120865a9d70d17554748f6f.sol,LOTS,"contract LOTS is EIP20Interface { using SafeMath for uint; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; uint public constant finalSupply = 10**9 * 10**uint(decimals); uint public totalSupply; uint public constant fundraisingReservation = 50 * finalSupply / 100; uint public constant foundationReservation = 5 * finalSupply / 100; uint public constant communityReservation = 25 * finalSupply / 100; uint public constant teamReservation = 20 * finalSupply / 100; uint public nextWithdrawDayFoundation; uint public nextWithdrawDayCommunity; uint public nextWithdrawDayTeam; uint public withdrawedFundrasingPart; uint public withdrawedFoundationCounter; uint public withdrawedCoummunityCounter; uint public withdrawedTeamCounter; address public manager; bool public paused; event Burn(address _from, uint _value); modifier onlyManager() { require(msg.sender == manager); _; }",1
0x652729577d5c5a13060f81c256aa79adb264f188.sol,VNETTokenPreSale,"contract VNETTokenPreSale is Ownable { using SafeMath for uint256; string public description = ; ERC20Basic public vnetToken; address wallet; uint256 public ratioNext; uint256 public ethPrice; uint256 public vnetSold; uint256 public vnetSupply = 30 * (10 ** 8) * (10 ** 6); uint256 public vnetPriceStart = 0.0026 * (10 ** 8); uint256 public vnetPriceTarget = 0.0065 * (10 ** 8); uint256 public weiMinimum = 1 * (10 ** 18); uint256 public weiMaximum = 100 * (10 ** 18); uint256 public weiWelfare = 10 * (10 ** 18); mapping(address => bool) public welfare; event Welfare(address indexed _buyer); event BuyVNET(address indexed _buyer, uint256 _ratio, uint256 _vnetAmount, uint256 _weiAmount); event EthPrice(uint256 _ethPrice); constructor(ERC20Basic _vnetToken, uint256 _ethPrice) public { vnetToken = _vnetToken; wallet = owner; calcRatioNext(); updateEthPrice(_ethPrice); }",1
0xef56166bfc23489b224a1c6b330b3bbd94e3af0c.sol,BLTCoin,"contract BLTCoin is ERC20Interface, Owned{ using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; uint256 public rate; uint256 public weiRaised; uint value; uint _ICOTokensLimit; uint _ownerTokensLimit; uint public bonusPercentage; bool public icoOpen; bool public bonusCompaignOpen; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyWhileOpen { require(icoOpen); _; }",1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x27887a512107d43b4ebbf66df1c29bac7eba1f1a.sol,CryptopusToken,"contract CryptopusToken is ERC20Interface, Owned { using SafeMath for uint; address public preSaleContract; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public saleLimit; uint public alreadySold; uint public firstWavePrice; uint public secondWavePrice; uint public thirdWavePrice; bool public saleOngoing; mapping(address => uint8) approved; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptopusToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); saleLimit = 40000000 * 10**uint(decimals); alreadySold = 0; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); firstWavePrice = 0.0008 ether; secondWavePrice = 0.0009 ether; thirdWavePrice = 0.001 ether; saleOngoing = false; }",1
0x012910aa43d4be652a67935db4cc4db4b14593f5.sol,AllyICO,"contract AllyICO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; address _tokenContract = 0x03e2cE0C0B99998e6906B90Ab6F9eac0deFAFf16; AltcoinToken cddtoken = AltcoinToken(_tokenContract); string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 12000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 20000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x708373572be20a1c4891083097d68a58970f6ec9.sol,LikaCrowdsale,"contract LikaCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0xde3ad37d806309761210c18704dc1a3faada4aa9.sol,DUBAI_Portfolio_Ib_883,"contract DUBAI_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 728002043355369000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd9fa8ca8e4c9d8089861640f384b42f66db4cc15.sol,Ethery,"contract Ethery is Pausable, ReentrancyGuard{ event NewBet(uint id, address player, uint wager, uint targetBlock); event BetResolved(uint id, BetStatus status); bytes32 constant byteMask = bytes32(0xF); enum BetStatus { Pending, PlayerWon, HouseWon, Refunded }",1
0x33ea26661f42aa6cdbdb63cad1677976bd502876.sol,DeeptonCoin,"contract DeeptonCoin is ERC20, Ownable, Pausable { uint128 internal MONTH = 30 * 24 * 3600; using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; }",1
0x4ef6ea200f5b5fe49421c03cb7690abedca5d685.sol,TimedCrowdsale,contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; },1
0x53fbaa187ed9eb5c67eb7b2e99674101ebcdd873.sol,ElementiumVesting,contract ElementiumVesting { using SafeMath for uint256; struct StagedLockingPlan { address beneficiary; uint256 managedAmount; uint256 start; uint256 stages; uint256 durationPerStage; uint256 releaseRatio; uint256 currentyStage; uint256 released; },1
0x6b766ec6540ceba812d036f79b39a016010c4e6a.sol,CubegoBrick,"contract CubegoBrick is IERC20, BasicAccessControl { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; mapping (address => mapping (address => uint256)) private _allowed; uint public mId = 5; CubegoCoreInterface public cubegoCore; function setConfig(address _cubegoCoreAddress, uint _mId) onlyModerators external { cubegoCore = CubegoCoreInterface(_cubegoCoreAddress); mId = _mId; }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,KydyBase,"contract KydyBase is KydyAccessControl, ERC721Basic { using SafeMath for uint256; using Address for address; event Created(address indexed owner, uint256 kydyId, uint256 yinId, uint256 yangId, uint256 genes); struct Kydy { uint256 genes; uint64 createdTime; uint64 rechargeEndBlock; uint32 yinId; uint32 yangId; uint32 synthesizingWithId; uint16 rechargeIndex; uint16 generation; }",1
0xf438e3a0c1bb9dc0ef6da672c97a282236d3f233.sol,HyperToken,"contract HyperToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HyperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x106B0Ab1922d0a8a44454d743A68EF936cc2F563] = _totalSupply; Transfer(address(0), 0x106B0Ab1922d0a8a44454d743A68EF936cc2F563, _totalSupply); }",1
0x284da39fec424ad0e1dc5a004b881de309c24a32.sol,Ownable,"contract Ownable { address internal _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function owner() public view returns (address) { return _owner; }",1
0x39ffccecc551f35f8dfcb52c8c01060919aed1ea.sol,FoMo3DUnlimited,"contract FoMo3DUnlimited is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x137679d52dfa0d8191600046afc29634e349182d); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 72 hours; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 999 years; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(20,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(52,0); fees_[3] = F3Ddatasets.TeamFee(43,0); potSplit_[0] = F3Ddatasets.PotSplit(30,0); potSplit_[1] = F3Ddatasets.PotSplit(20,0); potSplit_[2] = F3Ddatasets.PotSplit(10,0); potSplit_[3] = F3Ddatasets.PotSplit(20,0); }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,MerchantDealsHistory,"contract MerchantDealsHistory is Contactable, Restricted { string constant VERSION = ; bytes32 public merchantIdHash; event DealCompleted( uint orderId, address clientAddress, uint32 clientReputation, uint32 merchantReputation, bool successful, uint dealHash ); event DealCancelationReason( uint orderId, address clientAddress, uint32 clientReputation, uint32 merchantReputation, uint dealHash, string cancelReason ); event DealRefundReason( uint orderId, address clientAddress, uint32 clientReputation, uint32 merchantReputation, uint dealHash, string refundReason ); function MerchantDealsHistory(string _merchantId) public { require(bytes(_merchantId).length > 0); merchantIdHash = keccak256(_merchantId); }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xd95176d52ad16315390baf5b555a678ff4e3057c.sol,HikenCoin,"contract HikenCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HikenCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 2100000000000000000000000000; balances[0xF2b8c9e1C2553a577A1746164ae97DC3E0CFa0B4] = _totalSupply; emit Transfer(address(0), 0xF2b8c9e1C2553a577A1746164ae97DC3E0CFa0B4, _totalSupply); }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0xef58491224958d978facf55d2120c55a24516b98.sol,SecurityTokenRegistry,"contract SecurityTokenRegistry is ISecurityTokenRegistry, Util, Pausable, RegistryUpdater, ReclaimTokens { uint256 public registrationFee; event LogChangePolyRegisterationFee(uint256 _oldFee, uint256 _newFee); event LogNewSecurityToken(string _ticker, address indexed _securityTokenAddress, address indexed _owner); event LogAddCustomSecurityToken(string _name, string _symbol, address _securityToken, uint256 _addedAt); constructor ( address _polymathRegistry, address _stVersionProxy, uint256 _registrationFee ) public RegistryUpdater(_polymathRegistry) { registrationFee = _registrationFee; setProtocolVersion(_stVersionProxy, ); }",1
0xc0360a3507655e619cdf7e6ca616d9ddec4dec95.sol,Tge,"contract Tge is WhiteListToken { address public teamTokensWallet; address public bountyTokensWallet; address public reservedTokensWallet; uint public teamTokensPercent; uint public bountyTokensPercent; uint public reservedTokensPercent; uint public lockPeriod; uint public totalTokenSupply; event TgeFinalized(address indexed finalizer, uint256 saleEnded); function setLockPeriod(uint newLockPeriod) public onlyOwner { lockPeriod = newLockPeriod; }",1
0x9224ca23168a20bc1b5e2a1627edf783e193d39c.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x2c3b9d47f9a80507e93c9401eb22e111672604a3.sol,JCoinz,contract JCoinz is IERC20 { uint public constant _totalSupply = 1000000000000000000000000000000000; string public constant symbol =; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function JCoinz() { balances[msg.sender] = _totalSupply; },1
0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d.sol,TextMessage,"contract TextMessage is owned { uint cost; bool public enabled; event UpdateCost(uint newCost); event UpdateEnabled(string newStatus); event NewText(string number, string message); function TextMessage() { cost = 380000000000000; enabled = true; }",1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,ERC20Proxy,"contract ERC20Proxy is ERC20Interface, ERC20ImplUpgradeable { string public name; string public symbol; uint8 public decimals; function ERC20Proxy( string _name, string _symbol, uint8 _decimals, address _custodian ) ERC20ImplUpgradeable(_custodian) public { name = _name; symbol = _symbol; decimals = _decimals; }",1
0xd9894dd6e8d4f823bd8bcd1e8a871a295b1cfb07.sol,WorldCup2018,"contract WorldCup2018 is Base, AccessControl { using SafeMath for uint256; event WithdrawPayments(address indexed _player, uint256 _value); mapping(address => uint256) private payments; uint256 private totalPayments; function getTotalPayments() public view returns(uint retTotalPayments) { return totalPayments; }",1
0xefbb3f1058fd8e0c9d7204f532e17d7572affc3e.sol,MBCash,"contract MBCash { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public MBCashSupply = 21000000; uint256 public buyPrice = 55000; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function MBCash() public { totalSupply = MBCashSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x55d5a9ab9a97509ba0db01b8d5040567b14d2304.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,TMTGBaseToken,"contract TMTGBaseToken is StandardToken, TMTGPausable, TMTGBlacklist, HasNoEther { uint256 public openingTime; struct investor { uint256 _sentAmount; uint256 _initialAmount; uint256 _limit; }",1
0xa5d98b2f45fb388e37a61cece5b9b111a0ab2c30.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x318bf186c7681ed7efd57839e6415cd8a162713c.sol,MainCard,contract MainCard is BasicAuth { struct Card { uint32 m_Index; uint32 m_Duration; uint8 m_Level; uint16 m_DP; uint16 m_DPK; uint16 m_SP; uint16 m_IP; uint32[] m_Parts; },1
0x028ff933bd86bd4d699b1643477f858626482d35.sol,LUCKER,contract LUCKER is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; uint256 opentime=now+3600; uint256 opensome; uint256 _opensome; uint256 BEBMAX; uint256 BEBtime; uint256 Numberofairdrops; address ownersto; struct luckuser{ uint256 _time; uint256 _eth; uint256 _beb; uint256 _bz; uint256 _romd; uint256 Bond; uint256 sumeth; uint256 sumbeb; },1
0x29536b7ca7029b5cddeb03c0451715615aca35ba.sol,NewOSToken,contract NewOSToken is ToutiaoERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 10000000000e8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { assert (msg.sender == owner); _; },1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x69005b3573915bc6f45d070a191541b08822c73b.sol,SmartHashFast,"contract SmartHashFast { using SafeMath for uint256; uint256 constant public DEPOSIT_MINIMUM_AMOUNT = 100 finney; uint256 constant public MAXIMUM_DEPOSITS_PER_USER = 50; uint256 constant public MINIMUM_DAILY_PERCENT = 50; uint256 constant public REFERRAL_PERCENT = 50; uint256 constant public MARKETING_PERCENT = 100; uint256 constant public BonusContract_PERCENT = 50; uint256 constant public MAXIMUM_RETURN_PERCENT = 2000; uint256 constant public PERCENTS_DIVIDER = 1000; uint256 constant public BALANCE_STEP = 300 ether; uint256 constant public TIME_STEP = 1 days; uint256 constant public STEP_MULTIPLIER = 10; address constant public MARKETING_ADDRESS = 0xa5a3A84Cf9FD3f9dE1A6160C7242bA97b4b64065; address constant public bonus_ADDRESS = 0xe4661f1D737993824Ef3da64166525ffc3702487; uint256 public usersCount = 0; uint256 public depositsCount = 0; uint256 public totalDeposited = 0; uint256 public totalWithdrawn = 0; event Invest( address indexed investor, uint256 amount); struct User { uint256 deposited; uint256 withdrawn; uint256 timestamp; uint256 depositsCount; uint256[] deposits; }",1
0x1cfa0b95c531bc2c88a81a4263f6a6f5c1613b96.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xb49b4d400d66aaa53ec07184a8c7c6c9c23374c9.sol,GenjiCoin,"contract GenjiCoin is owned,IERC20{ using SafeMath for uint256; uint256 public constant _totalSupply = 999999999000000000000000000; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) public balances; mapping (address => mapping (address => uint256)) allowed; constructor() public { balances[msg.sender] = _totalSupply; }",1
0x3670a029a6ce9be3bd62c76853e747e65ddf6431.sol,NTA3D,"contract NTA3DEvents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 timeStamp ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onBuyKey ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 roundID, uint256 ethIn, uint256 keys, uint256 timeStamp ); event onBuyCard ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 cardID, uint256 ethIn, uint256 timeStamp ); event onRoundEnd ( address winnerAddr, bytes32 winnerName, uint256 roundID, uint256 amountWon, uint256 newPot, uint256 timeStamp ); event onDrop ( address dropwinner, bytes32 winnerName, uint256 roundID, uint256 droptype, uint256 win, uint256 timeStamp ); }",1
0x1dd72a0d3357901d51e791ba65476e101cb2c6a5.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { totalSupply = initialSupply * 10 ** uint256(decimalUnits); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x37ac9987c288835a96d0fc58245ed3ae1e9e1950.sol,EcomethToken,"contract EcomethToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 5000000e8; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x35ced9349943292f8a3b2e0a96fec76d7877ac4e.sol,BancorKillerContract,"contract BancorKillerContract { using SafeMath for uint256; address public admin; address public base_token; address public traded_token; uint256 public base_token_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; bool public base_token_is_seeded; bool public traded_token_is_seeded; mapping (address => uint256) public token_balance; constructor(address _base_token, address _traded_token,uint256 _base_token_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = tx.origin; base_token = _base_token; traded_token = _traded_token; base_token_seed_amount = _base_token_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; }",1
0x3670a029a6ce9be3bd62c76853e747e65ddf6431.sol,NTA3D,"contract NTA3DEvents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 timeStamp ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onBuyKey ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 roundID, uint256 ethIn, uint256 keys, uint256 timeStamp ); event onBuyCard ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, uint256 cardID, uint256 ethIn, uint256 timeStamp ); event onRoundEnd ( address winnerAddr, bytes32 winnerName, uint256 roundID, uint256 amountWon, uint256 newPot, uint256 timeStamp ); event onDrop ( address dropwinner, bytes32 winnerName, uint256 roundID, uint256 droptype, uint256 win, uint256 timeStamp ); }",1
0xdac15794f0fadfdcf3a93aeaabdc7cac19066724.sol,GreenX,"contract GreenX is Owner { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 constant public totalSupply = 375000000 * 10 ** 18; mapping(address => uint256) internal balances; mapping(address => mapping (address => uint256)) internal allowed; address public portalAddress; address public adminAddress; address public walletAddress; address public founderAddress; address public teamAddress; mapping(address => bool) public privateList; mapping(address => bool) public whiteList; mapping(address => uint256) public totalInvestedAmountOf; uint constant lockPeriod1 = 180 days; uint constant lockPeriod2 = 1 years; uint constant lockPeriod3 = 2 years; uint constant NOT_SALE = 0; uint constant IN_PRIVATE_SALE = 1; uint constant IN_PRESALE = 2; uint constant END_PRESALE = 3; uint constant IN_1ST_ICO = 4; uint constant IN_2ND_ICO = 5; uint constant IN_3RD_ICO = 6; uint constant END_SALE = 7; uint256 public constant salesAllocation = 187500000 * 10 ** 18; uint256 public constant bonusAllocation = 37500000 * 10 ** 18; uint256 public constant reservedAllocation = 90000000 * 10 ** 18; uint256 public constant founderAllocation = 37500000 * 10 ** 18; uint256 public constant teamAllocation = 22500000 * 10 ** 18; uint256 public constant minInvestedCap = 2500 * 10 ** 18; uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; uint saleState; uint256 totalInvestedAmount; uint public icoStartTime; uint public icoEndTime; bool public inActive; bool public isSelling; bool public isTransferable; uint public founderAllocatedTime = 1; uint public teamAllocatedTime = 1; uint256 public privateSalePrice; uint256 public preSalePrice; uint256 public icoStandardPrice; uint256 public ico1stPrice; uint256 public ico2ndPrice; uint256 public totalRemainingTokensForSales; uint256 public totalReservedAndBonusTokenAllocation; uint256 public totalLoadedRefund; uint256 public totalRefundedAmount; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event ModifyWhiteList(address investorAddress, bool isWhiteListed); event ModifyPrivateList(address investorAddress, bool isPrivateListed); event StartPrivateSales(uint state); event StartPresales(uint state); event EndPresales(uint state); event StartICO(uint state); event EndICO(uint state); event SetPrivateSalePrice(uint256 price); event SetPreSalePrice(uint256 price); event SetICOPrice(uint256 price); event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); event RevokeTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint256 txFee); event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); event Refund(address investorAddress, uint256 etherRefundedAmount, uint256 tokensRevokedAmount); modifier isActive() { require(inActive == false); _; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); }",1
0x316ee6b10479576e908e5272458c789c3f4d2a47.sol,DuanZiToken,contract DuanZiToken is ERC223 { using SafeMath for uint256; using SafeMath for uint; address public owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => uint) public increase; mapping (address => uint256) public unlockUnixTime; uint public maxIncrease=20; address public target; string internal name_= ; string internal symbol_ = ; uint8 internal decimals_= 18; uint256 internal totalSupply_= 2000000000e18; uint256 public toGiveBase = 5000e18; uint256 public increaseBase = 500e18; uint256 public OfficalHold = totalSupply_.mul(18).div(100); uint256 public totalRemaining = totalSupply_; uint256 public totalDistributed = 0; bool public canTransfer = true; uint256 public etherGetBase=5000000; bool public distributionFinished = false; bool public finishFreeGetToken = false; bool public finishEthGetToken = false; modifier canDistr() { require(!distributionFinished); _; },1
0x3813a81a0a116a086799d37b66c0fd9925cb98c6.sol,WTF,"contract WTF is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed = 100000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4042ff0b0ff691a1549d67ede0479a1f0d12f6ba.sol,Cosby,contract Cosby { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6e59116f211369823e4d8f86d816d0d58e3d9f48.sol,MinterStorePoolCrowdsale,contract MinterStorePoolCrowdsale is Ownable { using SafeMath for uint; address public multisigWallet; uint public startRound; uint public periodRound; uint public altCapitalization; uint public totalCapitalization; MinterStorePool public token = new MinterStorePool (); function MinterStorePoolCrowdsale () public { multisigWallet = 0xdee04DfdC6C93D51468ba5cd90457Ac0B88055FD; startRound = 1534118340; periodRound = 80; altCapitalization = 0; totalCapitalization = 2000 ether; },1
0x5b6acebad8f9e969d54bbe7c6efdc8674f8c7e76.sol,SafeMath,"contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0x25e41ae4b247baaae702cdc909d50fd14b2db7ea.sol,EthFlip,contract EthFlip is usingOraclize { struct Bet { bool win; uint betValue; uint timestamp; address playerAddress; uint randomNumber; },1
0x5290b7afccdd9d43e391f2d428d65a4de464f079.sol,CryptoWar,contract CryptoWar { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0xd4ca5c2aff1eefb0bea9e9eab16f88db2990c183.sol,XrpClassic,"contract XrpClassic is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 constant public decimals =8; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; constructor() public { name = ; symbol = ; initialSupply = 645354324324; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }",1
0x33125e6c9784d5ec23710fa78512b20ba1466860.sol,TESTToken,"contract TESTToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 10000000000000000000000000000; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 10000000000000000000000000; uint256 public constant minContribution = 1 ether / 100; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xedfd2e59cd5e5a683d14fc5cbd939a3602203e2f.sol,F3DGoQuick,"contract F3DGoQuick is F3Devents{ using SafeMath for uint256; using NameFilter for string; using F3DKeysCalcFast for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = ; string constant public symbol = ; uint256 private rndGap_ = 60 seconds; uint256 constant private rndInit_ = 5 minutes; uint256 constant private rndInc_ = 5 minutes; uint256 constant private rndMax_ = 5 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x4d73a6a5698990a01b6e526b73fceb0efbbfd159.sol,FAFA,"contract FAFA is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function FAFA(address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpImageStorage,contract BdpImageStorage is BdpBase { using SafeMath for uint256; struct Image { address owner; uint256 regionId; uint256 currentRegionId; mapping(uint16 => uint256[1000]) data; mapping(uint16 => uint16) dataLength; uint16 partsCount; uint16 width; uint16 height; uint16 imageDescriptor; uint256 blurredAt; },1
0x712f0350df4f56fad07bd5e2c74941cc30c5df88.sol,DTCC_ILOW_3,contract DTCC_ILOW_3 { address owner ; function DTCC_ILOW_2 () public { owner = msg.sender; },1
0x20ae0ca9d42e6ffeb1188f341a7d63450452def6.sol,Cipher,contract Cipher is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 1080000000000000000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender != owner); { },1
0x33ddc60a8f2ca78dfe0d10acbe6a1bcb6dc282e1.sol,RipplePro,"contract RipplePro { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function RipplePro( ) public { totalSupply = 18000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x324d65aa829a9b976fe661b03a7d4cd0d66ff843.sol,BCE,"contract BCE { using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public supplyLeftAtOrigin = 21000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public constant RATE = 500; function BCE( address sendTo, uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = sendTo; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdda9bcd985b1169607546b52910a0269dff5baf1.sol,Goo,contract Goo is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalGooProduction; address public owner; bool public gameStarted; uint256 public totalEtherGooResearchPool; uint256[] public totalGooProductionSnapshots; uint256[] public allocatedGooResearchSnapshots; uint256 public nextSnapshotTime; uint256 private MAX_PRODUCTION_UNITS = 999; uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000; mapping(address => uint256) private ethBalance; mapping(address => uint256) private gooBalance; mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; mapping(address => uint256) private lastGooSaveTime; mapping(address => uint256) public lastGooProductionUpdate; mapping(address => uint256) private lastGooResearchFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(uint256 => uint256)) private unitsOwned; mapping(address => mapping(uint256 => bool)) private upgradesOwned; mapping(uint256 => address) private rareItemOwner; mapping(uint256 => uint256) private rareItemPrice; mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; mapping(address => mapping(uint256 => uint256)) private unitAttackIncreases; mapping(address => mapping(uint256 => uint256)) private unitAttackMultiplier; mapping(address => mapping(uint256 => uint256)) private unitDefenseIncreases; mapping(address => mapping(uint256 => uint256)) private unitDefenseMultiplier; mapping(address => mapping(uint256 => uint256)) private unitGooStealingIncreases; mapping(address => mapping(uint256 => uint256)) private unitGooStealingMultiplier; mapping(address => mapping(address => uint256)) private allowed; mapping(address => bool) private protectedAddresses; struct TicketPurchases { TicketPurchase[] ticketsBought; uint256 numPurchases; uint256 raffleRareId; },1
0x7865956684839906f0432a4fc47516f00ab5f58c.sol,CustomToken,"contract CustomToken is BaseToken, BurnToken { constructor() public { balanceOf[0x348D6E3320F0Bd8D7281A6aa3545C51F852a2892] = totalSupply; emit Transfer(address(0), 0x348D6E3320F0Bd8D7281A6aa3545C51F852a2892, totalSupply); }",1
0x2b6cb3e260fedcaa522f5b6d3c02b8716345d26d.sol,tokenDemo,"contract tokenDemo is owned{ string public name; string public symbol; uint8 public decimals=18; uint public totalSupply; uint public sellPrice=0.01 ether; uint public buyPrice=0.01 ether; mapping(address => uint) public balanceOf; mapping(address => bool) public frozenAccount; function tokenDemo( uint initialSupply, string _name, string _symbol, address centralMinter ) payable { if(centralMinter !=0){ owner=centralMinter; }",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionToken,contract OptionToken is StandardToken { using SafeMath for uint256; OptionFactory public factory; ERC20 public firstToken; ERC20 public secondToken; uint public minIssueAmount; uint public expiry; uint public strikePrice; bool public isCall; string public symbol; uint public decimals; struct Issuer { address addr; uint amount; },1
0xeaf503fd64d0cf9278f29775b78c6f31001ffebc.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
