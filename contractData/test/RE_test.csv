file,contract,code,label
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x6dbc5978711cb22d7ba611bc18cec308ea12ea95.sol,PublicResolver,"contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant NAME_INTERFACE_ID = 0x691f3431; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c; bytes4 constant MULTIADDR_INTERFACE_ID = 0x4cb7724c; event AddrChanged(bytes32 indexed node, address a); event NameChanged(bytes32 indexed node, string name); event ABIChanged(bytes32 indexed node, uint256 indexed contentType); event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); event TextChanged(bytes32 indexed node, string indexedKey, string key); event MultiaddrChanged(bytes32 indexed node, bytes addr); struct PublicKey { bytes32 x; bytes32 y; }",1
0x730f8c40a08d02349a2d64e3193cf207a2a2dfe7.sol,PG_Bank,"contract PG_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x541ac3dbde0712b1a121bdd5e8c506ae594a4631.sol,XPTToken,contract XPTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XPTToken () { owner = msg.sender; },1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; function DSProxy(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x6a3f85f8a86e7b3de0269c20e9ab066dd57b8e21.sol,AccRegCenter,contract AccRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0x47fb9b34d4eca0ca1d25cafcb4924d8fc94e8170.sol,FlexibleTokenSale,"contract FlexibleTokenSale is Owned { using SafeMath for uint256; bool public suspended; uint256 public tokenPrice; uint256 public tokenPerEther; uint256 public contributionMin; uint256 public tokenConversionFactor; address public walletAddress; TokenTransfer token; uint256 public totalTokensSold; uint256 public totalEtherCollected; address public priceUpdateAddress; event Initialized(); event TokenPriceUpdated(uint256 _newValue); event TokenPerEtherUpdated(uint256 _newValue); event TokenMinUpdated(uint256 _newValue); event WalletAddressUpdated(address indexed _newAddress); event SaleSuspended(); event SaleResumed(); event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens); event TokensReclaimed(uint256 _amount); event PriceAddressUpdated(address indexed _newAddress); function FlexibleTokenSale(address _tokenAddress,address _walletAddress,uint _tokenPerEther,address _priceUpdateAddress) public Owned() { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(address(token) == address(0)); require(address(_tokenAddress) != address(0)); require(address(_tokenAddress) != address(this)); require(address(_tokenAddress) != address(walletAddress)); walletAddress = _walletAddress; priceUpdateAddress = _priceUpdateAddress; token = TokenTransfer(_tokenAddress); suspended = false; tokenPrice = 100; tokenPerEther = _tokenPerEther; contributionMin = 5 * 10**18; totalTokensSold = 0; totalEtherCollected = 0; tokenConversionFactor = 10**(uint256(18).sub(token.decimals()).add(2)); assert(tokenConversionFactor > 0); }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0000009a317684a5f840484357fa587aca76454c.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); }",1
0x0000009a317684a5f840484357fa587aca76454c.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); }",1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onClaimTokens (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); event onReceiveAirdrop(uint256 amount, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0xf0ef703a04cf96212031b51d373e8469687f308e.sol,ESCToken,contract ESCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ESCToken () { owner = msg.sender; },1
0x0356e14c2f8de339131c668c1747def594467a9a.sol,Club1VIT,"contract Club1VIT is Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public initialSupply = 1; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to); function totalSupply() public view returns (uint256) { return initialSupply; }",1
0xed3762edcc5820a5587105d7b9f574c711c4a700.sol,FoMo3Dshort,"contract FoMo3Dshort is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 public rndExtra_ = 30 minutes; uint256 public rndGap_ = 1 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 5 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x292d448b46f5419387e3886e89680ed4b7d62d09.sol,RegistrationBonus,"contract RegistrationBonus is Ownable { address public tokenAddr; uint256 constant bonusAmount = 1 * 1 ether; mapping (address => uint) public beneficiaryAddresses; mapping (uint => address) public beneficiaryUserIds; AbstractMintableToken token; event BonusEnrolled(address beneficiary, uint userId, uint256 amount); function RegistrationBonus(address _token){ tokenAddr = _token; token = AbstractMintableToken(tokenAddr); }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x6d4106c5c6cddeb5e0bbda23c4555a45dfaa92d7.sol,CucuSale,"contract CucuSale { address public beneficiary; uint public amountRaised; uint public price; uint public dynamicLocktime; uint public globalLocktime; uint public lockType = 0; token public tokenReward; uint public exchangeRate; mapping(address => uint256) public balanceOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public timelocksOf; address[] public founders; address public owner; event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution); event IsCharged(bool isCharged); event TokensClaimed(address founder, uint tokens); event TransferOwnership(); event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate); event NewGlobalLocktime(uint timelockUntil); event NewDynamicLocktime(uint timelockUntil); uint public tokenAvailable = 0; bool public charged = false; uint lastActionId = 0; constructor( address _beneficiary, address _addressOfTokenUsedAsReward, uint _globalLocktime, uint _dynamicLocktime, uint _exchangeRate ) public { beneficiary = _beneficiary; dynamicLocktime = _dynamicLocktime; tokenReward = token(_addressOfTokenUsedAsReward); globalLocktime = now + _globalLocktime * 1 minutes; exchangeRate = _exchangeRate; owner = msg.sender; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0x2682e3ad5358932ac5cd8f8616912cec76ad680c.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0x2e59c87e9349242063793761780550374a3146cf.sol,THORToken,contract THORToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function THORToken () { owner = msg.sender; },1
0x6f9e77dc013e6a7156a5aeb26fb095f3405fd911.sol,FlexibleTokenSale,"contract FlexibleTokenSale is Owned { using SafeMath for uint256; bool public suspended; uint256 public tokenPrice; uint256 public tokenPerEther; uint256 public contributionMin; uint256 public tokenConversionFactor; address public walletAddress; TokenTransfer token; uint256 public totalTokensSold; uint256 public totalEtherCollected; address public priceUpdateAddress; event Initialized(); event TokenPriceUpdated(uint256 _newValue); event TokenPerEtherUpdated(uint256 _newValue); event TokenMinUpdated(uint256 _newValue); event WalletAddressUpdated(address indexed _newAddress); event SaleSuspended(); event SaleResumed(); event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens); event TokensReclaimed(uint256 _amount); event PriceAddressUpdated(address indexed _newAddress); function FlexibleTokenSale(address _tokenAddress,address _walletAddress,uint _tokenPerEther,address _priceUpdateAddress) public Owned() { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(address(token) == address(0)); require(address(_tokenAddress) != address(0)); require(address(_tokenAddress) != address(this)); require(address(_tokenAddress) != address(walletAddress)); walletAddress = _walletAddress; priceUpdateAddress = _priceUpdateAddress; token = TokenTransfer(_tokenAddress); suspended = false; tokenPrice = 100; tokenPerEther = _tokenPerEther; contributionMin = 5 * 10**18; totalTokensSold = 0; totalEtherCollected = 0; tokenConversionFactor = 10**(uint256(18).sub(token.decimals()).add(2)); assert(tokenConversionFactor > 0); }",1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x20c476bb4c7aa64f919278fb9c09e880583beb4c.sol,X3ProfitMainFundTransfer,contract X3ProfitMainFundTransfer { uint public constant maxBalance = 340282366920938463463374607431768211456 wei; address public constant ADDRESS_EIFP2_CONTRACT = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3; address public constant ADDRESS_ADMIN = 0x6249046Af9FB588bb4E70e62d9403DD69239bdF5; bool private isResend = false; function () external payable { if(msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 0.1 ether && !isResend)){ if(ADDRESS_EIFP2_CONTRACT.balance > maxBalance) { ADDRESS_ADMIN.transfer(address(this).balance); return; },1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,Deco,contract Deco is ERC20ERC223 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 6*10**26; mapping(address => Account) private accounts; struct Account { uint256 balance; mapping(address => uint256) allowed; mapping(address => bool) isAllowanceAuthorized; },1
0x89234fab776fb68ec3c33529aa66f09b69a7b5f0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1.sol,CashPokerProPreICO,"contract CashPokerProPreICO is Ownable, Pausable { using SafeMath for uint; address public tokenWallet; uint public tokensSold; uint public weiRaised; uint public investorCount; Token public token; uint constant minInvest = 0.01 ether; uint constant tokensLimit = 10000000 * 1 ether; uint256 public startTime = 1503770400; uint256 public endTime = 1504893600; uint price = 0.00017 * 1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function CashPokerProPreICO() { tokenWallet = msg.sender; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0xd0080a841a8c5d2b6cd4bc640cdad7846de14dbf.sol,FtvTimelockFactory,"contract FtvTimelockFactory is BasicToken { ERC20 public token; address public tokenAssignmentControl; constructor (ERC20 _token, address _tokenAssignmentControl) { token = _token; tokenAssignmentControl = _tokenAssignmentControl; }",1
0xf08a7fd4f4b75188e89d0d27c2ae474858402cea.sol,DroneShowCoinICOContract,"contract DroneShowCoinICOContract is Ownable { using SafeMath for uint256; Token token; uint256 public constant RATE = 650; uint256 public constant CAP = 15000; uint256 public constant START = 1510754400; uint256 public constant DAYS = 30; bool public initialized = false; uint256 public raisedAmount = 0; uint256 public bonusesGiven = 0; uint256 public numberOfTransactions = 0; event BoughtTokens(address indexed to, uint256 value); modifier whenSaleIsActive() { assert (isActive()); _; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,SafeGuardsToken,contract SafeGuardsToken is CappedToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; address public canBurnAddress; mapping (address => bool) public frozenList; uint256 public frozenPauseTime = now + 180 days; uint256 public burnPausedTime = now + 180 days; constructor(address _canBurnAddress) CappedToken(61 * 1e6 * 1e18) public { require(_canBurnAddress != 0x0); canBurnAddress = _canBurnAddress; },1
0x430e87a95a421437ccaa0af644ac57e22914b07a.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0x5c28d0683be8143e5ecdd5fd0b39d702d98b1bb9.sol,TemplateCrowdsale,"contract TemplateCrowdsale is Consts, MainCrowdsale , BonusableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(9000 * TOKEN_DECIMAL_MULTIPLIER, 0xFB262Fe4620e7027424488F6C471b13DE7662A95, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1568917800) CappedCrowdsale(111111111111111111111111) { }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x0da76de0916ef2da3c58a97e4d09d501c56a9f15.sol,Piggy_Bank,"contract Piggy_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x5b3c6ac07f3729534b7483d31e48f15e6ce7c6e9.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint256 public constant rate = 17000; uint256 public constant cap = 80000000 ether / rate; bool public isFinalized = false; uint256 public endTime = 1522540800; ALT1Token public token; address public wallet; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function Crowdsale (ALT1Token _ALT1, address _wallet) public { assert(address(_ALT1) != address(0)); assert(_wallet != address(0)); assert(endTime > now); assert(rate > 0); assert(cap > 0); token = _ALT1; wallet = _wallet; }",1
0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x58bd394f3dfd9bbc15f4bc662b2def3e597e4e90.sol,AceTokenDistribution,"contract AceTokenDistribution is Ownable { using SafeMath for uint256; StarTokenInterface public token; event DistributionMint(address indexed to, uint256 amount); event ExtraMint(); function AceTokenDistribution (address _tokenAddress) { require(_tokenAddress != 0); token = StarTokenInterface(_tokenAddress); }",1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x475a8101fdde7f7246e31be77dd7dcb80f25d735.sol,Exchange,contract Exchange { struct Order { address creator; address token; bool buy; uint price; uint amount; },1
0x00f634a0bb03416816f8829928ef7d776f798414.sol,KiOS,"contract KiOS { address public admin; mapping(address => uint) public rates; event Purchase(address indexed payer, address indexed token, uint price, uint amount); event Received(address indexed sender, address indexed token, uint amount); event Sent(address indexed recipient, address indexed token, uint amount); constructor() public { admin = msg.sender; }",1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,SaleClockAuction,contract SaleClockAuction is ClockAuction { function SaleClockAuction(uint256 _cut) public ClockAuction(_cut) {},1
0x25d3b337e17ad34dbc8cb97d1a724545d90478fa.sol,AirdropiRide,contract AirdropiRide { Token public tokenReward; address public creator; address public owner = 0xd430B6C9706345760D94c4A8A14Cfa0164B04167; uint256 public startDate; uint256 public amount; modifier isCreator() { require(msg.sender == creator); _; },1
0x5165db3dffd92454c2d59faa8e2d907e54f174d3.sol,ViewlyBountyRewards,"contract ViewlyBountyRewards is DSAuth, DSMath { uint constant public MAX_TOKEN_REWARDS = 3000000 ether; DSToken public viewToken; uint public totalTokenRewards; mapping (address => uint) public tokenRewards; event LogTokenReward( address recipient, uint tokens ); function ViewlyBountyRewards(DSToken viewToken_) { viewToken = viewToken_; }",1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x485b224c97ad56dc5b145eafdee71a7b5163f735.sol,PonziBet,contract PonziBet { using SafeMath for uint; EthPyramid public pyramid; address public admin; address public contractAddress; uint public minBet; uint public roundTime; uint public startPrice; uint public endPrice; uint[] public upBetRecords; uint[] public downBetRecords; mapping (address => uint) lastBet; mapping (address => bool) userBet; mapping (bool => uint) totalBalance; mapping (address => uint) feeBalance; mapping (address => mapping (bool => uint)) userBalances; function PonziBet() public { admin = msg.sender; },1
0xb4007597da3402a1e2b69c8e1c6dd753d01a8035.sol,FundingVault,contract FundingVault { bool public _initialized = false; address public vaultOwner ; address public outputAddress; address public managerAddress; bool public allFundingProcessed = false; bool public DirectFundingProcessed = false; ABIFunding FundingEntity; ABIFundingManager FundingManagerEntity; ABIMilestones MilestonesEntity; ABIProposals ProposalsEntity; ABITokenSCADAVariable TokenSCADAEntity; ABIToken TokenEntity ; uint256 public amount_direct = 0; uint256 public amount_milestone = 0; bool public emergencyFundReleased = false; uint8 emergencyFundPercentage = 0; uint256 BylawsCashBackOwnerMiaDuration; uint256 BylawsCashBackVoteRejectedDuration; uint256 BylawsProposalVotingDuration; struct PurchaseStruct { uint256 unix_time; uint8 payment_method; uint256 amount; uint8 funding_stage; uint16 index; },1
0xebf0027ef3b4b7a742a148cddb0f2b14e5d8f0e9.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xc4ab0f59c4d8bb15e237906a06a736d965a2c390.sol,AirdropLibraToken,"contract AirdropLibraToken is Ownable { using SafeMath for uint256; uint256 decimal = 10**uint256(18); uint256 distributedTotal = 0; uint256 airdropStartTime; uint256 airdropEndTime; LibraToken private token; mapping (address => bool) public airdropAdmins; mapping(address => uint256) public airdropDoneAmountMap; address[] public airdropDoneList; event Airdrop(address _receiver, uint256 amount); event AddAdmin(address _admin); event RemoveAdmin(address _admin); event UpdateEndTime(address _operator, uint256 _oldTime, uint256 _newTime); modifier onlyOwnerOrAdmin() { require(msg.sender == owner || airdropAdmins[msg.sender]); _; }",1
0x000000c96e715a5b8cd3beaea66bdb749225fa2f.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); }",1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,BonusFinalizeAgent,"contract BonusFinalizeAgent is FinalizeAgent, SafeMathLib { CrowdsaleToken public token; Crowdsale public crowdsale; uint256 public allocatedTokens; uint256 tokenCap; address walletAddress; function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public { token = _token; crowdsale = _crowdsale; require(address(crowdsale) != 0); tokenCap = _tokenCap; walletAddress = _walletAddress; }",1
0x57ae3a491f4555e1eed37338d1b8b5222935f28a.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 1000; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0xeee7c7e228eafb0f8945c5dbaa8ea4f6ee12b36d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1818; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5d467Dfc5e3FcA3ea4bd6C312275ca930d2f3E19; addressOfTokenUsedAsReward = 0xB6eC8C3a347f66a3d7C4F39D6DD68A422E69E81d ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x4802fe0bf7eb3b3b0dce3ede89c575341f10e3e0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllCrowdsale,"contract ClinicAllCrowdsale is Crowdsale, FinalizableCrowdsale, MintedCrowdsale, ManagedWhitelist, Limited { constructor ( uint256 _tokenLimitSupply, uint256 _rate, address _wallet, address _privateSaleWallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _discountTokenAmount, uint256 _discountTokenPercent, uint256 _preSaleClosingTime, uint256 _softCapLimit, ClinicAllRefundEscrow _vault, uint256 _buyLimitSupplyMin, uint256 _buyLimitSupplyMax, uint256 _kycLimitEliminator ) Crowdsale(_rate, _wallet, _token) TimedCrowdsale(_openingTime, _closingTime) public { privateSaleWallet = _privateSaleWallet; tokenSupplyLimit = _tokenLimitSupply; discountTokenAmount = _discountTokenAmount; discountTokenPercent = _discountTokenPercent; preSaleClosingTime = _preSaleClosingTime; softCapLimit = _softCapLimit; vault = _vault; buyLimitSupplyMin = _buyLimitSupplyMin; buyLimitSupplyMax = _buyLimitSupplyMax; kycLimitEliminator = _kycLimitEliminator; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,TokenVault,"contract TokenVault is Ownable { address owner; event TokenTransfer(address indexed to, address token, uint amount); function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) { uint amount = balanceOfToken(token); if (amount > 0) { TokenTransfer(to, token, amount); return Token(token).transfer(to, amount); }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Arbitration,contract Arbitration is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x359a46571d4bc22a6a9310038b51e2d91163412f.sol,TokenSale,"contract TokenSale is Pausable { using SafeMath for uint256; ServusTokenInterface public servusToken; uint256 public totalWeiRaised; uint256 public tokensMinted; uint256 public totalSupply; uint256 public contributors; uint256 public decimalsMultiplier; uint256 public startTime; uint256 public endTime; uint256 public remainingTokens; uint256 public allocatedTokens; bool public finalized; bool public servusTokensAllocated; address public servusMultiSig = 0x0cc3e09c8a52fa0313154321be706635cdbdec37; uint256 public constant BASE_PRICE_IN_WEI = 1000000000000000; uint256 public constant PUBLIC_TOKENS = 100000000 * (10 ** 6); uint256 public constant TOTAL_PRESALE_TOKENS = 50000000 * (10 ** 6); uint256 public constant TOKENS_ALLOCATED_TO_SERVUS = 100000000 * (10 ** 6); uint256 public tokenCap = PUBLIC_TOKENS - TOTAL_PRESALE_TOKENS; uint256 public cap = tokenCap; uint256 public weiCap = cap * BASE_PRICE_IN_WEI; uint256 public firstDiscountPrice = (BASE_PRICE_IN_WEI * 85) / 100; uint256 public secondDiscountPrice = (BASE_PRICE_IN_WEI * 90) / 100; uint256 public thirdDiscountPrice = (BASE_PRICE_IN_WEI * 95) / 100; uint256 public firstDiscountCap = (weiCap * 5) / 100; uint256 public secondDiscountCap = (weiCap * 10) / 100; uint256 public thirdDiscountCap = (weiCap * 20) / 100; bool public started = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event NewClonedToken(address indexed _cloneToken); event OnTransfer(address _from, address _to, uint _amount); event OnApprove(address _owner, address _spender, uint _amount); event LogInt(string _name, uint256 _value); event Finalized(); function TokenSale(address _tokenAddress, uint256 _startTime, uint256 _endTime) public { require(_tokenAddress != 0x0); require(_startTime > 0); require(_endTime > _startTime); startTime = _startTime; endTime = _endTime; servusToken = ServusTokenInterface(_tokenAddress); decimalsMultiplier = (10 ** 6); }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x1a661224edc279a3844ecd8bd0cd715daafb9cf7.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27820800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x7eB71add7482F3462BAA46328f58a235E33dbD0e; }",1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x4b958074cee6546e29cdb3c43494e7425b85f59c.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x78a06472d78bfef33270654319b6373d51cf0575.sol,EasyMineTokenWallet,contract EasyMineTokenWallet { uint256 constant public VESTING_PERIOD = 180 days; uint256 constant public DAILY_FUNDS_RELEASE = 15000 * 10**18; address public owner; address public withdrawalAddress; Token public easyMineToken; uint256 public startTime; uint256 public totalWithdrawn; modifier isOwner() { require(msg.sender == owner); _; },1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x70cdbd16575651e3b78fa869a51eb8e991e079bb.sol,PRVTSToken,contract PRVTSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 555000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRVTSToken () { owner = msg.sender; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyPilot,"contract HorseyPilot { using SafeMath for uint256; event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8.sol,DisbursementHandler,contract DisbursementHandler is Ownable { struct Disbursement { uint256 timestamp; uint256 tokens; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,FourCrowdsale,"contract FourCrowdsale is TokenCappedCrowdsale, WhitelistCrowdsale, FinalizableCrowdsale { event RateChanged(uint256 newRate, string name); uint256 private constant E18 = 10**18; uint256 private TOKEN_SALE_CAP = 152000000 * E18; uint256 public constant TEAM_TOKENS = 50000000 * E18; address public constant TEAM_ADDRESS = 0x3EC2fC20c04656F4B0AA7372258A36FAfB1EF427; uint256 public constant ADVISORS_AND_CONTRIBUTORS_TOKENS = 39000000 * E18; address public constant ADVISORS_AND_CONTRIBUTORS_ADDRESS = 0x90adab6891514DC24411B9Adf2e11C0eD7739999; address public constant UNSOLD_ADDRESS = 0x4eC155995211C8639375Ae3106187bff3FF5DB46; uint256 public bonus; function FourCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _bonus, address _wallet, address _token) TokenCappedCrowdsale(TOKEN_SALE_CAP) Crowdsale(_startTime, _endTime, _rate, _wallet, _token) public { bonus = _bonus; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSStop,"contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7.sol,WFCToken,"contract WFCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x1dd6363c7f7a3150fb7ab13c29fe92f5bab23457.sol,CharityProject,"contract CharityProject is RBACManager { using SafeMath for uint256; modifier canWithdraw() { require( canWithdrawBeforeEnd || closingTime == 0 || block.timestamp > closingTime, ); _; }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; function DSProxy(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xcef8feebbdc278c0c81e07b87abf96b22d08fa6e.sol,UnicornRefunds,"contract UnicornRefunds { using SafeMath for uint; address public cardboardUnicornTokenAddress; address public unicornRanchAddress; address public owner = msg.sender; uint public pricePerUnicorn = 1 finney; uint public rewardUnicornAmount = 100; mapping(address => uint) allowedAmounts; mapping(address => bool) rewardClaimed; event RewardClaimed(address indexed _who, uint _bookingIndex); event UnicornsSold(address indexed _who, uint _unicornCount, uint _unicornCost, uint _paymentTotal); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x58c3069023ed736f430d585003715058c2e3c671.sol,BTCPayment,"contract BTCPaymentI is Ownable, PresaleFallbackReceiver { PaymentFallbackReceiver public presale; PaymentFallbackReceiver public mainsale; function addPayment(address _beneficiary, uint256 _tokens) public; function setPresale(address _presale) external; function setMainsale(address _mainsale) external; function presaleFallBack(uint256) public returns (bool); }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x486cf19a550e2814aef970b14e509e93209a0151.sol,EventChainCrowdsale,"contract EventChainCrowdsale is Haltable { using SafeMath for uint256; enum State{Preparing, Prepared, Presale, Phase1, Phase2, Closed}",1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 2000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { wallet = 0x9F1D5D27c7FD3EaB394b65B6c06e4Ef22F333210; addressOfTokenUsedAsReward = 0x4bF62424385ddcD858535cAa1878e512314a9Aeb; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0x6faff25ef78e39c518687b0dd19113f9b29ac562.sol,ETHedgeToken,contract ETHedgeToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,Deco,contract Deco is ERC20ERC223 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 6*10**26; mapping(address => Account) private accounts; struct Account { uint256 balance; mapping(address => uint256) allowed; mapping(address => bool) isAllowanceAuthorized; },1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x84f7c44b6fed1080f647e354d552595be2cc602f.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1.sol,CashPokerProPreICO,"contract CashPokerProPreICO is Ownable, Pausable { using SafeMath for uint; address public tokenWallet; uint public tokensSold; uint public weiRaised; uint public investorCount; Token public token; uint constant minInvest = 0.01 ether; uint constant tokensLimit = 10000000 * 1 ether; uint256 public startTime = 1503770400; uint256 public endTime = 1504893600; uint price = 0.00017 * 1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function CashPokerProPreICO() { tokenWallet = msg.sender; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; function DSProxy(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0xa227d444a52fd21c3a848c7650bc2cd5832f6487.sol,KTFForTestMigration,"contract KTFForTestMigration is PartialERC20, Ownable { string public name; string public symbol; uint32 public decimals; PrivateToken public pktf; uint32 public holderCount; constructor(PrivateToken _pktf) public { symbol = ; name = ; decimals = 18; _totalSupply = 0; _balances[msg.sender] = _totalSupply; pktf = _pktf; }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x4720f2468eeb7a795945c5ffbc3b0178e32250e0.sol,ExternalContracts,contract ExternalContracts is Ownable { MixGenInterface public geneScience; RewardContract public reward; address public storeAddress; function setMixGenAddress(address _address) external onlyOwner { MixGenInterface candidateContract = MixGenInterface(_address); require(candidateContract.isMixGen()); geneScience = candidateContract; },1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xc0eb85285d83217cd7c891702bcbc0fc401e2d9d.sol,HVNToken,"contract HVNToken is ERC20Interface, SafeMath, Owned { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; string public version = ; bool public transfersFrozen = false; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; }",1
0x2775f2a3c83bee1541d1d1bc308b3bb432b45151.sol,PLANETAGROToken,contract PLANETAGROToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 20000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PLANETAGROToken () { owner = msg.sender; },1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x40818f0d14325a9eba6b2a7d60bd61cb9e27ef0c.sol,Trade,"contract Trade is Registry { using SafeMath for uint; using SafeMath for uint256; event KyberTrade( address src, uint srcAmt, address dest, uint destAmt, address beneficiary, uint minConversionRate, address affiliate ); function executeTrade( address src, address dest, uint srcAmt, uint minConversionRate ) public payable returns (uint destAmt) { address protocolAdmin = getAddress(); uint ethQty; IERC20 tokenFunctions = IERC20(src); if (src == getAddress()) { require(msg.value == srcAmt, ); ethQty = srcAmt; }",1
0x0f5d6ae470d3b93eb3347212d480bf9b3acfe4f9.sol,LYFToken,contract LYFToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 120000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LYFToken () { owner = msg.sender; },1
0x91db07e4401c2559c7eb8290a77a0feef50843fd.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 3000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5daaAb630673a61f487965f90E13457a74F566D3; addressOfTokenUsedAsReward = 0x8aB10a31c97Af458Db24038Ed8b498590cf64d74; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xecfe4b7afc47260cb590d3043d3f790a61bb7910.sol,EbyteDistribution,"contract EbyteDistribution { mapping (address => uint256) balances; mapping (address => bool) public blacklist; Token public ebyteToken; address public owner; uint256 public rate = 100000000; uint256 public percentage = 20; uint256 public ethBalance = 10000000000; uint256 public ebyteBalance = 100; bool public contractLocked = true; event sendTokens(address indexed to, uint256 value); event Locked(); event Unlocked(); function EbyteDistribution(address _tokenAddress, address _owner) { ebyteToken = Token(_tokenAddress); owner = _owner; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x44f958d420f0543353a5e4f14e827d73f01b4261.sol,EBBToken,"contract EBBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 5963; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Crowdsale,"contract Crowdsale is Lockable, Operable, Withdrawal, PriceStrategy, LockableCrowdsale, WhitelistedCrowdsale, PausableCrowdsale { using SafeMath for uint256; constructor(uint256 _rateETHtoCHF, uint256 _minInvestmentInCHF, address _withdrawWallet, CosquareToken _token) PriceStrategy(_rateETHtoCHF, _minInvestmentInCHF) Withdrawal(_withdrawWallet) BaseCrowdsale(_token) public { }",1
0x3a773baa30d09f04da0bd869b142ea5503a31022.sol,MiniMeTokenSimple,"contract MiniMeTokenSimple is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; address public parentToken; uint public parentSnapShotBlock; uint public creationBlock; address public tokenFactory; function MiniMeTokenSimple( address _tokenFactory, address _parentToken, uint _parentSnapShotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) { tokenFactory = _tokenFactory; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; parentToken = _parentToken; parentSnapShotBlock = _parentSnapShotBlock; transfersEnabled = _transfersEnabled; creationBlock = block.number; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x1dd6363c7f7a3150fb7ab13c29fe92f5bab23457.sol,CharityProject,"contract CharityProject is RBACManager { using SafeMath for uint256; modifier canWithdraw() { require( canWithdrawBeforeEnd || closingTime == 0 || block.timestamp > closingTime, ); _; }",1
0x589fbf3d4168518b8b849b7eedfdb719407900ca.sol,AirDropLight,contract AirDropLight is OwnableWithAdmin { using SafeMath for uint256; uint256 public grandTotalClaimed = 0; ERC20 public token; uint256 maxDirect = 10000 * (10**uint256(18)); mapping(address => bool) public recipients; address[] public addresses; constructor(ERC20 _token) public { require(_token != address(0)); token = _token; },1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,SmartContractBank,contract SmartContractBank { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 paymentTime; uint256 withdrawals; bool increasedPercent; bool insured; },1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x02242d41c54f261a85ac8e8efa7046a3dfd53113.sol,C_banK,"contract C_banK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint manusSent; }",1
0x0f5ee401de162cd163b6ff46318eef2727dbb9fc.sol,MOIRAICO,"contract MOIRAICO { enum State { Preico, Ico, Successful }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x40818f0d14325a9eba6b2a7d60bd61cb9e27ef0c.sol,Trade,"contract Trade is Registry { using SafeMath for uint; using SafeMath for uint256; event KyberTrade( address src, uint srcAmt, address dest, uint destAmt, address beneficiary, uint minConversionRate, address affiliate ); function executeTrade( address src, address dest, uint srcAmt, uint minConversionRate ) public payable returns (uint destAmt) { address protocolAdmin = getAddress(); uint ethQty; IERC20 tokenFunctions = IERC20(src); if (src == getAddress()) { require(msg.value == srcAmt, ); ethQty = srcAmt; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x430e87a95a421437ccaa0af644ac57e22914b07a.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x400784d4d1fe603b2e7a96416fa9a1afadf47009.sol,UncTokenSale,"contract UncTokenSale is SafeMath, Pausable { address public beneficiary; UncToken public token; uint public hardCap; uint public highBonusRate = 115; uint public lowBonusRate = 110; uint public constant highBonus = 160000000000000000000; uint public constant minContribution = 4000000000000000000; uint public constant preMaxContribution = 200000000000000000000; uint public constant mainMaxContribution = 200000000000000000000; mapping(address => bool) public isVerifier; mapping(address => bool) public kycVerified; uint public preSaleTime; uint public mainSaleTime; uint public endSaleTime; uint public amountRaised; bool public beforeSale = true; bool public preSale = false; bool public mainSale = false; bool public saleEnded = false; bool public hardCapReached = false; mapping(address => address) public timeLocks; uint public rate = 45000; uint public constant lowRate = 10000; uint public constant highRate = 1000000; mapping(address => uint256) public contributionAmtOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public teamTokenBalanceOf; event HardReached(address _beneficiary, uint _amountRaised); event BalanceTransfer(address _to, uint _amount); event AddedOffChain(address indexed _beneficiary, uint256 tokensAllocated); event RateChanged(uint newRate); event VerifiedKYC(address indexed person); modifier beforeEnd() { require (now < endSaleTime); _; }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d.sol,CB_BANK,"contract CB_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0x8ad0a831b7a17b322e8aebd188a4a8eb3bfdb5e8.sol,CPVToken,contract CPVToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,CreditGAME,"contract CreditGAME is Owned, SafeMath, LinkedList{ mapping(address => bool) approvedGames; mapping(address => GameLock) gameLocks; mapping(address => bool) public isGameLocked; mapping(uint => address) public concludedGames; uint public amountLocked = 0; uint public concludedGameIndex = 0; struct GameLock{ uint amount; uint lockDuration; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x91ca47b9ec3187c77f324281a1851f4b991103f1.sol,FundingInputGeneral,"contract FundingInputGeneral { bool public initialized = false; uint8 public typeId = 0; address public FundingAssetAddress; address public deployer; event EventInputPaymentReceived(address sender, uint amount, uint8 _type); function FundingInputGeneral() public { deployer = msg.sender; }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,EthergotchiOwnershipV2,"contract EthergotchiOwnershipV2 is Controllable, ERC721, ERC721Enumerable, ERC721Metadata { mapping(uint256 => address) private ownerByTokenId; mapping(address => uint256[]) private tokenIdsByOwner; mapping(uint256 => uint256) private ownerTokenIndexByTokenId; mapping(uint256 => address) private approvedTransfers; mapping(address => mapping(address => bool)) private operators; uint256 private totalTokens; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4( keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4( keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4( keccak256() ); event Transfer( address indexed _from, address indexed _to, uint256 _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); modifier onlyValidToken(uint256 _tokenId) { require(ownerByTokenId[_tokenId] != address(0)); _; }",1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x7976af0ae2124a0771d5287aa16017b3f9dd43a4.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; bool transferable; modifier isTransferable() { require(transferable || msg.sender == owner); _; },1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0x54923b4f2e4433294c70559cc94d1812793f0451.sol,Future1Exchange,contract Future1Exchange { address public archon; mapping (address => mapping(address => uint256)) public _token; constructor() public { archon = msg.sender; },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,ElepigCrowdsale,"contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess { using SafeMath for uint256; enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 }",1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0xeee7c7e228eafb0f8945c5dbaa8ea4f6ee12b36d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1818; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5d467Dfc5e3FcA3ea4bd6C312275ca930d2f3E19; addressOfTokenUsedAsReward = 0xB6eC8C3a347f66a3d7C4F39D6DD68A422E69E81d ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xc0952584ddd2735a237f844dab59bde737e7fe14.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29980800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x51Ed81Fb25511a370207ca17f3D6Dbc7A1cFD43f; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0xcef8feebbdc278c0c81e07b87abf96b22d08fa6e.sol,UnicornRefunds,"contract UnicornRefunds { using SafeMath for uint; address public cardboardUnicornTokenAddress; address public unicornRanchAddress; address public owner = msg.sender; uint public pricePerUnicorn = 1 finney; uint public rewardUnicornAmount = 100; mapping(address => uint) allowedAmounts; mapping(address => bool) rewardClaimed; event RewardClaimed(address indexed _who, uint _bookingIndex); event UnicornsSold(address indexed _who, uint _unicornCount, uint _unicornCost, uint _paymentTotal); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x0317ada015cf35244b9f9c7d1f8f05c3651833ff.sol,TokenAbout,"contract TokenAbout is Controlled { event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); function isContract(address _addr) constant internal returns (bool) { if (_addr == 0) { return false; }",1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,PresaleMarket,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0xc739ae9ba934f937636a2ebaaf1ecdf04e11ef2f.sol,NXTGToken,contract NXTGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 7000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xc4ab0f59c4d8bb15e237906a06a736d965a2c390.sol,AirdropLibraToken,"contract AirdropLibraToken is Ownable { using SafeMath for uint256; uint256 decimal = 10**uint256(18); uint256 distributedTotal = 0; uint256 airdropStartTime; uint256 airdropEndTime; LibraToken private token; mapping (address => bool) public airdropAdmins; mapping(address => uint256) public airdropDoneAmountMap; address[] public airdropDoneList; event Airdrop(address _receiver, uint256 amount); event AddAdmin(address _admin); event RemoveAdmin(address _admin); event UpdateEndTime(address _operator, uint256 _oldTime, uint256 _newTime); modifier onlyOwnerOrAdmin() { require(msg.sender == owner || airdropAdmins[msg.sender]); _; }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x53c347888c54519820249ee629b30316f3b79974.sol,UCToken,contract UCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 70000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UCToken () { owner = msg.sender; },1
0x6e82aabffe24f275ad3f703aca922dd4d8f86168.sol,BatchTransfer,"contract BatchTransfer is Ownable { using SafeMath for uint256; event Withdraw(address indexed receiver, address indexed token, uint amount); event TransferEther(address indexed sender, address indexed receiver, uint256 amount); modifier checkArrayArgument(address[] _receivers, uint256[] _amounts) { require(_receivers.length == _amounts.length && _receivers.length != 0); _; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,JackpotHolding,"contract JackpotHolding is ERC223Receiving { uint public payOutNumber = 0; uint public payOutDivisor = 2; ZethrBankrollControllerInterface controller; Zethr zethr; constructor (address _controllerAddress, address _zethrAddress) public { controller = ZethrBankrollControllerInterface(_controllerAddress); zethr = Zethr(_zethrAddress); }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,HavvenEscrow,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,AgiCrowdsale,"contract AgiCrowdsale is Ownable, ReentrancyGuard { using SafeMath for uint256; uint256 public firstDayCap; uint256 public cap; uint256 public goal; uint256 public rate; uint256 public constant WEI_TO_COGS = 10**uint256(10); address public wallet; RefundVault public vault; SingularityNetToken public token; uint256 public startTime; uint256 public endTime; uint256 public firstDay; bool public isFinalized = false; uint256 public weiRaised; mapping(address => bool) public whitelist; mapping(address => uint256) public contribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenRelease(address indexed beneficiary, uint256 amount); event TokenRefund(address indexed refundee, uint256 amount); event Finalized(); function AgiCrowdsale( address _token, address _wallet, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _firstDayCap, uint256 _goal ) { require(_startTime >= getBlockTimestamp()); require(_endTime >= _startTime); require(_rate > 0); require(_goal > 0); require(_cap > 0); require(_wallet != 0x0); vault = new RefundVault(_wallet); token = SingularityNetToken(_token); wallet = _wallet; startTime = _startTime; endTime = _endTime; firstDay = startTime + 1 * 1 days; firstDayCap = _firstDayCap; rate = _rate; goal = _goal; cap = _cap; }",1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimHandler,contract MonethaUsersClaimHandler is Contactable { string constant VERSION = ; MonethaUsersClaimStorage public storageContract; event StorageContractOwnerChanged(address indexed _newOwner); constructor(address _storageAddr) public { storageContract = MonethaUsersClaimStorage(_storageAddr); },1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,EthereumLegitAirDrop,"contract EthereumLegitAirDrop is Ownable { uint public numDrops; uint public dropAmount; token myToken; function EthereumLegitAirDrop(address dropper, address tokenContractAddress) { myToken = token(tokenContractAddress); transferOwnership(dropper); }",1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,BonusFinalizeAgent,"contract BonusFinalizeAgent is FinalizeAgent, SafeMathLib { CrowdsaleToken public token; Crowdsale public crowdsale; uint256 public allocatedTokens; uint256 tokenCap; address walletAddress; function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public { token = _token; crowdsale = _crowdsale; require(address(crowdsale) != 0); tokenCap = _tokenCap; walletAddress = _walletAddress; }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreCrowdsale,"contract IRBPreCrowdsale is Ownable, Pausable { using SafeMath for uint; IRBToken public token; IRBPreRefundVault public vault; uint startTime = 1513065600; uint endTime = 1515963599; uint256 public constant minPresaleAmount = 108 * 10 ** 15; uint256 public constant goal = 1125 * 10 ** 18; uint256 public constant cap = 2250 * 10 ** 18; uint256 public weiRaised; bool public isFinalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function IRBPreCrowdsale(address _tokenAddress, address _vaultAddress) { require(_tokenAddress != address(0)); require(_vaultAddress != address(0)); token = IRBToken(_tokenAddress); vault = IRBPreRefundVault(_vaultAddress); }",1
0x32f1c992a32376fa0f723aecaa247119d3f7f8bd.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x70f90f6688cb26b6a924a2155b3d9529a0b36a90.sol,Crowdsale,"contract Crowdsale is Pausable{ using SafeMath for uint256; BurnableToken public token; address public wallet; uint256 public rate = 1883800000000000000000; uint256 tokensSold; uint256 public weiRaised; uint256 startTime; uint256 phaze1Start = 1564617600; uint256 phaze1End = 1567209600; uint256 phaze2Start = 1567296000; uint256 phaze2End = 1569801600; uint256 phaze3Start = 1569888000; uint256 phaze3End = 1572480000; uint256 rate1 = 3767600000000000000000; uint256 rate2 = 2354750000000000000000; uint256 rate3 = 2093100000000000000000; uint256 public hardcap = 250000000000000000000000000; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 time); event buyx(address buyer, address contractAddr, uint256 amount); constructor(address _wallet, BurnableToken _token, uint256 starttime, uint256 _cap) public{ require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; startTime = starttime; hardcap = _cap; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xc739ae9ba934f937636a2ebaaf1ecdf04e11ef2f.sol,NXTGToken,contract NXTGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 7000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTCrowdfund,"contract EPTCrowdfund { using SafeMath for uint256; EPTToken public token; address public beneficiaryAddress; address public founderAddress; uint256 public crowdfundStartTime = 1516579201; uint256 public crowdfundEndTime = 1518998399; uint256 public presaleStartTime = 1513123201; uint256 public presaleEndTime = 1516579199; uint256 public ethRaised; bool private tokenDeployed = false; uint256 public tokenSold; uint256 private ethRate; event ChangeFounderAddress(address indexed _newFounderAddress , uint256 _timestamp); event TokenPurchase(address indexed _beneficiary, uint256 _value, uint256 _amount); event CrowdFundClosed(uint256 _timestamp); enum State {PreSale, CrowdSale, Finish}",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function FinalizableCrowdsale(uint32 _startTime, uint32 _endTime, uint _rate, uint _hardCap, address _wallet, address _token) Crowdsale(_startTime, _endTime, _rate, _hardCap, _wallet, _token) { }",1
0xed8a2697d1af8f8cad0f6c5b9962d868d4ed2a41.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x74263f99e21db7c38a319e8ed40bfeca2da791f5.sol,CORENET,contract CORENET is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 36000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function CORENET () { owner = msg.sender; },1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0xd41ee3317467ab60109d76d6360807777c10afd7.sol,ZJLTTokenVault,"contract ZJLTTokenVault is Ownable { using SafeMath for uint256; address public teamWallet = 0x1fd4C9206715703c209651c215f506555a40b7C0; uint256 public startLockTime; uint256 public totalAlloc = 25 * 10 ** 18; uint256 public perValue = 20833333 * 10 ** 11; uint256 public timeLockPeriod = 30 days; uint256 public teamVestingStages = 12; uint256 public latestUnlockStage = 0; mapping (address => uint256) public lockBalance; ZJLTToken public token; bool public isExec; event Alloc(address _wallet, uint256 _value); event Claim(address _wallet, uint256 _value); modifier unLocked { uint256 nextStage = latestUnlockStage.add(1); require(startLockTime > 0 && now >= startLockTime.add(nextStage.mul(timeLockPeriod))); _; }",1
0x742686bb1b136b396b59818f42e47a4fc3509394.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersPercent; uint public bountyTokensCount; uint public price; uint public percentRate = 100; bool public bountyMinted = false; CommonSale public nextSale; MintableToken public token; function setToken(address newToken) onlyOwner { token = MintableToken(newToken); },1
0x2d3e7d4870a51b918919e7b851fe19983e4c38d5.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x4c478ac32725872e30bca49957abc7dbb325cb21.sol,daocrowdsale,"contract daocrowdsale is Ownable { using SafeMath for uint256; bytes32 constant password = keccak256(); bytes32 constant fin = keccak256(); COIN public DAO; uint256 public constant price = 500 finney; enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x57775c09b07896b979bb192b1b13df5a268757bd.sol,FutureTokenSaleLockBox,"contract FutureTokenSaleLockBox is Owned { using SafeMath for uint256; ERC20Interface public simpleToken; TokenSaleInterface public tokenSale; uint256 public unlockDate; event UnlockDateExtended(uint256 _newDate); event TokensTransferred(address indexed _to, uint256 _value); function FutureTokenSaleLockBox(ERC20Interface _simpleToken, TokenSaleInterface _tokenSale) Owned() public { require(address(_simpleToken) != address(0)); require(address(_tokenSale) != address(0)); simpleToken = _simpleToken; tokenSale = _tokenSale; uint256 endTime = tokenSale.endTime(); require(endTime > 0); unlockDate = endTime.add(26 weeks); }",1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x1fd2a7194c6bdc3c8f2c3b59b73f008a8f7a4818.sol,TokenTimelock,contract TokenTimelock is Ownable { using SafeERC20 for ERC20; using SafeMath for uint256; ERC20 public token; mapping(address => uint256) public balances; mapping(address => uint256) public releaseTime; constructor(ERC20 _token) public { token = _token; },1
0x486cf19a550e2814aef970b14e509e93209a0151.sol,EventChainCrowdsale,"contract EventChainCrowdsale is Haltable { using SafeMath for uint256; enum State{Preparing, Prepared, Presale, Phase1, Phase2, Closed}",1
0x35a1700ac75f6e9e096d9a5c90e3221b658096e0.sol,SpendableWallet,"contract SpendableWallet is Ownable { ERC20 public token; event ClaimedTokens( address indexed _token, address indexed _controller, uint256 _amount ); constructor(address _token, address _owner) public { token = ERC20(_token); owner = _owner; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x56c945f90c9cd1aafbcac78936f569e5fd2438bf.sol,HeroUp,"contract HeroUp is Ownable, CanReclaimToken { event HeroUpgraded(uint tokenId, address owner); HEROES_OLD public heroesOld; HEROES_NEW public heroesNew; constructor (HEROES_OLD _heroesOld, HEROES_NEW _heroesNew) public { require(address(_heroesOld) != address(0)); require(address(_heroesNew) != address(0)); heroesOld = _heroesOld; heroesNew = _heroesNew; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0xed4fd2e53153b8bfd866e11fb015a1bc4a0e9655.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0x890ee942fdce38034e3d3813344649c77a29e68f.sol,LemonSelfDrop1,contract LemonSelfDrop1 is Ownable { LemonToken public LemonContract; uint8 public dropNumber; uint256 public LemonsDroppedToTheWorld; uint256 public LemonsRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function LemonSelfDrop1 () { address c = 0x2089899d03607b2192afb2567874a3f287f2f1e4; LemonContract = LemonToken(c); dropNumber = 1; LemonsDroppedToTheWorld = 0; LemonsRemainingToDrop = 0; basicReward = 500; donatorRewardLevels = 1; totalDropTransactions = 0; },1
0x286bbee3f20f1702e707e58d33dc28a69e7efd4e.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x65061cfa23aa566316b0215c9eecabeafd4d9e81.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward1; address public addressOfTokenUsedAsReward2; address public addressOfTokenUsedAsReward3; address public addressOfTokenUsedAsReward4; address public addressOfTokenUsedAsReward5; uint256 public price = 7500; token tokenReward1; token tokenReward2; token tokenReward3; token tokenReward4; token tokenReward5; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xE37C4541C34e4A8785DaAA9aEb5005DdD29854ac; addressOfTokenUsedAsReward1 = 0xBD17Dfe402f1Afa41Cda169297F8de48d6Dfb613; addressOfTokenUsedAsReward2 = 0x489DF6493C58642e6a4651dDcd4145eaFBAA1018; addressOfTokenUsedAsReward3 = 0x404a639086eda1B9C8abA3e34a5f8145B4B04ea5; addressOfTokenUsedAsReward4 = 0x00755562Dfc1F409ec05d38254158850E4e8362a; addressOfTokenUsedAsReward5 = 0xE7AE9dc8F5F572e4f80655C4D0Ffe32ec16fF0E3; tokenReward1 = token(addressOfTokenUsedAsReward1); tokenReward2 = token(addressOfTokenUsedAsReward2); tokenReward3 = token(addressOfTokenUsedAsReward3); tokenReward4 = token(addressOfTokenUsedAsReward4); tokenReward5 = token(addressOfTokenUsedAsReward5); }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0x302eb72befc8af539432ec32c39423525412748f.sol,ZRSToken,contract ZRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 24000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ZRSToken () { owner = msg.sender; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,HavvenEscrow,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 internal rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0x0d853d20b54b8abfacb05fc5e81e8d4395021c01.sol,LxtBountyDistribution,contract LxtBountyDistribution is owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); uint256 public grandTotalClaimed = 0; struct Allocation { uint256 totalAllocated; uint256 amountClaimed; },1
0xa1ad52ff49fc70b7920b7d02483a58beb15d492b.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private owner = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private opAddress = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private comAddress = 0x24D160101C72c035287f772a8ac2b744a477F489; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0f717ffff71e639636fcdd33727ee8c17c4724bf); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 2 hours; uint256 constant private comDropGap_ = 24 hours; uint256 constant private rndNTR_ = 168 hours; uint256 public airDropPot_; uint256 public airDropPot2_; uint256 public airDropTracker_ = 0; uint256 public airDropTracker2_ = 0; uint256 public rID_; uint256 public comReWards_; uint256 public comAirDrop_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => uint256) public inviteCount_; mapping (address => bool) public addrLock_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => uint256[10]) public lastTen_; mapping (uint256 => uint256) public roundBetCount_; mapping (uint256 => mapping (uint256 =>uint256)) public comDropLastTime_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(48,0); fees_[1] = F3Ddatasets.TeamFee(33,0); fees_[2] = F3Ddatasets.TeamFee(18,0); potSplit_[0] = F3Ddatasets.PotSplit(10,20); potSplit_[1] = F3Ddatasets.PotSplit(5,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0xb602f224523c89c80dd8e970573291c63beeb778.sol,Crowdsale,contract Crowdsale is Ownable{ using SafeMath for uint; uint public decimals = 3; BineuroToken public token; function Crowdsale(address _tokenAddress) public{ token = BineuroToken(_tokenAddress); techSupport = msg.sender; token.setCrowdsaleContract(this); owner = token.getOwner(); },1
0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint manusSent; }",1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,AgiCrowdsale,"contract AgiCrowdsale is Ownable, ReentrancyGuard { using SafeMath for uint256; uint256 public firstDayCap; uint256 public cap; uint256 public goal; uint256 public rate; uint256 public constant WEI_TO_COGS = 10**uint256(10); address public wallet; RefundVault public vault; SingularityNetToken public token; uint256 public startTime; uint256 public endTime; uint256 public firstDay; bool public isFinalized = false; uint256 public weiRaised; mapping(address => bool) public whitelist; mapping(address => uint256) public contribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenRelease(address indexed beneficiary, uint256 amount); event TokenRefund(address indexed refundee, uint256 amount); event Finalized(); function AgiCrowdsale( address _token, address _wallet, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _firstDayCap, uint256 _goal ) { require(_startTime >= getBlockTimestamp()); require(_endTime >= _startTime); require(_rate > 0); require(_goal > 0); require(_cap > 0); require(_wallet != 0x0); vault = new RefundVault(_wallet); token = SingularityNetToken(_token); wallet = _wallet; startTime = _startTime; endTime = _endTime; firstDay = startTime + 1 * 1 days; firstDayCap = _firstDayCap; rate = _rate; goal = _goal; cap = _cap; }",1
0x4160836bd96bf4f2ed931bfefb3e00b3e68ad8f6.sol,PRHXToken,contract PRHXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1200000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRHXToken () { owner = msg.sender; },1
0xb602f224523c89c80dd8e970573291c63beeb778.sol,Crowdsale,contract Crowdsale is Ownable{ using SafeMath for uint; uint public decimals = 3; BineuroToken public token; function Crowdsale(address _tokenAddress) public{ token = BineuroToken(_tokenAddress); techSupport = msg.sender; token.setCrowdsaleContract(this); owner = token.getOwner(); },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x4498f897505d0e6991edeab24bc7b5727d72de28.sol,RFCICO,"contract RFCICO { using SafeMath for uint256; address public wallet; address public RFC; uint256 public price = 303; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public{ wallet = 0x1c46A08C940D9433297646cBa10Bc492c7D53A82; RFC = 0xed1CAa23883345098C7939C44Fb201AA622746aD; tokenReward = token(RFC); }",1
0x73e5451bcf4f7c47946abe89c772f3e6576909c3.sol,DragonCrowdsaleCore,"contract DragonCrowdsaleCore is Ownable, DragonPricing { using SafeMath for uint; address public beneficiary; address public charity; address public advisor; address public front; bool public advisorset; uint public tokensSold; uint public etherRaised; uint public presold; uint public presoldMax; uint public crowdsaleCounter; uint public advisorTotal; uint public advisorCut; Dragon public tokenReward; mapping ( address => bool ) public alreadyParticipated; modifier onlyFront() { if (msg.sender != front) { throw; }",1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0x6ddb328c94350b53a155e8cad141e3b972decc01.sol,BTCCMToken,contract BTCCMToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x75a17c63c2121447655955b55aaa1a413e750232.sol,CryderCrowdsale,contract CryderCrowdsale is Ownable { using SafeMath for uint256; address public wallet; CryderToken public presaleToken; CryderToken public token; bool public isBountyAllocated = false; mapping(address => bool) tokenRequests; uint public START_TIME = 1516467600; uint public CLOSE_TIME = 1519146000; uint256 public HARDCAP = 400000000000000000000000000; uint256 public exchangeRate = 3000; address public bounty = 0xa258Eb1817aA122acBa4Af66A7A064AE6E10552A; function () payable public { require(msg.sender == tx.origin); buyTokens(msg.sender); },1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30412800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xae09643734a0A0054fB4C1B376Ea95cd2d552dee; }",1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x4d0dc912fcad3b070d187ab8ac89e63d2b532b8a.sol,BliBliToken,"contract BliBliToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0x418d25d31c0a3c5559d8aa0c1c17d9cb3af9f59e.sol,Deposit,contract Deposit is Ownable { using SafeMath for uint256; struct ClientDeposit { uint256 balance; uint256 nextPaymentTotalAmount; uint256 nextPaymentDepositCommission; uint256 nextPaymentPlatformCommission; bool exists; bool isBlocked; },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x2898ca01df2dc4062e8b269806de4996295a1f5c.sol,SaleAuction,contract SaleAuction is AuctionBase { address public beneficiary = msg.sender; function SaleAuction(address _nftAddress) public { ERC721 candidateContract = ERC721(_nftAddress); nonFungibleContract = candidateContract; },1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x0356e14c2f8de339131c668c1747def594467a9a.sol,Club1VIT,"contract Club1VIT is Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public initialSupply = 1; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to); function totalSupply() public view returns (uint256) { return initialSupply; }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxyFactory,"contract DSProxyFactory { event Created(address indexed sender, address proxy, address cache); mapping(address=>bool) public isProxy; DSProxyCache public cache = new DSProxyCache(); function build() public returns (DSProxy proxy) { proxy = build(msg.sender); }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,SmartContractBank,contract SmartContractBank { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 paymentTime; uint256 withdrawals; bool increasedPercent; bool insured; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,OwnerContract,contract OwnerContract is Claimable { Claimable public ownedContract; address internal origOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); origOwner = ownedContract.owner(); ownedContract.claimOwnership(); return true; },1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x2737e022e8bf733b05fa0706b0e80003a576ccb4.sol,TokenValueRelayer,contract TokenValueRelayer { struct TokenValueRepresentation { uint256 value; string currency; uint256 timestamp; },1
0x3325e30f4326f17bdd79146db0a3835175f0e982.sol,SAMIToken,contract SAMIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000000000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function SAMIToken () { owner = msg.sender; },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,EthicHubTokenDistributionStrategy,"contract EthicHubTokenDistributionStrategy is Ownable, WhitelistedDistributionStrategy { event UnsoldTokensReturned(address indexed destination, uint256 amount); function EthicHubTokenDistributionStrategy(EthixToken _token, uint256 _rate, uint256 _rateForWhitelisted) WhitelistedDistributionStrategy(_token, _rate, _rateForWhitelisted) public { }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6.sol,ZethrSnap,contract ZethrSnap { struct SnapEntry { uint blockNumber; uint profit; },1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1.sol,CashPokerProPreICO,"contract CashPokerProPreICO is Ownable, Pausable { using SafeMath for uint; address public tokenWallet; uint public tokensSold; uint public weiRaised; uint public investorCount; Token public token; uint constant minInvest = 0.01 ether; uint constant tokensLimit = 10000000 * 1 ether; uint256 public startTime = 1503770400; uint256 public endTime = 1504893600; uint price = 0.00017 * 1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function CashPokerProPreICO() { tokenWallet = msg.sender; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,Deco,contract Deco is ERC20ERC223 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 6*10**26; mapping(address => Account) private accounts; struct Account { uint256 balance; mapping(address => uint256) allowed; mapping(address => bool) isAllowanceAuthorized; },1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x44f958d420f0543353a5e4f14e827d73f01b4261.sol,EBBToken,"contract EBBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 5963; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0xee91e81927bb047ea0f4b24e43dd5dc0684827a0.sol,BINGToken,contract BINGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BINGToken () { owner = msg.sender; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiCoinTempMgr,contract ZebiCoinTempMgr is Ownable{ using SafeMath for uint256; address public wallet; ZebiCoinCrowdsale public preSaleCSSC; ZebiCoin public tsc; uint64 tokenDecimals; mapping(address => bool) preSaleCancelledList; mapping(address => uint256) noncsAllocations; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefunds; modifier inPreSaleCancelledList { require(preSaleCancelledList[msg.sender]); _; },1
0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68.sol,Collectables,"contract Collectables is ERC721Full(, ), Ownable { using Strings for string; mapping(uint32 => address) public delegates; uint32[] public collectables; uint public delegateCount; event DelegateAdded(address indexed delegate, uint32 indexed delegateID); function addDelegate(address delegate) public onlyOwner { uint32 delegateID = uint32(delegateCount++); require(delegates[delegateID] == address(0), ); delegates[delegateID] = delegate; emit DelegateAdded(delegate, delegateID); }",1
0x4cf488387f035ff08c371515562cba712f9015d4.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0xa2edca10311a70883c5019b51048f55fd1508fe6.sol,FoMo3DshortAgain,"contract FoMo3DshortAgain is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 30 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x5155a0722a45905dacf49598a02eff3777340acd.sol,RegistryUpdater,"contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public featureRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0), ); polymathRegistry = _polymathRegistry; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,LPCWalletReserveWrapper,"contract LPCWalletReserveWrapper is DSThing { ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee); address public walletReserve; WETH public weth; ERC20 public dai; SaiLPC public lpc; function LPCWalletReserveWrapper(address walletReserve_, WETH weth_, ERC20 dai_, SaiLPC lpc_) public { assert(address(walletReserve_) != 0); assert(address(weth_) != 0); assert(address(dai_) != 0); assert(address(lpc_) != 0); walletReserve = walletReserve_; weth = weth_; lpc = lpc_; dai = dai_; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0x6f9ef4d30498f23e7d3116e272b855597fba83bd.sol,P3DRaffle,contract P3DRaffle is Owned { using SafeMath for uint; HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); function harvestabledivs() view public returns(uint256) { return ( P3Dcontract_.dividendsOf(address(this))) ; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x359a46571d4bc22a6a9310038b51e2d91163412f.sol,TokenSale,"contract TokenSale is Pausable { using SafeMath for uint256; ServusTokenInterface public servusToken; uint256 public totalWeiRaised; uint256 public tokensMinted; uint256 public totalSupply; uint256 public contributors; uint256 public decimalsMultiplier; uint256 public startTime; uint256 public endTime; uint256 public remainingTokens; uint256 public allocatedTokens; bool public finalized; bool public servusTokensAllocated; address public servusMultiSig = 0x0cc3e09c8a52fa0313154321be706635cdbdec37; uint256 public constant BASE_PRICE_IN_WEI = 1000000000000000; uint256 public constant PUBLIC_TOKENS = 100000000 * (10 ** 6); uint256 public constant TOTAL_PRESALE_TOKENS = 50000000 * (10 ** 6); uint256 public constant TOKENS_ALLOCATED_TO_SERVUS = 100000000 * (10 ** 6); uint256 public tokenCap = PUBLIC_TOKENS - TOTAL_PRESALE_TOKENS; uint256 public cap = tokenCap; uint256 public weiCap = cap * BASE_PRICE_IN_WEI; uint256 public firstDiscountPrice = (BASE_PRICE_IN_WEI * 85) / 100; uint256 public secondDiscountPrice = (BASE_PRICE_IN_WEI * 90) / 100; uint256 public thirdDiscountPrice = (BASE_PRICE_IN_WEI * 95) / 100; uint256 public firstDiscountCap = (weiCap * 5) / 100; uint256 public secondDiscountCap = (weiCap * 10) / 100; uint256 public thirdDiscountCap = (weiCap * 20) / 100; bool public started = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event NewClonedToken(address indexed _cloneToken); event OnTransfer(address _from, address _to, uint _amount); event OnApprove(address _owner, address _spender, uint _amount); event LogInt(string _name, uint256 _value); event Finalized(); function TokenSale(address _tokenAddress, uint256 _startTime, uint256 _endTime) public { require(_tokenAddress != 0x0); require(_startTime > 0); require(_endTime > _startTime); startTime = _startTime; endTime = _endTime; servusToken = ServusTokenInterface(_tokenAddress); decimalsMultiplier = (10 ** 6); }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Sample,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x29632c10d76bd1aed6b1524bf5bde4c992610670.sol,ApplicationEntity,"contract ApplicationEntityABI { address public ProposalsEntity; address public FundingEntity; address public MilestonesEntity; address public MeetingsEntity; address public BountyManagerEntity; address public TokenManagerEntity; address public ListingContractEntity; address public FundingManagerEntity; address public NewsContractEntity; bool public _initialized = false; bool public _locked = false; uint8 public CurrentEntityState; uint8 public AssetCollectionNum; address public GatewayInterfaceAddress; address public deployerAddress; address testAddressAllowUpgradeFrom; mapping (bytes32 => uint8) public EntityStates; mapping (bytes32 => address) public AssetCollection; mapping (uint8 => bytes32) public AssetCollectionIdToName; mapping (bytes32 => uint256) public BylawsUint256; mapping (bytes32 => bytes32) public BylawsBytes32; function ApplicationEntity() public; function getEntityState(bytes32 name) public view returns (uint8); function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external; function setUpgradeState(uint8 state) public ; function addAssetProposals(address _assetAddresses) external; function addAssetFunding(address _assetAddresses) external; function addAssetMilestones(address _assetAddresses) external; function addAssetMeetings(address _assetAddresses) external; function addAssetBountyManager(address _assetAddresses) external; function addAssetTokenManager(address _assetAddresses) external; function addAssetFundingManager(address _assetAddresses) external; function addAssetListingContract(address _assetAddresses) external; function addAssetNewsContract(address _assetAddresses) external; function getAssetAddressByName(bytes32 _name) public view returns (address); function setBylawUint256(bytes32 name, uint256 value) public; function getBylawUint256(bytes32 name) public view returns (uint256); function setBylawBytes32(bytes32 name, bytes32 value) public; function getBylawBytes32(bytes32 name) public view returns (bytes32); function initialize() external returns (bool); function getParentAddress() external view returns(address); function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256); function acceptCodeUpgradeProposal(address _newAddress) external; function initializeAssetsToThisApplication() external returns (bool); function transferAssetsToNewApplication(address _newAddress) external returns (bool); function lock() external returns (bool); function canInitiateCodeUpgrade(address _sender) public view returns(bool); function doStateChanges() public; function hasRequiredStateChanges() public view returns (bool); function anyAssetHasChanges() public view returns (bool); function extendedAnyAssetHasChanges() internal view returns (bool); function getRequiredStateChanges() public view returns (uint8, uint8); function getTimestamp() view public returns (uint256); }",1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0x5b82f83eeb171f829e5ca6d2c6205cd22ce7b821.sol,FBBCToken,"contract FBBCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x44f958d420f0543353a5e4f14e827d73f01b4261.sol,EBBToken,"contract EBBToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 5963; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onClaimTokens (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); event onReceiveAirdrop(uint256 amount, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,Token,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0xc45865b235a7c6693b9db5fed46ea8a3022d9b07.sol,DcorpCrowdsaleProxy,"contract DcorpCrowdsaleProxy is IDcorpCrowdsaleProxy, Ownership, TokenObserver, TokenRetriever { enum Stages { Deploying, Attached, Deployed }",1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINContract,"contract VINContract is SafeMath { VINNDTokenContract public VINToken; enum Stage{ Pause, Init, Running, Stopped }",1
0x75a17c63c2121447655955b55aaa1a413e750232.sol,CryderCrowdsale,contract CryderCrowdsale is Ownable { using SafeMath for uint256; address public wallet; CryderToken public presaleToken; CryderToken public token; bool public isBountyAllocated = false; mapping(address => bool) tokenRequests; uint public START_TIME = 1516467600; uint public CLOSE_TIME = 1519146000; uint256 public HARDCAP = 400000000000000000000000000; uint256 public exchangeRate = 3000; address public bounty = 0xa258Eb1817aA122acBa4Af66A7A064AE6E10552A; function () payable public { require(msg.sender == tx.origin); buyTokens(msg.sender); },1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0xedf19b437d1a67e18b15dd4a859dd52f9cfa012f.sol,ERC777TokenScheduledTimelock,"contract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable { using SafeMath for uint256; ERC777Token public token; uint256 public totalVested; struct Timelock { uint256 till; uint256 amount; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0xee3aaa50b8000cc87d66cd3d4704fd3316fc8725.sol,MineFarmer,contract MineFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; _0xBitcoinToken Token = _0xBitcoinToken(0xB6eD7644C69416d67B522e20bC294A9a9B405B31); address partnerAddress; constructor() public{ ceoAddress=0x85abE8E3bed0d4891ba201Af1e212FE50bb65a26; partnerAddress = 0x20C945800de43394F70D789874a4daC9cFA57451; },1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorLender,contract BancorLender { struct BorrowAgreement { address lender; address borrower; uint256 tokenAmount; uint256 collateralAmount; uint32 collateralRatio; uint expiration; },1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x00ec5112673b69bd5f545dc6a3bede8674f878eb.sol,CCPToken,contract CCPToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 55000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; uint public totalCollected = 0; function CCPToken () { owner = msg.sender; },1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuction,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxyFactory,"contract DSProxyFactory { event Created(address indexed sender, address proxy, address cache); mapping(address=>bool) public isProxy; DSProxyCache public cache = new DSProxyCache(); function build() public returns (DSProxy proxy) { proxy = build(msg.sender); }",1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x517c8bbb18d69d7d8f059175f612d556670b22c3.sol,AirDropAFTKSeven,"contract AirDropAFTKSeven is Ownable { Token token; mapping(address => uint256) public redeemBalanceOf; event BalanceSet(address indexed beneficiary, uint256 value); event Redeemed(address indexed beneficiary, uint256 value); event BalanceCleared(address indexed beneficiary, uint256 value); event TokenSendStart(address indexed beneficiary, uint256 value); event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); function AirDropAFTKSeven() public { address _tokenAddr = 0x7fa2f70bd4c4120fdd539ebd55c04118ba336b9e; token = Token(_tokenAddr); }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardAuction,contract CardAuction is CardOwnership { ClockAuctionBase public saleAuction; function setSaleAuction(address _address) external onlyOwner { ClockAuctionBase candidateContract = ClockAuctionBase(_address); require(candidateContract.isSaleAuction()); saleAuction = candidateContract; },1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x56ce81f0ede8716a2f3b6349f805e0f13643c168.sol,TokenVesting,"contract TokenVesting is Ownable { using SafeMath for uint; ERC20 public token; address public receiver; uint256 public startTime; uint256 public cliff; uint256 public totalPeriods; uint256 public timePerPeriod; uint256 public totalTokens; uint256 public tokensClaimed; event VestingFunded(uint256 totalTokens); event TokensClaimed(uint256 tokensClaimed); event VestingKilled(); constructor( address _token, address _receiver, uint256 _startTime, uint256 _cliff, uint256 _totalPeriods, uint256 _timePerPeriod ) public { token = ERC20(_token); receiver = _receiver; startTime = _startTime; cliff = _cliff; totalPeriods = _totalPeriods; timePerPeriod = _timePerPeriod; }",1
0x0e6e19549a89c9bec84b5b632cd1674f8e066d06.sol,EtheremonAdventureItem,"contract EtheremonAdventureItem is NFTStandard(, ), BasicAccessControl { uint constant public MAX_OWNER_PERS_SITE = 10; uint constant public MAX_SITE_ID = 108; uint constant public MAX_SITE_TOKEN_ID = 1080; address public adventureHandler; struct Item { uint classId; uint value; }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0xed6cd75aac7db5abbf382673dfe76e27c7399150.sol,VIPSToken,contract VIPSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 60000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VIPSToken () { owner = msg.sender; },1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0xb3b3fa00a534ab0c7437bc5e9f4f97f1f98b930d.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address prize_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address activate_addr2 = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address activate_addr1 = 0x6C7DFE3c255a098Ea031f334436DD50345cFC737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xc87a693dbba31aefb9457683b7d245dad756db88); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x4d4377ef856e89cbf76f8e994ab3065445d82f4f.sol,Airdrop,"contract Airdrop is Pausable { using SafeMath for uint256; GenbbyToken public token; uint256 public tokens_sold; uint256 public constant decimals = 18; uint256 public constant factor = 10 ** decimals; uint256 public constant total_tokens = 500000 * factor; event Drop(address to, uint256 amount); function setToken(address tokenAddress) onlyOwner public { token = GenbbyToken(tokenAddress); }",1
0x78a73b6cbc5d183ce56e786f6e905cadec63547b.sol,FabricTokenFundraiser,contract FabricTokenFundraiserConfig is FabricTokenConfig { uint constant CONVERSION_RATE = 9000; uint constant TOKENS_HARD_CAP = 71250 * (10**3) * DECIMALS_FACTOR; uint constant START_DATE = 1518688800; uint constant END_DATE = 1522576800; uint constant TOKENS_LOCKED_CORE_TEAM = 12 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 7 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = START_DATE + 1 years; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = START_DATE + 180 days; uint constant TOKENS_BOUNTY_PROGRAM = 1 * (10**6) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 50000000000 wei; uint constant MIN_CONTRIBUTION = 0.1 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 9 ether; },1
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7.sol,WFCToken,"contract WFCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x0692de52a966c107021e8a84db8486b4be57ecf1.sol,OQToken,contract OQToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function OQToken () { owner = msg.sender; },1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,AgiCrowdsale,"contract AgiCrowdsale is Ownable, ReentrancyGuard { using SafeMath for uint256; uint256 public firstDayCap; uint256 public cap; uint256 public goal; uint256 public rate; uint256 public constant WEI_TO_COGS = 10**uint256(10); address public wallet; RefundVault public vault; SingularityNetToken public token; uint256 public startTime; uint256 public endTime; uint256 public firstDay; bool public isFinalized = false; uint256 public weiRaised; mapping(address => bool) public whitelist; mapping(address => uint256) public contribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenRelease(address indexed beneficiary, uint256 amount); event TokenRefund(address indexed refundee, uint256 amount); event Finalized(); function AgiCrowdsale( address _token, address _wallet, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _firstDayCap, uint256 _goal ) { require(_startTime >= getBlockTimestamp()); require(_endTime >= _startTime); require(_rate > 0); require(_goal > 0); require(_cap > 0); require(_wallet != 0x0); vault = new RefundVault(_wallet); token = SingularityNetToken(_token); wallet = _wallet; startTime = _startTime; endTime = _endTime; firstDay = startTime + 1 * 1 days; firstDayCap = _firstDayCap; rate = _rate; goal = _goal; cap = _cap; }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6.sol,ZethrSnap,contract ZethrSnap { struct SnapEntry { uint blockNumber; uint profit; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,FourCrowdsale,"contract FourCrowdsale is TokenCappedCrowdsale, WhitelistCrowdsale, FinalizableCrowdsale { event RateChanged(uint256 newRate, string name); uint256 private constant E18 = 10**18; uint256 private TOKEN_SALE_CAP = 152000000 * E18; uint256 public constant TEAM_TOKENS = 50000000 * E18; address public constant TEAM_ADDRESS = 0x3EC2fC20c04656F4B0AA7372258A36FAfB1EF427; uint256 public constant ADVISORS_AND_CONTRIBUTORS_TOKENS = 39000000 * E18; address public constant ADVISORS_AND_CONTRIBUTORS_ADDRESS = 0x90adab6891514DC24411B9Adf2e11C0eD7739999; address public constant UNSOLD_ADDRESS = 0x4eC155995211C8639375Ae3106187bff3FF5DB46; uint256 public bonus; function FourCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _bonus, address _wallet, address _token) TokenCappedCrowdsale(TOKEN_SALE_CAP) Crowdsale(_startTime, _endTime, _rate, _wallet, _token) public { bonus = _bonus; }",1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0xbccfe34a2c6c59e396d2873d0d5bcb4736c8e2e7.sol,SwapController,"contract SwapController is DSAuth, TokenController { TokenTransferGuard[] public guards; function SwapController(address[] _guards) { for (uint i=0; i<_guards.length; i++) { addGuard(_guards[i]); }",1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0x26a9bab7b085582f56885f084174115e51fb58e4.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0x51c22c78d753939c8aebae437c2f18eee43ca296.sol,PrivateSale,"contract PrivateSale is Ownable { LamdenTau public lamdenTau; address public buyer; uint256 public priceInWei; function PrivateSale(address _tokenContractAddress, address _buyer, uint256 _priceInWei) public { require(_buyer != address(0)); require(_tokenContractAddress != address(0)); require(_priceInWei > 0); buyer = _buyer; priceInWei = _priceInWei; lamdenTau = LamdenTau(_tokenContractAddress); }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0xebbdf302c940c6bfd49c6b165f457fdb324649bc.sol,HydroToken,contract HydroToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function HydroToken() public { totalSupply = 11111111111 * 10**18; balances[msg.sender] = totalSupply; },1
0x01e0f57c42bf976676ea1daa1b04d69aba6bdaf3.sol,BatchTransferWallet,"contract BatchTransferWallet is Ownable { using SafeMath for uint256; event LogWithdrawal(address indexed receiver, uint amount); function batchTransfer(address _tokenAddress, address[] _investors, uint256[] _tokenAmounts) public { ERC20BasicInterface token = ERC20BasicInterface(_tokenAddress); require(_investors.length == _tokenAmounts.length && _investors.length != 0); uint decimalsForCalc = 10 ** uint256(token.decimals()); for (uint i = 0; i < _investors.length; i++) { require(_tokenAmounts[i] > 0 && _investors[i] != 0x0); _tokenAmounts[i] = _tokenAmounts[i].mul(decimalsForCalc); require(token.transfer(_investors[i], _tokenAmounts[i])); }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,SafeGuardsToken,contract SafeGuardsToken is CappedToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; address public canBurnAddress; mapping (address => bool) public frozenList; uint256 public frozenPauseTime = now + 180 days; uint256 public burnPausedTime = now + 180 days; constructor(address _canBurnAddress) CappedToken(61 * 1e6 * 1e18) public { require(_canBurnAddress != 0x0); canBurnAddress = _canBurnAddress; },1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30412800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xae09643734a0A0054fB4C1B376Ea95cd2d552dee; }",1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,ExternStateProxyToken,"contract ExternStateProxyToken is SafeDecimalMath, Proxyable { TokenState public state; string public name; string public symbol; uint public totalSupply; function ExternStateProxyToken(string _name, string _symbol, uint initialSupply, address initialBeneficiary, TokenState _state, address _owner) Proxyable(_owner) public { name = _name; symbol = _symbol; totalSupply = initialSupply; if (_state == TokenState(0)) { state = new TokenState(_owner, address(this)); state.setBalanceOf(initialBeneficiary, totalSupply); emit Transfer(address(0), initialBeneficiary, initialSupply); }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol,Sale,"contract Sale is Ownable { Calculator calculator; ERC20 token; address tokenSeller; uint256 public minimalTokens = 100000000000; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Sale(address tokenAddress, address calculatorAddress) { tokenSeller = msg.sender; token = ERC20(tokenAddress); setCalculatorAddress(calculatorAddress); }",1
0xdbe13bf528ca21bb6c306539109c21a304191f72.sol,HISToken,contract HISToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xf1a47b728439730e9f83054d7c352575bf13f0b4.sol,RPTCrowdsale,"contract RPTCrowdsale { using SafeMath for uint256; RPTToken public token; uint256 public totalWeiRaised; uint32 public exchangeRate = 3000; uint256 public preDistriToAcquiantancesStartTime = 1510876801; uint256 public preDistriToAcquiantancesEndTime = 1511827199; uint256 public presaleStartTime = 1511827200; uint256 public presaleEndTime = 1513036799; uint256 public crowdfundStartTime = 1513036800; uint256 public crowdfundEndTime = 1515628799; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; address public beneficiaryAddress; enum State { Acquiantances, PreSale, CrowdFund, Closed }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,AdvisorsTokensHolder,"contract AdvisorsTokensHolder is Ownable { using SafeMath for uint256; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0xedf19b437d1a67e18b15dd4a859dd52f9cfa012f.sol,ERC777TokenScheduledTimelock,"contract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable { using SafeMath for uint256; ERC777Token public token; uint256 public totalVested; struct Timelock { uint256 till; uint256 amount; }",1
