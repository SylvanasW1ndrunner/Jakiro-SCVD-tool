file,contract,code,label
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x365a3335866ac0b5f7002608eae1043d526f44d7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x0c72ab6f7fa937e637f4741ab8e61500ab33c24e71bd88c81eb458dde498338b; constructor() public { owner = msg.sender; },1
0x6be66252c14915e2a4f7e9621bc17365c4f35244.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,EditionStorage,"contract EditionStorage is BaseStorage { uint public offset = 1000000; uint public offsetIndex = 1; uint8[3] public defaultEditionLimits = [10, 89, 200]; mapping (uint => mapping (uint8 => uint8)) public editionCounts; mapping (uint => mapping (uint8 => uint8)) public editionLimits; mapping (uint => uint) public lastEditionOf; function setOffset(uint _offset) external onlyOwner { offset = _offset; }",1
0x5ac8359a7d38afedf7ed0d4abb283cd2654d126a.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,ExchangeRate,"contract ExchangeRate is Ownable { event RateUpdated(uint timestamp, bytes32 symbol, uint rate); mapping(bytes32 => uint) public rates; function updateRate(string _symbol, uint _rate) public onlyOwner { rates[keccak256(_symbol)] = _rate; RateUpdated(now, keccak256(_symbol), _rate); }",1
0xbcef236c69228f004da2fa693c3347946798e0c3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0xe319847f14624ad62a99c7eb5e6d738f61fcf185.sol,EtherPaint,"contract EtherPaint { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; mapping(address => uint256[16]) public tokenBalance; uint256[128][128] public colorPerCoordinate; uint256[16] public colorPerCanvas; event colorUpdate(uint8 posx, uint8 posy, uint8 colorid); event priceUpdate(uint8 colorid); event tokenUpdate(uint8 colorid, address who); event dividendUpdate(); event pushuint(uint256 s); mapping(address => int256[16]) public payouts; uint256[16] public totalSupply; uint256 public allTotalSupply; int256[16] totalPayouts; uint256[16] earningsPerToken; uint256[16] public contractBalance; address public owner; uint256 public ownerFee; function EtherPaint() public { owner = msg.sender; colorPerCanvas[0] = 128*128; pushuint(1 finney); }",1
0xf066a61ebcb0a11ec3921cf9fbcca4561877526f.sol,MasterNodeMining,"contract MasterNodeMining is Ownable{ using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maximumSupply = 10000000 * (10 ** uint256(decimals)); uint256 public constant icoSupply = 9000000 * (10 ** uint256(decimals)); uint256 public constant TokensPerEther = 1000; uint256 public constant icoEnd = 1522540800; uint256 public constant teamTokens = 1538352000; address public multisig = 0xF33014a0A4Cf06df687c02023C032e42a4719573; uint256 public totalSupply; function transfer(address _to, uint _value) public returns (bool success) { require( msg.data.length >= (2 * 32) + 4 ); require( _value > 0 ); require( balances[msg.sender] >= _value ); require( balances[_to] + _value > balances[_to] ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8cc0ef2b26ff52f86de029cb38ed53b7ed98a57.sol,PumpAndDump,contract PumpAndDump { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x280daacbd812725baf46e273b84426b1e10ab410.sol,CBEXTOKEN,"contract CBEXTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CBEXTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x11b50FD47E6053F78dd98A95AD07127Bd63C8AF2] = _totalSupply; Transfer(address(0), 0x11b50FD47E6053F78dd98A95AD07127Bd63C8AF2, _totalSupply); }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 2000 * 10**18; uint public maxWithdraw = 50000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; balanceOf[_escrow] = 7850047931491270769372792; totalSupply = 7850047931491270769372792; }",1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint256 value; bytes data; bytes4 sig; },1
0x556241b90b4c55457a31e27eb612bdc11815d989.sol,NemixToken,"contract NemixToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NemixToken() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xd9d42c6d1ebf9083d9514e5ae5f53cd627708c12.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Registry,contract Registry is Ownable { bool opened; string[] identifiers; mapping(string => address) registrantOfIdentifier; mapping(string => uint[]) versionsOfIdentifier; mapping(string => mapping(uint => Template)) templateOfVersionOfIdentifier; constructor(bool _opened) Ownable() public { opened = _opened; },1
0x6b775965ff81583429ee39f4f6a5fb6889ab61eb.sol,ZTKDIGITALTOKEN,"contract ZTKDIGITALTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZTKDIGITALTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xb6d8f913834B34BC5c997C63C597956E42dA405a] = _totalSupply; Transfer(address(0), 0xb6d8f913834B34BC5c997C63C597956E42dA405a, _totalSupply); }",1
0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,EOMarketToken,"contract EOMarketToken is AccessService { uint8 public decimals = 0; uint256 public totalSupply = 100; uint256 public totalSold = 0; string public name = ; string public symbol = ; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; address[] shareholders; mapping (address => uint256) addressToIndex; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EOMarketToken() public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; balances[this] = totalSupply; }",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Control,contract Control { mapping(address => uint8) public agents; modifier onlyADM() { require(agents[msg.sender] == 1); _; },1
0x0de1beed64aa3ca5f563a1ba585861748c352231.sol,BioCoin,"contract BioCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BioCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 10000000; balances[0x66125E7980a3A79413485e61Cd8161Fa6C467227] = _totalSupply; Transfer(address(0), 0x66125E7980a3A79413485e61Cd8161Fa6C467227, _totalSupply); }",1
0x184001d794a8c91def72b8a488b67cc907d4e5be.sol,Ore,"contract Ore { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 25529833 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function Ore() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbc7981956a44b5c5de21ad30aec8099c3ca27dba.sol,HodlETH,contract HodlETH { mapping (address => uint) public userInvested; mapping (address => uint) public entryTime; mapping (address => uint) public withdrawnAmount; mapping (address => uint) public referrerOn; address public advertisingFund = 0x01429d58058B3e84F6f264D91254EA3a96E1d2B7; uint public advertisingPercent = 6; address techSupportFund = 0x0D5dB78b35ecbdD22ffeA91B46a6EC77dC09EA4a; uint public techSupportPercent = 2; uint public startPercent = 25; uint public fiveDayHodlPercent = 30; uint public tenDayHodlPercent = 35; uint public twentyDayHodlPercent = 45; uint public lowBalance = 500 ether; uint public middleBalance = 2000 ether; uint public highBalance = 3500 ether; uint public soLowBalanceBonus = 5; uint public lowBalanceBonus = 10; uint public middleBalanceBonus = 15; uint public highBalanceBonus = 20; function bonusPercent() public view returns(uint){ uint balance = address(this).balance; if (balance < lowBalance){ return (soLowBalanceBonus); },1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c3f48ae556893ef033e37d673f7a218454692fa.sol,SWEDEN_WINS,"contract SWEDEN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,token,"contract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}",1
0x848bcb77c97d449312ece071cd999e5f0d30f849.sol,TokenMCT,"contract TokenMCT{ using SafeMath for uint; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMCT(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc14c848a2a5945e1a415976fc059550ecbe7b034.sol,Line,contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public giftNumerator = 1; uint constant public denominator = 100; uint constant public ownerDenominator = 100; uint public jackpot = 0; address[] internal addresses; mapping(address => SpinRec) internal spinsByAddr; mapping(bytes32 => SpinRec) internal spinsByQuery; struct SpinRec { uint id; bytes32 queryId; uint bet; uint token; },1
0x178381837f84a7a636f57a3f2946cda512e5caab.sol,TreasureToken,contract TreasureToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x505d0c2061f124c0ae03f795c4aeddd7ff9d471e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x07b2f3fbfda96208704e14068a50144f2ec6a37c.sol,Evocoin,contract Evocoin{ string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint public constant totalSupply = 7500000000*10**5; uint userIndex = 0; address public constant owner = 0x34A4933de38bF3830C7848aBb182d553F5a5D523; struct user{ address _adress; uint _value; },1
0x5258e585f8efe5d7ecca0a9232fc26fd8ca02436.sol,KCOIN,"contract KCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d9562d5f3b53316e25952079227621adca9eb49.sol,Test,"contract Test{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Test( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; unitsOneEthCanBuy = 1000; }",1
0xdc24f9cc79f802587b56f27a7db0833e40c8a22c.sol,FuckCoin,contract FuckCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6cbadb622d30a8c998c907911a9b160e735348fc.sol,BitEspritCoin,"contract BitEspritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) _balances; mapping(address => mapping(address => uint)) allowed; function BitEspritCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; _balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); }",1
0xd0823c151d23678c6efe2b73b70aedf25be469fa.sol,AIOToken,"contract AIOToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIOToken() public { symbol = ; name = ; decimals = 18; totalSupply = 870000 * 10**uint(decimals); balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); bonusEnds = now + 3 weeks; endDate = now + 8 weeks; }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x25c08bb7aa204d221288d9739899f4edf96f5fba.sol,PornTokenV2Crowdsale,"contract PornTokenV2Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint private currentBalance; uint public deadline; uint public price; uint public initialTokenAmount; uint public currentTokenAmount; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); function PornTokenV2Crowdsale( address sendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward ) { beneficiary = sendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = 13370000000000; initialTokenAmount = 747943160; currentTokenAmount = 747943160; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f.sol,POTJ,contract POTJ { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xee6465f5df390676c02ebe15cdad07d63e4b1ad6.sol,EthereumMoon,"contract EthereumMoon { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumMoon() public { totalSupply = 500000000000000; balanceOf[msg.sender] = 500000000000000; name = ; symbol = ; decimals = 8; }",1
0x53c2159fa4690ccaa773086a137fb1cd17f65f35.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0x92e55c6ee3171779174cebb27211120b730c155c.sol,SantimentWhiteList,contract SantimentWhiteList { string constant public VERSION = ; function () { throw; },1
0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x9c49b65ddef30ad4a32c0ff6bf103144cd7733fc.sol,Sports3D,contract Sports3D { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbca5b3524e2d52c38fd6ca6dd10233575baa8533.sol,VOCC_I098_20181211,"contract VOCC_I098_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x87b9d30c83317d1c07f49c7583bef7e8eea24107.sol,SecurityTokenZhiFu,"contract SecurityTokenZhiFu { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWUtility,None,1
0x6e850bf8607a37e84a489008eeb94fb19331b061.sol,FastEth,contract FastEth { address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35; address constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03; address constant private CASHBACK = 0x33cA4CbC4b171c32C16c92AFf9feE487937475F8; address constant private PRIZE = 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653; uint constant public PERCENT = 4; uint constant public BONUS_PERCENT = 5; uint constant StartEpoc = 1541354370; struct Deposit { address depositor; uint deposit; uint payout; },1
0x737717b587fae986354660d023eefbcec4552558.sol,TokenERC20,"contract TokenERC20{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x6ce4642936028cf493c9bdd72e78130297cb77ea.sol,Ownable,"contract Ownable { address public owner; address public ownerCandidate; address[4] public admins; uint256 public ownershipTransferCounter; constructor(address _owner, address[4] _admins) public { owner = _owner; admins[0] = _admins[0]; admins[1] = _admins[1]; admins[2] = _admins[2]; admins[3] = _admins[3]; }",1
0x5aa4769f204f0b9e8d9c852377bf90fbe5bf2aeb.sol,MultiX250max03eth,contract MultiX250max03eth { address constant private PROMO = 0x74E6B17a922C741c4dA0b71796eFB0edDDda398a; uint constant public PROMO_PERCENT = 10; uint constant public MULTIPLIER = 250; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x00ea6f91b00e080e816f1bb2fad71b0fe1528983.sol,VCOIN,"contract VCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07] = _totalSupply; Transfer(address(0), 0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07, _totalSupply); }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x5544138f866b9a76c7c020719a094c530bac72fe.sol,LuckGameToken,"contract LuckGameToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xdfbfd64726b1b178ef8204ae4992f641f31c8248.sol,EloPlayToken,"contract EloPlayToken is ERC20Token, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; address public TARGET_ADDRESS; address public TARGET_TOKENS_ADDRESS; uint256 public START_TS; uint256 public END_TS; uint256 public CAP; uint256 public USDETHRATE; bool public halted; uint256 public totalEthers; event TokensBought(address indexed buyer, uint256 ethers, uint256 new_ether_balance, uint256 tokens, uint256 target_address_tokens, uint256 new_total_supply, uint256 buy_price); event FundTransfer(address backer, uint amount, bool isContribution); function EloPlayToken(uint256 _start_ts, uint256 _end_ts, uint256 _cap, address _target_address, address _target_tokens_address, uint256 _usdethrate) { START_TS = _start_ts; END_TS = _end_ts; CAP = _cap; USDETHRATE = _usdethrate; TARGET_ADDRESS = _target_address; TARGET_TOKENS_ADDRESS = _target_tokens_address; }",1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0x26c0e6f69b18125f68ac55f439b1e10c2a2e5c03.sol,Owners,contract Owners { mapping (address => bool) public owners; uint public ownersCount; uint public minOwnersRequired = 2; event OwnerAdded(address indexed owner); event OwnerRemoved(address indexed owner); constructor(bool withDeployer) public { if (withDeployer) { ownersCount++; owners[msg.sender] = true; },1
0x268f03c41d3f33a697eed9c7f0632053556fae9e.sol,BountyClaims,"contract BountyClaims is Ownable { using SafeMath for uint256; ERC20 public token; address public wallet; mapping(address => uint256) bountyTokens; event Claim( address indexed beneficiary, uint256 amount ); function BountyClaims( ERC20 _token, address _wallet) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrSlots,contract ZethrSlots is ZethrGame { struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint8 numSpins; },1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1ebd8d3ca115451b9b6bbaa7ee2f7b0f96e49fd8.sol,ArthurStandardToken,"contract ArthurStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; function ArthurStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x580c1e3caca14826976b5820947f7ad486ac174d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc4a0ab20f1901c24740e06966cca9d5f2e5d5e79.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0x00817122beef212ac22e65fc0fba8bc065fd5f66.sol,UNTToken,contract UNTToken is MintableToken{ string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 8; mapping(address => uint256) public lockamount; address[] lockaddress; bool private isFreezed = false; function UNTToken() public { totalSupply = 2000000000E3; balances[msg.sender] = totalSupply; },1
0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994.sol,SHERE_PFII_II_883,"contract SHERE_PFII_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1219985648835240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4a7c09a885a31755dd4cd1ce816d257fbe30dcf.sol,BBTDonate,contract BBTDonate { address public owner; bool public isClosed; uint256 public totalReceive; uint256 public remain; mapping (address => uint256) public record; mapping (address => bool) public isAdmin; modifier onlyAdmin { require(msg.sender == owner || isAdmin[msg.sender]); _; },1
0x185480332ee00c4a23422df11e022172dc10d5a9.sol,NausiCoin,"contract NausiCoin is Erc20Token, owned { string public name; string public symbol; uint public decimals; uint _totalSupply; mapping(address => uint) _balanceOf; mapping(address => mapping(address => uint)) _allowance; event Burn(address indexed from, uint amount); event Mint(address indexed from, uint amount); constructor(string tokenName, string tokenSymbol, uint tokenDecimals, uint tokenTotalSupply) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; _totalSupply = tokenTotalSupply * 10**uint(decimals); _balanceOf[msg.sender] = _totalSupply; }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0xd0563bc1a5a824c17c0c73c98725234de9b1dd93.sol,Depix,"contract Depix is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47] = _totalSupply; emit Transfer(address(0), 0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47, _totalSupply); }",1
0xbfb7eee5dbc373433a97431fd5a3010b53e16378.sol,DDAContract,contract DDAContract is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 10**26; mapping (address => uint) public balances; mapping (address => mapping (address => uint256)) public allowed; address dedeAddress; function totalSupply() constant returns (uint totalSupply){ return _totalSupply; },1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkOwnership,"contract ArtworkOwnership is ArtworkBase, ArtworkUnique, ERC721 { string public constant NAME = ; string public constant SYMBOL = ; ERC721Metadata public erc721Metadata; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256()); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function approve( address _to, uint256 _tokenId ) external whenNotPaused { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); }",1
0x74e345b0597ea3bc5762df0092e6bf8c891a7d0f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0x00c2982959f852abbdb0f5ec023609ea1ca579e8.sol,GAC,"contract GAC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7895a43ae537e8e1ac97006ea9235807eea04cfa.sol,YunMint,"contract YunMint is Operational, ReentrancyGuard, BurnableToken, StandardToken { using SafeMath for uint; using SafeMath for uint256; using DateTime for uint256; event Release(address operator, uint256 value, uint256 releaseTime); event Burn(address indexed burner, uint256 value); event Freeze(address indexed owner, uint256 value, uint256 releaseTime); event Unfreeze(address indexed owner, uint256 value, uint256 releaseTime); struct FrozenBalance {address owner; uint256 value; uint256 unFrozenTime;}",1
0x3a8a6d2bc23fb68a245250ad34019a65cf057418.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x5513401cb13ec32809d238ee19a84405759147cc.sol,INTO_ICO,"contract INTO_ICO is Pausable { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public supply; uint256 public rate; uint256 public weiRaised; uint256 public openingTime; uint256 public closingTime; uint256 public duration; uint256 public minInvest; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public { rate = 50000; wallet = owner; token = ERC20(0x7f738ffbdE7ECAC18D31ECba1e9B6eEF5b9214b7); minInvest = 0.05 * 1 ether; duration = 176 days; openingTime = 1530446400; closingTime = openingTime + duration; }",1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x6e7a61fbe11873f4c7d0983c79683aad5c0788bd.sol,ERC20Receive,contract ERC20Receive { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,CRYPTOSSTOKEN,"contract CRYPTOSSTOKEN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x719e7f0dadfdea25b78595da944f44d15d7e6795.sol,Musk,"contract Musk is Token { string public name; uint8 public decimals; string public symbol; constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerBase,contract FlowerBase is FlowerAdminAccess { struct Flower { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint16 cooldownIndex; uint16 generation; },1
0xecbed48098c4f25a16195c45ddf5fd736e28b14b.sol,UserfeedsClaimWithConfigurableValueMultiTransfer,"contract UserfeedsClaimWithConfigurableValueMultiTransfer is Destructible, WithClaim { function post(string data, address[] recipients, uint[] values) public payable { emit Claim(data); transfer(recipients, values); }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0x71be4a37ef6423c4dc0530410454d85da3d73d64.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x70f53cb14a08700d0816f01bdae54b3f507f2ce2.sol,Contract50,contract Contract50 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] /50 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x518049c81352636b34d82f0a3fad8cfe3571f35a.sol,TICKET,"contract TICKET { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TICKET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378.sol,OPCToken,"contract OPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OPCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3.sol,queue,contract queue { Queue public q; struct BuyTicket { address account; uint amount; uint time; },1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x51696e028e0fe5416481c28cf1a2626d43680751.sol,IngridIsAHorribleHumanCoin,"contract IngridIsAHorribleHumanCoin is SystemTesterCode { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function IngridIsAHorribleHumanCoin( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5cb888182fbffdb62c08fb4b5a343914f00fdfee.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc52c48074c3dcf9acbcb90b468484284d777490.sol,BDDBToken,"contract BDDBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf9a6f344FFEBF88e23e7a94e6F301f370CAac8E1] = _totalSupply; emit Transfer(address(0), 0xf9a6f344FFEBF88e23e7a94e6F301f370CAac8E1, _totalSupply); }",1
0xb3a0dc0daa5ce33fc14a142c0fd4a1586c4e8c82.sol,Bitstraq_Token,"contract Bitstraq_Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitstraq_Token() public { symbol = ; name = ; decimals = 10; _totalSupply = 5000000000000000000; balances[0x9652A328f3003235E57194ef7C7c0e54F60C9E6e] = _totalSupply; Transfer(address(0), 0x9652A328f3003235E57194ef7C7c0e54F60C9E6e, _totalSupply); }",1
0x874c3471d459f4107abaeb915cdba6c562cfba3d.sol,Gorgona,contract Gorgona { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; GorgonaKiller public gorgonaKiller; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x029fa59111136ce592e136760a1df1d4a6cd564b.sol,RetailLoyaltySystemBase,"contract RetailLoyaltySystemBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function RetailLoyaltySystemBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xf3fb69ef211c6d1e838a5c2223ef54fed4f24090.sol,SafeMath,None,1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x78dd22e93357d6f926fa0f7cb860c5e6e1bcf484.sol,LETSY,"contract LETSY is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x3aa9C81C14cE1799533C5e24b1e90c00344c5A9c] = _totalSupply; emit Transfer(address(0), 0x3aa9C81C14cE1799533C5e24b1e90c00344c5A9c, _totalSupply); }",1
0x03a9458d77dd705829fa758c64dbe770385295cc.sol,PolicyRegistry,"contract PolicyRegistry { event PolicyUpdate(uint indexed _subcourtID, string _policy); address public governor; mapping(uint => string) public policies; modifier onlyByGovernor() {require(governor == msg.sender, ); _;}",1
0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x282d74cc2203e5c19b522876ca6fdee59d3b800b.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0x20d2f8fdd0951f2f5249c86b3cdc2be7656f2c01.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public _balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(decimals); _balanceOf[msg.sender] = _totalSupply; name = ; symbol = ; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,Whitelist,"contract Whitelist is Ownable, RBAC { string public constant ROLE_WHITELISTED = ; modifier onlyIfWhitelisted(address _operator) { checkRole(_operator, ROLE_WHITELISTED); _; }",1
0xefc1b11ad4b183ad859ef220a9c498cb04716a31.sol,Counter,"contract Counter { event Won(address winner, uint amount); uint public i; address public owner; function Counter() public { owner = msg.sender; }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x296b3fc8e3cc768f834152586e5ad708bfe8f163.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5abaff0b83f81dc061c590aadcba013c69237fd7.sol,CryptoJade,"contract CryptoJade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoJade() public { symbol = ; name = ; decimals = 18; _totalSupply = 125000000000000000000000000; balances[0x5E77C4cf41618A897759b3A2A32665C85BC2aF21] = _totalSupply; Transfer(address(0), 0x5E77C4cf41618A897759b3A2A32665C85BC2aF21, _totalSupply); }",1
0x219b9040eb7d8d8c2e8e84b87ce9ac1c83071980.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1cd74dd56b0929f1505c6e1f9bdf57fb31d60631.sol,BugisContract,"contract BugisContract { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 600000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BugisContract( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0x3a03afa73623b99eedaa6180a869dd5bde17a601.sol,CheapLambos,contract CheapLambos { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0x6bef7336e8176ce577d32a4ffc8c7e87b726d4a3.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 4; _totalSupply = 5000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xc41585205b83b7c643a37b87887c97cf31cb8867.sol,QINTAR,"contract QINTAR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 5; _totalSupply = 100000000000; balances[0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b] = _totalSupply; emit Transfer(address(0), 0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b, _totalSupply); }",1
0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15.sol,EGFToken,"contract EGFToken is ERC20, owned { mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor () ERC20() public { }",1
0x17c8d8b7659141273a1c2223030c89b96713a44a.sol,XPS,"contract XPS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XPS( ) public { totalSupply = 20000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x7476c85d6dfc144c6b196d8956b4cc2bbfb860f2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,PiToken,"contract PiToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PiToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 3141592653589793238 ** uint256(decimals); balanceOf[msg.sender] = totalSupply = 3141592653589793238; tokenName = ; tokenSymbol = ; }",1
0x3595279a9f0658eb2649976f155111bae1ae9de6.sol,GGE,"contract GGE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GGE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa15b24b7b883aac6bc6582b0057c09d62a7a1b2c.sol,Simply10,contract Simply10 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x18835a9009a2a1a1dc1dce33ba7e417f9cee1154.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2.sol,BFBtoken,"contract BFBtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoinSale,"contract HngCoinSale is owned, HngCoin { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HngCoinSale( uint256 initialSupply, string tokenName, string tokenSymbol ) HngCoin(initialSupply, tokenName, tokenSymbol) public {}",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x36cc5160e243f91157d8c14222f2ed5c52cf3d05.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x78af82f8924f99cec0afef357105382b8a44708f.sol,EraTokens,"contract EraTokens is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x71fbecb11e291f824fd5dc9e760f56a5239e4702.sol,HodlDAO,contract HodlDAO { string public version = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => withdrawalRequest) public withdrawalRequests; struct withdrawalRequest { uint sinceTime; uint256 amount; },1
0x32d55157bd2ae652f4b6be48ee4a7a1686d28a3f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf355164187e533b1969b4de46737c4e8bc9ae7e2.sol,MASToken,"contract MASToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MASToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41dcc20e5fc42e21087afb0864683101be5a95ff.sol,Farmcoin,"contract Farmcoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Farmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x059accb493f5a47dc97cc0443aeec8a3fd2591c1.sol,TRXT,"contract TRXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRXT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x2612bb62eaa42991d12be0892c27040d4143e037.sol,ToknTalkToken,"contract ToknTalkToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; address public mintSigner = msg.sender; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public totalSupply = 0; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public mintedBy; function transfer(address to, uint amount) external returns (bool) { require(to != address(this)); require(to != 0); uint balanceOfMsgSender = balanceOf[msg.sender]; require(balanceOfMsgSender >= amount); balanceOf[msg.sender] = balanceOfMsgSender - amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; }",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x400c73395bbc01d9e757f02f267925e1de0779f8.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0xec662B61C129fcF9fc6DD6F1A672021A539CE45d); },1
0x31a6ba952064f3895e29a5a7f0731287368ab89e.sol,NutrioCoin,contract NutrioCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 50000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6.sol,SLUTZToken,"contract SLUTZToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SLUTZToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 25000000000000000; balances[0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1] = _totalSupply; Transfer(address(25000000000000000), 0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1, _totalSupply); }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0x261bb5e1c53248860f4bc405abaae3e0bfc12874.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0x74a31dc20802cb1e41201af055ce7dfcd31d291d.sol,m10fanclub,"contract m10fanclub is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function m10fanclub() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 12 weeks; endDate = now + 52 weeks; }",1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x37d82a4e03e93529c1a32429984e12e7875ea1d8.sol,OMGCatCoin,"contract OMGCatCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OMGCatCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x921beCA00339c458342cF09b4B0f4adb3942e332] = _totalSupply; Transfer(address(0), 0x921beCA00339c458342cF09b4B0f4adb3942e332, _totalSupply); }",1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,Bitscreen,contract Bitscreen { struct IPFSHash { bytes32 hash; uint8 hashFunction; uint8 size; },1
0xdc448e8a2a92a5ce799b197e982d773c605318a4.sol,YESToken,"contract YESToken is Ownable, BriantToken { function YESToken() BriantToken () {}",1
0xcfca01488643501cab56d1855921c897d5ee4b1b.sol,BitcoinInw,"contract BitcoinInw is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c] = _totalSupply; emit Transfer(address(0), 0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c, _totalSupply); }",1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x341492c5f449ca8accae37d73aed8fcd21995ef9.sol,WEIPAY,"contract WEIPAY { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0x31a5f35f32756fe35d39bafe85607d93185b23f2.sol,GNNM,"contract GNNM { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GNNM( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeca0415f309789ade195a51988d760b6d51f5de9.sol,GreenMed,"contract GreenMed is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 100000000000000000000000000; address public owner; uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x87e960f996e789ca2c8415fc449e4720adbe0497.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xed17658ad6b3fe87c7dc7323d0e77c4116a23626.sol,Deploy,"contract Deploy is Ownable, Arbitrage { function transfer(address _to, uint256 _value) { require(balances[msg.sender] > _value); require(balances[_to] + _value > balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); }",1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x8815df7e7e92b9b038658f0870e062548136e8cd.sol,LDC,"contract LDC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62.sol,WncToken,"contract WncToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WncToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x036ba95116edf4f79d5c0da9639ed1f31b1ebcd9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x84d5c939ddfdc3ea033f03e18213a6906f94e0c3.sol,CryptoSagaDungeonProgress,"contract CryptoSagaDungeonProgress is Claimable, AccessDeploy { mapping(address => uint32[25]) public addressToProgress; function getProgressOfAddressAndId(address _address, uint32 _id) external view returns (uint32) { var _progressList = addressToProgress[_address]; return _progressList[_id]; }",1
0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989.sol,ERC20TokenCPN,contract ERC20TokenCPN { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; address public regulator; uint8 public regulatorStatus; uint internal amount; struct agent { uint balance; mapping (address => uint) allowed; uint8 permission; },1
0x54d3ad23846643b93098915001ab274ea19e5622.sol,Maths,None,1
0xd8d94cfa0dc8898d13e6f9a1618c490f68c160dd.sol,MichaelCoin,"contract MichaelCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MichaelCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100; balances[0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25] = _totalSupply; Transfer(address(0), 0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25, _totalSupply); }",1
0xf208f8cdf637e49b5e6219fa76b014d49287894f.sol,Gainz,contract Gainz { address owner; constructor () public { owner = msg.sender; },1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,MyBoToken,"contract MyBoToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function MyBoToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x5abaff0b83f81dc061c590aadcba013c69237fd7.sol,CryptoJade,"contract CryptoJade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoJade() public { symbol = ; name = ; decimals = 18; _totalSupply = 125000000000000000000000000; balances[0x5E77C4cf41618A897759b3A2A32665C85BC2aF21] = _totalSupply; Transfer(address(0), 0x5E77C4cf41618A897759b3A2A32665C85BC2aF21, _totalSupply); }",1
0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3.sol,CoinifinexToken,"contract CoinifinexToken { uint256 constant public TOTAL_TOKEN = 10 ** 9; uint256 constant public TOKEN_FOR_ICO = 650 * 10 ** 6; uint256 constant public TOKEN_FOR_COMPANY = 200 * 10 ** 6; uint256 constant public TOKEN_FOR_BONUS = 50 * 10 ** 6; mapping (address => uint256) public tokenForTeam; mapping (address => uint256) public tokenForTeamGet; address[] public teamAddress; uint public startTime; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinifinexToken( ) public { totalSupply = TOTAL_TOKEN * 10 ** uint256(decimals); name = ; symbol = ; startTime = 1538265600; tokenForTeam[0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x040440286a443822211dDe0e7E9DA3F49aF2EBC7] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xc456aC342f17E7003A03479e275fDA322dE38681] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24] = 300 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x88311485647e19510298d7Dbf0a346D5B808DF03] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe387125f1b24E59f7811d26fbb26bdA1c599b061] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xC5b644c5fDe01fce561496179a8Bb7886349bD75] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF] = 5 * 10 ** 6 * 10 ** uint256(decimals); teamAddress.push(0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0); teamAddress.push(0x040440286a443822211dDe0e7E9DA3F49aF2EBC7); teamAddress.push(0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71); teamAddress.push(0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D); teamAddress.push(0xc456aC342f17E7003A03479e275fDA322dE38681); teamAddress.push(0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24); teamAddress.push(0x88311485647e19510298d7Dbf0a346D5B808DF03); teamAddress.push(0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F); teamAddress.push(0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1); teamAddress.push(0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb); teamAddress.push(0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77); teamAddress.push(0xe387125f1b24E59f7811d26fbb26bdA1c599b061); teamAddress.push(0xC5b644c5fDe01fce561496179a8Bb7886349bD75); teamAddress.push(0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78); teamAddress.push(0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae); teamAddress.push(0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF); uint arrayLength = teamAddress.length; for (uint i=0; i<arrayLength; i++) { tokenForTeamGet[teamAddress[i]] = tokenForTeam[teamAddress[i]] * 1 / 10; balanceOf[teamAddress[i]] = tokenForTeamGet[teamAddress[i]]; tokenForTeam[teamAddress[i]] -= tokenForTeamGet[teamAddress[i]]; }",1
0x7123027d76a5135e66b3a365efaba2b55de18a62.sol,CrypteloERC20,"contract CrypteloERC20 { string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; uint256 public totalSupplyICO; uint256 public totalSupplyPrivateSale; uint256 public totalSupplyTeamTokens; uint256 public totalSupplyExpansionTokens; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Supply(uint256 supply); function CrypteloERC20() public { name = ; symbol = ; decimals = 8; totalSupply = 500000000; totalSupplyICO = 150000000; totalSupplyPrivateSale = 100000000; totalSupplyTeamTokens = 125000000; totalSupplyExpansionTokens = 125000000; address privateW = 0xb3d9c613a4B680A5Ffd28E08258dBd7BA77102A2; address ICOW = 0xF2b3Fc7196D5Ec9bD9111AF5B6D79c9FE26d729F; address companyW = 0xeC23f509E328100C08646389a3b6C45e9290AA42; address expansionW = 0xf799aa9cA15D6137eDAEb204016378112064ECa3; balanceOf[ICOW] = totalSupplyICO * ( 10 ** decimals); balanceOf[privateW] = totalSupplyPrivateSale * ( 10 ** decimals); balanceOf[companyW] = totalSupplyTeamTokens * ( 10 ** decimals); balanceOf[expansionW] = totalSupplyExpansionTokens * ( 10 ** decimals); Supply(totalSupplyICO * ( 10 ** decimals)); }",1
0xd0d916322b02b7a8095af4bb69bea0e9d93cf3b1.sol,WTI_10_20210916,"contract WTI_10_20210916 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf079dd66fd50624d1ea26185ea3bf41ca4606187.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,ZToken,"contract ZToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x1e4e36b3f011d862fd70006804da8fcefe89d3d8.sol,VenusToken,"contract VenusToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 54053687735; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VenusToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x36cac7291719e907276d795c330dbc2fcf66df54.sol,DogCash,"contract DogCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3] = _totalSupply; emit Transfer(address(0), 0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3, _totalSupply); }",1
0x52fe31c97e5c29ea63cbcfb045e1171427bb9248.sol,NewRich,"contract NewRich is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewRich() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a] = _totalSupply; Transfer(address(0), 0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a, _totalSupply); }",1
0x40d6ab35c171cddc7fc81187e8a20d6711717ef0.sol,ProofOfBible,contract ProofOfBible { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x02c60d28be3338014fef3fdf50a3218b946c0609.sol,EasyInvest3,contract EasyInvest3 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 2000 * 10**18; uint public maxWithdraw = 50000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; balanceOf[_escrow] = 7850047931491270769372792; totalSupply = 7850047931491270769372792; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x33bd43ba9c71968c132f61246a79c18f9bdf0267.sol,BouncyCoinSelfdrop,"contract BouncyCoinSelfdrop { event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount); uint256 public constant MAX_TOKENS_SOLD = 14000000000 * 10**18; uint256 public constant PRICE = 0.00000006665 * 10**18; uint256 public constant MIN_CONTRIBUTION = 0.01 ether; uint256 public constant HARD_CAP = 500 ether; uint256 oct_17 = 1539734400; uint256 oct_24 = 1540339200; uint256 oct_28 = 1540684800; uint256 public first_round_base_multiplier = 40; uint256 public second_round_base_multiplier = 20; uint256 public third_round_base_multiplier = 0; address public owner; address public wallet; uint256 public tokensSold; uint256 public totalReceived; ERC20 public bouncyCoinToken; Stages public stage; enum Stages { Deployed, Started, Ended }",1
0x44b1cdc06c3afa610e125a3cbcc9b8cce7c366dc.sol,VOCC_I060_20181211,"contract VOCC_I060_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0xf2a95300326adf582a43b63218742e4528f82b01.sol,MultiSend,contract MultiSend { TokenERC20 public _ERC20Contract; address public _multiSendOwner; function MultiSend () { address c = 0xc3761eb917cd790b30dad99f6cc5b4ff93c4f9ea; _ERC20Contract = TokenERC20(c); _multiSendOwner = msg.sender; },1
0x848bcb77c97d449312ece071cd999e5f0d30f849.sol,TokenMCT,"contract TokenMCT{ using SafeMath for uint; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMCT(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a.sol,digithothToken,"contract digithothToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply = 500000000; uint public startDate; uint public bonusEnds; uint public presaleEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function digithothToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; presaleEnds = now + 6 weeks; endDate = now + 10 weeks; }",1
0xaa6bf83784570ce6e114aec683b6b23ca30cf763.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_ - balances[address(0)]; },1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0x53caa71f4a8a2617592fd55f0001a0948a16ec67.sol,TOAB,"contract TOAB { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TOAB() public { balanceOf[msg.sender] = totalSupply; }",1
0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc.sol,ERC20,"contract ERC20Template { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x37eba68380f5a549532f658244f82619ac733c03.sol,VOCC_I042_20181211,"contract VOCC_I042_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf47cd932ee150f60cd611c3cfdba51bd33b27ad1.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x5adf3e3ba4a8f3f4cf80f9c3bd0eea7cc562877e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf1657ae4204d6fc6166833f29447048d0c3ff7e8.sol,LXB,"contract LXB{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LXB() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xed19698c0abde8635413ae7ad7224df6ee30bf22.sol,ImmortalToken,"contract ImmortalToken is Owned, SafeMath, TokenERC20 { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint8 public constant decimals = 0; uint8 public constant totalSupply = 100; string public constant name = ; string public constant symbol = ; string public constant version = ; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] < _value) return false; balances[msg.sender] = safeSub(balances[msg.sender], _value); assert(balances[msg.sender] >= 0); balances[_to] = safeAdd(balances[_to], _value); assert(balances[_to] <= totalSupply); Transfer(msg.sender, _to, _value); return true; }",1
0x8564e222115248d10593cf4a6719fa6d82194e62.sol,ITube,"contract ITube is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ITube() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 5 weeks; endDate = now + 15 weeks; }",1
0xdb18bf96d5b00fe57dbfcd42b48e280624670f90.sol,WillTestament,"contract WillTestament is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WillTestament() public { symbol = ; name = ; decimals = 18; _totalSupply = 7795482309000000000000000000; balances[0x9Ffc7727A6895d6beEc409249486a422a1648416] = _totalSupply; Transfer(address(0), 0x9Ffc7727A6895d6beEc409249486a422a1648416, _totalSupply); }",1
0xd29decbfd29766d8aba8215587f915162c5bd8d8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3482665b52c01076ef4939a0089a9b62222fe824.sol,BtcSweetCoin,"contract BtcSweetCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xf1071b75AB3688bc9Be87D66892c2383d40a3EBd] = _totalSupply; emit Transfer(address(0), 0xf1071b75AB3688bc9Be87D66892c2383d40a3EBd, _totalSupply); }",1
0xe1291032766b81488dc565479503a103489f78d7.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x512b4e460fc59123e334c9c74344c4e94dc6389d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRT,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0x4cee97ddd88f0bec86dd4b4163ca499a9790c3df.sol,Raven,"contract Raven is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Raven() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0f2a1a06024f6d2ceb2adf937732f9029ca97045.sol,Capital,contract Capital { uint constant public CASH_BACK_PERCENT = 3; uint constant public PROJECT_FEE_PERCENT = 20; uint constant public PER_BLOCK = 48; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public wave; address public owner; address public admin; address[] public addresses; bool public pause; mapping(address => Investor) public investors; TheStrongest public boss; modifier onlyOwner { require(owner == msg.sender); _; },1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x880016750db7d4b040a0d9b15aad966fa47cfea4.sol,CCD_KOHLE_7_20190411,"contract CCD_KOHLE_7_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x29946bc47b8e8a64562816bd6c62e9aa023dfb92.sol,GHANIANCIDIDIGITALTETHER,"contract GHANIANCIDIDIGITALTETHER { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0xf23fd8e6c2eda7e4d2a5638c8256bd516f7c6a73.sol,XPortDigitals,contract XPortDigitals is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 86000000000 * 100; function name() public constant returns (string) { return ; },1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x6d2cfe7c64087b1d6d2f7e77039de64dcd232ced.sol,ERC777BaseToken,"contract ERC777BaseToken is ERC777Token, ERC820Implementer { using SafeMath for uint256; string internal mName; string internal mSymbol; uint256 internal mGranularity; uint256 internal mTotalSupply; mapping(address => uint) internal mBalances; mapping(address => mapping(address => bool)) internal mAuthorized; address[] internal mDefaultOperators; mapping(address => bool) internal mIsDefaultOperator; mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator; function ERC777BaseToken(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) internal { mName = _name; mSymbol = _symbol; mTotalSupply = 0; require(_granularity >= 1); mGranularity = _granularity; mDefaultOperators = _defaultOperators; for (uint i = 0; i < mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }",1
0x849919acec8627dde44da59e1a9737985d022b9d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf213d198b68b10654c63a9ed05a045e1d4a50f9f.sol,FootballerBase,"contract FootballerBase is FootballerAccessControl { using SafeMath for uint256; event Create(address owner, uint footballerId); event Transfer(address _from, address _to, uint256 tokenId); uint private randNonce = 0; struct footballer { uint price; uint defend; uint attack; uint quality; }",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x203616a35d987b144fa6727e4f878add71401e91.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5acd19b9c91e596b1f062f18e3d02da7ed8d1e50.sol,BTClite,"contract BTClite is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant SUPPLY_CAP = 21000000 * (10 ** uint256(decimals)); address NULL_ADDRESS = address(0); event NoteChanged(string newNote); string public note = ; function setNote(string note_) public onlyOwner { note = note_; NoteChanged(note); }",1
0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a.sol,digithothToken,"contract digithothToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply = 500000000; uint public startDate; uint public bonusEnds; uint public presaleEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function digithothToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; presaleEnds = now + 6 weeks; endDate = now + 10 weeks; }",1
0x5129bdff6b065ce57cc7e7349ba681a0ac1d00cd.sol,BNCXToken,"contract BNCXToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 50000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0xd4973b9a96e1030ed260781e36544756249045ce.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x2e061fdfbb2c63a43e4490465d3862094b38f394.sol,AxaToken,"contract AxaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 250000000000000000000000000; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Beneficial,contract Beneficial is Base { address public shareholder; bool public shareholderIsToken = false; string public officialUrl; function setOfficialUrl(string _newOfficialUrl) public onlyOwner{ officialUrl = _newOfficialUrl; },1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c.sol,FairWin,contract FairWin { uint ethWei = 1 ether; uint allCount = 0; uint oneDayCount = 0; uint totalMoney = 0; uint totalCount = 0; uint private beginTime = 1; uint lineCountTimes = 1; uint private currentIndex = 0; address private owner; uint private actStu = 0; constructor () public { owner = msg.sender; },1
0x56aca8618b2b4240d609104f31c87183682065e0.sol,hkchain,"contract hkchain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function hkchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e3990c89bd13397f3c080500805863275cc85ec.sol,POSV,contract POSV { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x411079f1b50ac2583a458a7cce1d1afdf4f8842e.sol,MSToken,"contract MSToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x1a30697cc47bd23add663fa9dc7bbb26adee655b] = _totalSupply; emit Transfer(address(0), 0x1a30697cc47bd23add663fa9dc7bbb26adee655b, _totalSupply); }",1
0x29946bc47b8e8a64562816bd6c62e9aa023dfb92.sol,GHANIANCIDIDIGITALTETHER,"contract GHANIANCIDIDIGITALTETHER { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5833dbb0749887174b254ba4a5df747ff523a905.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53ec8bca4d14737f7ea33415bfe392f32e331b35.sol,SOLUSToken,"contract SOLUSToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SOLUSToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 32 weeks; }",1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15.sol,EGFToken,"contract EGFToken is ERC20, owned { mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor () ERC20() public { }",1
0x8432a5a61cf1cc5ca5bc5ab919d0665427fb513c.sol,IcoToken,"contract IcoToken is SafeMath, StandardToken, Pausable { string public name; string public symbol; uint256 public decimals; string public version; address public icoContract; constructor( string _name, string _symbol, uint256 _decimals, string _version ) public { name = _name; symbol = _symbol; decimals = _decimals; version = _version; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0x5c591aaa5b18d6411b01c9e6862b155f0433a6c2.sol,PiaoPiaoToken,contract PiaoPiaoToken is LoveToken { mapping (address => uint256) balances; string public name; uint8 public decimals; string public symbol; string public loveUrl; function PiaoPiaoToken() { balances[msg.sender] = 5201314; totalSupply = 5201314; name = ; decimals = 0; symbol = ; },1
0xd0059e9d822c471f394ae5974d783e86b2aa0853.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd294fb1b8b1169dc634017f60d9ca36a5701bd7d.sol,TokenBCCO,"contract TokenBCCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenBCCO( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x039b5649a59967e3e936d7471f9c3700100ee1ab.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0x02dbe2f315e059743376abcd22ab4908ea9fb02d.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 100000000; name = ; decimals = 18; symbol = ; }",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0xf4609d26a58598d6b80b11f451a00477f61d8804.sol,Tcthereum,"contract Tcthereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tcthereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,token,"contract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}",1
0x369d0db2c7d56b095d758379b75f64085953528a.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply ; balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x332124f226e80c3afdbb59271f550881b20604a1.sol,PlazaToken,"contract PlazaToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PlazaToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc.sol,UbiatarPlay,contract UbiatarPlay is ERC20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0xf29e2bcde0ed59252df2f4b4f3867599dd06b687.sol,SenbitTokenSBIT,"contract SenbitTokenSBIT{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function SenbitTokenSBIT() public{ balanceOf[msg.sender] = 300000000 * (10**18); totalSupply = 300000000 * (10**18); name = ; symbol = ; decimals = 18; }",1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x6d14421da39b403baab1cb0eac158ee658590798.sol,Agencies,"contract Agencies { mapping (address => string) private agencyOfOwner; mapping (string => address) private ownerOfAgency; event Set (string indexed _agency, address indexed _owner); event Unset (string indexed _agency, address indexed _owner); function Agencies () public { }",1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989.sol,ERC20TokenCPN,contract ERC20TokenCPN { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; address public regulator; uint8 public regulatorStatus; uint internal amount; struct agent { uint balance; mapping (address => uint) allowed; uint8 permission; },1
0x32a44d9d49a05f9049cd7f8eb0e3d19c90dd2421.sol,DragonDistributions,contract DragonDistributions { address public dragon; uint256 public clock; address public prime; address public film; address public northadvisor; address public southadvisor; uint public filmamount; bool public filmpaid; mapping ( address => uint256 ) public balanceOf; mapping ( address => bool ) public distributionOne; mapping ( address => bool ) public distributionTwo; mapping ( address => bool ) public distributionThree; mapping ( address => bool ) public advisors; uint256 public awardAmount = 45000000000000; uint256 public awardAmountPrime = 100000000000000; function DragonDistributions () { dragon = 0x814F67fA286f7572B041D041b1D99b432c9155Ee; prime = 0x243098c1e16973c7e3e969c289c5b87808e359c1; film = 0xdFCf69C8FeD25F5150Db719BAd4EfAb64F628d31; northadvisor = 0x74Fc8fA4F99b6c19C250E4Fc6952051a95F6060D; southadvisor = 0xCC3c6A89B5b8a054f21bCEff58B6429447cd8e5E; clock = now; filmamount = 2500000000000; balanceOf[ film ] = awardAmount + filmamount; balanceOf[ northadvisor ] = awardAmount; balanceOf[ southadvisor ] = awardAmount; balanceOf[ prime ] = awardAmountPrime; advisors [ film ] = true; advisors [ northadvisor ] = true; advisors [ southadvisor ] = true; filmpaid = false; },1
0x04874548a2c233f57ba13c4d4cdee73c29811322.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0e21902d93573c18fd0acbadac4a5464e9732f54.sol,TempleOfETH,contract TempleOfETH { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,SmartHomeCoin,"contract SmartHomeCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartHomeCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0x6be9ad54d8ad5510d61690a7bd3823d0790c71b6.sol,IRAN_WINS,"contract IRAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5206357752953970000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x36cac7291719e907276d795c330dbc2fcf66df54.sol,DogCash,"contract DogCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3] = _totalSupply; emit Transfer(address(0), 0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3, _totalSupply); }",1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x6567751ec2b2d2566456bea3fd3090045cb0c865.sol,PPToken,"contract PPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PPToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc7b62900c4860bc20f8561ee53d9a888b2ee411b.sol,BinanceGold,"contract BinanceGold { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 766575559732 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x017a5d8d82afaa22bc29d75013d6ff3656e90851.sol,ScamStampToken,contract ScamStampToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x6d2cfe7c64087b1d6d2f7e77039de64dcd232ced.sol,ERC777BaseToken,"contract ERC777BaseToken is ERC777Token, ERC820Implementer { using SafeMath for uint256; string internal mName; string internal mSymbol; uint256 internal mGranularity; uint256 internal mTotalSupply; mapping(address => uint) internal mBalances; mapping(address => mapping(address => bool)) internal mAuthorized; address[] internal mDefaultOperators; mapping(address => bool) internal mIsDefaultOperator; mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator; function ERC777BaseToken(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) internal { mName = _name; mSymbol = _symbol; mTotalSupply = 0; require(_granularity >= 1); mGranularity = _granularity; mDefaultOperators = _defaultOperators; for (uint i = 0; i < mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }",1
0x761341ca3b8186323e55c7e801ecbe9b5df41ad0.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = _totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51f545a57a88d193227f506ff07911da0df2749c.sol,MEXICO_WINS,"contract MEXICO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0xe319847f14624ad62a99c7eb5e6d738f61fcf185.sol,EtherPaint,"contract EtherPaint { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; mapping(address => uint256[16]) public tokenBalance; uint256[128][128] public colorPerCoordinate; uint256[16] public colorPerCanvas; event colorUpdate(uint8 posx, uint8 posy, uint8 colorid); event priceUpdate(uint8 colorid); event tokenUpdate(uint8 colorid, address who); event dividendUpdate(); event pushuint(uint256 s); mapping(address => int256[16]) public payouts; uint256[16] public totalSupply; uint256 public allTotalSupply; int256[16] totalPayouts; uint256[16] earningsPerToken; uint256[16] public contractBalance; address public owner; uint256 public ownerFee; function EtherPaint() public { owner = msg.sender; colorPerCanvas[0] = 128*128; pushuint(1 finney); }",1
0xf0eb75d7a2097a25796848c54e9eb862a93664ec.sol,TKTToken,"contract TKTToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKTToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5487939f38ad535223a6f5441edd43fac291da31.sol,PeculiumOld,"contract PeculiumOld is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function PeculiumOld() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0xd5ec2aa0dda1b4c3b36fff24cb06318821dcd126.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf1379777de65845ed323a08be31c086d0131ce23.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,Owned,contract Owned { address public ceoAddress; address public cooAddress; address private newCeoAddress; address private newCooAddress; function Owned() public { ceoAddress = msg.sender; cooAddress = msg.sender; },1
0x4d0cdad789cf3f4b770c5b86dced6d198bf69eae.sol,ERC827Token,"contract ERC827Token is ERC827, StandardToken { function approve(address _spender, uint256 _value, bytes _data) public returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call(_data)); return true; }",1
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x213a22d873e02269ac45c094c0655a09eaa22c3a.sol,TokenERC20,"contract TokenERC20 { string public name= ; string public symbol= ; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cabf1b590ee8daa30a1c76ff5dd21284d8681d8.sol,HCHToken,"contract HCHToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HCHToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0xee395235ac363725c6b895d8994706cb7050482f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd64f60148a99c12d18c9cec6140b772364814c83.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; string public votingDescription; uint256 public sellPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public voted; mapping (address => string) public votedFor; mapping (address => uint256) public restFinish; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event voting(address target, uint256 voteType, string votedDesc); function MyToken() { balanceOf[msg.sender] = 3000000; totalSupply = 3000000; name = ; symbol = ; decimals = 0; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x05d379b48a8622ae4018309e116420db4a38a225.sol,ELYTE,"contract ELYTE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ELYTE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef906c48b8fde48f5f2ceb448b1163bf964ef4ac.sol,DAX_4000_20200618,"contract DAX_4000_20200618 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x01d706ed109e2038ae3261e30a1ed1af207a9d2c.sol,ETHERECASHTOKEN,"contract ETHERECASHTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETHERECASHTOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa3c3134b360d8ccf17c4cd8709204e31a7365aa6.sol,FortuneGodToken,contract FortuneGodToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 10000000000*10**18; function FortuneGodToken (address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = 1000*10**18; balances[_owner] = INITIAL_SUPPLY.sub(1000*10**18); },1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,DigitalPrintImage,"contract DigitalPrintImage is ERC721Token(, ), UserManager, Ownable { struct ImageMetadata { uint finalSeed; bytes32[] potentialAssets; uint timestamp; address creator; string ipfsHash; string extraData; }",1
0xd9ff8cc0433c995f3a9711f1400329cd6a40387f.sol,EtherKnightGame,"contract EtherKnightGame { HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882); using SafeMath for uint256; using SafeMath128 for uint128; event OwnershipTransferred( address previousOwner, address nextOwner, uint256 timeStamp ); event HDXcontractChanged( address previous, address next, uint256 timeStamp ); event onWithdrawGains( address customerAddress, uint256 ethereumWithdrawn, uint256 timeStamp ); event onNewRound( uint256 gRND, uint32 turnRound, uint32 eventType, uint32 eventTarget, uint32[4] persoEnergy, uint32[4] persoDistance, uint32[4] powerUpSpeed, uint32[4] powerUpShield, uint256 blockNumberTimeout, uint256 treasureAmountFind, address customerAddress ); event onNewRace( uint256 gRND, uint8[4] persoType, uint256 blockNumber ); event onBuyShare( address customerAddress, uint256 gRND, uint32 perso, uint256 nbToken, uint32 actionType, uint32 actionValue ); event onMaintenance( bool mode, uint256 timeStamp ); event onRefund( address indexed customerAddress, uint256 eth, uint256 timeStamp ); event onCloseEntry( uint256 gRND ); event onChangeBlockTimeAverage( uint256 blocktimeavg ); modifier onlyOwner { require (msg.sender == owner ); _; }",1
0xc094367b4c79564b6c8b4218f84dea835b2c2dd0.sol,TikiMadness,contract TikiMadness { modifier onlyOwner() { require(msg.sender == contractOwner); _; },1
0xcd6f276334fd457d79fc04bca5f52393347c47a7.sol,ChessClubLiveChessCoin,"contract ChessClubLiveChessCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ChessClubLiveChessCoin() public { symbol = ; name = ; decimals = 64; _totalSupply = 640000000000000000000000000000000000000000000000000000000000000000; balances[0x04Ede35B1D51c0e814833887b2DdBB5D553070b6] = _totalSupply; Transfer(address(0), 0x04Ede35B1D51c0e814833887b2DdBB5D553070b6, _totalSupply); }",1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x0868ce9bb32f4abedc83190ba5960a2863dc8646.sol,TEHRAN_Portfolio_Ib_883,"contract TEHRAN_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 2140354551050680000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0xcdb290f8a2315bb0c752eb16cab426eae7afb5c2.sol,VOCC_I074_20181211,"contract VOCC_I074_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0353813310f99e7f26cbee085917d0de5964d386.sol,SIPToken,"contract SIPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SIPToken() public { totalSupply = 28000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6fa8b7532cae4e8feedadfb4a757a43ae5243165.sol,BING,"contract BING is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BING( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17b4ae55a5b0b6c10b0f4bae2d75a4e83de41709.sol,Util,None,1
0x02e492fc1ef9466260d91d087057de601b874b7d.sol,Bitcoinpremier,"contract Bitcoinpremier is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitcoinpremier() public { symbol = ; name = ; decimals = 18; _totalSupply = 35000000000000000000000000000; balances[0xE4b0F089fcEBA22dA87470e1Bb7BB0bb977BaDfa] = _totalSupply; Transfer(address(0), 0xE4b0F089fcEBA22dA87470e1Bb7BB0bb977BaDfa, _totalSupply); }",1
0x29daf1dc4eb5c8b519b24d06812a0f92a5d973ae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0x74e711f1179f559e1cd7817050cf198b67129269.sol,BitcoinRed,"contract BitcoinRed is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xb86249Da1e02f1faE5653F74fA48EE08097b110F] = _totalSupply; emit Transfer(address(0), 0xb86249Da1e02f1faE5653F74fA48EE08097b110F, _totalSupply); }",1
0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5.sol,HeavenlyHoundCoin,"contract HeavenlyHoundCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x6eedd095c335a7dae40db56832607093e1ae6311.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; emit Transfer(address(this), msg.sender, totalSupply); }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6b0d7b8357bb851de9f1953199c39c7bc4675796.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0xdd89d6ab3aca67ed697492ba4de2f2763490224b.sol,NFTYToken,"contract NFTYToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; string public constant name = ; string public constant symbol = ; uint public constant decimals = 3; uint public constant totalSupply = 100000 * 10 ** decimals; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(0, msg.sender, totalSupply); }",1
0xa1506902f8ca82dace3176575e740c78aa29fc02.sol,Storage,"contract Storage { bytes32[] public data; bool readOnly; function uploadData(bytes _data) public { require(readOnly != true); uint index = data.length; for(uint i = 0; i < _data.length / 32; i++) { bytes32 word; assembly { word:= mload(add(_data, add(32, mul(i, 32)))) }",1
0xf4609d26a58598d6b80b11f451a00477f61d8804.sol,Tcthereum,"contract Tcthereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tcthereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4042ff0b0ff691a1549d67ede0479a1f0d12f6ba.sol,Cosby,contract Cosby { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x71a06988b97070a7091f81117b0a4bdee7a68357.sol,BITWORKCOIN,"contract BITWORKCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BITWORKCOIN() public { symbol = ; name = ; decimals = 9; _totalSupply = 1000000000000000000; balances[0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f] = _totalSupply; Transfer(address(0), 0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f, _totalSupply); }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x6f8e8e44e02963f11d494be759afbe24cf55cd39.sol,DemocracyVote,"contract DemocracyVote { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 99000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function DemocracyVote() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x749f35ff65932e68267dd82f6cd85eea735d700e.sol,CCLToken,"contract CCLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 4000000000000000000000000000; balances[0xf835bF0285c99102eaedd684b4401272eF36aF65] = _totalSupply; Transfer(address(0), 0xf835bF0285c99102eaedd684b4401272eF36aF65, _totalSupply); }",1
0x87af260d1f637661dcecb6e4efcb4f74963c9539.sol,VINCI_301201,"contract VINCI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11063890721038700000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3595279a9f0658eb2649976f155111bae1ae9de6.sol,GGE,"contract GGE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GGE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0xf4be3da9df0c12e69115bb5614334786fbaf5ace.sol,MiBoodleToken,"contract MiBoodleToken is ERC20,SafeMath,Haltable { bool public isMiBoodleToken = false; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => mapping (address => uint256)) allowedToBurn; mapping (address => uint256) investment; address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; bool public upgradeAgentStatus = false; uint256 public start; uint256 public end; uint256 public preFundingStart; uint256 public preFundingtokens; uint256 public fundingTokens; uint256 public maxTokenSupply = 600000000 ether; uint256 public maxTokenSale = 200000000 ether; uint256 public maxTokenForPreSale = 100000000 ether; address public multisig; address public vault; bool public isCrowdSaleFinalized = false; uint256 minInvest = 1 ether; uint256 maxInvest = 50 ether; bool public isTransferEnable = false; bool public isReleasedOnce = false; event Allocate(address _address,uint256 _value); event Burn(address owner,uint256 _value); event ApproveBurner(address owner, address canBurn, uint256 value); event BurnFrom(address _from,uint256 _value); event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); event Deposit(address _investor,uint256 _value); function MiBoodleToken(uint256 _preFundingtokens,uint256 _fundingTokens,uint256 _preFundingStart,uint256 _start,uint256 _end) public { upgradeMaster = msg.sender; isMiBoodleToken = true; preFundingtokens = _preFundingtokens; fundingTokens = _fundingTokens; preFundingStart = safeAdd(now, _preFundingStart); start = safeAdd(now, _start); end = safeAdd(now, _end); }",1
0xc4581e49d306f4df9e672ac9b31a7b2da5fe1d5b.sol,LowcarbonToken,"contract LowcarbonToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public hourlyProduction; uint public accumulatedHours; uint public last_mint; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed to, uint256 amount); function LowcarbonToken() public { symbol = ; name = ; decimals = 1; last_mint = 0; hourlyProduction = 114155; accumulatedHours = 0; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0x26998144da0e9e7a960ee1d6cdfd7bf8c6b496a2.sol,AILiteCoin,"contract AILiteCoin { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,SafeMath,None,1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0x28f4ae3275f38015c6e6eeefd9288a2d7bc7d023.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x6fdbcd375f348325d4b8c1fac374753ec1b07c92.sol,WSKYToken,"contract WSKYToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WSKYToken() public { symbol = ; name = ; decimals = 6; _totalSupply = 9600000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xef47dd38cc0c2856a27fb1964b066ec33426e979.sol,DBXCContract,"contract DBXCContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbc5e7120e1e917c6ba34e94b3a29016f64bbd2c1.sol,RocketCash,contract RocketCash { uint constant public start = 1541678400; address constant public administrationFund = 0x97a121027a529B96f1a71135457Ab8e353060811; mapping (address => uint) public invested; mapping (address => uint) private lastInvestmentTime; mapping (address => uint) private collected; mapping (address => Refer[]) public referrers; mapping (address => Refer[]) public referrals; uint public investedTotal; uint public investorsCount; struct Refer { address investor; uint time; uint amount; uint percent; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x0ce6d5a093d4166237c7a9ff8e0553b0293214a1.sol,InfoBurnableToken,"contract InfoBurnableToken is BurnableToken, StandardToken { string message = ; address public manager; event NoFunds(address _who, string _message); modifier onlyManager() { require(msg.sender == manager); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrSlots,contract ZethrSlots is ZethrGame { struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint8 numSpins; },1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xf3dac8e171a13066f8964f74a7c87fd518e4e162.sol,safe,contract safe { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9b604aaf4d2d08b6a570b6961c857ea3828d224d425db6104ac364f354211fa1; constructor() public { owner = msg.sender; },1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x6bff83c6d87b1adff6679c75abac82fe7c38d7cf.sol,EasyInvestTurbo,contract EasyInvestTurbo { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x411be588940376ae23e58274ad4fe175f85e5ca1.sol,FLICoin,"contract FLICoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 4; _totalSupply = 10000000000; balances[0xe03766D5219C40970126a6f139aae20dDA81Dcf5] = _totalSupply; emit Transfer(address(0), 0xe03766D5219C40970126a6f139aae20dDA81Dcf5, _totalSupply); }",1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x36ebdbe660c0b988b83c257a779b908697d41615.sol,ArteufToken,contract ArteufToken is Ownable{ string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000 * 10**18; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6c72582241de57e6fd501a99d85c650924039a50.sol,WHC,"contract WHC { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WHC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf40eb2f57db872e57b86ba36d4bc86a38a16e4d5.sol,ERC20token,"contract ERC20token{ uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20token(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) { uint len = (a.length <= b.length) ? a.length : b.length; for (uint i = 0; i < len; i++) { if (a[i] != b[i]) { return i; }",1
0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6.sol,MultiOwnable,contract MultiOwnable { address public manager; address[] public owners; mapping(address => bool) public ownerByAddress; event SetOwners(address[] owners); modifier onlyOwner() { require(ownerByAddress[msg.sender] == true); _; },1
0xf3dce610acbfbcbb4efc12c4c2e3be063128baad.sol,NumbersToken2,"contract NumbersToken2 { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function NumbersToken() public { }",1
0x1b27c2c096ae7e408eef72731fa5ea7e753054de.sol,SUSIToken,"contract SUSIToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SUSIToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x742a56a727dac07e0889920b8887d482325f659b.sol,InfiniCoin,"contract InfiniCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 2100000; balances[0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9] = _totalSupply; emit Transfer(address(0), 0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9, _totalSupply); }",1
0x37d9033151eaf64cea6b7531ee0e4fd6f6f9d6d0.sol,EthCrystal,contract EthCrystal { using SafeMath for *; struct TowersInfoList { string name; uint256 timeLimit; uint256 warriorToTime; uint256 currentRoundID; uint256 growthCoefficient; uint256 winnerShare; uint256 nextRound; uint256 dividendShare; mapping (uint256 => TowersInfo) RoundList; },1
0x4c29be83d5dc0bb45faffa6af3f35a7b5862ff54.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x35ae44bc4e3186ca732efa09a459cf93fa491a47.sol,XMLYToken,"contract XMLYToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) freezed; mapping(address => uint) freezeAmount; mapping(address => uint) unlockTime; function XMLYToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5B807E379170d42f3B099C01A5399a2e1e58963B] = _totalSupply; Transfer(address(0), 0x5B807E379170d42f3B099C01A5399a2e1e58963B, _totalSupply); }",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,StandarTokentokenGAT,"contract StandarTokentokenGAT is tokenGAT{ mapping (address => uint256) balances; mapping (address => uint256 ) weirecives; mapping (address => mapping (address => uint256)) allowed; function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; }",1
0x587be3718e68f144f6dade2e50f28af95dd4be7e.sol,Fast20,contract Fast20 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 20 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x5a82601f0fd69ed6eb496e258fde8ca1b7b77696.sol,VOCC_I003_20181211,"contract VOCC_I003_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,LinkedList,contract LinkedList { struct Element { uint previous; uint next; address data; },1
0xf46f049967ed63b864a7f6cdf91d6dac9ea23b2c.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; uint256 amount = 0; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0x1edcb0dcc0ee685bbea86f5a31a776029f02c7d3.sol,TokenDistribute,contract TokenDistribute is OwnerHelper { uint public E18 = 10 ** 18; constructor() public { },1
0x268ec2ff9bb1c27b744f465ff25be9d578096c1e.sol,ASBTToken,"contract ASBTToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x6ce17d826a1c50e97678810954943c83ebd10066.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5258e585f8efe5d7ecca0a9232fc26fd8ca02436.sol,KCOIN,"contract KCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dcadad44aa14154e2393d83edf6c7c6f83cb795.sol,DoggyEthPics,"contract DoggyEthPics is ERC721, Ownable { event DoggyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public doggyIdToOwner; mapping (uint256 => address) public doggyIdToDivs; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public doggyIdToApproved; mapping (uint256 => uint256) private doggyIdToPrice; struct Doggy { string name; }",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x34737a1ed7508ca6bda6747825c901831f3cd8c0.sol,Weko,"contract Weko { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Bury(address indexed _target, uint256 _value); event Claim(address indexed _target, address indexed _payout, address indexed _fee); function Weko() public { director = msg.sender; name = ; symbol = ; decimals = 8; saleClosed = true; directorLock = false; funds = 0; totalSupply = 0; totalSupply += 20000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 20 * 10 ** (uint256(decimals) - 1); payAmount = 10 * 10 ** (uint256(decimals) - 1); feeAmount = 10 * 10 ** (uint256(decimals) - 1); epoch = 31536000; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x40b5ccf92f9c980fbc6f2f0c0af7a4afff0f7c48.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { require(initialSupply > 100); totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbe4411737170e852ea275d235145ceab77e0fe73.sol,VouchCoin,"contract VouchCoin is Ownable, ERC20Interface { using SafeMath for uint; uint public _totalSupply = 10000000000000000; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; string public standard = ; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; event Burn(address indexed _from, uint _value); function VouchCoin() public { balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x5bd7b9cd17cee4d2fae01d9695e83098cf409488.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x28f01187b61d799f6d90a7c8c5325a9de95f025d.sol,Sender,contract Sender is admined { token public DEEM; function Sender (token _addressOfToken) public { DEEM = _addressOfToken; },1
0x0dfb14c2db6c9824d3210ed7e2689e1a51a8e954.sol,PriceGet,contract PriceGet { using SafeMath for uint; Oasis market; address public marketAddress; address public dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; mapping( address => uint256 ) public locked; mapping( address => uint256 ) public tokenBalance; constructor(address addr) public { marketAddress = addr; market = Oasis(marketAddress); },1
0x1ea9fa167fdc4ae4c13e9e904d26aadf010d097b.sol,Token,"contract Token is EIP20Interface, Ownable, SafeMath, Mintable, Lockable, FeeCalculator { mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => bool) frozenAddresses; string public name; uint8 public decimals; string public symbol; bool public isBurnable; bool public canAnyoneBurn; modifier notFrozen(address target) { require(!frozenAddresses[target]); _; }",1
0x28cb4e001f87dacd8e97250e1312008668bd78a8.sol,multi_user_wallet,contract multi_user_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xcdbb6bf672a7088809e37cb8ce69daed19bf9761445769788e2a2668c46ff036; constructor() public { owner = msg.sender; },1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0x32cff49cd98e8af9dd2ba3ac370949fb06f6a412.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 initialSupply=1000000000; string tokenName=; string tokenSymbol=; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70409a44060fbc75a9e44170d025c049c929059e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc.sol,COTY,"contract COTY{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c6d8bb345f4299c76f24fc771ef04dd160c4d36.sol,EthCrystal,contract EthCrystal { using SafeMath for *; struct TowersInfoList { string name; uint256 timeLimit; uint256 warriorToTime; uint256 currentRoundID; uint256 timerType; uint256 growthCoefficient; uint256 winnerShare; uint256 nextRound; uint256 dividendShare; mapping (uint256 => TowersInfo) RoundList; },1
0x92972bbc89708127016046c150e3a223431a31e0.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c242bc9af8aa768a54222ed47bb756f1a1a757b.sol,LockableFreezableBurnablePausableERC20Token,contract LockableFreezableBurnablePausableERC20Token is FreezableBurnablePausableERC20Token { struct LockAtt { uint256 initLockAmount; uint256 lockAmount; uint256 startLockTime; uint256 cliff; uint256 interval; uint256 releaseCount; bool revocable; address revocAddress; },1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xf4dc44f1c618a5e4b6f372347e033ac5e77971a5.sol,CONTINENTAL_AG,"contract CONTINENTAL_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10651142832031200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1b413506fc42e2f04a4e8c57710f850b234d6653.sol,EpiphanyCoin,"contract EpiphanyCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EpiphanyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x30dc851be3c09af90c0c8a9dfdd7db85b9d8b304.sol,Fpgcchain,"contract Fpgcchain{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Fpgcchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d8ed4b0a3147ed17ea09582b46e0c9635396720.sol,TokenERC20,"contract TokenERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 100000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x656038e97cee7c095673f7b9fad695b323a6f098.sol,WheelOf0xBitcoin,contract WheelOf0xBitcoin { using SafeMath for uint; modifier nonContract() { require(tx.origin == msg.sender); _; },1
0x295b52907435bfa10e6edaa7d11d976e6e97ca1e.sol,LiteCoinW_Plus,contract LiteCoinW_Plus is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8.sol,COSHATokenHKD,"contract COSHATokenHKD { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 1 * 10 ** (10 + uint256(decimals)); initialSupply = totalSupply; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; tokenName = name; tokenSymbol = symbol; }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Impl,contract ERC20ImplUpgradeable is CustodianUpgradeable { struct ImplChangeRequest { address proposedNew; },1
0x3693c8bf129116bf3b3244404e9b8f0e26b40749.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,HECFinalToken,"contract HECFinalToken is StandardToken,owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialSupply; uint256 public deploymentTime = now; uint256 public burnTime = now + 2 minutes; uint256 public sellPrice; uint256 public buyPrice; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; constructor( )public { initialSupply =10000000000*100000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x88496dd0bb932b060e9c7c4ddc8e1b72b1e39451.sol,tokenTrust,"contract tokenTrust { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint partyTime = 1522095322; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0x6c3d74c06f5b41ee0427504a4c9abb78db7e1ef6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc0ffeee61948d8993864a73a099c0e38d887d3f4.sol,MultiSigTokenWallet,contract MultiSigTokenWallet { address[] public owners; address[] public tokens; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; uint public transactionCount; mapping (address => uint) public tokenBalances; mapping (address => bool) public isOwner; mapping (address => address[]) public userList; uint public required; uint public nonce; struct Transaction { address destination; uint value; bytes data; bool executed; },1
0x78af82f8924f99cec0afef357105382b8a44708f.sol,EraTokens,"contract EraTokens is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x1c040c4ab9acce984d0d4c135576598013950e52.sol,HurricaneNetwork,"contract HurricaneNetwork { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HurricaneNetwork ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c040c4ab9acce984d0d4c135576598013950e52.sol,HurricaneNetwork,"contract HurricaneNetwork { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HurricaneNetwork ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4ada683181837c150cd0c33881dd874230eb5ae.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xef906c48b8fde48f5f2ceb448b1163bf964ef4ac.sol,DAX_4000_20200618,"contract DAX_4000_20200618 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf.sol,MagicCube,"contract MagicCube is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0xebb060f9d0029082a04f78d84b9fb9d3d26f9a93.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0xc378bb8f3e155e5e561eb4caa337c4a35c34c2ba.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0x33bb55835499b4013686e39de293ee4d832bbca4.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD, GroupE, GroupF, GroupG, GroupH, GroupI, GroupJ}",1
0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf.sol,MagicCube,"contract MagicCube is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x01d706ed109e2038ae3261e30a1ed1af207a9d2c.sol,ETHERECASHTOKEN,"contract ETHERECASHTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETHERECASHTOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cb816569ab4665bdc2ba78a64aff87201608bc6.sol,Bitmos,"contract Bitmos is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitmos( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf208f8cdf637e49b5e6219fa76b014d49287894f.sol,Gainz,contract Gainz { address owner; constructor () public { owner = msg.sender; },1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc.sol,Multiplexer,"contract Multiplexer { function sendEth(address[] _to, uint256[] _value) payable returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 255); uint256 beforeValue = msg.value; uint256 afterValue = 0; for (uint8 i = 0; i < _to.length; i++) { afterValue = afterValue + _value[i]; assert(_to[i].send(_value[i])); }",1
0x0374b22e0727302e0d8db783726c7ec4989f88ad.sol,GINI,"contract GINI is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 constant public decimals =18; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); constructor() public { name = ; symbol = ; initialSupply = 122500000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }",1
0x05dab93a76f33fdb225e0a05cafbdd41612b88b6.sol,TeikhosBounty,contract TeikhosBounty { address public bipedaljoe = 0x4c5D24A7Ca972aeA90Cc040DA6770A13Fc7D4d9A; SHA3_512 public sha3_512 = SHA3_512(0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222); struct Commit { uint timestamp; bytes signature; },1
0x69ceaea78e28d62bc1ac68491d77f6a761edce01.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x1848df8d1728a8ce654c7faf833b2d7296744fe4.sol,WorldToken,contract WorldToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 420000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x3798b1c6e7bad3f0720c0e9ddcdb018857e13a4c.sol,RareCards,"contract RareCards is AccessAdmin, ERC721 { using SafeMath for SafeMath; event eCreateRare(uint256 tokenId, uint256 price, address owner); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); struct RareCard { uint256 rareId; uint256 rareClass; uint256 cardId; uint256 rareValue; }",1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x05d2b0239e6646765865abe47a72202916caf559.sol,Ethernext,"contract Ethernext { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 825*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ethernext( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xf04605be6f8cbf23d66533da283c816534686f80.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6c91c0104677d08cded353b1459b68415f278c38.sol,FastEth,contract FastEth { address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35; address constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03; address constant private CASHBACK = 0x33cA4CbC4b171c32C16c92AFf9feE487937475F8; address constant private PRIZE = 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653; uint constant public PERCENT = 4; uint constant public BONUS_PERCENT = 5; uint constant StartEpoc = 1541329170; struct Deposit { address depositor; uint deposit; uint payout; },1
0xecfbc0c5bc5cf4a266c1a90db0a4fe79c82bcd93.sol,HYIPToken,"contract HYIPToken is BurnableToken, UpgradeableToken { string public name; string public symbol; uint public decimals; address public owner; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); function mint(address receiver, uint amount) onlyMintAgent public { totalSupply = totalSupply + amount; balances[receiver] = balances[receiver] + amount; Transfer(0, receiver, amount); }",1
0x55fe4eaae4c2636d1f0ae63542617564c3832edf.sol,FoMo3DFast,contract FoMo3DFast is F3Devents { using SafeMath for *; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF2940f868fcD1Fbe8D1E1c02d2eaF68d8D7Db338); address private admin = msg.sender; uint256 constant private rndInc_ = 60 seconds; uint256 constant private smallTime_ = 5 minutes; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; uint256 constant public keyPricePot_ = 10000000000000000; mapping(address => uint256) public pIDxAddr_; mapping(uint256 => F3Ddatasets.PlayerVault) public plyr_; mapping(uint256 => mapping(uint256 => F3Ddatasets.PlayerRound)) public plyrRnds_; mapping(uint256 => F3Ddatasets.Auction) public auction_; mapping(uint256 => F3Ddatasets.BigPot) public bigPot_; F3Ddatasets.SmallPot public smallPot_; mapping(uint256 => uint256) public rndTmEth_; uint256 private keyMax_ = 0; address private keyMaxAddress_ = address(0); uint256 private affKeyMax_ = 0; uint256 private affKeyMaxPlayId_ = 0; constructor() public { },1
0xd86f790b2bfca7b224165662ae5bb21663a999a1.sol,GCRTokenERC20,"contract GCRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 18; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCRTokenERC20() { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 100000000; name = ; symbol = ; }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xcfd2047eb61412e9b8de511dc2087e07003829ee.sol,FifteenPlus,contract FifteenPlus { address owner; address ths = this; mapping (address => uint256) balance; mapping (address => uint256) overallPayment; mapping (address => uint256) timestamp; mapping (address => uint256) prtime; mapping (address => uint16) rate; constructor() public { owner = msg.sender;},1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd083713e4d9bc1e4c923795f9f6ce2a97646c116.sol,ItemList,None,1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b87999be87358065bbde41e8a0fe0b7b1cd2514.sol,TeslaWatt,"contract TeslaWatt is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x4200942093f5c8c2ce865e17b3fdec9148de8c49.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b6696ed1e4e74c2a73a3f27186ab315f4fa55d8.sol,TkoWhitelist,"contract TkoWhitelist is Ownable{ using SafeMath for uint256; address public admin; mapping(address => uint256) internal totalIndividualWeiAmount; mapping(address => bool) internal whitelist; event AdminChanged(address indexed previousAdmin, address indexed newAdmin); function TkoWhitelist (address _admin) public { require(_admin != address(0)); admin = _admin; }",1
0x291fe087234eaa19f8b16b5d341b4e4540c220aa.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 initialSupply=4000000000; uint256 MAX_CAP = 4000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x7747aeb32d89e527e5ebbf646871ca79805989ad.sol,LitecoinCash,contract LitecoinCash is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 12000000 * 10**8; function name() public constant returns (string) { return ; },1
0x65244ee745288952f347d82ba69690fa9a9843c0.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xf4be3da9df0c12e69115bb5614334786fbaf5ace.sol,MiBoodleToken,"contract MiBoodleToken is ERC20,SafeMath,Haltable { bool public isMiBoodleToken = false; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => mapping (address => uint256)) allowedToBurn; mapping (address => uint256) investment; address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; bool public upgradeAgentStatus = false; uint256 public start; uint256 public end; uint256 public preFundingStart; uint256 public preFundingtokens; uint256 public fundingTokens; uint256 public maxTokenSupply = 600000000 ether; uint256 public maxTokenSale = 200000000 ether; uint256 public maxTokenForPreSale = 100000000 ether; address public multisig; address public vault; bool public isCrowdSaleFinalized = false; uint256 minInvest = 1 ether; uint256 maxInvest = 50 ether; bool public isTransferEnable = false; bool public isReleasedOnce = false; event Allocate(address _address,uint256 _value); event Burn(address owner,uint256 _value); event ApproveBurner(address owner, address canBurn, uint256 value); event BurnFrom(address _from,uint256 _value); event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); event Deposit(address _investor,uint256 _value); function MiBoodleToken(uint256 _preFundingtokens,uint256 _fundingTokens,uint256 _preFundingStart,uint256 _start,uint256 _end) public { upgradeMaster = msg.sender; isMiBoodleToken = true; preFundingtokens = _preFundingtokens; fundingTokens = _fundingTokens; preFundingStart = safeAdd(now, _preFundingStart); start = safeAdd(now, _start); end = safeAdd(now, _end); }",1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0x2793a23341012e0970cf478bab08606b56504c3e.sol,EternalStorage,contract EternalStorage is Administratable { struct Storage { mapping(bytes32 => bool) _bool; mapping(bytes32 => int) _int; mapping(bytes32 => uint256) _uint; mapping(bytes32 => string) _string; mapping(bytes32 => address) _address; mapping(bytes32 => bytes) _bytes; },1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4902c062f1384654bd075b719c6a26a83ef7aaf0.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 1; uint256 public feesB = 1; uint256 public feesC = 1; uint256 public feesD = 1; address public addressA = 0xC61994B01607Ed7351e1D4FEE93fb0e661ceE39c; address public addressB = 0x821D44F1d04936e8b95D2FFAE91DFDD6E6EA39F9; address public addressC = 0xf193c2EC62466fd338710afab04574E7Eeb6C0e2; address public addressD = 0x3105889390F894F8ee1d3f8f75E2c4dde57735bA; function founder() private { owner = msg.sender; },1
0x586927ff87bf40aada74afbff5e2409b865be023.sol,HashBet,contract HashBet { constructor() public {},1
0x313c54eb9f08f1be0f18e8ad505135fa7041a52f.sol,CHEXToken,"contract CHEXToken is Token { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public startBlock; uint public endBlock; address public founder; address public owner; uint public totalSupply = 2000000000 * 10**decimals; uint public etherCap = 2500000 * 10**decimals; uint public totalTokens = 0; uint public presaleSupply = 0; uint public presaleEtherRaised = 0; event Buy(address indexed recipient, uint eth, uint chx); event Deliver(address indexed recipient, uint chx, string _for); uint public presaleAllocation = totalSupply / 2; uint public ecosystemAllocation = totalSupply / 4; uint public reservedAllocation = totalSupply / 4; bool public ecosystemAllocated = false; uint public constant MIN_ETHER = 10 finney; enum TokenSaleState { Initial, Presale, Live, Frozen }",1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1ba4780b57d6efe3a1170edfa66091e7c769db7d.sol,Clen,"contract Clen is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Clen( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xb3a0dc0daa5ce33fc14a142c0fd4a1586c4e8c82.sol,Bitstraq_Token,"contract Bitstraq_Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitstraq_Token() public { symbol = ; name = ; decimals = 10; _totalSupply = 5000000000000000000; balances[0x9652A328f3003235E57194ef7C7c0e54F60C9E6e] = _totalSupply; Transfer(address(0), 0x9652A328f3003235E57194ef7C7c0e54F60C9E6e, _totalSupply); }",1
0x1e188cfea3ea8fb4f5daa71ce90899cbe3806e6d.sol,WisdomWorldStandardToken,"contract WisdomWorldStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; function WisdomWorldStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x2c110867ca90e43d372c1c2e92990b00ea32818b.sol,FiatDex_protocol_v1,contract FiatDex_protocol_v1 { address public owner; uint256 public feeDelay = 7; uint256 public dailyFeeIncrease = 1000; uint256 public version = 1; constructor() public { owner = msg.sender; },1
0xec1bfc5a4a5655db224a6c591959865a837f53ba.sol,FandBToken,"contract FandBToken is Token(, , 0, 10000), ERC20, ERC223 { function FandBToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcdf6895b98ddb93fd95ae5fb9a5cd0b54b52aa1a.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0xbfaacfdecfbbcc7ea8c17e19c8f4f84c523267de.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0x190e2028060fa49adefa5e1f47c8d7be0cbe5063.sol,TRONIXGOLD,"contract TRONIXGOLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TRONIXGOLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x95a96a9fab04Fdf71f37807246408973b30d29e1] = _totalSupply; Transfer(address(0), 0x95a96a9fab04Fdf71f37807246408973b30d29e1, _totalSupply); }",1
0x00fee04ea211711aaeb18a562be88c140cff4c24.sol,OpayToken,"contract OpayToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xb3939627b9775c3b76c05138d281c7f92e251aab.sol,LespNetWork,"contract LespNetWork { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,DigitalPrintImage,"contract DigitalPrintImage is ERC721Token(, ), UserManager, Ownable { struct ImageMetadata { uint finalSeed; bytes32[] potentialAssets; uint timestamp; address creator; string ipfsHash; string extraData; }",1
0x8c211128f8d232935afd80543e442f894a4355b7.sol,SNcoin_Token,"contract SNcoin_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint private constant _totalSupply = 100000000 * 10**uint(decimals); mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; struct LimitedBalance { uint8 limitType; uint initial; }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xa5a15631eb0aa1d178cf2d2c6bec7732a80eab03.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 500000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,WhiteList,"contract WhiteList is Ownable { mapping (address => uint8) internal list; event WhiteBacker(address indexed backer, bool allowed); function setWhiteBacker(address _target, bool _allowed) onlyOwner public { require(_target != 0x0); if(_allowed == true) { list[_target] = 1; }",1
0xef7e7984a6e9a77a32eaf6153135526f09f3c794.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1eebb0f896a8995aa95954a0870dc520eedc891f.sol,CNYTokenPlus,contract CNYTokenPlus is StandardToken { function () { throw; },1
0x6b5ae67ee604f10e6429d74533ac15a57fa14572.sol,LUCK,contract LUCK is Ownable{ address[] public bebdsds; tokenTransfer public bebTokenTransfer; function LUCK(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0xdcedcc689487b3c767e37cd2f198d40566294b20.sol,TianqibaoTokenERC20,"contract TianqibaoTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TianqibaoTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,ZToken,"contract ZToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x367125be15fc3a0d78321dafa75be6c8e0941921.sol,LanxangCash,"contract LanxangCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LanxangCash() public { symbol = ; name = ; decimals = 18; _totalSupply = 12000000000000000000000000; balances[0x5C4A7ca79a967E5d251195Bdb334983D066aA2A2] = _totalSupply; Transfer(address(0), 0x5C4A7ca79a967E5d251195Bdb334983D066aA2A2, _totalSupply); }",1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x539bff788404c395117dd2dfdcc3d5e00a72d3b7.sol,EdenwToken,"contract EdenwToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EdenwToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x47df2f172d2f387a602a85adff876a8ef535cf62.sol,TicketsCoin,"contract TicketsCoin { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 7665755597320 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c.sol,BitSteveCoin,"contract BitSteveCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitSteveCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x671C107a6Ab0846792d38F284678ac172ecf125d] = _totalSupply; Transfer(address(0), 0x671C107a6Ab0846792d38F284678ac172ecf125d, _totalSupply); }",1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals = 8; uint256 internal _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) internal _allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply(); name = tokenName; symbol = tokenSymbol; }",1
0x6de8f49a47f4cdcf7cb69cafb1b6a74a4f38d113.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0x93D3F120D5d594E764Aa3a0Ac0AfCBAD07944f71); },1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7.sol,GodsOfOlympus,contract GodsOfOlympus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0xdfb9e87ff81cb089484ef8150a21be80f6cdd401.sol,CRYPTOPOKER,"contract CRYPTOPOKER { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000* (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x4c1547be2c6f77c514840041b5a53d32f69e2c64.sol,Escrow,"contract Escrow { event Deposit(uint tokens); address dai_0x_address = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; mapping ( address => uint256 ) public balances; function deposit(uint tokens) public returns (bool success){ balances[msg.sender]+= tokens; ERC20(dai_0x_address).transferFrom(msg.sender, address(this), tokens); emit Deposit(tokens); return true; }",1
0x6bff83c6d87b1adff6679c75abac82fe7c38d7cf.sol,EasyInvestTurbo,contract EasyInvestTurbo { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0xb4b330972e302081ebacd054f4305a3af4103f0f.sol,CryptoTradeToken,"contract CryptoTradeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoTradeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD] = _totalSupply; emit Transfer(address(0), 0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD, _totalSupply); }",1
0x6c2fa6691b237c9e453926d8d484d4c5ab635db5.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xd3ac627abdc1ce6c27c04b37c86e368f754f2995.sol,GradualPro,contract GradualPro { address constant private FIRST_SUPPORT = 0xf8F04b23dACE12841343ecf0E06124354515cc42; address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c; uint constant public FIRST_PERCENT = 4; uint constant public TECH_PERCENT = 1; uint constant public MULTIPLIER = 121; uint constant public MAX_LIMIT = 2 ether; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x85924fdcccb75c47c3d2155ae0a519018164cac0.sol,StandardToken,"contract StandardToken is TelomereCoin { function transfer(address _to, uint256 _value) returns (bool success) { require(allowTransfer); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,WHOIS,"contract WHOIS is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WHOIS( ) TokenERC20(100000000, , ) public {}",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0x4221eb87b28de194e916f2b09274471fb0b01b1c.sol,SafeMath,None,1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6c61f6343b7420e142fb05f8b86afed3179eb0f0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xe0090146f0eb3193a8a12380e3ec14732589e41f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c0f4c64821d6f8fa96975e20d5bb3ea79eb1071.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x05411045febbb4c8fad13acceb292848b58bd64dd9292cbc9a23f432769a5930; constructor() public { owner = msg.sender; },1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c227eb319c24249df66d0c5879515aa59787471.sol,BitAlpha,contract BitAlpha is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 21500000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function BitAlpha() { owner = msg.sender; balances[owner] = 21500000 * 10**8; },1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x549ace5ff0c3a1881682fa06813c06884f7ee2e0.sol,EarlyTokenSale,"contract EarlyTokenSale is MintableSale { using SafeMath for uint256; uint256 public fundingGoal; uint256 public tokensPerEther; uint public deadline; address public multiSigWallet; uint256 public amountRaised; Token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; address public creator; address public addressOfTokenUsedAsReward; bool public isFunding = false; mapping (address => uint256) public accredited; event FundTransfer(address backer, uint amount); function EarlyTokenSale( address _addressOfTokenUsedAsReward ) payable { creator = msg.sender; multiSigWallet = 0x9581973c54fce63d0f5c4c706020028af20ff723; addressOfTokenUsedAsReward = _addressOfTokenUsedAsReward; tokenReward = Token(addressOfTokenUsedAsReward); setupAccreditedAddress(0xec7210E3db72651Ca21DA35309A20561a6F374dd, 1000); }",1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0xda6bae24e98db8ec03151d5edcf9ade67e442b6d.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, StealthGridToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) StealthGridToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,ShareToken,"contract ShareToken is ERC20Token, WhiteListManager { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; address public icoContract; uint256 constant E2 = 10**2; mapping(address => bool) public rewardTokenLocked; bool public mainSaleTokenLocked = true; uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT = 6666666667; uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT = 33333333333; uint256 public airDropTokenIssuedTotal; uint256 public bountyTokenIssuedTotal; uint256 public constant TOKEN_SUPPLY_SEED_LIMIT = 500000000 * E2; uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT = 2500000000 * E2; uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT; uint256 public seedAndPresaleTokenIssuedTotal; uint8 private constant PRESALE_EVENT = 0; uint8 private constant MAINSALE_EVENT = 1; uint8 private constant BOUNTY_EVENT = 2; uint8 private constant AIRDROP_EVENT = 3; function ShareToken() public { totalTokenIssued = 0; airDropTokenIssuedTotal = 0; bountyTokenIssuedTotal = 0; seedAndPresaleTokenIssuedTotal = 0; mainSaleTokenLocked = true; }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x4cd6e70a33092e2e3aac431c39b3de364042f9f0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x45e4390e6387b896268661ed4e2066df40a95a29.sol,VOCC_I032_20181211,"contract VOCC_I032_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa29d3d850d169eca564e71a02c13b7d76bc0eff4.sol,Scorpio,"contract Scorpio { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Scorpio( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 40000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 4000000000000000; name = ; symbol = ; }",1
0x1d5854e7f4dd81d9d4c09097d3cc736c7771f234.sol,vualt,contract vualt { bytes32 keyHash; address owner; bytes32 wallet_id = 0x162fb6d4a567c777d990e7b7517f9068408a67c8cca7089c7649eeeb349ee523; constructor() public { owner = msg.sender; },1
0x419b8ed155180a8c9c64145e76dad49c0a4efb97.sol,ApproveAndCallToken,"contract ApproveAndCallToken is StandardToken { function approveAndCall(address _spender, uint _value, bytes _data) public returns (bool) { TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _data); return true; }",1
0x7329e152d805dec79c67e45d4e04f3b6ce545b7c.sol,HmcDistributor,contract HmcDistributor { uint64 public constant lockDuration = 1 minutes; uint256 public constant bonus = 2*10*18; uint public constant minBlockNumber = 5000000; address public owner; address public hmcAddress; uint256 public joinCount = 0; uint256 public withdrawCount = 0; uint256 public distributorCount = 0; struct member { uint unlockTime; bool withdraw; },1
0x6b6d1a8858893c3e228f335726e1417a35832f76.sol,Carbon,contract Carbon { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 1000000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3.sol,CoinifinexToken,"contract CoinifinexToken { uint256 constant public TOTAL_TOKEN = 10 ** 9; uint256 constant public TOKEN_FOR_ICO = 650 * 10 ** 6; uint256 constant public TOKEN_FOR_COMPANY = 200 * 10 ** 6; uint256 constant public TOKEN_FOR_BONUS = 50 * 10 ** 6; mapping (address => uint256) public tokenForTeam; mapping (address => uint256) public tokenForTeamGet; address[] public teamAddress; uint public startTime; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinifinexToken( ) public { totalSupply = TOTAL_TOKEN * 10 ** uint256(decimals); name = ; symbol = ; startTime = 1538265600; tokenForTeam[0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x040440286a443822211dDe0e7E9DA3F49aF2EBC7] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xc456aC342f17E7003A03479e275fDA322dE38681] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24] = 300 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x88311485647e19510298d7Dbf0a346D5B808DF03] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe387125f1b24E59f7811d26fbb26bdA1c599b061] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xC5b644c5fDe01fce561496179a8Bb7886349bD75] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF] = 5 * 10 ** 6 * 10 ** uint256(decimals); teamAddress.push(0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0); teamAddress.push(0x040440286a443822211dDe0e7E9DA3F49aF2EBC7); teamAddress.push(0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71); teamAddress.push(0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D); teamAddress.push(0xc456aC342f17E7003A03479e275fDA322dE38681); teamAddress.push(0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24); teamAddress.push(0x88311485647e19510298d7Dbf0a346D5B808DF03); teamAddress.push(0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F); teamAddress.push(0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1); teamAddress.push(0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb); teamAddress.push(0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77); teamAddress.push(0xe387125f1b24E59f7811d26fbb26bdA1c599b061); teamAddress.push(0xC5b644c5fDe01fce561496179a8Bb7886349bD75); teamAddress.push(0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78); teamAddress.push(0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae); teamAddress.push(0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF); uint arrayLength = teamAddress.length; for (uint i=0; i<arrayLength; i++) { tokenForTeamGet[teamAddress[i]] = tokenForTeam[teamAddress[i]] * 1 / 10; balanceOf[teamAddress[i]] = tokenForTeamGet[teamAddress[i]]; tokenForTeam[teamAddress[i]] -= tokenForTeamGet[teamAddress[i]]; }",1
0x414b23b9deb0da531384c5db2ac5a99ee2e07a57.sol,TPCToken,"contract TPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TPCToken() public { totalSupply = 900000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc.sol,Multiplexer,"contract Multiplexer { function sendEth(address[] _to, uint256[] _value) payable returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 255); uint256 beforeValue = msg.value; uint256 afterValue = 0; for (uint8 i = 0; i < _to.length; i++) { afterValue = afterValue + _value[i]; assert(_to[i].send(_value[i])); }",1
0x1e834560e79def1479555bf5d9a35e8bc3dbe70a.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x92972bbc89708127016046c150e3a223431a31e0.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef.sol,LylToken,"contract LylToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LylToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2019763bd984cce011cd9b55b0e700abe42fa6c7.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0xda0e0303f4bf08cff92e88e13c0e743b14fea0d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x03684715e3a614ec80d1b31b62987e0b25925999.sol,GWGFPLUS,"contract GWGFPLUS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GWGFPLUS( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c227eb319c24249df66d0c5879515aa59787471.sol,BitAlpha,contract BitAlpha is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 21500000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function BitAlpha() { owner = msg.sender; balances[owner] = 21500000 * 10**8; },1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70528e8cc624f437fd01ab5a5215d8bb092b73ff.sol,ERC20,"contract ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x30f7411efcd4acc98c41d5ae6fe3cdd35aa1b68a.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa24f50fa560d2ec57956955f929273e899994bca.sol,XZEN,"contract XZEN is StandardToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant tokenCreationCapPreICO = 55000000*10**decimals; address public multiSigWallet = 0x51cf183cbe4e4c80297c49ff5017770fdd95c06d; address public teamWallet = 0x2BeB722Dc6E80D0C61e63240ca44B8a6D538e3Ae; uint public oneTokenInWei = 31847133757962; uint startDate = 1510592400; function XZEN() { owner = teamWallet; balances[teamWallet] = 55000000*10**decimals; totalSupply = totalSupply.add(balances[teamWallet]); Transfer(0x0, teamWallet, balances[teamWallet]); }",1
0x64d5e7be2e92d4436ba9c4a630491cb268764103.sol,funds,contract funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9a1488a97840653a0be4a4aed50ecf6137507b7c798a86604f31e3199852668c; constructor() public { owner = msg.sender; },1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239.sol,TruffleCoin,"contract TruffleCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 27000000000; balances[0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A] = _totalSupply; emit Transfer(address(0), 0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A, _totalSupply); }",1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53ef8e6cb3a7c96d7aecf39b2d4d09c166269c34.sol,AUX1418,"contract AUX1418 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 7; _totalSupply = 1000000000; balances[0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16] = _totalSupply; emit Transfer(address(0), 0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16, _totalSupply); }",1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xda36819cfa6167ab5d7932aa8a7852b377a15ab9.sol,DOJC,"contract DOJC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DOJC( ) public { totalSupply = 500000000000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000000000; name = ; symbol = ; }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8a63a921b5d678b4a27dc81e44321923e297b4cf.sol,Doves,"contract Doves is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Doves() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDf4943c61042919Bd45312d033Bd697A1E0A6397] = _totalSupply; Transfer(address(0), 0xDf4943c61042919Bd45312d033Bd697A1E0A6397, _totalSupply); }",1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0x69875fbeb23cfd52e7e7c23929c4f50a4fc377c3.sol,ThinSkinLarry,"contract ThinSkinLarry { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ThinSkinLarry( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x836f95d2a2f5150200c76f45a0b0679542ab6bbd.sol,BANK_IV_PFII_883,"contract BANK_IV_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 426401924563853000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xd216c12e89ac892e944edf6c947c860681ef18da.sol,Knightium,"contract Knightium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Knightium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2.sol,BFBtoken,"contract BFBtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x065313f29dc4a4b8b5fc4915059d122065519957.sol,Future1Exchange,contract Future1Exchange { address public adminaddr; mapping (address => mapping(address => uint256)) public dep_token; mapping (address => uint256) public dep_ETH; constructor() public { adminaddr = msg.sender; },1
0x753e7389ecc2566264587522a3e96e12d7a442c9.sol,BKKToken,"contract BKKToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 300*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BKKToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x77d4447a3f042d3c88fae21b28d52b905d6c3dfc.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x586927ff87bf40aada74afbff5e2409b865be023.sol,HashBet,contract HashBet { constructor() public {},1
0xf272fb519aed5e92a06a90426336f378423718e5.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol) public { totalSupply = _initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _tokenName; symbol = _tokenSymbol; }",1
0x92891fb5abe9049e181ca49ce04a9872c0c1ca44.sol,SimplyBank,contract SimplyBank { mapping (address => uint256) dates; mapping (address => uint256) invests; address constant private TECH_SUPPORT = 0x85889bBece41bf106675A9ae3b70Ee78D86C1649; function() external payable { if (msg.value == 0.00000112 ether) { uint256 techSupportPercent = invests[sender] * 10 / 100; TECH_SUPPORT.transfer(techSupportPercent); uint256 withdrawalAmount = invests[sender] - techSupportPercent; sender.transfer(withdrawalAmount); dates[sender] = 0; invests[sender] = 0; },1
0xcd74d15b488ed7ef7874819e8cb6daa75a759dc3.sol,OPTPRG_EURRUB_20190423_1,"contract OPTPRG_EURRUB_20190423_1 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14400000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x51f545a57a88d193227f506ff07911da0df2749c.sol,MEXICO_WINS,"contract MEXICO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0x0dcc6e4f98e734048689a63b824e89b8a58ed591.sol,MDGame,contract MDGame is Owned { using SafeMath for *; struct turnInfos{ string question; string option1name; string option2name; uint endTime; uint option1; uint option2; uint pool; bool feeTake; },1
0x41451e8e7fd5b9a4f8176ccf1a0db2b68abc77fb.sol,FART,contract FART { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0x6d8811059eb8f0509acec06648ea95b3ae01be72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x190e569be071f40c704e15825f285481cb74b6cc.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x6dd2c2a82234d280e2b397db17b923fab49695e6.sol,DHSCToken,contract DHSCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 1000000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0x873467738b5053f155639208b7495318fced5262.sol,StreamNetworkToken,"contract StreamNetworkToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StreamNetworkToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7632819325000000000000000000; balances[0xcfb1E02D3687B7Eedea33E8acA96Bc34869fE17b] = _totalSupply; Transfer(address(0), 0xcfb1E02D3687B7Eedea33E8acA96Bc34869fE17b, _totalSupply); }",1
0x417866263b96ea8fb86e1f332018dda49820c85a.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address target, bytes data) external payable onlyOwner returns (bool) { return target.call.value(msg.value)(data); }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,MainCard,"contract MainCard is BasicAuth,MainBase { struct Card { uint32 m_Index; uint32 m_Duration; uint8 m_Level; uint16 m_DP; uint16 m_DPK; uint16 m_SP; uint16 m_IP; uint32[] m_Parts; }",1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x5c976e71bb27538bddb0ed399be1722c6745bcb6.sol,ProofOfKennyCoin,contract ProofOfKennyCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,MyBoToken,"contract MyBoToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function MyBoToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x5bc6a25063a8641ba95546ddbac3180791fc3ba0.sol,TokenTeks,"contract TokenTeks is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TokenTeks() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xa9aeE8A3695cdfD58936332e833ebAf2abfcc48b] = _totalSupply; Transfer(address(0), 0xa9aeE8A3695cdfD58936332e833ebAf2abfcc48b, _totalSupply); }",1
0xcdb290f8a2315bb0c752eb16cab426eae7afb5c2.sol,VOCC_I074_20181211,"contract VOCC_I074_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2a0937dedadf8fe3f16a779c56524739ef77f149.sol,TEL_AVIV_Portfolio_I_883,"contract TEL_AVIV_Portfolio_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 742949791335499000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f.sol,CarbonExchangeCoinToken,"contract CarbonExchangeCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CarbonExchangeCoinToken() public { owner = msg.sender; totalSupply = 50000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0x18911e747108241e4afe4feeecc742e90c5177bd.sol,VistaToken,"contract VistaToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VistaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x50fd51b624ca86be3dbc640515ebc407a163cd6c.sol,Versionable,contract Versionable { string public versionCode; function getVersionByte(uint index) constant returns (bytes1) { return bytes(versionCode)[index]; },1
0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x504d917d0e941550e9f89df195b969e7430118ee.sol,SRDToken,"contract SRDToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRDToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239.sol,TruffleCoin,"contract TruffleCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 27000000000; balances[0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A] = _totalSupply; emit Transfer(address(0), 0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A, _totalSupply); }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,WhiteList,"contract WhiteList is Ownable { mapping (address => uint8) internal list; event WhiteBacker(address indexed backer, bool allowed); function setWhiteBacker(address _target, bool _allowed) onlyOwner public { require(_target != 0x0); if(_allowed == true) { list[_target] = 1; }",1
0x207b893467904d076add0a44f94ac8c8d92d2e0c.sol,CARAT,"contract CARAT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CARAT() public { symbol = ; name = ; decimals = 4; _totalSupply = 14000000; balances[0x7c675fD4d6EE644a7D758ab1C03B3312976D0103] = _totalSupply; Transfer(address(0), 0x7c675fD4d6EE644a7D758ab1C03B3312976D0103, _totalSupply); }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0x518e5a711cf84666b98dddb00a0d4a0a6c59955e.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,Gallery_MuYi_No2,contract Gallery_MuYi_No2 is StandardToken { function () { throw; },1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,FollowCoin,"contract FollowCoin is Ownable, ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping (address => uint256) public balances; mapping (address => bool) public allowedAccount; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public isHolder; address [] public holders; event Burn(address indexed from, uint256 value); bool public contributorsLockdown = true; function disableLockDown() onlyOwner { contributorsLockdown = false; }",1
0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b.sol,FTWCoin,contract FTWCoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function FTWCoin() public { balances[msg.sender] = 250000000000000000000000000; totalSupply = 250000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000; fundsWallet = msg.sender; },1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0.sol,MyToken,"contract MyToken is owned { string public name = ; string public symbol = ; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8.sol,SmartBlockchainPro,contract SmartBlockchainPro { mapping (address => uint256) invested; mapping (address => uint256) atBlock; address public marketingAddr = 0x43bF9E5f8962079B483892ac460dE3675a3Ef802; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 1 / 100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x70aedc0621a686067fdba7fb4fdb209ea185fe73.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0x421a0ee46dbfee7f65076c7e0c32fa86918bf62d.sol,BBX,"contract BBX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BBX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c934a503fe39721591b97b8c56f013bf78a8d19.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1b413506fc42e2f04a4e8c57710f850b234d6653.sol,EpiphanyCoin,"contract EpiphanyCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EpiphanyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff.sol,BTYCEC,contract BTYCEC is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sysusermoney; uint public sysoutmoney; uint public sellPrice; uint public buyPrice; uint public btycbuyPrice; uint public btycsellPrice; uint public sysPer; uint public sysPrice1; uint public sysPer1; uint public systime1; uint public sysPrice2; uint public sysPer2; uint public systime2; uint public transper; bool public actived; uint public onceAddTime; uint public upper1; uint public upper2; uint public teamper1; uint public teamper2; uint public outper1; uint public outper2; uint public sellper; uint public sysday; uint public sysminteth; uint public hasoutmony; uint public hasbuymoney; uint public hassellmoney; uint public hasbuyeth; uint public hasselleth; uint public hasbtycbuymoney; uint public hasbtycsellmoney; mapping(address => uint) balances; mapping(address => uint) myeth; mapping(address => uint) froeth; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => address) public fromaddr; mapping(address => uint) public crontime; mapping(address => uint) public mintnum; uint[] public permans; mapping(address => uint) public teamget; struct sunsdata{ uint n1; uint n2; uint getmoney; },1
0x6edea3515749cef9986d05f08104ffd976217bb7.sol,BestMultiplierV3,contract BestMultiplierV3 { struct Deposit { address depositor; uint deposit; uint payout; },1
0x402288b27f39223d8a8131b53b35b9976d2c46d7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6bb7a864a695ff718c9d8330c7d2ed9293949169.sol,ColorStarToken,"contract ColorStarToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,OracleContractAdapter,contract OracleContractAdapter is Object { event OracleAdded(address _oracle); event OracleRemoved(address _oracle); mapping(address => bool) public oracles; modifier onlyOracle { if (oracles[msg.sender]) { _; },1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0x45ca8d5458d7f3f7d2f47daae253924cafc2f331.sol,EmiratesCoin,"contract EmiratesCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EmiratesCoin( ) public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6c79b4ed1cfe6ae97e6a8f117138cb583638954f.sol,ERC20Token,"contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Template,"contract Template is Ownable, SupportsInterfaceWithLookup { bytes4 public constant InterfaceId_Template = 0xd48445ff; mapping(string => string) nameOfLocale; mapping(string => string) descriptionOfLocale; bytes32 public bytecodeHash; uint public price; address public beneficiary; event Instantiated(address indexed creator, address indexed contractAddress); constructor( bytes32 _bytecodeHash, uint _price, address _beneficiary ) public { bytecodeHash = _bytecodeHash; price = _price; beneficiary = _beneficiary; if (price > 0) { require(beneficiary != address(0)); }",1
0x18035ee31125a9934de44b0105cd31691cce95d5.sol,BigBoobsToken,"contract BigBoobsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BigBoobsToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5] = _totalSupply; Transfer(address(0), 0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5, _totalSupply); }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0x1e867d04fbb7434093071237813df00b3df6ee77.sol,GridcubePlatformToken,"contract GridcubePlatformToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public _currentSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GridcubePlatformToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 12 weeks; _totalSupply = 30000000000000000000000000; address OwnerAdd = 0xb917cd85b61813ac1cd29ba0a8c37e0cd9f11162; uint256 CommunityTokens = 10000000000000000000000000; uint256 ProjectTokens = 10000000000000000000000000; uint256 HoldTokens = CommunityTokens + ProjectTokens; uint256 SaleTokens = safeSub(_totalSupply, HoldTokens); balances[OwnerAdd] = HoldTokens; Transfer(address(0), OwnerAdd, HoldTokens); _currentSupply = SaleTokens; }",1
0x517be460e08a7ecce448f54b41658c0bfb0d8674.sol,StringYokes,None,1
0x540cf76f7efaffdeef8eec75b07807353667cef7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a.sol,ZethrDice,contract ZethrDice is ZethrGame { struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint8 rollUnder; uint8 numRolls; },1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dd72a0d3357901d51e791ba65476e101cb2c6a5.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { totalSupply = initialSupply * 10 ** uint256(decimalUnits); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x0d3264ab9ee29bec9534f0f210ca8db3ac4794a8.sol,LeifengMedals,"contract LeifengMedals { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LeifengMedals( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x377748ddc51b3075b84500a6ed95d260a102d85f.sol,TuneToken,"contract TuneToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TuneToken() public { totalSupply = 3e9 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xea8c9db193996bbc3f6a9afbdbea2b3b62c11253.sol,RAcoinToken,"contract RAcoinToken is Ownable, ERC20Interface { string public constant symbol = ; string public constant name = ; uint private _totalSupply; uint public constant decimals = 18; uint private unmintedTokens = 20000000000*uint(10)**decimals; event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value); struct LockupRecord { uint amount; uint unlockTime; }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0xd82f9939aa0ba1bf5d5bbade54b5f2f61d2cfdbe.sol,NEWT,"contract NEWT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NEWT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0xed98b38f4fc2fcc633465b699f6d983d96e1fe8c.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Airdrop(address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x6b3f9f54e2a684ea28365af5f3dd6d714df4328b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef4bbb338e2d21ffcbde49ea2b94befe2bba05f1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0x77e00640a6343152a35542027ba76407bdde0bb6.sol,quiz_please,contract quiz_please { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4d50c99294daa84d8de9b2a5b9b6a6d9a8d88aa3.sol,SERBIA_WINS,"contract SERBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b193e107a773967bd821bcf8218f3548cfa2503.sol,PossContract,"contract PossContract is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PossContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0xAbB082211930DA475879BF315AFaDDD55913C6a8] = _totalSupply; Transfer(address(0), 0xAbB082211930DA475879BF315AFaDDD55913C6a8, _totalSupply); }",1
0x70673d36178f17ac064747c7bdd026240be194b5.sol,UNIQ,"contract UNIQ { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function UNIQ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x20d2f8fdd0951f2f5249c86b3cdc2be7656f2c01.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public _balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(decimals); _balanceOf[msg.sender] = _totalSupply; name = ; symbol = ; }",1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0x7125df83a5d3945728036d3c5e48e2c9e38d1607.sol,Smartolution,contract Smartolution { struct User { uint value; uint index; uint atBlock; },1
0x6cb816569ab4665bdc2ba78a64aff87201608bc6.sol,Bitmos,"contract Bitmos is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitmos( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6abf810730a342add1374e11f3e97500ee774d1f.sol,BCFAuction,contract BCFAuction is Pausable { struct CardAuction { address seller; uint128 startPrice; uint128 endPrice; uint64 duration; uint64 startedAt; },1
0x5c8d8245e52f893de53c716c969b1526a0075070.sol,ENXAirDrop,"contract ENXAirDrop is Ownable { function airDrop ( address contractObj, address tokenRepo, address[] airDropDesinationAddress, uint[] amounts) public onlyOwner{ for( uint i = 0 ; i < airDropDesinationAddress.length ; i++ ) { ERC20Interface(contractObj).transferFrom( tokenRepo, airDropDesinationAddress[i],amounts[i]); }",1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0x07ce333ec45618d838c32e60cee5cb1ce389e06e.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, SafeMath { struct Reserve { uint256 virtualBalance; uint8 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x022882d9fcf023e57926e4e01d1b137aabd93416.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd07d571e0a45306350c005f5ed858783ae725d71.sol,Members,contract Members is Owned { address public coin; MemberStatus[] public status; mapping(address => History) public tradingHistory; struct MemberStatus { string name; uint256 times; uint256 sum; int8 rate; },1
0xeaaa3585ffdcc973a22929d09179dc06d517b84d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol) internal { totalSupply = _initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _tokenName; symbol = _tokenSymbol; }",1
0xbd35aefa375b57a801ddc87615aef1e9f353df28.sol,ToTheMoon,"contract ToTheMoon { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ToTheMoon( ) public { totalSupply = 1000000000 * 10 ** 18; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0xe3d424dffecc3759fcc997f5eba2a01a58585405.sol,ERC20Standard,contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard() public { decimals = 18; symbol = ; name = ; mintable = true; owner = msg.sender; totalSupply = 300000000 * (10 ** decimals); balances[msg.sender] = totalSupply; },1
0x1fd1f34a7476fa7d7b2187c8bd255e39e78271e6.sol,PAXPAGO,"contract PAXPAGO is TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0xc094367b4c79564b6c8b4218f84dea835b2c2dd0.sol,TikiMadness,contract TikiMadness { modifier onlyOwner() { require(msg.sender == contractOwner); _; },1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x83a611488d53cfcda749c2239c1516ab1c514fe7.sol,PICC_301201,"contract PICC_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10814019086663000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x70a128fe6c4f654f52fc799f250506bed550945e.sol,CpublicGold,"contract CpublicGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CpublicGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 6000000000000000000000000000; balances[0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3] = _totalSupply; emit Transfer(address(0), 0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3, _totalSupply); }",1
0x39f968b4b8b367ce20f5aefc852591f7eada4b3e.sol,Administration,"contract Administration is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Administration() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000000000000000000000; balances[0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c] = _totalSupply; Transfer(address(0), 0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c, _totalSupply); }",1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0x0f6029ebde2ecd9ab4d60dd5d0a297e9e59bf77a.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
0x75163374524bac8ca983bea408a0e3f22a1cb25b.sol,BannerDesk,"contract BannerDesk is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000000; balances[0x3b970B892c1113a567656b447f14A7195C85C487] = _totalSupply; emit Transfer(address(0), 0x3b970B892c1113a567656b447f14A7195C85C487, _totalSupply); }",1
0x4d74acfb21f3be9d98263fc0b721840be958ef9d.sol,DomenoToken,"contract DomenoToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DomenoToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000000; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6.sol,MultiOwnable,contract MultiOwnable { address public manager; address[] public owners; mapping(address => bool) public ownerByAddress; event SetOwners(address[] owners); modifier onlyOwner() { require(ownerByAddress[msg.sender] == true); _; },1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0.sol,CCOIN,"contract CCOIN is ERC20, Ownable { struct Escrow { address creator; address brand; address agreementContract; uint256 reward; }",1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x47c69e05d3d32658cb01cee954af9bb7885b094a.sol,VICETOKEN_ICO_IS_FAKE,"contract VICETOKEN_ICO_IS_FAKE { string public name = ""https: string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VICETOKEN_ICO_IS_FAKE( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ""https: symbol = ; }",1
0x0078bd770f55a3c6b8f3b3d2a0c21fcac8a92394.sol,SetLibrary,None,1
0xa6237a177c4e0fc24818649bca7ce5ab44933a00.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2019763bd984cce011cd9b55b0e700abe42fa6c7.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc.sol,C3_TokenCreate,"contract C3_TokenCreate is owned, TokenERC20 { uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function C3_TokenCreate( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5cafe6c85ea7c3b1bb62ca5254fae636ba8ae616.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x6b963f7b38980f5fbbd129fe98059eb2144076a7.sol,BLV,"contract BLV { string public name; string public symbol; uint8 public decimals = 1; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLV( ) public { totalSupply = 1000000000; balanceOf[msg.sender] = 1000000000; name = ; symbol = ; }",1
0x5b29a6277c996b477d6632e60eef41268311ce1c.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 500000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0x201e7cd92e03ea87c51d3e22974243ed7a26a1cb.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 7; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55bec5649fbb5f5be831ee5b0f7a8a8f02b25144.sol,PuzzleGift,contract PuzzleGift { address prop = msg.sender; function()payable{},1
0x568a693e1094b1e51e8053b2fc642da7161603f5.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc654928ecf5f984ef72c806ec9b6e2d213c90818.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c6b3fd123d575cbeb1670a1fcc9c8fd603357a3.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8.sol,DragonLifeChain,"contract DragonLifeChain is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x361cef27a967e3fa2d8fc117b3f2cfe2a09bbc02.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdda784ce15449948520580cacb229717cd7ad261.sol,Laker_Show,contract Laker_Show { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1dec6cf84a749ef01bf72a1d415c650393afbd3b11bf92e1e22e0c2372c0df4b; constructor() public { owner = msg.sender; },1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x537c23b71d847eef947f150ac7e33b1854138d5c.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 50000 * 10 ** uint256(decimals); string public contract_link = ""https: mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { owner = 0xCD6011A9D3995A693F9964608D08EDbb48220225; balanceOf[owner] = totalSupply; }",1
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); address addressCrowdSale = 0xc699d90671Cb8373F21060592D41A7c92280adc4; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply.mul(11).div(18); balanceOf[addressCrowdSale] = totalSupply.sub(balanceOf[msg.sender]); name = tokenName; symbol = tokenSymbol; }",1
0x512a4d492669e5f0746609d638796c0ad94276cd.sol,RaceCoin,"contract RaceCoin is ERC20, AccessAdmin, IRaceCoin { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalRaceCoinProduction; uint256 public bonusMatchFunPercent = 10; uint256 public bonusOffLinePercent = 10; uint256 constant refererPercent = 5; address[] public playerList; uint256 public totalEtherPool; uint256[] private totalRaceCoinProductionSnapshots; uint256[] private allocatedProductionSnapshots; uint256[] private allocatedRaceCoinSnapshots; uint256[] private totalRaceCoinSnapshots; uint256 public nextSnapshotTime; mapping(address => uint256) private ethBalance; mapping(address => uint256) private raceCoinBalance; mapping(address => uint256) private refererDivsBalance; mapping(address => uint256) private productionBaseValue; mapping(address => uint256) private productionMultiplier; mapping(address => uint256) private attackBaseValue; mapping(address => uint256) private attackMultiplier; mapping(address => uint256) private attackPower; mapping(address => uint256) private defendBaseValue; mapping(address => uint256) private defendMultiplier; mapping(address => uint256) private defendPower; mapping(address => uint256) private plunderBaseValue; mapping(address => uint256) private plunderMultiplier; mapping(address => uint256) private plunderPower; mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots; mapping(address => uint256) private lastRaceCoinSaveTime; mapping(address => uint256) public lastRaceCoinProductionUpdate; mapping(address => uint256) private lastProductionFundClaim; mapping(address => uint256) private lastRaceCoinFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address referal, address player, uint256 amount); event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder); mapping (address => bool) actionContracts; function setActionContract(address _actionAddr, bool _useful) external onlyAdmin { actionContracts[_actionAddr] = _useful; }",1
0x58002a6b6e659a16de9f02f529b10536e307b0d9.sol,CHFT,"contract CHFT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5375bD481a1442694893eDA7d47FcEb04e8776fD] = _totalSupply; emit Transfer(address(0), 0x5375bD481a1442694893eDA7d47FcEb04e8776fD, _totalSupply); }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28.sol,BoltToken,"contract BoltToken is ERC20{ address owner = msg.sender; bool public canPurchase = false; mapping (address => uint) balances; mapping (address => uint) roundContributions; address[] roundContributionsIndexes; mapping (address => mapping (address => uint)) allowed; uint public currentSupply = 0; uint public totalSupply = 32032000000000000000000000; uint public round = 0; uint public roundFunds = 0; uint public roundReward = 200200000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public isToken = true; string public tokenSaleAgreement = ""https: uint contributionsDistribStep = 0; event Contribution(address indexed from, uint value); event RoundEnd(uint roundNumber); function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; }",1
0x7045c5c158aecd68eed18671cc8775fc7f7d6e70.sol,DHCToken,contract DHCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 40000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0xc66e78b1078ba0e65d311c92854dd446451b2ba6.sol,Xoom,"contract Xoom is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xoom() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b] = _totalSupply; Transfer(address(0), 0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b, _totalSupply); }",1
0x6b31d68c23c27f04d813aa1cb8ac436dc0432971.sol,ERC20,"contract ERC20 { address owner; string public name; string public symbol; uint public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function ERC20() public { owner = msg.sender; }",1
0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1.sol,VOCC_I073_20181211,"contract VOCC_I073_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf07d979303c50a8632848cb154c6b30980218c07.sol,PXLProperty,contract PXLProperty is StandardToken { uint8 constant LEVEL_1_MODERATOR = 1; uint8 constant LEVEL_2_MODERATOR = 2; uint8 constant LEVEL_1_ADMIN = 3; uint8 constant LEVEL_2_ADMIN = 4; uint8 constant LEVEL_1_ROOT = 5; uint8 constant LEVEL_2_ROOT = 6; uint8 constant LEVEL_3_ROOT = 7; uint8 constant LEVEL_PROPERTY_DAPPS = 8; uint8 constant LEVEL_PIXEL_PROPERTY = 9; uint8 constant FLAG_NSFW = 1; uint8 constant FLAG_BAN = 2; address pixelPropertyContract; mapping (address => uint8) public regulators; mapping (uint16 => Property) public properties; mapping (address => uint256[2]) public ownerWebsite; mapping (address => uint256[2]) public ownerHoverText; struct Property { uint8 flag; bool isInPrivateMode; address owner; address lastUpdater; uint256[5] colors; uint256 salePrice; uint256 lastUpdate; uint256 becomePublic; uint256 earnUntil; },1
0x065313f29dc4a4b8b5fc4915059d122065519957.sol,Future1Exchange,contract Future1Exchange { address public adminaddr; mapping (address => mapping(address => uint256)) public dep_token; mapping (address => uint256) public dep_ETH; constructor() public { adminaddr = msg.sender; },1
0x276528880ac7e202f3db20d74402ea0a9c8774a8.sol,ERC20Token,"contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xb47f7059e3706c0ccf270ba11f1747a137f9fd12.sol,Fund,"contract Fund{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function Fund() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994.sol,SHERE_PFII_II_883,"contract SHERE_PFII_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1219985648835240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d.sol,TextMessage,"contract TextMessage is owned { uint cost; bool public enabled; event UpdateCost(uint newCost); event UpdateEnabled(string newStatus); event NewText(string number, string message); function TextMessage() { cost = 380000000000000; enabled = true; }",1
0x562f0c1d080be544b3095d02abcdb9786249a416.sol,SEAPORT_Portfolio_V_883,"contract SEAPORT_Portfolio_V_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 926816166179938000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28e860cb89e705de876f858671cb757f650fdae2.sol,WEPAYCOIN,"contract WEPAYCOIN { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x12ac8d8f0f48b7954bcda736af0576a12dc8c387.sol,OPL,"contract OPL { string public name; string public symbol; uint8 public decimals = 18; bool public adminVer = false; address public owner; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Emission(address indexed from, uint256 value); function OPL() public { totalSupply = 210000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; owner = msg.sender; }",1
0x39e5bd6ae0f2aa9240d2ae7fbf49e36f05dd339f.sol,SafeMath,None,1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x2c1180e2818069e5a9f911e636fb8f3db5106a9f.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; },1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x5b15a638d1defbf055dc2d7653d5ff1bd5a9494c.sol,CHEMCHINA_PFIII_III_883,"contract CHEMCHINA_PFIII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 960045161637506000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4.sol,FccToken,"contract FccToken is Owned, StandardToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function FccToken() { balances[msg.sender] = 200000000* 10**8; totalSupply = 200000000* 10**8; locked = false; }",1
0x18486c451fdc6eac512d468967f75729d11b89ea.sol,LiteCoinW,contract LiteCoinW is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0x3a8a6d2bc23fb68a245250ad34019a65cf057418.sol,DiscountPercentToken,"contract DiscountPercentToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DiscountPercentToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xdc8fd6abd32fd9d0dc74e6947aca082658adeb3d.sol,UMIproject,contract UMIproject { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; UMIBiggestInvestor public umiBiggestInvestor; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0xb3939627b9775c3b76c05138d281c7f92e251aab.sol,LespNetWork,"contract LespNetWork { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1cae8c6ec705520b11f10f773b7010958363318e.sol,Hermes,contract Hermes { using MathForInterset for uint; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public DAY_VALUE = 0; uint public DAY_LIMIT = 200 ether; uint public DEPOSIT_AMOUNT; uint public PERCENT_FOR_MARKETING = 1500000000; address[] public ADDRESSES; mapping(address => Investor) public INVESTORS; address public ADMIN_ADDR; struct Investor { uint id; uint percentCount; uint deposit; uint date; address referrer; uint reinvestID; uint actualValue; uint stage; uint startReinvestDate; uint dayLimitValue; },1
0x009b40aab0ec2d4abd696db7b0cfce5c24eb9114.sol,CAMToken,"contract CAMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE] = _totalSupply; emit Transfer(address(0), 0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE, _totalSupply); }",1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x5287b19bf61a4f9375d1f6624565db164bcb0208.sol,ARBITRAGING,"contract ARBITRAGING is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function ARBITRAGING (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x03684715e3a614ec80d1b31b62987e0b25925999.sol,GWGFPLUS,"contract GWGFPLUS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GWGFPLUS( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x5b29a6277c996b477d6632e60eef41268311ce1c.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 500000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; }",1
0x37d9033151eaf64cea6b7531ee0e4fd6f6f9d6d0.sol,EthCrystal,contract EthCrystal { using SafeMath for *; struct TowersInfoList { string name; uint256 timeLimit; uint256 warriorToTime; uint256 currentRoundID; uint256 growthCoefficient; uint256 winnerShare; uint256 nextRound; uint256 dividendShare; mapping (uint256 => TowersInfo) RoundList; },1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x6ec2e2e2bd43d4deaa883533f80ea61682236073.sol,HACHIKO,"contract HACHIKO is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5409fcd56836e0e0459c12ab45e7ef23c6094bed.sol,RedExchange,contract RedExchange { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6f2deef18421ba39065223b23ef38666b3052a46.sol,Marine,contract Marine is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 1000000000 * (10 ** uint256(decimals)); uint256 public MRNToEth; uint256 public ethInWei; address public devWallet; function Marine () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; MRNToEth = 20000000; devWallet = msg.sender; },1
0xbdae4cb65e1c68cd9cd41b73c93ae3d331acad5c.sol,Vote,"contract Vote is Ownable { event CandidateRegistered(uint candidateId, string candidateName, string candidateDescription); event VoteCast(uint candidateId); struct Candidate { uint candidateId; string candidateName; string candidateDescription; }",1
0x1c242bc9af8aa768a54222ed47bb756f1a1a757b.sol,SafeMath,None,1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryBase,contract ChemistryBase is Ownable { struct Element{ bytes32 symbol; },1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x0dea9b8e6bf08d6859e29256942916f0cfb884fb.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0xb42f5366792ed7c08995451c1a93780b7554762b.sol,MyAdvancedToken,"contract MyAdvancedToken is developed, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x9222740a4351abda9d83f3c7165c556e802f920e.sol,StandardToken,"contract StandardToken is ERC20, SafeMath { event Transfer(address indexed from, address indexed to, uint indexed value, bytes data); event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length != size + 4) { revert(); }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc08dcf2fa37b87a89ac7f0fdcb4aebda378dea29.sol,MITToken,contract MITToken is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping(uint => Holder) public lockholders; uint public lockholderNumber; struct Holder { address eth_address; uint exp_time; },1
0x3f90421fd22b7e3251c8600430acc82922d2a434.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0x20bcae16a8ba95d8e8363e265de4ecfc36ec5cd9.sol,HEYBITCOIN,"contract HEYBITCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HEYBITCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 2311000000000000000000000000; balances[0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384] = _totalSupply; Transfer(address(0), 0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384, _totalSupply); }",1
0x580c1e3caca14826976b5820947f7ad486ac174d.sol,BitcoinAgileToken,"contract BitcoinAgileToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51.sol,EtherColor,"contract EtherColor is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; mapping (uint256 => uint256) private colorIndexToPreviousPrice; mapping (uint256 => address[5]) private colorIndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Color { string name; }",1
0x2151288dfdbd547e071d8c6dc7fe3301235ae87c.sol,Bitcoin1,"contract Bitcoin1 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitcoin1() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0xff3b1d46351D3feb6d2B3703B7d990a706953222] = _totalSupply; Transfer(address(0), 0xff3b1d46351D3feb6d2B3703B7d990a706953222, _totalSupply); }",1
0x214f96e84d3c0f2920bb90fec861be4925edf02b.sol,HorseyToken,"contract HorseyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(string _symbol, string _name, uint8 _decimals, uint _totalSupply ) public { symbol = _symbol; name = _name; decimals = _decimals; totalSupply = _totalSupply * 10**uint(_decimals); balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); }",1
0x1768fc7978e9abae733dd6c3de837a57a2f2ce4f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x71880d9f448c995ec5a7c9d68f2b0e256ef510d2.sol,ValueTokenBase,"contract ValueTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ValueTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,BitBonus,"contract BitBonus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x633A5cD23D95c26f750B802A03A82490C00Da802] = _totalSupply; emit Transfer(address(0), 0x633A5cD23D95c26f750B802A03A82490C00Da802, _totalSupply); }",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4609d26a58598d6b80b11f451a00477f61d8804.sol,Tcthereum,"contract Tcthereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tcthereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0x5890ef4e676cd051e59a348b46e0b3e73601f34d.sol,HIW,"contract HIW { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HIW() { owner = 0x878479357C54d993be99bD332b2649A146da41C0; name = ; symbol = ; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[owner] = 10000000000000000000000000000; }",1
0x282c3971f8041bf4ab8b0d2ad0875e94958f8940.sol,RENAULT_301201,"contract RENAULT_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10641072767863300000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b2988f2d77c38b46a753ea09a4f6bf726e07e34.sol,LILE,"contract LILE1Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xf354b2e5ea679a726d0348a974971cb4697bf508.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5c7f7e79b710a7bd29d8a381621e0268c98dcf06.sol,ERC20Standard,"contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x5513401cb13ec32809d238ee19a84405759147cc.sol,INTO_ICO,"contract INTO_ICO is Pausable { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public supply; uint256 public rate; uint256 public weiRaised; uint256 public openingTime; uint256 public closingTime; uint256 public duration; uint256 public minInvest; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public { rate = 50000; wallet = owner; token = ERC20(0x7f738ffbdE7ECAC18D31ECba1e9B6eEF5b9214b7); minInvest = 0.05 * 1 ether; duration = 176 days; openingTime = 1530446400; closingTime = openingTime + duration; }",1
0x6c558a4976e751391fb73dd61fa6a72c318d80b5.sol,BitQ,"contract BitQ is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitQ() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000; balances[0x74205dece41e14DCE4fD94da4Dcfb255f3A69059] = _totalSupply; Transfer(address(0), 0x74205dece41e14DCE4fD94da4Dcfb255f3A69059, _totalSupply); }",1
0x190e569be071f40c704e15825f285481cb74b6cc.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x841b42c7ee6a15904d1926bf15ffdb6d30a77723.sol,GDC,"contract GDC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GDC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x71f04062e5794e0190fdca9a2bf1f196c41c3e6e.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 value); event Burn(address indexed to, uint256 value); function mint(address addr, uint256 value) onlyOwner public returns (bool) { _totalSupply = _totalSupply.add(value); _balances[addr] = _balances[addr].add(value); emit Mint(addr, value); emit Transfer(address(0), addr, value); return true; }",1
0x414e58fbd9264565d611c5eb2a392a70529dad41.sol,CoinEGGToken,contract CoinEGGToken is Token { string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 10000000000*(10**18); balances[msg.sender] = totalSupply; name = ; decimals = 18; symbol = ; },1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol,YSS,"contract YSS is Owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function YSS(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits, address centralMinter) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0) {owner = centralMinter;}",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x716989fa21d5043165079ddbfd04a76a001a595a.sol,COCTokenBase,"contract COCTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; address public administrator; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function COCTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; administrator = msg.sender; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[administrator] = totalSupply; }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrBigWheel,contract ZethrBigWheel is ZethrGame { using SafeMath for uint8; struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint bets; },1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0x4d48ee87ab535833fdd79c7d1c4aac3c7c304b13.sol,Pomda,contract Pomda { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0xb3f48d38ace4b44c710ba32cb5aea66c0f533571.sol,AUTOCOIN,"contract AUTOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4] = _totalSupply; emit Transfer(address(0), 0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4, _totalSupply); }",1
0xa31b52ee117b946741c5fb49f010ed1d56b443e0.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) public returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0xf375e839fecff22f847eb2df66d440aeb7226916.sol,KTLContract,"contract KTLContract is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 30000000000000000000000000000; bool public stopped; mapping (address => int8) public blackList; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Blacklisted(address indexed target); event DeleteFromBlacklist(address indexed target); event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value); event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value); modifier notStopped { require(!stopped); _; }",1
0x08d88845df68222fc8a1e631ab1817f1660766c5.sol,SafeMath,None,1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x1dbd7059247baf317b11c9e36308fa8582867d4b.sol,EDOGE,"contract EDOGE is ERC223, SafeMath { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 100000000000 * 10**8; address public owner; bool public unlocked = false; bool public tokenCreated = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function EDOGE() public { require(tokenCreated == false); tokenCreated = true; owner = msg.sender; balances[owner] = totalSupply; require(balances[owner] > 0); }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0xcf5a08af322e52bee93861341f7bd90eb3d65aa3.sol,HeavyLitecoin,"contract HeavyLitecoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HeavyLitecoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8] = _totalSupply; Transfer(address(0), 0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8, _totalSupply); }",1
0x5c0e4f2a54f1e0716ea64de7cfe83b0cf1ad417b.sol,PowrLedgerToken,"contract PowrLedgerToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PowrLedgerToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 21 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xaa4ec8484e89bed69570825688789589d38eea5e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5abaff0b83f81dc061c590aadcba013c69237fd7.sol,CryptoJade,"contract CryptoJade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoJade() public { symbol = ; name = ; decimals = 18; _totalSupply = 125000000000000000000000000; balances[0x5E77C4cf41618A897759b3A2A32665C85BC2aF21] = _totalSupply; Transfer(address(0), 0x5E77C4cf41618A897759b3A2A32665C85BC2aF21, _totalSupply); }",1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,RobincoinERC20,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,Controllable,contract Controllable is Ownable { mapping(address => uint256) private contractIndices; address[] private contracts; modifier onlyActiveContracts() { require(contractIndices[msg.sender] != 0); _; },1
0x4c7e8e14626249eea89b3d643ebe68795b49a6f1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x6d8811059eb8f0509acec06648ea95b3ae01be72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x580c1e3caca14826976b5820947f7ad486ac174d.sol,BitcoinAgileToken,"contract BitcoinAgileToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d.sol,TextMessage,"contract TextMessage is owned { uint cost; bool public enabled; event UpdateCost(uint newCost); event UpdateEnabled(string newStatus); event NewText(string number, string message); function TextMessage() { cost = 380000000000000; enabled = true; }",1
0xd8ee3a6b246674a7c6ca07ed9d8b4500d1d80371.sol,MemeRecorder,contract MemeRecorder { address[] public memeContracts; constructor() public {},1
0x1ebd8d3ca115451b9b6bbaa7ee2f7b0f96e49fd8.sol,ArthurStandardToken,"contract ArthurStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; function ArthurStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x7996f859a313aab6458558c648e2f1f4acbf5f93.sol,HealthAidToken,contract HealthAidToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 25000000000 * 100000000; function name() public constant returns (string) { return ; },1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0x6abf810730a342add1374e11f3e97500ee774d1f.sol,BCFAuction,contract BCFAuction is Pausable { struct CardAuction { address seller; uint128 startPrice; uint128 endPrice; uint64 duration; uint64 startedAt; },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0x8a113a57e74aef531bee8de7e16e604916f053ac.sol,ClipperCoin,"contract ClipperCoin is Owned{ using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public totalSupply = 200000000 ether; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClipperCoin( uint256 initialSupply, string tokenName, uint8 tokenDecimals, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; }",1
0xed2192afa8c062dfd6883759380b7f2d1dc6c0c0.sol,Owned,contract Owned { modifier onlyOwner() { require(msg.sender == owner); _; },1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0x512d3dfe9c5f04276d772984c3a94039ad34b32b.sol,Airdrop,"contract Airdrop { function transfer(address from, address caddress, address[] _tos, uint256[] v) public returns (bool) { require(_tos.length > 0); require(v.length > 0); bytes4 id = bytes4(keccak256()); for (uint i = 0; i < _tos.length; i++) { require(caddress.call(id, from, _tos[i], v[i])); }",1
0x36b53bf543eebf9ad42c5f161efd1247f38d034d.sol,REOC,"contract REOC { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function REOC() public { totalSupply = 2000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xb430244b442c228a59a0fd4450fa7eedd5fbf833.sol,VOC_ethchf_48013527701_20181215,"contract VOC_ethchf_48013527701_20181215 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 330000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0xf5068761511594c82328102f4fde4650ed9ea6c4.sol,WHP,contract WHP is StandardToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address private creator; mapping (address => uint256) private blackmap; mapping (address => uint256) private releaseamount; modifier onlyCreator() { require(msg.sender == creator); _; },1
0x4d797cbb28c49bd074db4a47b582c95fd37804a1.sol,CloutToken,"contract CloutToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function CloutToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0x212fa406fd28663ee6110d863a18e80960300e5c.sol,AnxToken,"contract AnxToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x963012c66676F1B4d8cbb491dd78AF3278789738] = _totalSupply; emit Transfer(address(0), 0x963012c66676F1B4d8cbb491dd78AF3278789738, _totalSupply); }",1
0xf443aaaf1e0770a078b5e1b783e68eb71c9e2f0f.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0xd359e3f53b5d4e11b8b11dc0772448f380accf3c.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x37f16599a7a4ba385770dbc3c143485fc2b709ce.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 36000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0.sol,LLTokenBTB,"contract LLTokenBTB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function LLTokenBTB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc.sol,TVToken,contract TVToken { string public name = ; string public symbol = ; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply; uint256 constant initialSupply = 950007890020; bool public stopped = false; address internal owner = 0x0; modifier ownerOnly { require(owner == msg.sender); _; },1
0x6c0f03411ab250f0a080a4420190b821affd4602.sol,ERC721Token,"contract ERC721Token is ERC721Interface, ERC721Metadata, ERC721Enumerable, Owned { using SafeMath for uint; uint public ownerCount = 0; uint public deedCount = 0; mapping(address => uint) public balances; mapping(uint => address) public mIdOwner; mapping(uint => address) public mIdApproved; function balanceOf(address _owner) external view returns (uint balance) { balance = balances[_owner]; }",1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0xb4b330972e302081ebacd054f4305a3af4103f0f.sol,CryptoTradeToken,"contract CryptoTradeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoTradeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD] = _totalSupply; emit Transfer(address(0), 0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD, _totalSupply); }",1
0x6e3990c89bd13397f3c080500805863275cc85ec.sol,POSV,contract POSV { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0xdd850d1d845a444a13e9516317a0a57075d9cf8e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x04247b9b59091b349eb60e429fe7dbc99fdad34b.sol,FSC3,"contract FSC3 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FSC3( ) TokenERC20() public {}",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x34770f06ae8a9a7b44fd8d636af6a3fec2a58b98.sol,StdToken,"contract StdToken is Token { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; uint public supply; function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); uint previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; emit Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); }",1
0x539bff788404c395117dd2dfdcc3d5e00a72d3b7.sol,EdenwToken,"contract EdenwToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EdenwToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xc81068cd335889736fc485592e4d73a82403d44b.sol,Factories,contract Factories { GooToken constant goo = GooToken(0xdf0960778c6e6597f197ed9a25f12f5d971da86c); Units units = Units(0x0); Inventory inventory = Inventory(0x0); mapping(address => uint256[]) private playerFactories; mapping(uint256 => mapping(uint256 => uint32[8])) public tileBonuses; mapping(address => bool) operator; address owner; uint256 public constant MAX_SIZE = 40; constructor() public { owner = msg.sender; },1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x5bedf488d29407bc08e77cd9ee292c2041a61c8c.sol,UnKoin,contract UnKoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,SupplySchedule,contract SupplySchedule is Owned { using SafeMath for uint; using SafeDecimalMath for uint; struct ScheduleData { uint totalSupply; uint startPeriod; uint endPeriod; uint totalSupplyMinted; },1
0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989.sol,ERC20TokenCPN,contract ERC20TokenCPN { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; address public regulator; uint8 public regulatorStatus; uint internal amount; struct agent { uint balance; mapping (address => uint) allowed; uint8 permission; },1
0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f.sol,TopCoinFXToken,contract TopCoinFXToken { string public name = ; string public symbol = ; uint256 public constant decimals = 18; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 1000000000; uint public constant powNumber = 10; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,PiToken,"contract PiToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PiToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 3141592653589793238 ** uint256(decimals); balanceOf[msg.sender] = totalSupply = 3141592653589793238; tokenName = ; tokenSymbol = ; }",1
0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb.sol,ZIP,"contract ZIP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZIP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x1b60504beb425f7cfc8dd14f29924cf596ffaf0b.sol,SafeMath,None,1
0x21aec0a028d7adec228595b24439c7eb969edd5f.sol,Sudokoin,"contract Sudokoin { uint supply = 203462379904501283815424; uint public boards = 0; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 12; mapping (address => mapping (address => uint)) allowances; mapping (address => uint) balances; mapping (uint => bool) public claimedBoards; event Approval(address indexed _owner, address indexed _spender, uint _value); event BoardClaimed(uint _board, uint _no, address _by); event Burn(address indexed _from, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); function allowance(address _owner, address _spender) constant returns (uint remaining) { remaining = allowances[_owner][_spender]; }",1
0x5573cb8589a2ed0ca4029202739bfc251932201f.sol,STRATCO,"contract STRATCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2fb23f5b0b18e947186c9cc848b86d550c81711c.sol,AndhraToken,"contract AndhraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AndhraToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0x3878c8700b65afcc237f0cf29dc7eae7fa236192] = _totalSupply; Transfer(address(0), 0x3878c8700b65afcc237f0cf29dc7eae7fa236192, _totalSupply); }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoinSale,"contract HngCoinSale is owned, HngCoin { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HngCoinSale( uint256 initialSupply, string tokenName, string tokenSymbol ) HngCoin(initialSupply, tokenName, tokenSymbol) public {}",1
0x1899924f87138cd0607e27c516a84bc839faa1a4.sol,TokenCreator,"contract TokenCreator { event TokenCreated(address indexed owner, address token); function createToken (string _name, string _symbol, uint8 _decimals) public { emit TokenCreated(msg.sender, new MyToken(_name, _symbol, _decimals, msg.sender)); }",1
0xb463ffd52534720186eb18b3b90a94bf12d61619.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 _decimals ) public { decimals = _decimals; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xf20a773b3d9f2a1f080fbae1156a5e9768ceb615.sol,BabyCoin,"contract BabyCoin is Ownable { using SafeMath for uint256; string public name; string public symbol; uint32 public decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdropNum = 2 ether; uint256 public airdropSupply = 2000; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function BabyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0x536ad2443ba256577876dbb4b89db10966513475.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 400000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x48de9c6454d9da324d7908a6472ca4fb77a3e4fd.sol,LC,"contract LC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ba2d5e4384a69df6066e1cf6c395909254910fb.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0x1db45a09efcdd8955b1c3bb855b5a8d333446bff.sol,Share,"contract Share { bool public pause; address public owner; mapping (address => uint) public holds; mapping (address => uint256) public fullfilled; mapping (address => uint256) public sellPrice; mapping (address => uint) public toSell; uint256 public watermark; event PAUSED(); event STARTED(); event SHARE_TRANSFER(address from, address to, uint amount); event INCOME(uint256); event PRICE_SET(address holder, uint shares, uint256 price, uint sell); event WITHDRAWAL(address owner, uint256 amount); event SELL_HOLDS(address from, address to, uint amount, uint256 price); event SEND_HOLDS(address from, address to, uint amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,Crowdsale,"contract Crowdsale is Pausable, TokenVesting { using SafeMath for uint; address public multisigETH; address public commissionAddress; uint public tokensForTeam; uint public ethReceivedPresale; uint public ethReceivedMain; uint public totalTokensSent; uint public tokensSentMain; uint public tokensSentPresale; uint public tokensSentDev; uint public startBlock; uint public endBlock; uint public maxCap; uint public minCap; uint public minContributionMainSale; uint public minContributionPresale; uint public maxContribution; bool public crowdsaleClosed; uint public tokenPriceWei; uint public refundCount; uint public totalRefunded; uint public campaignDurationDays; uint public firstPeriod; uint public secondPeriod; uint public thirdPeriod; uint public firstBonus; uint public secondBonus; uint public thirdBonus; uint public multiplier; uint public status; Step public currentStep; address[] public holdersIndex; address[] public devIndex; enum Step { FundingPreSale, FundingMainSale, Refunding }",1
0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals = 8; uint256 internal _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) internal _allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply(); name = tokenName; symbol = tokenSymbol; }",1
0x0f598112679b78e17a4a9febc83703710d33489c.sol,MoneroGold,contract MoneroGold { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 21000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213.sol,YesManCoin,"contract YesManCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YesManCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88] = _totalSupply; Transfer(address(0), 0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88, _totalSupply); }",1
0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb.sol,ZIP,"contract ZIP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZIP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x26cd1f0943d5877f7de475571172f957c337d4e4.sol,GoldenBit,"contract GoldenBit is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 960000000000000000000000000; balances[0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB] = _totalSupply; emit Transfer(address(0), 0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB, _totalSupply); }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0x6c558a4976e751391fb73dd61fa6a72c318d80b5.sol,BitQ,"contract BitQ is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitQ() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000; balances[0x74205dece41e14DCE4fD94da4Dcfb255f3A69059] = _totalSupply; Transfer(address(0), 0x74205dece41e14DCE4fD94da4Dcfb255f3A69059, _totalSupply); }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0xbf5fb038c28df2b8821988da78c3ebdbf7aa5ac7.sol,GIFT_ENVELOPE,contract GIFT_ENVELOPE { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5890ef4e676cd051e59a348b46e0b3e73601f34d.sol,HIW,"contract HIW { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HIW() { owner = 0x878479357C54d993be99bD332b2649A146da41C0; name = ; symbol = ; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[owner] = 10000000000000000000000000000; }",1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,Bitscreen,contract Bitscreen { struct IPFSHash { bytes32 hash; uint8 hashFunction; uint8 size; },1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0xdc24f9cc79f802587b56f27a7db0833e40c8a22c.sol,FuckCoin,contract FuckCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b29a6277c996b477d6632e60eef41268311ce1c.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 500000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; }",1
0x73f46f17b1a9712262dc3410b37eae4233f36ff9.sol,NeutralToken,contract NeutralToken { function isSenderOwner(address sender) private view returns (bool) { return sender == owner_; },1
0x38f22479795a1a51ccd1e5a41f09c7525fb27318.sol,Bitcoin,"contract Bitcoin { using SafeMath for uint256; uint8 public decimals;uint256 public supplyCap;string public website;string public email = ;address private oW;address public coinage;uint256 public totalSupply;mapping (address => uint256) private balances;mapping (address => mapping (address => uint256)) internal allowed;bool private mintable = true; function Bitcoin(uint256 cap, uint8 dec) public {oW = msg.sender; decimals=dec;supplyCap=cap * (10 ** uint256(decimals));}",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0xf20a773b3d9f2a1f080fbae1156a5e9768ceb615.sol,BabyCoin,"contract BabyCoin is Ownable { using SafeMath for uint256; string public name; string public symbol; uint32 public decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdropNum = 2 ether; uint256 public airdropSupply = 2000; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function BabyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0x77331db23993850d34372c94b804de2461625503.sol,MHCToken,contract MHCTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function MHCTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0xdfbd6a960a55bcfcf59d5925351e05a51498bcef.sol,RockCoin,"contract RockCoin is ERC20{ uint initialSupply = 16500000; string name = ; string symbol = ; uint USDExchangeRate = 300; bool preSale = true; bool burned = false; uint saleTimeStart; address ownerAddress; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint amount); modifier onlyOwner{ if (msg.sender == ownerAddress) { _; }",1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0xe3d424dffecc3759fcc997f5eba2a01a58585405.sol,ERC20Standard,contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard() public { decimals = 18; symbol = ; name = ; mintable = true; owner = msg.sender; totalSupply = 300000000 * (10 ** decimals); balances[msg.sender] = totalSupply; },1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x5c227eb319c24249df66d0c5879515aa59787471.sol,BitAlpha,contract BitAlpha is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 21500000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function BitAlpha() { owner = msg.sender; balances[owner] = 21500000 * 10**8; },1
0x37d82a4e03e93529c1a32429984e12e7875ea1d8.sol,OMGCatCoin,"contract OMGCatCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OMGCatCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x921beCA00339c458342cF09b4B0f4adb3942e332] = _totalSupply; Transfer(address(0), 0x921beCA00339c458342cF09b4B0f4adb3942e332, _totalSupply); }",1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,TxFeatures,contract TxFeatures is BasicToken { struct Tx { uint timestamp; uint amount; },1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0xc094d10e8c0f5f507bb986f01b0c44a83cbf8440.sol,Crowdsale,"contract Crowdsale is Ownable, RateSetter { using SafeMath for uint256; ERC20 public token; CCWhitelist public whitelist; uint256 public startTimePre; uint256 public endTimePre; uint256 public startTimeIco; uint256 public endTimeIco; address public wallet; uint32 public ethEurRate; uint32 public btcEthRate; uint256 public tokensSoldPre; uint256 public tokensSoldIco; uint256 public weiRaised; uint256 public eurRaised; uint256 public contributions; uint256 public preCap; uint8 public preDiscountPercentage; uint256 public icoPhaseAmount1; uint256 public icoPhaseAmount2; uint256 public icoPhaseAmount3; uint256 public icoPhaseAmount4; uint8 public icoPhaseDiscountPercentage1; uint8 public icoPhaseDiscountPercentage2; uint8 public icoPhaseDiscountPercentage3; uint8 public icoPhaseDiscountPercentage4; uint32 public HARD_CAP_EUR = 19170000; uint32 public SOFT_CAP_EUR = 2000000; uint256 public HARD_CAP_IN_TOKENS = 810 * 10**24; mapping (address => uint) public contributors; function Crowdsale(uint256 _startTimePre, uint256 _endTimePre, uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress) { require(_startTimePre >= now); require(_endTimePre >= _startTimePre); require(_startTimeIco >= _endTimePre); require(_endTimeIco >= _startTimeIco); require(_ethEurRate > 0 && _btcEthRate > 0); require(_wallet != address(0)); require(_tokenAddress != address(0)); require(_whitelistAddress != address(0)); startTimePre = _startTimePre; endTimePre = _endTimePre; startTimeIco = _startTimeIco; endTimeIco = _endTimeIco; ethEurRate = _ethEurRate; btcEthRate = _btcEthRate; wallet = _wallet; token = ERC20(_tokenAddress); whitelist = CCWhitelist(_whitelistAddress); preCap = 90 * 10**24; preDiscountPercentage = 50; icoPhaseAmount1 = 135 * 10**24; icoPhaseAmount2 = 450 * 10**24; icoPhaseAmount3 = 135 * 10**24; icoPhaseAmount4 = 90 * 10**24; icoPhaseDiscountPercentage1 = 40; icoPhaseDiscountPercentage2 = 30; icoPhaseDiscountPercentage3 = 20; icoPhaseDiscountPercentage4 = 0; }",1
0x46940639ff7122539b71e836eccb08e53b08045d.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0.sol,LLTokenBTB,"contract LLTokenBTB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function LLTokenBTB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32fb35728c3d95ac9591708bfb91136577ab1dd2.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x36ebdbe660c0b988b83c257a779b908697d41615.sol,ArteufToken,contract ArteufToken is Ownable{ string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000 * 10**18; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x190e2028060fa49adefa5e1f47c8d7be0cbe5063.sol,TRONIXGOLD,"contract TRONIXGOLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TRONIXGOLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x95a96a9fab04Fdf71f37807246408973b30d29e1] = _totalSupply; Transfer(address(0), 0x95a96a9fab04Fdf71f37807246408973b30d29e1, _totalSupply); }",1
0x1fc4f3ed0415fd13748383a08069c549910cc655.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x369d0db2c7d56b095d758379b75f64085953528a.sol,CryptoLeu,"contract CryptoLeu is owned, TokenERC20, Pausable { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CryptoLeu() TokenERC20(60000000, , ) public {}",1
0x1aced77b121ed465a95fb5471e3d409fd2d4ede6.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x1c9be00d799132986edcd2d099b9f28e5757677c.sol,_0xEtherToken,"contract _0xEtherToken is ERC20Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol = ; string public name = ; uint8 public decimals = 8; uint public _totalSupply = 10000000000000000; uint public maxSupplyForEra = 5000000000000000; uint public latestDifficultyPeriodStarted; uint public tokensMinted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget = _MAXIMUM_TARGET; bytes32 public challengeNumber; uint public rewardEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; mapping(bytes32 => bytes32) solutionForChallenge; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; address private owner; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xEtherToken() public { owner = msg.sender; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x2668afe75c5b0b726c2b4388658edae365eda4e2.sol,B2ANDcoin,"contract B2ANDcoin is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function B2ANDcoin( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x022882d9fcf023e57926e4e01d1b137aabd93416.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x856912680349a406f72e26aa994100b8ad409f87.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; function transfer(address to, uint value) public returns (bool) { require((to != 0x0) && (to != address(this))); if (balances[msg.sender] < value) revert(); balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); return true; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x02c60d28be3338014fef3fdf50a3218b946c0609.sol,EasyInvest3,contract EasyInvest3 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x571df5a0b5571a3cc7dcbd8185b200426376845f.sol,EBRK,"contract EBRK { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EBRK( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b.sol,FTWCoin,contract FTWCoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function FTWCoin() public { balances[msg.sender] = 250000000000000000000000000; totalSupply = 250000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000; fundsWallet = msg.sender; },1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7.sol,Bgc,"contract Bgc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bgc( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd96205b1ef12bc471195fe92a896c461528181ab.sol,CandyToken,"contract CandyToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8476957a872ac0bc253333cc063b6a37f6a6faa3.sol,CINDICATORFund,"contract CINDICATORFund { mapping (address => uint256) public balances; mapping (address => bool) public voters; uint256 public votes = 0; bytes32 hash_pwd = 0x9f280e9af8b2203790b80a28449e312091a38cd80f67c9a7ad5a5ce1a8317f49; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 35 ether; address public sale = 0x0; function perform_withdraw(address tokenAddress) { require(bought_tokens); ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; require(token.transfer(msg.sender, tokens_to_withdraw)); }",1
0x33a104dcbed81961701900c06fd14587c908eaa3.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xc654928ecf5f984ef72c806ec9b6e2d213c90818.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x52fb36c83ad33c1824912fc81071ca5eeb8ab390.sol,TOKENERC20,"contract TOKENERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TOKENERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0d1c63e12fde9e5cada3e272576183aba9cfeda2.sol,ZenswapNetworkToken,"contract ZenswapNetworkToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 20000000000000000000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0x07ce333ec45618d838c32e60cee5cb1ce389e06e.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, SafeMath { struct Reserve { uint256 virtualBalance; uint8 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,ERC20,contract ERC20 { function totalSupply() constant returns (uint256 supply) {},1
0x4bb12d68c795462c12ec30ad82421218d9c32a7d.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public percent; mapping(address => uint256) public percentOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event RewardToken(address backer, uint amount, uint percent); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward, uint initPercent ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken * 1 wei; tokenReward = token(addressOfTokenUsedAsReward); percent = initPercent; }",1
0x52ccb8ebb0f55a592ce67dd49249f6cb0c64a129.sol,Globglogabgalab,"contract Globglogabgalab is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Globglogabgalab() public { symbol = ; name = ; decimals = 7; _totalSupply = 13370000000000000; balances[0x433a57803f841C5611e5370ad5CD97bf46e25cb6] = _totalSupply; Transfer(address(0), 0x433a57803f841C5611e5370ad5CD97bf46e25cb6, _totalSupply); }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,Milestones,"contract Milestones is Ownable { enum State { PreIco, IcoOpen, IcoClosed, IcoSuccessful, IcoFailed, BankLicenseSuccessful, BankLicenseFailed }",1
0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0.sol,TokenERC20,"contract TokenERC20 is SafeMath { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) private addressBalance; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function balanceOf (address _owner) constant returns (uint256 balance) { return addressBalance[_owner]; }",1
0x6de20d9d444354ff9b271a6ea6f9274f2467df35.sol,Rollback,"contract Rollback is Owned, ApprovalReceiver { event onSetCredit(address account , uint256 amount); event onReturned(address who, uint256 tokenAmount, uint256 ethAmount); using SafeMath for uint256; Token public token = Token(0xD850942eF8811f2A866692A623011bDE52a462C1); uint256 public totalSetCredit; uint256 public totalReturnedCredit; struct Credit { uint128 total; uint128 used; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0x70538834e68efe5061a11c4999fc050e55ae2b68.sol,AYA,"contract AYA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000; balances[0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b] = _totalSupply; emit Transfer(address(0), 0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b, _totalSupply); }",1
0xce78ab22cd0331a52af7bb4b622edfa792819d47.sol,RUDAWORLD,"contract RUDAWORLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RUDAWORLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad] = _totalSupply; Transfer(address(0), 0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad, _totalSupply); }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0xf265534f967d29190c995314190aa2275f710af5.sol,MHT,"contract MHT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function MHT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x6b27bfd273ec79a64a62b4b3a18a89045c2389b1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x461d558429cb87a5faf967a4333d671b7a97c04f.sol,BOBOToken,"contract BOBOToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 295000000000000000000000000; balances[0xEDFfEaB5E58abAF81C62762DF71DC755fd787F6f] = _totalSupply; emit Transfer(address(0), 0xEDFfEaB5E58abAF81C62762DF71DC755fd787F6f, _totalSupply); }",1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0xa2dfd314cb3fcf821300a2e518469b6544ad6a84.sol,threeZZZToken,"contract threeZZZToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function threeZZZToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf42455BDBA7584b614A2F4E8A5e687ffF31fd896] = _totalSupply; Transfer(address(0), 0xf42455BDBA7584b614A2F4E8A5e687ffF31fd896, _totalSupply); }",1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x0f08bdc02fb681462cb6c73b6b351297692aa6e4.sol,XRUN,"contract XRUN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; mapping (address => uint256) public limitAccount; event LimitBalance(address target, uint256 balance); event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,ShareToken,"contract ShareToken is ERC20Token, WhiteListManager { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; address public icoContract; uint256 constant E2 = 10**2; mapping(address => bool) public rewardTokenLocked; bool public mainSaleTokenLocked = true; uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT = 6666666667; uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT = 33333333333; uint256 public airDropTokenIssuedTotal; uint256 public bountyTokenIssuedTotal; uint256 public constant TOKEN_SUPPLY_SEED_LIMIT = 500000000 * E2; uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT = 2500000000 * E2; uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT; uint256 public seedAndPresaleTokenIssuedTotal; uint8 private constant PRESALE_EVENT = 0; uint8 private constant MAINSALE_EVENT = 1; uint8 private constant BOUNTY_EVENT = 2; uint8 private constant AIRDROP_EVENT = 3; function ShareToken() public { totalTokenIssued = 0; airDropTokenIssuedTotal = 0; bountyTokenIssuedTotal = 0; seedAndPresaleTokenIssuedTotal = 0; mainSaleTokenLocked = true; }",1
0xb459571c4d5b8119ab76d0a5308106c61f9918c5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0x8bbb3375d2401da181711032f658c52252b03275.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x02df890024de6658a5a323c9ea33e8cd492bd3906a19c9977574634af4215a98; constructor() public { owner = msg.sender; },1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x06779e2a75cc5b7ad2c14cf98d88cf2cfcfcc6f1.sol,lucky9io,"contract lucky9io { uint public house_edge = 0; uint public jackpot = 0; uint public total_wins_wei = 0; uint public total_wins_count = 0; uint public total_tickets = 0; bool private game_alive = true; address private owner = 0x5Bf066c70C2B5e02F1C6723E72e82478Fec41201; address[] private entries_addresses; bytes32[] private entries_blockhash; uint private entries_count = 0; modifier onlyOwner() { require(msg.sender == owner, ); _; }",1
0x17c8d8b7659141273a1c2223030c89b96713a44a.sol,XPS,"contract XPS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XPS( ) public { totalSupply = 20000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0xd4d8c546549719f0e79a0b11d624a52859c111d7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,MyBoToken,"contract MyBoToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function MyBoToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xdca82e4dfbce4442b19a85df47fd64aeaaf55d9f.sol,RouletteRules,contract RouletteRules { uint8[5809] payoutTable; address developer; constructor() public { developer = msg.sender; },1
0x089b85fa15f72c1088cbbef23a49db80b91dd521.sol,BlockEstateToken,"contract BlockEstateToken { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BlockEstateToken() public { balances[msg.sender] = 10000000000000000; _totalSupply = 10000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1c3db3898c05d77bd742a219f8f488aac0cb013b.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol= ; uint8 public decimals = 18; uint256 public totalSupply = 500000000 * 10 ** 18 ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0x58849d4a250bbb9d47d6cd93c7ab39ab1e06aeda.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1df6eadc2e1e9f4cbb2d94369210d8f1b790ee19.sol,PinnacleToken,contract PinnacleToken { uint private constant _totalSupply = 100000000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function PinnacleToken() { balances[msg.sender] = _totalSupply; },1
0xc08dcf2fa37b87a89ac7f0fdcb4aebda378dea29.sol,MITToken,contract MITToken is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping(uint => Holder) public lockholders; uint public lockholderNumber; struct Holder { address eth_address; uint exp_time; },1
0x8ce188196892455fb131dea104bc3ba4e8516654.sol,VOCC_I026_20181211,"contract VOCC_I026_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x281043fa2101009dc85d98e0fcd538d299f6eb1c.sol,TKCC,"contract TKCC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e6a00012c2005ca5c75b3ad58baac1a7a8e241f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x33555a3130fc40082a566005714eeec369e62fc8.sol,Dividends,contract Dividends { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 10000000* (10 ** uint256(decimals)); uint256 SellFee = 1250; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x414b23b9deb0da531384c5db2ac5a99ee2e07a57.sol,TPCToken,"contract TPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TPCToken() public { totalSupply = 900000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5438b0938fb88a979032f45b87d2d1aeffe5cc28.sol,Gifto,contract Gifto is ERC20Interface { uint public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; address public owner; mapping(address => uint256) balances; mapping(address => bool) approvedInvestorList; mapping(address => uint256) deposit; address[] buyers; uint _icoPercent = 10; uint public _icoSupply = _totalSupply * _icoPercent / 100; uint public _minimumBuy = 10 ** 17; uint public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x02b3c88b805f1c6982e38ea1d40a1d83f159c3d4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa25d9e3c177a45265349d4bd37b23ec2669dea5b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0xc0ca7bd6f54341bb871f6106acde6ec4d65c1f91.sol,SarahCoin,"contract SarahCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SarahCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000; balances[0xC027b267C1A801497B1D234bfF336d5937C2bF48] = _totalSupply; Transfer(address(0), 0xC027b267C1A801497B1D234bfF336d5937C2bF48, _totalSupply); }",1
0x696be206174bea69e7a00b4deb1c6fddfa4786c9.sol,RAZEN,"contract RAZEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RAZEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce] = _totalSupply; Transfer(address(0), 0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce, _totalSupply); }",1
0x7996f859a313aab6458558c648e2f1f4acbf5f93.sol,HealthAidToken,contract HealthAidToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 25000000000 * 100000000; function name() public constant returns (string) { return ; },1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0xd5dc75c85159e95f0bd8b5196f4f096a6b7fea1f.sol,BMICoin,"contract BMICoin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant UNIT = 10 ** decimals; address public companyWallet; address public backendWallet; uint256 public maxSupply = 3000000 * UNIT; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyBackend() { require(msg.sender == backendWallet); _; }",1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x25caf15e1cc43e7bfa9853a68de463bfb0d27021.sol,IndividualLockableToken,"contract IndividualLockableToken is PausableToken{ using SafeMath for uint256; event LockTimeSetted(address indexed holder, uint256 old_release_time, uint256 new_release_time); event Locked(address indexed holder, uint256 locked_balance_change, uint256 total_locked_balance, uint256 release_time); struct lockState { uint256 locked_balance; uint256 release_time; }",1
0xeec58a6a1584145106693c24115b7efebf9de896.sol,BlockchainTechnologyFundingToken,"contract BlockchainTechnologyFundingToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x2a89115A6160987088CDA53b72f9751005A91EfE] = _totalSupply; emit Transfer(address(0), 0x2a89115A6160987088CDA53b72f9751005A91EfE, _totalSupply); }",1
0x7192bb75777dab47ef6fbf6f6c0e4bcbb2294f38.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0x6d8811059eb8f0509acec06648ea95b3ae01be72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0e496fe351e9a2eabcc76d57b1248e10394d60be.sol,yiDaoGame,"contract yiDaoGame { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaoGame( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x6db92e635ba5d2834fff3db03b6be80d8aa28d5a.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0x1d8ebb2f0345874e9193388ef3a2f063eaa71edc.sol,QuadCoin,"contract QuadCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function QuadCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000000; balances[0x8E38343A2fFcC3dC60b623128E506E1DF5713b62] = _totalSupply; Transfer(address(0), 0x8E38343A2fFcC3dC60b623128E506E1DF5713b62, _totalSupply); }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40489719e489782959486a04b765e1e93e5b221a.sol,SGEToken,"contract SGEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SGEToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x31a5f35f32756fe35d39bafe85607d93185b23f2.sol,GNNM,"contract GNNM { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GNNM( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Token,"contract Token is Owner, Mortal { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; struct Fund{ uint amount; uint unlockStartTime; uint unlockInterval; uint unlockPercent; bool isValue; }",1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1afafc35b364595f06e89a0429c5762452eb7ffd.sol,BasicToken,"contract BasicToken is ERC20Basic, Pausable { using SafeMath for uint256; mapping(address => uint256) freeBalances; mapping(address => uint256) frozenBalances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; }",1
0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837.sol,JawazToken,"contract JawazToken { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JawazToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xece73b9f0e0a3d7f33f79fd1d77cb344288b9966.sol,RVG,"contract RVG is owned, StdToken { string public name = ; string public symbol = ; string public website = ; uint public decimals = 18; uint256 public totalSupplied; uint256 public totalBurned; constructor(uint256 _totalSupply) public { supply = _totalSupply * (1 ether / 1 wei); totalBurned = 0; totalSupplied = 0; balances[address(this)] = supply; }",1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x52a5e1a56a124dce84e548ff96122246e46d599f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa29e71cb2e30e8af956d64b025b88a5ca3d7ecd2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,TokenERC20,"contract TokenERC20 is owned{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c91c0104677d08cded353b1459b68415f278c38.sol,FastEth,contract FastEth { address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35; address constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03; address constant private CASHBACK = 0x33cA4CbC4b171c32C16c92AFf9feE487937475F8; address constant private PRIZE = 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653; uint constant public PERCENT = 4; uint constant public BONUS_PERCENT = 5; uint constant StartEpoc = 1541329170; struct Deposit { address depositor; uint deposit; uint payout; },1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa13034912eca36ddb8a0b62bc86251006d8296d6.sol,LightAirdrop,contract LightAirdrop is OwnableContract{ function LightAirdrop() public { },1
0x516f49a1a2087d481b73abe69f50d6e663228cca.sol,CRYPTOZOLToken,"contract CRYPTOZOLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOZOLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x9254ab18462437F517De179806d83Aa5c9A27031] = _totalSupply; Transfer(address(0), 0x9254ab18462437F517De179806d83Aa5c9A27031, _totalSupply); }",1
0x2add07c4d319a1211ed6362d8d0fbe5ef56b65f6.sol,RETNToken,"contract RETNToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function RETNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf.sol,MagicCube,"contract MagicCube is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5af3630746975d9cbaf236d4117b08a2c7a0bd77.sol,SafeMath,None,1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x3a1237d38d0fb94513f85d61679cad7f38507242.sol,Mindexcoin,"contract Mindexcoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Mindexcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0x54dd71cac082ac6fcfeb727c5bbb0a07be1c5de9.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; winnerAddress = 0xFb2D26b0caa4C331bd0e101460ec9dbE0A4783A4; admins[contractCreator] = true; },1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint256 value; bytes data; bytes4 sig; },1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xb430244b442c228a59a0fd4450fa7eedd5fbf833.sol,VOC_ethchf_48013527701_20181215,"contract VOC_ethchf_48013527701_20181215 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 330000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x783cf9c6754bf826f1727620b4baa19714fedf8d.sol,ETH_MIXER,contract ETH_MIXER { uint256 feePaid; uint256 creatorFee = 0.001 ether; uint256 totalTransfered; struct Transfer { uint256 timeStamp; uint256 currContractBallance; uint256 transferAmount; },1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x3ff9ba3001e61d5833208bef78ea5c268d418398.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x41ebb67c868f5f28bcd823ddbf39c0f32b191256.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f.sol,TopCoinFXToken,contract TopCoinFXToken { string public name = ; string public symbol = ; uint256 public constant decimals = 18; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 1000000000; uint public constant powNumber = 10; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x209f98bc320133681458125bc57ecc03718311cc.sol,bjTest,contract bjTest is Ownable { using SafeMath for uint256; uint256 public JoustNum = 1; uint256 public NumberOfPart = 0; uint256 public Commission = 0.024 * 1 ether; uint256 public RateEth = 0.3 * 1 ether; uint256 public TotalRate = 2.4 * 1 ether; struct BJJtab { uint256 JoustNumber; uint256 UserNumber; address UserAddress; uint256 CoincidNum; uint256 Winning; },1
0x28f2c01a3d86ee4faf037147f0aeb49c2eab47ce.sol,DESH,"contract DESH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000; balances[0x2cF5dc0700bc0dccCF305AD2CFc28717e8299207] = _totalSupply; emit Transfer(address(0), 0x2cF5dc0700bc0dccCF305AD2CFc28717e8299207, _totalSupply); }",1
0xbcdbb16c645816842b6ae7ebea8baa4b35203e73.sol,NetkillerCashier,contract NetkillerCashier{ address public owner; uint public amount; uint public amounteth; modifier onlyOwner { require(msg.sender == owner); _; },1
0xb49c61b2da035bf198815a0d43f108530a834cce.sol,SafeMath,None,1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x1f002ba292d85239fee400a04b21bb3aa4777461.sol,FLTTToken,contract FLTTToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 49800000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function FLTTToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0x2e8e02e29bdc2ef651c351d70eceac23f6349c6f.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,Synth,"contract SynthetixState is ISynthetixState, State, LimitedSetup { using SafeMath for uint; using SafeDecimalMath for uint; mapping(address => IssuanceData) public issuanceData; uint public totalIssuerCount; uint[] public debtLedger; uint public importedXDRAmount; uint public issuanceRatio = SafeDecimalMath.unit() / 5; uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit(); mapping(address => bytes4) public preferredCurrency; constructor(address _owner, address _associatedContract) State(_owner, _associatedContract) LimitedSetup(1 weeks) public {}",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x743bba828949fce4557bad9a52db488ce6fdff8d.sol,ZHSH,"contract ZHSH{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ZHSH() public { balances[msg.sender] = 1300000000000; totalSupply = 1300000000000; name = ; decimals =4; symbol = ; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5abaff0b83f81dc061c590aadcba013c69237fd7.sol,CryptoJade,"contract CryptoJade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoJade() public { symbol = ; name = ; decimals = 18; _totalSupply = 125000000000000000000000000; balances[0x5E77C4cf41618A897759b3A2A32665C85BC2aF21] = _totalSupply; Transfer(address(0), 0x5E77C4cf41618A897759b3A2A32665C85BC2aF21, _totalSupply); }",1
0x4c8c4659f734294d9561c8b0efc210028ed12052.sol,company_acc,contract company_acc { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc209a261dae1dc7caa5b02a54874c85a69de5c9ddc0b0bebdbfa9a394fb24caf; constructor() public { owner = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x7176a57a53a87a800a6d7ec33c8479a8deb57d8b.sol,ARIToken,"contract ARIToken { function ARIToken(address _tokenManager, address _escrow) { tokenManager = _tokenManager; escrow = _escrow; }",1
0x0d6afbb95eec6d35255f8f269c971634a5b3eab0.sol,BOXT,"contract BOXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BOXT() public { balances[msg.sender] = 50000000000000; totalSupply = 50000000000000; name = ; decimals =4; symbol = ; }",1
0x523dc2c35f1d6071b5cd72cf4d7b670193034824.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c6a2ece543d3038f98cea1a2a5f0759fbceb8b1.sol,BatchTokensTransfer,contract BatchTokensTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c0f4c64821d6f8fa96975e20d5bb3ea79eb1071.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x05411045febbb4c8fad13acceb292848b58bd64dd9292cbc9a23f432769a5930; constructor() public { owner = msg.sender; },1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xde6c1dd8404827149f6edc09e50476aa0cd7b4ab.sol,SRX,"contract SRX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRX( ) public { totalSupply = 100000000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000000; name = ; symbol = ; }",1
0x188ff41cc7960dd51b3aa802fcb17ba17c41276d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x64e65d352f6a2949463b3a7595911b61bbafc63e.sol,KIPToken,"contract KIPToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 10000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x4d797cbb28c49bd074db4a47b582c95fd37804a1.sol,CloutToken,"contract CloutToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function CloutToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0xbe2a1d562817b6064e0568a4dc9e2c80f7478dfe.sol,TSCoin,"contract TSCoin { uint256 totalSupply_; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply = 200000000*(10**uint256(decimals)); uint256 public buyPrice; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function totalSupply() public view returns (uint256){ return totalSupply_; }",1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0xdff95d14094b92ad5dd042fdb47b6f25f33fbbaa.sol,DiXiEnergy,contract DiXiEnergy is Limitedsale { string public standart = ; string public name = ; string public symbol = ; uint8 public decimals = 2; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; },1
0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9.sol,Jiggs,contract Jiggs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2e98a6804e4b6c832ed0ca876a943abd3400b224.sol,Bela,"contract Bela is MintableToken, HasNoEther { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public ownerTimeLastMinted; uint public ownerMintRate; uint private globalMintRate; uint public totalBelaStaked; struct TokenStakeData { uint initialStakeBalance; uint initialStakeTime; uint initialStakePercentage; address stakeSplitAddress; }",1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0xf449ef0007c98761bdfced7ab1d0351f71d30468.sol,Danetonbit,"contract Danetonbit { uint256 public totalSupply = 8*10**28; string public name = ; uint8 public decimals = 18; string public symbol = ; mapping (address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor() public { balances[0x5C8E4172D2bB9A558c6bbE9cA867461E9Bb5C502] = totalSupply; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,ERC20OptionsConverter,"contract ERC20OptionsConverter is BaseOptionsConverter, TimeSource, Math { address esopAddress; uint32 exercisePeriodDeadline; mapping(address => uint) internal balances; uint public totalSupply; uint32 public optionsConversionDeadline; event Transfer(address indexed from, address indexed to, uint value); modifier converting() { if (currentTime() >= exercisePeriodDeadline) throw; _; }",1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogBase,"contract EtherDogBase is EtherDogACL { event Birth(address owner, uint256 EtherDogId, uint256 matronId, uint256 sireId, uint256 genes, uint256 generation); event Transfer(address from, address to, uint256 tokenId); struct EtherDog { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint32 siringWithId; uint16 cooldownIndex; uint16 generation; }",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x71972877d68acf22114e05578364a307cafe2885.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) internal constant returns (uint256 ) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0xcf91ddfd551c8eee7dc88372acd8c49a0d8726a3.sol,Alecrypto,"contract Alecrypto is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Alecrypto() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252] = _totalSupply; Transfer(address(0), 0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252, _totalSupply); }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0x4ce68b018062cfccd66c7fbbb2cc1f0161d22150.sol,BOWTERC20,"contract BOWTERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BOWTERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb.sol,NOUR,"contract NOUR { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x64e65d352f6a2949463b3a7595911b61bbafc63e.sol,KIPToken,"contract KIPToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 10000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x41ff17293fe3d87d4b6c9dc050ce17694145e1bc.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x654cdd809f86d1414fcb5563b383dbeccfb8b995.sol,VOCC_I057_20181211,"contract VOCC_I057_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x37e1160184f7dd29f00b78c050bf13224780b0b0.sol,YCCToken,"contract YCCToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function YCCToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x742a56a727dac07e0889920b8887d482325f659b.sol,InfiniCoin,"contract InfiniCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 2100000; balances[0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9] = _totalSupply; emit Transfer(address(0), 0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9, _totalSupply); }",1
0xce78ab22cd0331a52af7bb4b622edfa792819d47.sol,RUDAWORLD,"contract RUDAWORLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RUDAWORLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad] = _totalSupply; Transfer(address(0), 0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad, _totalSupply); }",1
0x031f7f7749247e0913aace12002cf61f039cd7b1.sol,WWECoin,"contract WWECoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WWECoin() public { symbol = ; name = ; decimals = 5; _totalSupply = 5000000000000; balances[0x92c826CA75FA55a64a4688F14863Fe21c04eE02C] = _totalSupply; Transfer(address(0), 0x92c826CA75FA55a64a4688F14863Fe21c04eE02C, _totalSupply); }",1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x409de70d8ad0135e6fd91f343899b93d903c998b.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x700fc72abc067e90111a391d0fae8ce8c799b38f.sol,MultiTransfer,"contract MultiTransfer { address[] public Airdrop2; function multiTransfer(ERC20 token, address[] Airdrop2, uint256 amount) public { for (uint256 i = 0; i < Airdrop2.length; i++) { token.transfer( Airdrop2[i], amount * 10 ** 18); }",1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f.sol,CarbonExchangeCoinToken,"contract CarbonExchangeCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CarbonExchangeCoinToken() public { owner = msg.sender; totalSupply = 50000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0x2154f9d7da8bf221e102197195531c82cee1677e.sol,AIUToken,"contract AIUToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x46570e37d496855b391573fd567599e567a73cb4.sol,VOCC_I043_20181211,"contract VOCC_I043_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x485f3b5ec637187749fd643e517662bd99a4124d.sol,cardpoints,"contract cardpoints is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function cardpoints() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x35B92cb97A07389f0092779844572ae89BF8983a] = _totalSupply; emit Transfer(address(0), 0x35B92cb97A07389f0092779844572ae89BF8983a, _totalSupply); }",1
0x83ba853b8196bb51c148dd762a827c703b156450.sol,FeeWallet,"contract FeeWallet is IFeeWallet, Ownable, Members { address public serviceAccount; uint public servicePercentage; uint public affiliatePercentage; mapping (address => uint) public pendingWithdrawals; function FeeWallet( address _serviceAccount, uint _servicePercentage, uint _affiliatePercentage) public { serviceAccount = _serviceAccount; servicePercentage = _servicePercentage; affiliatePercentage = _affiliatePercentage; }",1
0xebaa1766c577a1ea5833f0502bd9984aef22c61f.sol,DadiSale,contract DadiSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint256 pledged; uint index; },1
0x92b12168afde3b068fdb201ff42c407be27d15ad.sol,Gravestone,"contract Gravestone { string public fullname; string public birth_date; string public death_date; string public epitaph; Worship[] public worships; uint public worship_count; constructor(string _fullname,string _birth_date,string _death_date,string _epitaph) public { fullname = _fullname; birth_date = _birth_date; death_date = _death_date; epitaph = _epitaph; }",1
0xaa70bc3e835e12d6902a8e4da77db4842e519c42.sol,DhaCoin,"contract DhaCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DhaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x54053ea92b9366182dbbf3e4583c8a5496bb2903.sol,CCD_KOHLE_3_20190411,"contract CCD_KOHLE_3_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdcaa6f95fcdd339b80631fed7eb213d653c21b12.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc.sol,COTY,"contract COTY{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d538b9b3c1c3f58707a9689b5bc3d860c011242.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x1ee72092724d17c4667563bac428babfe11f6440.sol,IMAGEWORLD,"contract IMAGEWORLD { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IMAGEWORLD( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,LeaderSystem,"contract LeaderSystem { using SafeMath for uint256; event NewLeader(uint256 _indexTable, address _addr, uint256 _index, uint256 _sum); event LeadersClear(uint256 _indexTable); uint8 public constant leadersCount = 7; mapping (uint8 => uint256) public leaderBonuses; struct LeadersTable { uint256 timestampEnd; uint256 duration; uint256 minSum; address[] leaders; mapping (address => uint256) users; }",1
0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae.sol,EtherBrand,"contract EtherBrand is ERC721 { event Birth(uint256 tokenId, bytes32 name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name); event Transfer(address from, address to, uint256 tokenId); struct Brand { bytes32 name; address owner; uint256 price; uint256 last_price; address approve_transfer_to; }",1
0x30d62b3392520580ffc74d7326bb29a4bf541a4d.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol,VirtualGift,contract VirtualGift is ERC721 { ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); struct Gift { uint256 price; string description; },1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxyCache,contract DSProxyCache { mapping(bytes32 => address) cache; function read(bytes _code) public view returns (address) { bytes32 hash = keccak256(_code); return cache[hash]; },1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa140297bd7aa035d6a4d5abc29b787555aae109f.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0x837768a7231b3363fdddbf6dd89bde1c20dd4676.sol,wphcToken,"contract wphcToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function wphcToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0x330ac902cc4cb12e02249358dcfe3f60785e3439.sol,Easy30,contract Easy30 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 30 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0xa1292ec56f9b78b0fac3f9b80baac133078dd087.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x0d2dea6d6d6780860431e7c8b0cce6db4ca49a41.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdb03170241b7a789934b677a64fa49e7783b41d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xed3ce5919656b9988ab33c04a0e684ec94043f5b.sol,UltraVioletToken,"contract UltraVioletToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function UltraVioletToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xa211db1867e4fa5dc0dd4d8f51f177a51d054d94.sol,ZTKGamers,"contract ZTKGamers is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 5000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 962; uint256 public totalZTKCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; event ZTKCheckIssue(string chequeIndex); struct ZTKCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0xaa70bc3e835e12d6902a8e4da77db4842e519c42.sol,DhaCoin,"contract DhaCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DhaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6c72582241de57e6fd501a99d85c650924039a50.sol,WHC,"contract WHC { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WHC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd2d0f85b690604c245f61513bf4679b24ed64c35.sol,BFDToken,"contract BFDToken is EIP20Interface, SafeMath { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string constant public name = ; uint8 constant public decimals = 18; string constant public symbol = ; mapping (address => uint256) public addressType; mapping (address => uint256[3]) public releaseForSeed; mapping (address => uint256[5]) public releaseForTeamAndAdvisor; event AllocateToken(address indexed _to, uint256 _value, uint256 _type); address public owner; uint256 public finaliseTime; function BFDToken() public { totalSupply = 20*10**26; balances[msg.sender] = totalSupply; owner = msg.sender; }",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0x71402645d25196842b0434a1805726b7c0eef426.sol,BlueChips,contract BlueChips { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xf449ef0007c98761bdfced7ab1d0351f71d30468.sol,Danetonbit,"contract Danetonbit { uint256 public totalSupply = 8*10**28; string public name = ; uint8 public decimals = 18; string public symbol = ; mapping (address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor() public { balances[0x5C8E4172D2bB9A558c6bbE9cA867461E9Bb5C502] = totalSupply; }",1
0x4bb301e545a3e948b20ea9a0f02d3948af6fe6db.sol,TarynToken,contract TarynToken is AccessControlled { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public totalSupply; mapping(address => uint256) balances; mapping(uint256 => address) public addresses; mapping(address => uint256) public indexes; uint public index = 1; function TarynToken() public { totalSupply = INITIAL_SUPPLY; },1
0xc668715818831645cdf0eee3a9b84590fa979e65.sol,BGAToken,"contract BGAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 600000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x64fac631db32d70d77e0b759f9a27e1f6b9e9f6f.sol,TON,"contract TON { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TON() public { balanceOf[msg.sender] = totalSupply; }",1
0x91e1dcfbfe7b6be8ac836d08fb493b085ebbb3ef.sol,CoinLottoToken,"contract CoinLottoToken is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function CoinLottoToken (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x508f36baac673fe9e213e69f0f75cbcfeb015917.sol,MKT,"contract MKT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MKT ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeecfa1f63f9cce7ae80a49d5341dcba2563d72e1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 7600000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af.sol,archercoin,"contract archercoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function archercoin() TokenERC20() public {}",1
0x2906f2b553dcfda6891cba64b0ac9e5780b5c1a6.sol,CoinCopyTrade,"contract CoinCopyTrade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply =2000000000000000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0x1c242bc9af8aa768a54222ed47bb756f1a1a757b.sol,SafeMath,None,1
0x5044ac8da9601edf970dcc91a10c5f41c5c548c0.sol,UPower,contract UPower { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3f9ad22a9c2a52bda2a0811d1080fc9cd23c6c46.sol,IBITToken,"contract IBITToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IBITToken() public { totalSupply = 32000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xb4b330972e302081ebacd054f4305a3af4103f0f.sol,CryptoTradeToken,"contract CryptoTradeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptoTradeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD] = _totalSupply; emit Transfer(address(0), 0x92Bf51aB8C48B93a96F8dde8dF07A1504aA393fD, _totalSupply); }",1
0x01628c3308f798362f89886bdac1506e0b33a045.sol,CBC,"contract CBC is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10 ** uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x8564e222115248d10593cf4a6719fa6d82194e62.sol,ITube,"contract ITube is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ITube() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 5 weeks; endDate = now + 15 weeks; }",1
0x01d706ed109e2038ae3261e30a1ed1af207a9d2c.sol,ETHERECASHTOKEN,"contract ETHERECASHTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETHERECASHTOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39127b81f7c63dcc2477079bd17f08256584f623.sol,VOCC_I055_20181211,"contract VOCC_I055_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x32cd77627ddb1dd8bda46e35c6e68aadfe916066.sol,RedlineFinancialLabCoin,"contract RedlineFinancialLabCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedlineFinancialLabCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0xb4933b15b21924af2c18012c4da78b182f060107.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x51696e028e0fe5416481c28cf1a2626d43680751.sol,IngridIsAHorribleHumanCoin,"contract IngridIsAHorribleHumanCoin is SystemTesterCode { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function IngridIsAHorribleHumanCoin( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xeafff1c115d5f8060531356a21c46668eff6da96.sol,EasyInvest35,contract EasyInvest35 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 35 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x88ac7fbe0024b025ea61db8c7389aab7e75cf2ee.sol,GrandTourer,"contract GrandTourer { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x418ce003a8ad9925239bd20ea52abc1d950aeea1.sol,KidChain,contract KidChain is StandardToken { function () public { revert(); },1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0x4b353a668f90025337e7f1fcd4202c41f50a22df.sol,LEToken,"contract LEToken is StandardToken, Owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 3*10**28; function LEToken(address beneficiary) public { totalSupply_ = INITIAL_SUPPLY; balances[beneficiary] = INITIAL_SUPPLY; }",1
0xec0dc71b3e5fc3f8ddfc655e800ae6d9b55f993f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x2e0b77cd408989a8f09e22d2c832be793f167aae.sol,FrameworkInvest,"contract FrameworkInvest is MintedCrowdsale,CappedCrowdsale, Ownable { mapping(address => bool) public owners; uint8 decimals = 18; enum CrowdsaleStage { PS_R1, PS_R2, PS_R3, PS_R4, PS_R5, PS_R6, PS_R7, ICO }",1
0xd5dc75c85159e95f0bd8b5196f4f096a6b7fea1f.sol,BMICoin,"contract BMICoin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant UNIT = 10 ** decimals; address public companyWallet; address public backendWallet; uint256 public maxSupply = 3000000 * UNIT; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyBackend() { require(msg.sender == backendWallet); _; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0xbc7981956a44b5c5de21ad30aec8099c3ca27dba.sol,HodlETH,contract HodlETH { mapping (address => uint) public userInvested; mapping (address => uint) public entryTime; mapping (address => uint) public withdrawnAmount; mapping (address => uint) public referrerOn; address public advertisingFund = 0x01429d58058B3e84F6f264D91254EA3a96E1d2B7; uint public advertisingPercent = 6; address techSupportFund = 0x0D5dB78b35ecbdD22ffeA91B46a6EC77dC09EA4a; uint public techSupportPercent = 2; uint public startPercent = 25; uint public fiveDayHodlPercent = 30; uint public tenDayHodlPercent = 35; uint public twentyDayHodlPercent = 45; uint public lowBalance = 500 ether; uint public middleBalance = 2000 ether; uint public highBalance = 3500 ether; uint public soLowBalanceBonus = 5; uint public lowBalanceBonus = 10; uint public middleBalanceBonus = 15; uint public highBalanceBonus = 20; function bonusPercent() public view returns(uint){ uint balance = address(this).balance; if (balance < lowBalance){ return (soLowBalanceBonus); },1
0xcf7097406448a6b3b109139e52e20ee909e437d2.sol,Ferrarium,"contract Ferrarium is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ferrarium() public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5bd7b9cd17cee4d2fae01d9695e83098cf409488.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x4be10da47a07716af28ad199fbe020501bddd7af.sol,XTToken,"contract XTToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XTToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x72ba699f0f3c29d0f886c264ec7350533a32b3d5.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x0ef4bd1e9baa163d410b31d47bd4e9ebe7dfda1c.sol,EdxToken,contract EdxToken is ERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; struct VestInfo { uint256 vested; uint256 remain; },1
0x40f5d52331674b60bc532f553c97feac5d60ab34.sol,CryptoMinerTokenPlat,contract CryptoMinerTokenPlat{ modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6f793d30138161e6a5ae98c851882b7dc194d501.sol,EUROSIBENERGO_PFXXI_I_883,"contract EUROSIBENERGO_PFXXI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 597902679176595000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1ba0383fd6b699f35c804a4179536a7c4473780e.sol,VEKSELBERG_Portfolio_I_883,"contract VEKSELBERG_Portfolio_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1248388771473920000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol,X_wallet,contract X_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8b65236d01ab5274303220d4c78b02ef7685ca757275036fc104f62fbe6e10a7; constructor() public { owner = msg.sender; },1
0xe35ff61bbec1c56f5aa304de7bf173d29970d0ac.sol,lindyhanCoin,"contract lindyhanCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function lindyhanCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0x4427bC64b0f00C29393e5b03C164cc9629fF83E8] = _totalSupply; Transfer(address(0), 0x4427bC64b0f00C29393e5b03C164cc9629fF83E8, _totalSupply); }",1
0x18035ee31125a9934de44b0105cd31691cce95d5.sol,BigBoobsToken,"contract BigBoobsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BigBoobsToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5] = _totalSupply; Transfer(address(0), 0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5, _totalSupply); }",1
0xf3dac8e171a13066f8964f74a7c87fd518e4e162.sol,safe,contract safe { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9b604aaf4d2d08b6a570b6961c857ea3828d224d425db6104ac364f354211fa1; constructor() public { owner = msg.sender; },1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc5b106f17246b2f5c0c658dbd6e8d168695806ab.sol,SIEToken,contract SIEToken { using SafeMath for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 3000000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownToken,"contract ExoTownToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public icoContract = 0x0; modifier onlyIcoContract() { require(msg.sender == icoContract); _; }",1
0x64d5e7be2e92d4436ba9c4a630491cb268764103.sol,funds,contract funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9a1488a97840653a0be4a4aed50ecf6137507b7c798a86604f31e3199852668c; constructor() public { owner = msg.sender; },1
0x2cbf103901196f99619f2bf9accdf079e9c76819.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, SMUToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) SMUToken(initialSupply, tokenName, tokenSymbol) public {}",1
0xa1a6cea5c52461028c8d436428ceddb6ce8e7ddc.sol,Metayen,contract Metayen { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x716989fa21d5043165079ddbfd04a76a001a595a.sol,COCTokenBase,"contract COCTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; address public administrator; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function COCTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; administrator = msg.sender; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[administrator] = totalSupply; }",1
0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f.sol,token123,contract token123 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token123() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x5cc0076a6bbf43344a7923c5cca40f5bdff2970e.sol,LiteToken,"contract LiteToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LiteToken() public { symbol = ; name = ; decimals = 4; _totalSupply = 84000000000000; balances[0x186d32c30f1DeFfF1eeDb34Ee661426918243545] = _totalSupply; emit Transfer(address(0), 0x186d32c30f1DeFfF1eeDb34Ee661426918243545, _totalSupply); }",1
0x39cfd754c85023648bf003bea2dd498c5612abfa.sol,TokenBank,contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; },1
0xda5441a5807e5cda5871b6504644e13d677706b1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6bcfcc7035dbe589e9c0c91260772630ce92f25b.sol,TOMAToken,"contract TOMAToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TOMAToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c3bb10de15c31d5dbe48fbb7b87735d1b7d8c32.sol,BLONDCOIN,"contract BLONDCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BLONDCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 45000000000000000000000000; balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply; Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply); }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x1d38b2f0329568ad8730b1970905e4978c16b7ff.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,OfflineSecret,"contract OfflineSecret { modifier validSecret(address to, string secret, bytes32 hashed) { require(checkSecret(to, secret, hashed)); _; }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4efd3bf84f40eda370e52df162eccc394cfc8834.sol,Zhoan,"contract Zhoan { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; address private admin_add; uint private present_money=0; event Transfer(address indexed from, address indexed to, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowances; constructor(uint256 limit,string token_name,string token_symbol,uint8 token_decimals) public { admin_add=msg.sender; name=token_name; symbol=token_symbol; totalSupply=limit * 10 ** uint256(decimals); decimals=token_decimals; balanceOf[admin_add]=totalSupply; }",1
0x1bb28e79f2482df6bf60efc7a33365703bcf1536.sol,hodlEthereum,"contract hodlEthereum { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1596067200; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd.sol,TokenERC20,"contract TokenERC20 is owned{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply=210000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; bool public paused = false; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Seo(address indexed from, uint256 value); function TokenERC20() public { totalSupply = uint256(totalSupply); balanceOf[msg.sender] = totalSupply; name = string(name); symbol = string(symbol); }",1
0xbcef236c69228f004da2fa693c3347946798e0c3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a.sol,RocketCoin,"contract RocketCoin { string public constant symbol = ; string public constant name = ; uint public constant decimals = 18; uint public constant totalSupply = 10000000 * 10 ** decimals; address owner; bool airDropStatus = true; uint airDropAmount = 300 * 10 ** decimals; uint airDropGasPrice = 20 * 10 ** 9; mapping (address => bool) participants; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function RocketCoin() public { owner = msg.sender; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0x26d5b54ba01d5d5a18a99c3fc126c5eb356c1076.sol,VOCC_I092_20181211,"contract VOCC_I092_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcfca01488643501cab56d1855921c897d5ee4b1b.sol,BitcoinInw,"contract BitcoinInw is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c] = _totalSupply; emit Transfer(address(0), 0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c, _totalSupply); }",1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd3676a37a23ad8f4238064c1edc704debf335f26.sol,CariNetPrivilege,"contract CariNetPrivilege { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CariNetPrivilege ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x347d11b17022f0f636dda2492f980cc60117d3f7.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); }",1
0xdba934811a10d2cfe5f33736cc56c42e7b8fd067.sol,HAMDAN,"contract HAMDAN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HAMDAN() public { symbol = ; name = ; decimals = 18; _totalSupply = 999000000000000000000000000; balances[0x91A4A840B9C5e01fc2f735e0331f698D07d98aAE] = _totalSupply; Transfer(address(0), 0x91A4A840B9C5e01fc2f735e0331f698D07d98aAE, _totalSupply); }",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa2651bfa1d613fea0f7a3138e442e4ee865b5ec7.sol,AdsVenture,contract AdsVenture is Owned{ struct User{ string username; uint balance; },1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd.sol,TokenERC20,"contract TokenERC20 is owned{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply=210000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; bool public paused = false; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Seo(address indexed from, uint256 value); function TokenERC20() public { totalSupply = uint256(totalSupply); balanceOf[msg.sender] = totalSupply; name = string(name); symbol = string(symbol); }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,EditionStorage,"contract EditionStorage is BaseStorage { uint public offset = 1000000; uint public offsetIndex = 1; uint8[3] public defaultEditionLimits = [10, 89, 200]; mapping (uint => mapping (uint8 => uint8)) public editionCounts; mapping (uint => mapping (uint8 => uint8)) public editionLimits; mapping (uint => uint) public lastEditionOf; function setOffset(uint _offset) external onlyOwner { offset = _offset; }",1
0x6b6d1a8858893c3e228f335726e1417a35832f76.sol,Carbon,contract Carbon { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 1000000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGame,contract TheEthGame { using SafeMath for uint256; struct Player { uint256 score; uint256 lastCellBoughtOnBlockNumber; uint256 numberOfCellsOwned; uint256 numberOfCellsBought; uint256 earnings; uint256 partialHarmonicSum; uint256 partialScoreSum; address referreal; bytes32 name; },1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0x518be1097f1b72e60f9e12247980f4c08b643809.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b78d47bfd2b391f2f34f31a128487e6768ab4f6.sol,eduCash,"contract eduCash { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function eduCash( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1.sol,VOCC_I073_20181211,"contract VOCC_I073_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0x5192a95f79c83e1581574b90f75a28af79c871ff.sol,DiscountPercentCoin,"contract DiscountPercentCoin is Authorizable, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0x3a7ebc138fd59ccce16b7968199c2ac7b013bbc0.sol,NewToken,contract NewToken { function NewToken() { totalSupply = 1000000000000000000; name = ; decimals = 9; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x64e99085fca7f908e1de0db94dae7449b90e97a5.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x008d3c9e91f8abff45f39eb71b316a0606c6d378.sol,TCN,"contract TCN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TCN( ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = 100000000000000000; name = ; symbol = ; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xa15b24b7b883aac6bc6582b0057c09d62a7a1b2c.sol,Simply10,contract Simply10 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0xbe407e7f8687965412c31f259eb16f75c44fc80b.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; address ownerWallet; bool released = false; enum LockupType {NOLOCK, FOUNDATION, TEAM, CONSORTIUM, PARTNER, BLACK}",1
0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f.sol,token123,contract token123 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token123() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x505d0c2061f124c0ae03f795c4aeddd7ff9d471e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd76ababc8887a72453f5f48ea831b782e49c557a.sol,PizzaCoin,"contract PizzaCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xd0bd12a8d5ebca1e2fa46da59f1993ec51c3d75c.sol,BKToken,"contract BKToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BKToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100000000 * (10 ** decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x7895a43ae537e8e1ac97006ea9235807eea04cfa.sol,YunMint,"contract YunMint is Operational, ReentrancyGuard, BurnableToken, StandardToken { using SafeMath for uint; using SafeMath for uint256; using DateTime for uint256; event Release(address operator, uint256 value, uint256 releaseTime); event Burn(address indexed burner, uint256 value); event Freeze(address indexed owner, uint256 value, uint256 releaseTime); event Unfreeze(address indexed owner, uint256 value, uint256 releaseTime); struct FrozenBalance {address owner; uint256 value; uint256 unFrozenTime;}",1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0xf226b12c03514571c5a473b2627f5528da46d263.sol,ECRecovery,None,1
0x1f002ba292d85239fee400a04b21bb3aa4777461.sol,FLTTToken,contract FLTTToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 49800000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function FLTTToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0xbfaacfdecfbbcc7ea8c17e19c8f4f84c523267de.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4.sol,FccToken,"contract FccToken is Owned, StandardToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function FccToken() { balances[msg.sender] = 200000000* 10**8; totalSupply = 200000000* 10**8; locked = false; }",1
0xbd11eae443ef0e96c1cc565db5c0b51f6c829c0b.sol,AENToken,"contract AENToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 350000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97.sol,metahashtoken,"contract metahashtoken { string public name; string public symbol; uint8 public decimals; uint public totalTokens; uint public finalyze; address public ownerContract; address public owner; mapping (address => uint256) public balance; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function totalSupply() public constant returns (uint256 _totalSupply){ return totalTokens; }",1
0x369d0db2c7d56b095d758379b75f64085953528a.sol,CryptoLeu,"contract CryptoLeu is owned, TokenERC20, Pausable { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CryptoLeu() TokenERC20(60000000, , ) public {}",1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xf19903d8e5b7d604b62d2a210b39ba9e1e1f93ef.sol,STASHToken,"contract STASHToken is STASHInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function STASHToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 36000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 600000; fundsWallet = msg.sender; }",1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,PlatformTeamCoinVer01,"contract PlatformTeamCoinVer01 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x729e895e186b7fbd34485d496415bb2f42629b71.sol,RequestCore,"contract RequestCore is Administrable { using SafeMath for uint256; using SafeMathUint96 for uint96; using SafeMathInt for int256; using SafeMathUint8 for uint8; enum State { Created, Accepted, Canceled }",1
0x887ed27475f60f2df56fefc1f18f3aa8da65fb22.sol,ParkCoin,"contract ParkCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ParkCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1be34bec23ef52fca1b5bb9ce27da1277ca4eebd.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 4000000000 * 10 ** uint256(decimals); address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); address public dateTimeAddr = 0x1a6184CD4C5Bea62B0116de7962EE7315B7bcBce; DateTime dateTime = DateTime(dateTimeAddr); uint[] lockupTime = [dateTime.toTimestamp(2018,11,13),dateTime.toTimestamp(2019,1,13),dateTime.toTimestamp(2019,3,13),dateTime.toTimestamp(2019,5,13)]; uint8[] lockupPercent = [0,25,50,75]; constructor() public { balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0xedf7eac72ff28dbcde6aa14322726a7d05739007.sol,EasyInvest20,contract EasyInvest20 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 20 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x57deefef435a069d95a1523ae8955c993b2b1201.sol,pennyCoin,"contract pennyCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function pennyCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238] = _totalSupply; Transfer(address(0), 0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238, _totalSupply); }",1
0xed51040da497901107870ece117f9ed8df4f4e52.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x696be206174bea69e7a00b4deb1c6fddfa4786c9.sol,RAZEN,"contract RAZEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RAZEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce] = _totalSupply; Transfer(address(0), 0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce, _totalSupply); }",1
0x186b32c1b89db762a8ffa317172a4926714e6336.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55e539fb53394851e8c541411d31c942b14b998e.sol,URUGUAY_WINS,"contract URUGUAY_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 325566187175265000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,LoliCoin,"contract LoliCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LoliCoin() TokenERC20() public {}",1
0x5438b0938fb88a979032f45b87d2d1aeffe5cc28.sol,Gifto,contract Gifto is ERC20Interface { uint public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; address public owner; mapping(address => uint256) balances; mapping(address => bool) approvedInvestorList; mapping(address => uint256) deposit; address[] buyers; uint _icoPercent = 10; uint public _icoSupply = _totalSupply * _icoPercent / 100; uint public _minimumBuy = 10 ** 17; uint public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x7038c15f76ad2667837c438c8819fd969899cdbe.sol,Airdrop,"contract Airdrop { function drop(ERC20 token, address[] recipients, uint256[] values) public { for (uint256 i = 0; i < recipients.length; i++) { token.transfer(recipients[i], values[i]); }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0x558c62533def5e9d77a7e555490c0e2889eacf3a.sol,UTokenContract,"contract UTokenContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public UTExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public{ require (crowdsaleIsOpen == true); require(msg.value != 0); mintUTToken(msg.sender, (msg.value * UTExchangeRate * 10**decimals) / etherChange); }",1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33c1aa1014e4ffd61c312671a42ecff8aef6201f.sol,IndividualLockableToken,"contract IndividualLockableToken is ERC20Pausable, Ownable{ using SafeMath for uint256; event LockTimeSetted(address indexed holder, uint256 old_release_time, uint256 new_release_time); event Locked(address indexed holder, uint256 locked_balance_change, uint256 total_locked_balance, uint256 release_time); struct lockState { uint256 locked_balance; uint256 release_time; }",1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x749dab228c71e650addba8c9875b842ad460a3c2.sol,KyberContributorWhitelist,contract KyberContributorWhitelist is Ownable { uint public slackUsersCap = 7; mapping(address=>uint) public addressCap; function KyberContributorWhitelist() {},1
0x0305b4ccbfd603d92ca0d5eae752000273e26a60.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5.sol,DYLC_ERC20Token,"contract DYLC_ERC20Token { address public owner; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 5000000000 * (10**18); uint256 public currentSupply = 0; uint256 public angelTime = 1522395000; uint256 public privateTime = 1523777400; uint256 public firstTime = 1525073400; uint256 public secondTime = 1526369400; uint256 public thirdTime = 1527665400; uint256 public endTime = 1529047800; uint256 public constant earlyExchangeRate = 83054; uint256 public constant baseExchangeRate = 55369; uint8 public constant rewardAngel = 20; uint8 public constant rewardPrivate = 20; uint8 public constant rewardOne = 15; uint8 public constant rewardTwo = 10; uint8 public constant rewardThree = 5; uint256 public constant CROWD_SUPPLY = 550000000 * (10**18); uint256 public constant DEVELOPER_RESERVED = 4450000000 * (10**18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdd89d6ab3aca67ed697492ba4de2f2763490224b.sol,NFTYToken,"contract NFTYToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; string public constant name = ; string public constant symbol = ; uint public constant decimals = 3; uint public constant totalSupply = 100000 * 10 ** decimals; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(0, msg.sender, totalSupply); }",1
0x400c73395bbc01d9e757f02f267925e1de0779f8.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0xec662B61C129fcF9fc6DD6F1A672021A539CE45d); },1
0x71402645d25196842b0434a1805726b7c0eef426.sol,BlueChips,contract BlueChips { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x282c3971f8041bf4ab8b0d2ad0875e94958f8940.sol,RENAULT_301201,"contract RENAULT_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10641072767863300000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x7895a43ae537e8e1ac97006ea9235807eea04cfa.sol,DateTime,None,1
0x570581a21edb40d399b6d2f407a86506c4b7d663.sol,EVO2,contract EVO2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6b963f7b38980f5fbbd129fe98059eb2144076a7.sol,BLV,"contract BLV { string public name; string public symbol; uint8 public decimals = 1; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLV( ) public { totalSupply = 1000000000; balanceOf[msg.sender] = 1000000000; name = ; symbol = ; }",1
0x556241b90b4c55457a31e27eb612bdc11815d989.sol,NemixToken,"contract NemixToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NemixToken() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x37810173b70e86b8435f8c28590e8faceff59044.sol,SatoMotive,"contract SatoMotive is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SatoMotive() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf44970e29510EDE8fFED726CF8C447F7512fb59f] = _totalSupply; Transfer(address(0), 0xf44970e29510EDE8fFED726CF8C447F7512fb59f, _totalSupply); }",1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,HajjERC20,"contract HajjERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1eeeaffe28d463dcf2c1898d19cf3871e9a17d7c.sol,MultiTransfer,"contract MultiTransfer is MultiOwnable { function MultiTransaction(address _tokenAddress, address[] _addresses, uint256[] _values) public onlyOwner { SNOVToken token = SNOVToken(_tokenAddress); for (uint256 i = 0; i < _addresses.length; i++) { token.transfer(_addresses[i], _values[i]); }",1
0x72d2da71d6ea20c63a4f23b888ea70dc044f6800.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53c2159fa4690ccaa773086a137fb1cd17f65f35.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xc4c06df5c799bec6ee6e4652beec86e5cfc94778.sol,BTF,"contract BTF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTF() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x2f253924924525632B82a2CEB99F7325fB036866] = _totalSupply; Transfer(address(0), 0x2f253924924525632B82a2CEB99F7325fB036866, _totalSupply); }",1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0xaa5eb02bdaf93190922365f4e6326e1131dde3e4.sol,PublicBatchTransfer,"contract PublicBatchTransfer is WalletUsage { using SafeERC20 for ERC20; uint256 public fee; function PublicBatchTransfer(address walletAddress,uint256 _fee){ require(walletAddress != address(0)); setWallet(walletAddress); setFee(_fee); }",1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0xbca5b3524e2d52c38fd6ca6dd10233575baa8533.sol,VOCC_I098_20181211,"contract VOCC_I098_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x875ee23ab07f56476d9029720b43008c20477b38.sol,FlowNet,"contract FlowNet { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint _initialTotalAmount, uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialTotalAmount; balances[msg.sender] = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6c1a692ea7c92ae76cbfdda122830698c950f0ff.sol,CursedToken,contract CursedToken is ERC20 { string public symbol = ; string public name = ; uint8 public decimals = 0; uint public totalSupply = 0; address public owner = 0x55516b579E56C1287f0700eddDa352C2d2c5b3b6; address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CursedToken() public { },1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x0cddd1094b8331b63191282f9b73cf609e139ac4.sol,PWGLToken,contract PWGLToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 88888888866666666; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6c558a4976e751391fb73dd61fa6a72c318d80b5.sol,BitQ,"contract BitQ is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitQ() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000; balances[0x74205dece41e14DCE4fD94da4Dcfb255f3A69059] = _totalSupply; Transfer(address(0), 0x74205dece41e14DCE4fD94da4Dcfb255f3A69059, _totalSupply); }",1
0x77af8c290d10882f634267177128cc7d1e893785.sol,GlobalTransportServices,"contract GlobalTransportServices is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x34644911eeefd50877cca86562e673b94885048b.sol,RUSS_PFVI_III_883,"contract RUSS_PFVI_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1055519864651380000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x35ced9349943292f8a3b2e0a96fec76d7877ac4e.sol,BancorKillerContract,"contract BancorKillerContract { using SafeMath for uint256; address public admin; address public base_token; address public traded_token; uint256 public base_token_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; bool public base_token_is_seeded; bool public traded_token_is_seeded; mapping (address => uint256) public token_balance; constructor(address _base_token, address _traded_token,uint256 _base_token_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = tx.origin; base_token = _base_token; traded_token = _traded_token; base_token_seed_amount = _base_token_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; }",1
0x2a790479cd47f686804fe570b903f3b6cf08599d.sol,ChainmonstersShop,contract ChainmonstersShop { using SafeMath for uint256; address public owner; bool started; uint256 public totalCoinsSold; address medianizer; uint256 shiftValue = 100; uint256 multiplier = 10000; struct Package { uint256 price; string packageReference; bool isActive; uint256 coinsAmount; },1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x6f796ed01c70c796d8378bfbc616a158ea5065c6.sol,WELTCOIN,"contract WELTCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WELTCOIN() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x7f278332a149436adf6F440B4F27492366AA7e5d] = _totalSupply; Transfer(address(0), 0x7f278332a149436adf6F440B4F27492366AA7e5d, _totalSupply); }",1
0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378.sol,OPCToken,"contract OPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OPCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x4159e265fdfa4e581e9b0b2988346ee7db4f0b7e.sol,BANK_III_PFI_883,"contract BANK_III_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 416540085732862000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x585847041ecea75bb8bfe7f2019181978f363dae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2dd09c71d951148bba0f25be7f76ba401fe8ef84.sol,GoTokenDutchAuction,contract GoTokenDutchAuction { GoToken public token; address public owner_address; address public wallet_address; address public whitelister_address; address public distributor_address; uint256 constant public bid_threshold = 10 finney; uint256 public token_multiplier; uint256 public num_tokens_auctioned; uint256 public price_start; uint256 constant public CURVE_CUTOFF_DURATION = 8 days; uint256 public price_constant1; uint256 public price_exponent1; uint256 public price_constant2; uint256 public price_exponent2; uint256 public privatesale_start_time; uint256 public auction_start_time; uint256 public end_time; uint256 public start_block; uint256 public received_wei; uint256 public received_wei_with_bonus; uint256 public funds_claimed; uint256 public final_price; struct Account { uint256 accounted; uint256 received; },1
0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9.sol,Jiggs,contract Jiggs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7439655b739c936147475a7390f2040282da4766.sol,Token,"contract Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; string public description; uint8 public decimals; string public logoURL; string public name; string public symbol; uint public totalSupply; address public creator; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function Token( string _description, string _logoURL, string _name, string _symbol, uint256 _totalSupply ) public { description = _description; logoURL = _logoURL; name = _name; symbol = _symbol; decimals = 18; totalSupply = _totalSupply; creator = tx.origin; Created(creator, _totalSupply); balances[creator] = _totalSupply; }",1
0x537607e30d7a4343fe555d3087ec4762f9002a2c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x72a3678da1e6683ebb58f006888903496d4e97ab.sol,ENC,contract ENC is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10 ** 14 / 2; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3.sol,Bablorub,contract Bablorub is Storage { address public owner = msg.sender; modifier withDeposit() { if (msg.value > 0) { _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0051d363a60bd98d8a10927d10708e5ef853b306.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0x05b075b00cd4779e53dd646759b3c1087b37986a.sol,TriLionToken,"contract TriLionToken { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TriLionToken() public { balances[msg.sender] = 1000000000000000000; _totalSupply = 1000000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x474b4642fa37528652e907a2a3ef7ded8fec8cc8.sol,Cyberminer,"contract Cyberminer is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Cyberminer( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6.sol,SLUTZToken,"contract SLUTZToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SLUTZToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 25000000000000000; balances[0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1] = _totalSupply; Transfer(address(25000000000000000), 0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1, _totalSupply); }",1
0x5304a4b788946f534088e9d8975ca8c1a3ded913.sol,Ozcar,"contract Ozcar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ozcar() public { symbol = ; name = ; decimals = 18; _totalSupply = 1250000000000000000000000000; balances[0xB9705a168AB4a92A78b1F3246fBb98cb5a4a8d6E] = _totalSupply; Transfer(address(0), 0xB9705a168AB4a92A78b1F3246fBb98cb5a4a8d6E, _totalSupply); }",1
0x2f664dccaef62d345d78b62a8095acc828e67e4c.sol,FriendsFingersToken,"contract FriendsFingersToken is DetailedERC20, MintableToken, BurnableToken, SafeContract { address public builder; modifier canTransfer() { require(mintingFinished); _; }",1
0xd38f3c46d20aa7021e486290a24e25eba1491909.sol,IVNTToken,"contract IVNTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xD0899570c15DCfFE5952D32D68A9464725d6BF78; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerBase,contract FlowerBase is FlowerAdminAccess { struct Flower { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint16 cooldownIndex; uint16 generation; },1
0x920231a0e58d685f29ca3838777093fad88f665f.sol,Moongang,contract Moongang { modifier onlyOwner { require(msg.sender == owner); _; },1
0x51d9e05775bde1b3c12d781d2f847b1ab93e3c3d.sol,EthAnte,contract EthAnte { uint public timeOut; uint public feeRate; address public TechnicalRise = 0x7c0Bf55bAb08B4C1eBac3FC115C394a739c62538; address public lastBidder; function EthAnte() public payable { lastBidder = msg.sender; timeOut = now + 1 hours; feeRate = 10; },1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x00c2982959f852abbdb0f5ec023609ea1ca579e8.sol,GAC,"contract GAC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1.sol,VOCC_I073_20181211,"contract VOCC_I073_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28577a6d31559bd265ce3adb62d0458550f7b8a7.sol,CCCToken,"contract CCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CCCToken() public { balanceOf[msg.sender] = totalSupply; }",1
0xecab747bebdbc679ae03349ae325399b0ad7092c.sol,VOCC_I012_20181211,"contract VOCC_I012_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,CustodyStorage,contract CustodyStorage { BBODServiceRegistry public bbodServiceRegistry; mapping(address => bool) public custodiesMap; uint public custodyCounter = 0; address[] public custodiesArray; event CustodyRemoved(address indexed custody); constructor(address _serviceRegistryAddress) public { bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress); },1
0x5c13a9ad2601eeec34672c655d2ca994a360c4a0.sol,GalacticX,"contract GalacticX is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function GalacticX( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xce4726859edc21f0acd5acf8f852f42a1a2dd54b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf084d5bc3e35e3d903260267ebd545c49c6013d0.sol,DimonCoin,contract DimonCoin { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0x0e7d77bf4c468b6b626b07be5aa1c8222eb08324.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf2249b2f36a21185ab97f83214cd8fc5802bb8a0.sol,BLCToken,"contract BLCToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0.sol,LLTokenBTB,"contract LLTokenBTB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function LLTokenBTB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae.sol,EtherBrand,"contract EtherBrand is ERC721 { event Birth(uint256 tokenId, bytes32 name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name); event Transfer(address from, address to, uint256 tokenId); struct Brand { bytes32 name; address owner; uint256 price; uint256 last_price; address approve_transfer_to; }",1
0xf3e6264475f63d771ca562a5176fb9a9b79acd67.sol,Celer,"contract Celer is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Celer() public { symbol = ; name = ; decimals = 8; _totalSupply = 90000000000000000; balances[0x19532C1A9588ec51fc0EB54467E08233636b1a91] = _totalSupply; emit Transfer(address(0), 0x19532C1A9588ec51fc0EB54467E08233636b1a91, _totalSupply); }",1
0x0305b4ccbfd603d92ca0d5eae752000273e26a60.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x50fb2403b415c4ce2c94c7bf7cbfa36145fc5cbf.sol,SCCC,"contract SCCC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0x1d2196207512665ad3beb7c3641f7db409dc7beb.sol,BitcoinBLUE,"contract BitcoinBLUE { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitcoinBLUE( ) public { totalSupply = 2100000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c3a7bafd90133756ac63fee437844c47f707420.sol,ZenswapDistribution,contract ZenswapDistribution is Ownable { token public tokenReward; constructor() public { tokenReward = token(0x4fa000dF40C06FC8c7D9179661535846B7Cd4f87); },1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0x1c9be00d799132986edcd2d099b9f28e5757677c.sol,_0xEtherToken,"contract _0xEtherToken is ERC20Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol = ; string public name = ; uint8 public decimals = 8; uint public _totalSupply = 10000000000000000; uint public maxSupplyForEra = 5000000000000000; uint public latestDifficultyPeriodStarted; uint public tokensMinted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget = _MAXIMUM_TARGET; bytes32 public challengeNumber; uint public rewardEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; mapping(bytes32 => bytes32) solutionForChallenge; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; address private owner; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xEtherToken() public { owner = msg.sender; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,MonsterBase,"contract MonsterBase is MonsterAccessControl { event Birth(address owner, uint256 monsterId, uint256 matronId, uint256 sireId, uint256 genes, uint16 generation); event Transfer(address from, address to, uint256 tokenId); struct Monster { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint32 siringWithId; uint16 cooldownIndex; uint16 generation; }",1
0x35027a992a3c232dd7a350bb75004ad8567561b2.sol,EasyInvestForever,contract EasyInvestForever { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public interestRate = 1; uint256 public nextBlock = block.number + 5900; function () external payable { if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; interestRate = (currentBalance - previousBalance) / 10e18 + 1; interestRate = (interestRate > 10) ? 10 : ((interestRate < 1) ? 1 : interestRate); previousBalance = currentBalance ; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0x330b37346f0e759ad29af0221d249f5227876ac4.sol,ERC20Token,contract ERC20Token { function totalSupply() constant returns (uint supply) {},1
0xf297a0806f24dbc96794af54c8c3691874c430f4.sol,ForestEcosphere,"contract ForestEcosphere { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97.sol,metahashtoken,"contract metahashtoken { string public name; string public symbol; uint8 public decimals; uint public totalTokens; uint public finalyze; address public ownerContract; address public owner; mapping (address => uint256) public balance; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function totalSupply() public constant returns (uint256 _totalSupply){ return totalTokens; }",1
0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49.sol,Beneficial,contract Beneficial is Base { function Beneficial() public { },1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c4de8424a6184c830234b996f7dba9720dc9306.sol,XKnockoutHamster,contract XKnockoutHamster { using SafeMath for uint256; struct EntityStruct { bool active; bool vip; uint listPointer; uint256 date; uint256 update; uint256 exit; uint256 profit; },1
0xf354b2e5ea679a726d0348a974971cb4697bf508.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x1c76457f18230dc1c83d3376ca663ca7312f86d8.sol,ETR,"contract ETR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETR() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[msg.sender] = _totalSupply; bonusEnds = now + 0.1 weeks; endDate = now + 500 weeks; }",1
0xa48d3b79f43477224933e492e42f5cacf4091ecc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25be312868aed68afaf5ac75aed062f4d4c78ce3.sol,RAIOCO,"contract RAIOCO is Ownable { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RAIOCO( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a.sol,ZethrDice,contract ZethrDice is ZethrGame { struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint8 rollUnder; uint8 numRolls; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x77b3106417d4cf3138882cc21d4710c71183b707.sol,Brave3d,contract Brave3d { struct Stage { uint8 cnt; uint256 blocknumber; bool isFinish; uint8 deadIndex; mapping(uint8 => address) playerMap; },1
0x5046e860ff274fb8c66106b0ffb8155849fb0787.sol,JavaScriptToken,contract JavaScriptToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 7991996 * 10**8; function name() public constant returns (string) { return ; },1
0x838df5c03147f0b038c24b18af5bb5dee1ffd446.sol,Edgecoin,"contract Edgecoin is SafeMath, DateTime, EdgeSmartToken { address owner; uint private totalCollected = 0; uint private preSaleCollected = 0; uint private ICOCollected = 0; uint256 public totalTokensCap = (50000000 * 10**_decimals); uint public preSaleTokensLimit = (10000000 * 10**_decimals); uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); uint public icoSaleHardCap = (25000000 * 10**_decimals); uint256 private preSaleTokenPrice = (10000 * 10**_decimals); uint256 private ICOTokenPrice = (5000 * 10**_decimals); bool ICOActive = true; uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0); uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); uint256 private tokensToBuy; mapping (address => bool) private isOwner; mapping (address => bool) private isConfirmed; mapping (uint => address) private ownersArr; uint public nonce; uint public threshold = 3; uint public pendingAmount; address public pendingAddress; uint public confirmedTimesByOwners = 0; constructor() public { owner = msg.sender; isOwner[0x512B431fc06855C8418495ffcc570D246B654f6E] = true; isOwner[0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48] = true; isOwner[0x9016f6fb21F454F294A78AdeFbD700f4B6795C91] = true; ownersArr[0] = 0x512B431fc06855C8418495ffcc570D246B654f6E; ownersArr[2] = 0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48; ownersArr[3] = 0x9016f6fb21F454F294A78AdeFbD700f4B6795C91; totalCollected = 366536727590000000000000; preSaleCollected = 265029930140000000000000; ICOCollected = 101506797450000000000000; }",1
0x03684715e3a614ec80d1b31b62987e0b25925999.sol,GWGFPLUS,"contract GWGFPLUS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GWGFPLUS( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf317f4acfc0d70ccc79a2f24cfbbd7ebc02cfa2e.sol,CryptoStrategiesIntelligence,contract CryptoStrategiesIntelligence is StandardToken { function () public { revert(); },1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrBigWheel,contract ZethrBigWheel is ZethrGame { using SafeMath for uint8; struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint bets; },1
0xc5b106f17246b2f5c0c658dbd6e8d168695806ab.sol,SIEToken,contract SIEToken { using SafeMath for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 3000000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0x5b5d0fbbd75d4501e5cdc854c445fb0eabcb0afc.sol,EmrCrowdfund,"contract EmrCrowdfund is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function EmrCrowdfund( uint256 initialSupply, uint256 _tokenPrice, string tokenName, string tokenSymbol ) public { tokenPrice = _tokenPrice / 10 ** uint256(decimals); totalSupply = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f.sol,POTJ,contract POTJ { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3a1237d38d0fb94513f85d61679cad7f38507242.sol,MindexcoinToken,"contract MindexcoinToken is owned, Mindexcoin { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MindexcoinToken( uint256 initialSupply, string tokenName, string tokenSymbol ) Mindexcoin(initialSupply, tokenName, tokenSymbol) public {}",1
0x40489719e489782959486a04b765e1e93e5b221a.sol,SGEToken,"contract SGEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SGEToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x33286518eff61b810b9796cf847d84be65160147.sol,XCAToken,"contract XCAToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XCAToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a.sol,digithothToken,"contract digithothToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply = 500000000; uint public startDate; uint public bonusEnds; uint public presaleEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function digithothToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; presaleEnds = now + 6 weeks; endDate = now + 10 weeks; }",1
0x1a94fdf6d0bf45d298557789550bb2d7e359ca2d.sol,CrossChainEntertainmentTokenE,"contract CrossChainEntertainmentTokenE { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x6e7a61fbe11873f4c7d0983c79683aad5c0788bd.sol,ERC20Receive,contract ERC20Receive { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x72bd9e034a034796d77b080bb3d477333c651be4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa35f8ec479ba1f8113b27636f1dfa3ae30c3eeae.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3.sol,queue,contract queue { Queue public q; struct BuyTicket { address account; uint amount; uint time; },1
0x1e05efba2fd19cc48a123a9e38afa6a9ffc18f41.sol,TwentyOneMillionToken,contract TwentyOneMillionToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xdfb9e87ff81cb089484ef8150a21be80f6cdd401.sol,CRYPTOPOKER,"contract CRYPTOPOKER { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000* (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x6b775965ff81583429ee39f4f6a5fb6889ab61eb.sol,ZTKDIGITALTOKEN,"contract ZTKDIGITALTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZTKDIGITALTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xb6d8f913834B34BC5c997C63C597956E42dA405a] = _totalSupply; Transfer(address(0), 0xb6d8f913834B34BC5c997C63C597956E42dA405a, _totalSupply); }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BasicToken,contract BasicToken is ERC20Basic { mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xaf6dbf545cc245c00b425d02e545b6ecc1527f3d.sol,LSCKcoin,"contract LSCKcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LSCKcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65] = _totalSupply; Transfer(address(0), 0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65, _totalSupply); }",1
0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3.sol,Bablorub,contract Bablorub is Storage { address public owner = msg.sender; modifier withDeposit() { if (msg.value > 0) { _; },1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol,X_wallet,contract X_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8b65236d01ab5274303220d4c78b02ef7685ca757275036fc104f62fbe6e10a7; constructor() public { owner = msg.sender; },1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0x6fc2a418d752e4b26dc372ccd766696f9c462e30.sol,HTG,"contract HTG { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HTG( ) public { totalSupply = 5000000000000; balanceOf[msg.sender] = 5000000000000; name = ; symbol = ; }",1
0x20d88cfc6d23d06c98d7661aded19043e9ee5aa0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39e743fee400a5d9b36f1167b70c10e8f06440e5.sol,TNCGroupToken,"contract TNCGroupToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x27718f6f920781f551082e7b61bd5d046f394400.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdd6eef0507f10d21f716e36d8b1aae76a4fa3f62.sol,CashexGlobalCoin,contract CashexGlobalCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 1000000000000000000; function name() public constant returns (string) { return ; },1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0xa48d3b79f43477224933e492e42f5cacf4091ecc.sol,AdvancedCOINSToken,"contract AdvancedCOINSToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf0cfbff3ed2d09ff731148bc96726e77ce18d649.sol,AIMT,"contract AIMT { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x9283df9554419641f2cab66af4876f9de8526e4c.sol,KikkeliToken,contract KikkeliToken is MintableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; bool public transfersEnabled = false; event TransfersEnabled(); modifier whenTransfersEnabled() { require(transfersEnabled); _; },1
0x2fe3538f247b0152583f9eedf87aa922aebba6d2.sol,DistributedInvestmentOperationPlatformToken,"contract DistributedInvestmentOperationPlatformToken is Pausable, BurnableToken, Standard223Token, FrozenToken { string public name; string public symbol; uint256 public decimals; constructor (uint256 _initialSupply, string _name, string _symbol, uint256 _decimals) public { totalSupply_ = _initialSupply; name = _name; symbol = _symbol; decimals = _decimals; balances[msg.sender] = _initialSupply; emit Transfer(0x0, msg.sender, _initialSupply); }",1
0x570581a21edb40d399b6d2f407a86506c4b7d663.sol,EVO2,contract EVO2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x18b70ebdbca93c0299c87b594676dfed54a1b88d.sol,Timecoin,"contract Timecoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Timecoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2.sol,Poge,"contract Poge { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Poge( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x53ef8e6cb3a7c96d7aecf39b2d4d09c166269c34.sol,AUX1418,"contract AUX1418 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 7; _totalSupply = 1000000000; balances[0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16] = _totalSupply; emit Transfer(address(0), 0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16, _totalSupply); }",1
0x8a96115b0fdc06ab845cf7d5196c80d8ebec4130.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1db45a09efcdd8955b1c3bb855b5a8d333446bff.sol,Share,"contract Share { bool public pause; address public owner; mapping (address => uint) public holds; mapping (address => uint256) public fullfilled; mapping (address => uint256) public sellPrice; mapping (address => uint) public toSell; uint256 public watermark; event PAUSED(); event STARTED(); event SHARE_TRANSFER(address from, address to, uint amount); event INCOME(uint256); event PRICE_SET(address holder, uint shares, uint256 price, uint sell); event WITHDRAWAL(address owner, uint256 amount); event SELL_HOLDS(address from, address to, uint amount, uint256 price); event SEND_HOLDS(address from, address to, uint amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x564a47b92be4d4070f3488112c6dd4ed757ad4c7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value)public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62.sol,SECToken,"contract SECToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SECToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x27e06500263d6b27a3f8b7be636aabc7adc186be.sol,EasyInvestForeverNeverending,contract EasyInvestForeverNeverending { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public calculatedLow = 0; uint256 public investedTotal = 0; uint256 public interestRate = 100; uint256 public nextBlock = block.number + 5900; function () external payable { investedTotal += msg.value; if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; else calculatedLow = 0; interestRate = (currentBalance - previousBalance) / 10e16 + 100; interestRate = (interestRate > 1000) ? 1000 : interestRate; previousBalance = currentBalance ; if (calculatedLow == 0) calculatedLow = currentBalance - (investedTotal * interestRate / 10000); uint256 currentGrowth = 0; currentBalance= address(this).balance; if (currentBalance > calculatedLow) currentGrowth = currentBalance - calculatedLow; if (interestRate == 100) interestRate = 100 * currentGrowth / (previousBalance - calculatedLow + 1); interestRate = (interestRate < 5) ? 5 : interestRate; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0xa575aea29bcf52afa55113b3b1b9e3813143d10d.sol,TokenLingERC20,"contract TokenLingERC20 { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20 ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17aeb3c181365bc4a386d8dc6ecbe2a96a379088.sol,CipherPlayToken,contract CipherPlayToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 24000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x581a653c16ed7ae3f3fa86b549aba090abd42e8b.sol,BYB,"contract BYB{ string public name =; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply =100000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BYB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x1ebda9b505ad2c6ccee86bfc18f58035dcfdc26a.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0x70e6718a025dfaa44159f1c9a9cc20f575f3cdf0.sol,Payreum,contract Payreum is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 500000000 * (10 ** uint256(decimals)); uint256 public PYRToEth; uint256 public ethInWei; address public devWallet; function Payreum () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; PYRToEth = 200000; devWallet = msg.sender; },1
0x6cabf1b590ee8daa30a1c76ff5dd21284d8681d8.sol,HCHToken,"contract HCHToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HCHToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xc59cb23295e2deeb66bd090acb6b02be8d30a11f.sol,Utils,contract Utils { function Utils() { },1
0x6d358ad6eca1461f092659797e8dceb2d5150fa6.sol,EthereumPrivate,"contract EthereumPrivate { string public name=; string public symbol=; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumPrivate() public { totalSupply = 960000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x34770f06ae8a9a7b44fd8d636af6a3fec2a58b98.sol,StdToken,"contract StdToken is Token { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; uint public supply; function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); uint previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; emit Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); }",1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x5573cb8589a2ed0ca4029202739bfc251932201f.sol,STRATCO,"contract STRATCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,WarToken,"contract WarToken is ERC721, AccessAdmin { struct Fashion { uint16 protoId; uint16 quality; uint16 pos; uint16 health; uint16 atkMin; uint16 atkMax; uint16 defence; uint16 crit; uint16 isPercent; uint16 attrExt1; uint16 attrExt2; uint16 attrExt3; }",1
0x56c388df7f4e0947014705f7d61bdc6ebb128ad0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x53088104b7a9a04e52d8b884571634c815bce666.sol,ALONY_HETZ_20230515,"contract ALONY_HETZ_20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15815873703135800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa52d89b535b68e955a516a49c5fa3f6f501ead6e.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5b25b78751126e3a8feffe784d4e2b456c1071a9.sol,GESCrowdsale,contract GESCrowdsale is Ownable { StandardToken public token; constructor(StandardToken _token) public { require(_token != address(0)); token = _token; },1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae.sol,EtherBrand,"contract EtherBrand is ERC721 { event Birth(uint256 tokenId, bytes32 name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name); event Transfer(address from, address to, uint256 tokenId); struct Brand { bytes32 name; address owner; uint256 price; uint256 last_price; address approve_transfer_to; }",1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,ActionAuction,"contract ActionAuction is AccessNoWithdraw { using SafeMath for uint256; event AuctionCreate(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionSold(uint256 indexed index, address indexed seller, address indexed buyer, uint256 tokenId, uint256 price); event AuctionCancel(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionPriceChange(uint256 indexed index, address indexed seller, uint256 tokenId, uint64 newGwei); struct Auction { address seller; uint64 tokenId; uint64 price; uint64 tmStart; uint64 tmSell; }",1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7.sol,RewardsGiftToken,"contract RewardsGiftToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RewardsGiftToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x405d44c9ed3d2d80e375b2360ed0713b71c6b811.sol,Criplos,"contract Criplos { event Transfer(address indexed from, address indexed to, uint tokens); using SafeMath for uint; using ToAddress for bytes; string constant public symbol = ; string constant public name = ; uint8 constant public decimals = 18; address owner; address public advance; address[] recordAccts; uint public priceTokens; uint public minMining; uint public minRemining; uint public minWithdraw; uint public minTransfer; uint totalTokens_; uint totalMining_; uint totalMiners_; uint techBuff_; struct Record { uint balance; uint volume; uint level; address master; }",1
0x35bfd2cfe27ef7af2029d584b9b6c2ca27d9b3c7.sol,EasyEthProfit,contract EasyEthProfit{ mapping (address => uint256) invested; mapping (address => uint256) dateInvest; uint constant public FEE = 4; uint constant public ADMIN_FEE = 10; address private adminAddr; constructor() public{ adminAddr = msg.sender; },1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,PublicBank,"contract PublicBank is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PublicBank() TokenERC20(21000000, , ) public { }",1
0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378.sol,OPCToken,"contract OPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OPCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0x01d5d0108589f3c52fcce6e65503bb6515e66698.sol,DcorpProxy,"contract DcorpProxy is TokenObserver, TransferableOwnership, TokenRetriever { enum Stages { Deploying, Deployed, Executed }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,SafeOpt,None,1
0xc6567b2be42c208bc6875b9ae6b07d0618738c39.sol,DrunkCoin,contract DrunkCoin is IERC20 { using SafeMath for uint256; uint public _totalSupply = 0; address public owner; string public symbol; string public name; uint8 public decimals; uint256 public rate; uint256 public etherRaised; uint256 public drunkness; bool public icoRunning; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function () public payable { require(icoRunning); require(msg.value > 0); etherRaised += msg.value; uint256 tokens = msg.value.mul(rate); if(drunkness < 50 * 1 ether) { if(drunkness < 20 * 1 ether) { drunkness += msg.value * 20; if(drunkness > 20 * 1 ether) drunkness = 20 * 1 ether; },1
0x868f77e4758776afa2cc2e46ce972e2043ca8e00.sol,YumeGorilla,"contract YumeGorilla { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public constant totalSupply = 87700000000 * 10 ** decimals; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(0, msg.sender, totalSupply); }",1
0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0.sol,MyToken,"contract MyToken is owned { string public name = ; string public symbol = ; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x8516b43a9b547e4692433340ca9f0a13b5d25d7f.sol,TheInternetCoin,contract TheInternetCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200*10**24; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xda0b84a81662ec19ba06b8e902f22964dd69e13d.sol,KRT,"contract KRT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KRT( ) public { totalSupply = 288000000000000000000000000; balanceOf[msg.sender] = 288000000000000000000000000; name = ; symbol = ; }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x17d30c85376bc2c39edc1da179162d308559a3c4.sol,KFCToken,contract KFCToken { string public name = ; string public symbol = ; uint256 public constant decimals = 8; string public priceIco = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 100000000; uint public constant powNumber = 10; uint public constant PRE_ICO = 20000000 * powNumber ** decimals; uint public constant ICO = 50000000 * powNumber ** decimals; uint public constant TECHNOLOGY_DEVELOPMENT = 10000000 * powNumber ** decimals; uint public constant OPERATION_FUND = 10000000 * powNumber ** decimals; uint public constant TEAM_PARTNER_COMPANION = 10000000 * powNumber ** decimals; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x556b7a8e1e842625844de6a08669cd20523ce131.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x292ee80f00e83faa51a793a87503024f36f3a1dc.sol,Futurescoin,"contract Futurescoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Futurescoin() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3] = _totalSupply; Transfer(address(0), 0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3, _totalSupply); }",1
0x693f915802b6f2bf47e97bf28ac118042278c9fa.sol,DynamicToken,"contract DynamicToken is TokenInterface { bool public isClosed; bool public isMaxSupplyLocked; bool public isLockedOpen; bool public isContractOwnerLocked; uint256 public maxSupply; address public upgradedContract; address public contractOwner; address[] public accounts; string[] public proofIds; mapping (address => bool) public accountExists; mapping (string => bool) proofIdExists; event TransferFrom(address indexed _from, address indexed _to, address indexed _spender, uint256 _amount); event Issue(address indexed _from, address indexed _to, uint256 _amount, string _proofId); event Burn(address indexed _burnFrom, uint256 _amount); event Close(address indexed _closedBy); event Upgrade(address indexed _upgradedContract); event LockOpen(address indexed _by); event LockContractOwner(address indexed _by); event TransferContractOwnership(address indexed _by, address indexed _to); event MaxSupply(address indexed _by, uint256 _newMaxSupply, bool _isMaxSupplyLocked); function DynamicToken() { contractOwner = msg.sender; maxSupply = 10**7; totalSupply = 0; isClosed = false; isMaxSupplyLocked = false; isLockedOpen = false; isContractOwnerLocked = false; }",1
0x01628c3308f798362f89886bdac1506e0b33a045.sol,CBC,"contract CBC is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10 ** uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x8495332b80411cf5114b6c3ecc81deeb65b3951d.sol,SUPERBANK,contract SUPERBANK{ mapping (address => uint256) invested; mapping (address => uint256) dateInvest; uint constant public FEE = 1; uint constant public ADMIN_FEE = 8; uint constant public REFERRER_FEE = 11; address private adminAddr; constructor() public{ adminAddr = msg.sender; },1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0xc48e4349d482296c32bb7ca430466f324c694d34.sol,RozowkaCoin,"contract RozowkaCoin { string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RozowkaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000000; name = ; symbol = ; }",1
0x753e7389ecc2566264587522a3e96e12d7a442c9.sol,BKKToken,"contract BKKToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 300*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BKKToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xed3ce5919656b9988ab33c04a0e684ec94043f5b.sol,UltraVioletToken,"contract UltraVioletToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function UltraVioletToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc.sol,TVToken,contract TVToken { string public name = ; string public symbol = ; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply; uint256 constant initialSupply = 950007890020; bool public stopped = false; address internal owner = 0x0; modifier ownerOnly { require(owner == msg.sender); _; },1
0xa177916265c6f647c8e0bfbed396aec1596d6af8.sol,AOS,contract AOS is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 500000000000000; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x178381837f84a7a636f57a3f2946cda512e5caab.sol,TreasureToken,contract TreasureToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0x520308ffce2feaf394be1f23997312dede3ef541.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x9283df9554419641f2cab66af4876f9de8526e4c.sol,KikkeliToken,contract KikkeliToken is MintableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; bool public transfersEnabled = false; event TransfersEnabled(); modifier whenTransfersEnabled() { require(transfersEnabled); _; },1
0x280daacbd812725baf46e273b84426b1e10ab410.sol,CBEXTOKEN,"contract CBEXTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CBEXTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x11b50FD47E6053F78dd98A95AD07127Bd63C8AF2] = _totalSupply; Transfer(address(0), 0x11b50FD47E6053F78dd98A95AD07127Bd63C8AF2, _totalSupply); }",1
0x08b4c866ae9d1be56a06e0c302054b4ffe067b43.sol,BitCar,contract BitCar is ERC20TokenInterface { function () public { revert(); },1
0x27054b13b1b798b345b591a4d22e6562d47ea75a.sol,AirSwapToken,"contract AirSwapToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant totalSupply = 5000000000000; uint256 becomesTransferable = 1508249410; uint256 lockingPeriod = 604800; modifier onlyAfter(uint256 _time) { require(now >= _time); _; }",1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x3a5f32732d6be576d5dec48354b2377e14675eca.sol,BCTToken,"contract BCTToken is PausableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 21000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x5347bfbec9803c6850dfd55d797e9ecf8689b688.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,ByteConvert,None,1
0xa13034912eca36ddb8a0b62bc86251006d8296d6.sol,LightAirdrop,contract LightAirdrop is OwnableContract{ function LightAirdrop() public { },1
0x8bbb3375d2401da181711032f658c52252b03275.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x02df890024de6658a5a323c9ea33e8cd492bd3906a19c9977574634af4215a98; constructor() public { owner = msg.sender; },1
0x0e16923571c50a48b4f9b3b8319606ef8d6106ae.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x597f180157564555ffd96235806415573a02ecb0e9af129d1ddc24e53fe00c96; constructor() public { owner = msg.sender; },1
0x5ab35ca26d56cf6a25162042daf8ab183687844c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x55100b6e3e1cc3018881a4a68edf229a80bac944.sol,MintingERC20,"contract MintingERC20 is ERC20 { mapping (address => bool) public minters; uint256 public maxSupply; function MintingERC20( uint256 _initialSupply, uint256 _maxSupply, string _tokenName, uint8 _decimals, string _symbol, bool _transferAllSupplyToOwner, bool _locked ) ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked) { standard = ; minters[msg.sender] = true; maxSupply = _maxSupply; }",1
0x5c88e93b5feae72f0fbe787c7f1b96ce3f29ee6a.sol,BWW_ERC20,"contract BWW_ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000000; uint256 public TokenPerKRWBuy = 4; mapping(bytes32 => bool) transactionHashes; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc.sol,CoinwareToken,"contract CoinwareToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinwareToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 260000000000000000000000000; balances[0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F] = _totalSupply; Transfer(address(0), 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F , _totalSupply); }",1
0x64c36b4cec69ee9041b48b950dfd0fc59a849f68.sol,SafeMath,None,1
0x2919336f7a427de135dc515fc5004b083d171ba4.sol,CryptoPokerMarket,"contract CryptoPokerMarket is CryptoPokerBase { event fallbackTrigged(bytes data); event saleCardEvent(address _address,uint256 price); event createSaleCardEvent(address _address); function() public payable { emit fallbackTrigged(msg.data); }",1
0xeecdfead2d05f0708450db0ddd65cd513a9b1eea.sol,DiscoverToken,"contract DiscoverToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000; balances[0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817] = _totalSupply; emit Transfer(address(0), 0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817, _totalSupply); }",1
0x0e44c40162b29f5252db58a7f46b8cabe2c0867f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0xa2d8fa4a15943f32f1bda104308519d33ad894ec.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x28863b9534af2a4c3d912e9a3b76b0b7b4fe2046.sol,ViberateBuyer,"contract ViberateBuyer { mapping (address => uint256) public balances; uint256 public buy_bounty; uint256 public withdraw_bounty; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4; uint256 public earliest_buy_time = 1504612800; uint256 public eth_cap = 10000 ether; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f.sol,HEART,"contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingCustom,contract BiddingCustom is BiddingBase { struct Auction { uint128 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; uint40 timeStart; },1
0xf0552ae7f174e43479159f87a66417cca31eb54b.sol,VOCC_I054_20181211,"contract VOCC_I054_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x74956d3e06b9edfab13f91ac45d8d22420545fd9.sol,TEGTY,"contract TEGTY is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 20 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 15; uint constant valueTeam = valueTotal / 100 * 85; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0xf442c2f7f9f91bd482fac07ed599ece40ffcc283.sol,HeelToken,"contract HeelToken { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=23000000000*10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HeelToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0xeed30721320b6372128e47dc48122fc2c65c1baa.sol,TestPausedToken,"contract TestPausedToken { address owner; uint256 public totalSupply = 1000000000000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public paused = true; mapping (address => mapping (address => uint256)) allowed; mapping(address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier whenNotPaused() { require(!paused); _; }",1
0xee278a3543afbe4c1639b430774537995c6bd995.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=36300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x7038c15f76ad2667837c438c8819fd969899cdbe.sol,Airdrop,"contract Airdrop { function drop(ERC20 token, address[] recipients, uint256[] values) public { for (uint256 i = 0; i < recipients.length; i++) { token.transfer(recipients[i], values[i]); }",1
0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc.sol,CoinwareToken,"contract CoinwareToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinwareToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 260000000000000000000000000; balances[0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F] = _totalSupply; Transfer(address(0), 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F , _totalSupply); }",1
0xbd91b8e4d0afb1b7fc19bca93a74a1c531bd125c.sol,IscmToken,contract IscmToken is StandardToken { function () { throw; },1
0x5744155b0891e09b36d871daf35c04a0f0ef4b9c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x87b9d30c83317d1c07f49c7583bef7e8eea24107.sol,SecurityTokenZhiFu,"contract SecurityTokenZhiFu { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x65731ac534bc0d3fdf3f4bdd2b09cf05044920bc.sol,MetadollarFund,contract MetadollarFund { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x77fa1d1ded3f4bed737e9ae870a6f3605445df9c.sol,CryptoPokemon,contract CryptoPokemon { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address devFeeAddress; address tournamentPrizeAddress; function CryptoPokemon () public { contractCreator = msg.sender; devFeeAddress = 0xFb2D26b0caa4C331bd0e101460ec9dbE0A4783A4; tournamentPrizeAddress = 0xC6784e712229087fC91E0c77fcCb6b2F1fDE2Dc2; admins[contractCreator] = true; },1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrSlots,contract ZethrSlots is ZethrGame { struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint8 numSpins; },1
0x4159e265fdfa4e581e9b0b2988346ee7db4f0b7e.sol,BANK_III_PFI_883,"contract BANK_III_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 416540085732862000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd532375971258953263218994966e2a0a3d5c18a.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721 { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc0c33a4c10dfdca03e583107eb5520555c86f9e.sol,CryptoProfit,contract CryptoProfit { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x83a611488d53cfcda749c2239c1516ab1c514fe7.sol,PICC_301201,"contract PICC_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10814019086663000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,ExchangeRate,"contract ExchangeRate is Ownable { event RateUpdated(uint timestamp, bytes32 symbol, uint rate); mapping(bytes32 => uint) public rates; function updateRate(string _symbol, uint _rate) public onlyOwner { rates[keccak256(_symbol)] = _rate; RateUpdated(now, keccak256(_symbol), _rate); }",1
0x680ec9492d8372662dd439294bff2bd373e96309.sol,MyEtherHODL,"contract MyEtherHODL is Ownable { event Hodl(address indexed hodler, uint indexed amount, uint untilTime, uint duration); event Party(address indexed hodler, uint indexed amount, uint duration); event Fee(address indexed hodler, uint indexed amount, uint elapsed); address[] public hodlers; mapping(address => uint) public indexOfHodler; mapping (address => uint) public balanceOf; mapping (address => uint) public lockedUntil; mapping (address => uint) public lockedFor; function get1(uint index) public constant returns(address hodler1, uint balance1, uint lockedUntil1, uint lockedFor1) { hodler1 = hodlers[index]; balance1 = balanceOf[hodler1]; lockedUntil1 = lockedUntil[hodler1]; lockedFor1 = lockedFor[hodler1]; }",1
0x5a086708501251d2c948d767a88379f0b8d8c300.sol,WeduToken,contract WeduToken is ERC20Interface { string private TOKEN_NAME; string private TOKEN_SYMBOL; uint8 private DECIMAL; uint private WEDU_UNIT; address owner; mapping(address => bool) internal blackList; uint private totalSupplyValue; struct BalanceType { uint locked; uint unlocked; },1
0xaf6dbf545cc245c00b425d02e545b6ecc1527f3d.sol,LSCKcoin,"contract LSCKcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LSCKcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65] = _totalSupply; Transfer(address(0), 0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x73307e983f8843d3e09d320dd4c35cf2783f71f6.sol,CDonToken,"contract CDonToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CDonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { symbol = tokenSymbol; name = tokenName; decimals = 18; _totalSupply = initialSupply * 10 ** uint256(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0xb39b66a7273b83bca1f2f618672302485b391f92.sol,ANHUI_ANNUITY_DAO_33_c,"contract ANHUI_ANNUITY_DAO_33_c { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x01a922de9af2c1158dd947ea5b794f0dd995c7df.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0xb3ccb987036d9e93ea895aa78378e137f72a5e84.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17f93475d2a978f527c3f7c44abf44adfba60d5c.sol,EtherCO2,"contract EtherCO2 { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherCO2() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x32d55157bd2ae652f4b6be48ee4a7a1686d28a3f.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d6ec066345e3466d9e970caad4732983ae4bc2c.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x582b2489710a4189ad558b6958641789587fcc27.sol,PonziUnlimited,contract PonziUnlimited { modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x54f61b89a0bac15c88c6bddf41573ddc1ba5bf6d.sol,LEF,"contract LEF is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function LEF() public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0xa48bb4d1baff077e9c45dab5d70db59537e8ab79.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0xf64196754b5548eef6bfcc434465c0d218309914.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1db45a09efcdd8955b1c3bb855b5a8d333446bff.sol,Share,"contract Share { bool public pause; address public owner; mapping (address => uint) public holds; mapping (address => uint256) public fullfilled; mapping (address => uint256) public sellPrice; mapping (address => uint) public toSell; uint256 public watermark; event PAUSED(); event STARTED(); event SHARE_TRANSFER(address from, address to, uint amount); event INCOME(uint256); event PRICE_SET(address holder, uint shares, uint256 price, uint sell); event WITHDRAWAL(address owner, uint256 amount); event SELL_HOLDS(address from, address to, uint amount, uint256 price); event SEND_HOLDS(address from, address to, uint amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x2a46885f8e02ce11dd21209f3cbc3e91561cfc8a.sol,TMToken,"contract TMToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe3147bc1046fab87292e1b743c1e657b37262496.sol,SafeMath,None,1
0xa29e71cb2e30e8af956d64b025b88a5ca3d7ecd2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6cb9c98e8e6ab46790b088d29a881008675c23eb.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 0; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 6666; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4b3b99e956588b54f5841f2fb7c63721e6c7c392.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0x51696e028e0fe5416481c28cf1a2626d43680751.sol,IngridIsAHorribleHumanCoin,"contract IngridIsAHorribleHumanCoin is SystemTesterCode { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function IngridIsAHorribleHumanCoin( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xce038523e278b6c1344d9e4f735f6064ad7a6032.sol,TokenSwap,"contract TokenSwap is Ownable { HumanStandardToken public ndc; HumanStandardToken public tpt; address public neverdieSigner; uint256 public minSwapAmount = 40; event Swap( address indexed to, address indexed PTaddress, uint256 rate, uint256 amount, uint256 ptAmount ); event BuyNDC( address indexed to, uint256 NDCprice, uint256 value, uint256 amount ); event BuyTPT( address indexed to, uint256 TPTprice, uint256 value, uint256 amount ); function TokenSwap(address _teleportContractAddress, address _neverdieContractAddress, address _signer) public { tpt = HumanStandardToken(_teleportContractAddress); ndc = HumanStandardToken(_neverdieContractAddress); neverdieSigner = _signer; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,SafeMath,None,1
0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 100000000; name = ; decimals = 18; symbol = ; }",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0xec270e8f52b492dd0c2dcd43fc6f868e78f49f18.sol,multiowned,contract multiowned { struct MultiOwnedOperationPendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x5c6d8bb345f4299c76f24fc771ef04dd160c4d36.sol,EthCrystal,contract EthCrystal { using SafeMath for *; struct TowersInfoList { string name; uint256 timeLimit; uint256 warriorToTime; uint256 currentRoundID; uint256 timerType; uint256 growthCoefficient; uint256 winnerShare; uint256 nextRound; uint256 dividendShare; mapping (uint256 => TowersInfo) RoundList; },1
0x848d015af507fb3840fee1078ad3a352e0aba055.sol,PUNCToken,"contract PUNCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PUNCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43] = _totalSupply; Transfer(address(0), 0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43, _totalSupply); }",1
0xce7382bf7f277a2b661aaf71408ac65b287305a0.sol,Maccabi,"contract Maccabi is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Maccabi() { uint supply = 15200000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x0d514c490640d6276b5bb5adc52d1453cf11c5a0.sol,Token,contract Token is StandardToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; address public mintableAddress; function Token(address sale_address) { balances[msg.sender] = 0; totalSupply = 0; name = name; decimals = decimals; symbol = symbol; mintableAddress = sale_address; allowTransfer = true; createTokens(); },1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0x1a699c9d8a34f7a60328bf5f3a3dbf10a3ad5baf.sol,SEAPORT_Portfolio_II_883,"contract SEAPORT_Portfolio_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1237146528101310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x37eba68380f5a549532f658244f82619ac733c03.sol,VOCC_I042_20181211,"contract VOCC_I042_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x282c3971f8041bf4ab8b0d2ad0875e94958f8940.sol,RENAULT_301201,"contract RENAULT_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10641072767863300000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x52ccb8ebb0f55a592ce67dd49249f6cb0c64a129.sol,Globglogabgalab,"contract Globglogabgalab is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Globglogabgalab() public { symbol = ; name = ; decimals = 7; _totalSupply = 13370000000000000; balances[0x433a57803f841C5611e5370ad5CD97bf46e25cb6] = _totalSupply; Transfer(address(0), 0x433a57803f841C5611e5370ad5CD97bf46e25cb6, _totalSupply); }",1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0xf1657ae4204d6fc6166833f29447048d0c3ff7e8.sol,LXB,"contract LXB{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LXB() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x0e16923571c50a48b4f9b3b8319606ef8d6106ae.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x597f180157564555ffd96235806415573a02ecb0e9af129d1ddc24e53fe00c96; constructor() public { owner = msg.sender; },1
0x419b8ed155180a8c9c64145e76dad49c0a4efb97.sol,ApproveAndCallToken,"contract ApproveAndCallToken is StandardToken { function approveAndCall(address _spender, uint _value, bytes _data) public returns (bool) { TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _data); return true; }",1
0x332e68dabba9ac8ac5f9a11423f7e72a8b648d1a.sol,DTDToken,"contract DTDToken is IERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 18; uint public _totalSupply = 100000000e18; uint public _tokenLeft = 100000000e18; uint public _round1Limit = 2300000e18; uint public _round2Limit = 5300000e18; uint public _round3Limit = 9800000e18; uint public _developmentReserve = 20200000e18; uint public _endDate = 1544918399; uint public _minInvest = 0.5 ether; uint public _maxInvest = 100 ether; mapping (address => uint256) _investedEth; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; address public owner; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x7880ddfa13218bae0a42ea56902de21ff29a82ce.sol,BlockGame,"contract BlockGame is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BlockGame() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB] = _totalSupply; Transfer(address(0), 0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB, _totalSupply); }",1
0xaf7188dbaa4e9a25864827cc9b9a72f663017834.sol,HammBones,"contract HammBones is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HammBones() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xcE599E08b3cAd353960143c01F6012cbf90C9DA8] = _totalSupply; Transfer(address(0), 0xcE599E08b3cAd353960143c01F6012cbf90C9DA8, _totalSupply); }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x6c61f6343b7420e142fb05f8b86afed3179eb0f0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x37f0137cb24c315d4f725473697e558d6ccaffaa.sol,CROATIA_WINS,"contract CROATIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 360448278658330000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc83355ef25a104938275b46cffd94bf9917d0691.sol,FUTR,"contract FUTR { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 MAX_SUBMITTED = 500067157619455000000000; uint256 _totalSupply = 0; uint256[] levels = [ 8771929824561400000000, 19895525330179400000000, 37350070784724800000000, 64114776667077800000000, 98400490952792100000000, 148400490952792000000000, 218400490952792000000000, 308400490952792000000000, 415067157619459000000000, 500067157619455000000000 ]; uint256[] ratios = [ 114, 89, 55, 34, 21, 13, 8, 5, 3, 2 ]; uint256 _submitted = 0; uint256 public tier = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event Mined(address indexed _miner, uint _value); event WaitStarted(uint256 endTime); event SwapStarted(uint256 endTime); event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time); event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time); string public name = ; uint8 public decimals = 18; string public symbol = ; bool public swap = false; bool public wait = false; bool public extended = false; uint256 public endTime; uint256 swapTime; uint256 swapEndTime; uint256 endTimeExtended; uint256 swapTimeExtended; uint256 swapEndTimeExtended; uint256 public payRate = 0; uint256 submittedFeesPaid = 0; uint256 penalty = 0; uint256 reservedFees = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () external payable { require(msg.sender != address(0) && tier != 10 && swap == false && wait == false); uint256 issued = mint(msg.sender, msg.value); Mined(msg.sender, issued); Transfer(this, msg.sender, issued); }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b.sol,TittyBase,"contract TittyBase { event Transfer(address indexed from, address indexed to); event Creation(address indexed from, uint256 tittyId, uint256 wpId); event AddAccessory(uint256 tittyId, uint256 accessoryId); struct Accessory { uint256 id; string name; uint256 price; bool isActive; }",1
0x5c3d0012ff81bb9a19d13f8e512d3e72843f0848.sol,RBAC,"contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); function checkRole(address _operator, string _role) public view { roles[_role].check(_operator); }",1
0x0374b22e0727302e0d8db783726c7ec4989f88ad.sol,GINI,"contract GINI is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 constant public decimals =18; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); constructor() public { name = ; symbol = ; initialSupply = 122500000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }",1
0x5abc07d28dcc3b60a164d57e4e3981a090c5d6de.sol,BOMBBA,"contract BOMBBA is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function quaker(address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,EthTranchePricing,"contract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib { uint public constant MAX_TRANCHES = 10; mapping (address => uint) public preicoAddresses; struct Tranche { uint amount; uint price; }",1
0xaa6e73f27efdecb282baaba5914dc23a41fc233c.sol,JILTOKEN,"contract JILTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b0d7b8357bb851de9f1953199c39c7bc4675796.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd0ffe3496101fd676b646ade429653d7df12edd2.sol,ContractEFT,contract ContractEFT is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = formatDecimals(500000000000); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; },1
0x51f4fcf219d79855341f749c0f1008c6066a2f1f.sol,EQU,"contract EQU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EQU( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,PublicBank,"contract PublicBank is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PublicBank() TokenERC20(21000000, , ) public { }",1
0xd3ac627abdc1ce6c27c04b37c86e368f754f2995.sol,GradualPro,contract GradualPro { address constant private FIRST_SUPPORT = 0xf8F04b23dACE12841343ecf0E06124354515cc42; address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c; uint constant public FIRST_PERCENT = 4; uint constant public TECH_PERCENT = 1; uint constant public MULTIPLIER = 121; uint constant public MAX_LIMIT = 2 ether; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xf226b12c03514571c5a473b2627f5528da46d263.sol,ECRecovery,None,1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5c493a221ae9b49c3e45f2df8a3b34223855c1f4.sol,ERC827Caller,"contract ERC827Caller { function makeCall(address _target, bytes _data) external payable returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x127a78da95f02d9139db64ea7d3f6de355975494.sol,DACToken,contract DACToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 30000000000000000; bool public stopped = false; address owner = 0x1e113613C889C76b792AdfdcbBd155904F3310a5; modifier isOwner { assert(owner == msg.sender); _; },1
0xdabd08643935a02fdf49cd6264f8d4de8e1feb69.sol,DAX,"contract DAX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAX( ) public { totalSupply = 200000000000000000000000000; balanceOf[msg.sender] = 200000000000000000000000000; name = ; symbol = ; }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0xed462f6d5a89cc5cab505c0549c2a4e7bbd2522b.sol,EVOLUTION2,contract EVOLUTION2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837.sol,JawazToken,"contract JawazToken { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JawazToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x761341ca3b8186323e55c7e801ecbe9b5df41ad0.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = _totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc.sol,TVToken,contract TVToken { string public name = ; string public symbol = ; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply; uint256 constant initialSupply = 950007890020; bool public stopped = false; address internal owner = 0x0; modifier ownerOnly { require(owner == msg.sender); _; },1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x571df5a0b5571a3cc7dcbd8185b200426376845f.sol,EBRK,"contract EBRK { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EBRK( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x0298d4d15bc4294386b05e5185d3833fc76924b3.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb.sol,NOUR,"contract NOUR { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51257ce076e3b4a2c4de2763e442ea2bf2c61e2c.sol,jiangguilong1,"contract jiangguilong1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function jiangguilong1(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0x6ab4c5563213ea49d3475d8b53f6fec918871d90.sol,DENMARK_WINS,"contract DENMARK_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xee6189995391e82bc48c8bed50285767c60d807f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4839e3de8737769e0f93f176d157dca5e48b7662.sol,CPCToken,"contract CPCToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CPCToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4b96090b1653ec92fd47337593e8a99b4cf902a1.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x28b07e3fe42cd85177bcbbad8e4b60e9e19aac0e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52a4b11b23587467b54a49ec0ccb47436526f714.sol,DoacaoEvento,"contract DoacaoEvento { address public responsavel; enum StatusDoacao{ABERTO, FECHADO, SACADO}",1
0x268f03c41d3f33a697eed9c7f0632053556fae9e.sol,BountyClaims,"contract BountyClaims is Ownable { using SafeMath for uint256; ERC20 public token; address public wallet; mapping(address => uint256) bountyTokens; event Claim( address indexed beneficiary, uint256 amount ); function BountyClaims( ERC20 _token, address _wallet) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; }",1
0x52fe31c97e5c29ea63cbcfb045e1171427bb9248.sol,NewRich,"contract NewRich is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewRich() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a] = _totalSupply; Transfer(address(0), 0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a, _totalSupply); }",1
0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 80000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xcf5a08af322e52bee93861341f7bd90eb3d65aa3.sol,HeavyLitecoin,"contract HeavyLitecoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HeavyLitecoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8] = _totalSupply; Transfer(address(0), 0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8, _totalSupply); }",1
0xcf5229653f1badd37ccedd1f96f6171715f28673.sol,TMCToken,"contract TMCToken is Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TMCToken (uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x006b4425ba57148466c0c54af1c484348a14a8a4.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,Reputation,contract Reputation { address owner; mapping(address => bool) whitelist; mapping(address => int) ratings; constructor () public { owner = msg.sender; },1
0x185480332ee00c4a23422df11e022172dc10d5a9.sol,NausiCoin,"contract NausiCoin is Erc20Token, owned { string public name; string public symbol; uint public decimals; uint _totalSupply; mapping(address => uint) _balanceOf; mapping(address => mapping(address => uint)) _allowance; event Burn(address indexed from, uint amount); event Mint(address indexed from, uint amount); constructor(string tokenName, string tokenSymbol, uint tokenDecimals, uint tokenTotalSupply) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; _totalSupply = tokenTotalSupply * 10**uint(decimals); _balanceOf[msg.sender] = _totalSupply; }",1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x6cc07cb2d1d354f9e2042a26697e7fe9cec4656c.sol,ERGCOIN,contract ERGCOIN is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 800000000 * 10**18; function name() public constant returns (string) { return ; },1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,HECFinalToken,"contract HECFinalToken is StandardToken,owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialSupply; uint256 public deploymentTime = now; uint256 public burnTime = now + 2 minutes; uint256 public sellPrice; uint256 public buyPrice; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; constructor( )public { initialSupply =10000000000*100000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x30dc851be3c09af90c0c8a9dfdd7db85b9d8b304.sol,Fpgcchain,"contract Fpgcchain{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Fpgcchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4bd3aac60b2e8893913b8398edda362e6b46dd98.sol,CryptoPoliceOfficerToken,"contract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable { using MathUtils for uint; string public name; string public symbol; uint8 public decimals = 18; mapping(address => mapping(address => uint)) allowances; bool public publicTransfersEnabled = false; uint public releaseStartTime; uint public lockedAmount; TokenLock[] public locks; struct TokenLock { uint amount; uint timespan; bool released; }",1
