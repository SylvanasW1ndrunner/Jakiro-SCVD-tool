file,contract,code,label
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0xd1632efa392925089785b43410c529f8959a8d9a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x35d76c3db8e826907d2a977500b54b3914ecc020.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1bb0a576936bce5d983e676073ac48ba49f12e05.sol,PullPayment,"contract PullPayment { using SafeMath for uint; mapping(address => uint) public payments; event LogRefundETH(address to, uint value); function asyncSend(address dest, uint amount) internal { payments[dest] = payments[dest].add(amount); }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileCycle,contract AgileCycle { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc.sol,SBITokenCrowdsale,"contract SBITokenCrowdsale is Owned, CrowdsaleParameters { using SafeMath for uint256; string public name = ; SBIToken private token; address public bank; address saleWalletAddress; uint private tokenMultiplier = 10; uint public totalCollected = 0; uint public saleStartTimestamp; uint public saleStopTimestamp; uint public saleGoal; bool public goalReached = false; uint public preicoTokensPerEth = 27314; uint public tokensPerEth = 10500; mapping (address => uint256) private investmentRecords; address crowdsaleAddress = this; uint256 public constant saleStartDate = 1530403200; uint256 public constant saleEndDate = 1535759940; uint256 public constant preSaleStartDate = 1529020800; uint256 public constant preSaleEndDate = 1530403140; uint public preSaleAmount = 5800000; event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther); event FundTransfer(address indexed from, address indexed to, uint indexed amount); function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public { token = SBIToken(_tokenAddress); bank = _bankAddress; tokenMultiplier = tokenMultiplier ** token.decimals(); saleWalletAddress = generalSaleWallet.addr; saleGoal = generalSaleWallet.amount; }",1
0xeafd8b734e32aec64c4b445e9da401427ef63a3a.sol,CryptoBossWannaCry,contract CryptoBossWannaCry is PullPayment{ bool init = false; address public administrator; uint256 public bossRoundNumber; uint256 private randNonce; uint256 constant public BOSS_HP_DEFAULT = 100000; uint256 public HALF_TIME_ATK_BOSS = 0; uint256 constant public VIRUS_MINING_PERIOD = 86400; uint256 public BOSS_DEF_DEFFAULT = 0; CryptoEngineerInterface public EngineerContract; CryptoMiningWarInterface public MiningwarContract; mapping(address => PlayerData) public players; mapping(uint256 => BossData) public bossData; struct PlayerData { uint256 currentBossRoundNumber; uint256 lastBossRoundNumber; uint256 win; uint256 share; uint256 dame; uint256 nextTimeAtk; },1
0x6fff3806bbac52a20e0d79bc538d527f6a22c96b.sol,Token,"contract Token is ERC20, Stoppable { bytes32 public symbol; string public name; uint256 public decimals = 18; TokenLogic public logic; function Token(string name_, bytes32 symbol_) { name = name_; symbol = symbol_; }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x708a64eba17df26cd7085c494b725160ba1a6b7d.sol,ConditionalEscrow,contract ConditionalEscrow is Escrow { function withdrawalAllowed(address _payee) public view returns (bool); function withdraw(address _payee) public { require(withdrawalAllowed(_payee)); super.withdraw(_payee); },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x64d581770b541b5609140232fc12f47bbe0fe6bc.sol,MonetoSale,"contract MonetoSale { Moneto public token; address public beneficiary; address public alfatokenteam; uint public alfatokenFee; uint public amountRaised; uint public tokenSold; uint public constant PRE_SALE_START = 1523952000; uint public constant PRE_SALE_END = 1526543999; uint public constant SALE_START = 1528617600; uint public constant SALE_END = 1531209599; uint public constant PRE_SALE_MAX_CAP = 2531250 * 10**18; uint public constant SALE_MAX_CAP = 300312502 * 10**17; uint public constant SALE_MIN_CAP = 2500 ether; uint public constant PRE_SALE_PRICE = 1250; uint public constant SALE_PRICE = 1000; uint public constant PRE_SALE_MIN_BUY = 10 * 10**18; uint public constant SALE_MIN_BUY = 1 * 10**18; uint public constant PRE_SALE_1WEEK_BONUS = 35; uint public constant PRE_SALE_2WEEK_BONUS = 15; uint public constant PRE_SALE_3WEEK_BONUS = 5; uint public constant PRE_SALE_4WEEK_BONUS = 0; uint public constant SALE_1WEEK_BONUS = 10; uint public constant SALE_2WEEK_BONUS = 7; uint public constant SALE_3WEEK_BONUS = 5; uint public constant SALE_4WEEK_BONUS = 3; mapping (address => uint) public icoBuyers; Stages public stage; enum Stages { Deployed, Ready, Ended, Canceled }",1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol,PLAY_iQuiz,contract PLAY_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x791af5fcb5198c9f469d66b934864dab43d7f044.sol,Verus,"contract Verus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 200000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xCC1967c9EF99848803bc744e881eF84F59CE2b34 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x219e0b7c4868add72a913eef492c228cd1f45cdd.sol,Firextoken,"contract Firextoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 75 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 12000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1104000000000; uint public target0drop = 4500; uint public progress0drop = 0; address multisig = 0x0A8961D531805c7ABB4442123c1b08064dA705Ac; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 10; uint256 public blocksBeforeTargetShoot = 40; constructor() public { },1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0x714c1ef3854591d4118bd6887d4740bc4d5f5412.sol,KaasyToken,"contract KaasyToken is ERC20Interface, Pausable, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply; uint public startDate; uint public bonusEnd20; uint public bonusEnd10; uint public bonusEnd05; uint public endDate; uint public tradingDate; uint public exchangeRate = 25000; uint256 public maxSupply; uint256 public soldSupply; uint256 public maxSellable; uint8 private teamWOVestingPercentage = 5; uint256 public minAmountETH; uint256 public maxAmountETH; address public currentRunningAddress; mapping(address => uint256) balances; mapping(address => uint256) ethDeposits; mapping(address => bool) kycAddressState; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) burnedBalances; event MintingFinished(uint indexed moment); bool isMintingFinished = false; event OwnBlockchainLaunched(uint indexed moment); event TokensBurned(address indexed exOwner, uint256 indexed amount, uint indexed moment); bool isOwnBlockchainLaunched = false; uint momentOwnBlockchainLaunched = 0; uint8 public versionIndex = 1; address addrUniversity; address addrEarlySkills; address addrHackathons; address addrLegal; address addrMarketing; constructor() public { maxSupply = 500000000 * (10 ** 18); maxSellable = maxSupply * 60 / 100; currentRunningAddress = address(this); soldSupply = 0; startDate = 1535760000; bonusEnd20 = 1536969600; bonusEnd10 = 1538179200; bonusEnd05 = 1539388800; endDate = 1542240000; tradingDate = 1543536000; minAmountETH = safeDiv(1 ether, 10); maxAmountETH = safeMul(1 ether, 5000); uint256 teamAmount = maxSupply * 150 / 1000; balances[address(this)] = teamAmount * (100 - teamWOVestingPercentage) / 100; emit Transfer(address(0), address(this), balances[address(this)]); balances[owner] = teamAmount * teamWOVestingPercentage / 100; kycAddressState[owner] = true; emit Transfer(address(0), owner, balances[owner]); addrUniversity = 0x20D9846AB6c348AfF24e762150aBfa15D99e4Af5; balances[addrUniversity] = maxSupply * 50 / 1000; kycAddressState[addrUniversity] = true; emit Transfer(address(0), addrUniversity, balances[addrUniversity]); addrEarlySkills = 0x3CF15B214734bB3C9040f18033440a35d18746Ca; balances[addrEarlySkills] = maxSupply * 50 / 1000; kycAddressState[addrEarlySkills] = true; emit Transfer(address(0), addrEarlySkills, balances[addrEarlySkills]); addrHackathons = 0x3ACEB78ff4B064aEE870dcb844cCa43FC6DcBe7d; balances[addrHackathons] = maxSupply * 45 / 1000; kycAddressState[addrHackathons] = true; emit Transfer(address(0), addrHackathons, balances[addrHackathons]); addrLegal = 0x65e1af8d76af6d1d3E47F14014F3105286FFBcF2; balances[addrLegal] = maxSupply * 30 / 1000; kycAddressState[addrLegal] = true; emit Transfer(address(0), addrLegal, balances[addrLegal]); addrMarketing = 0x3d7Db960837aF96C457bdB481C3De7cE80366b2c; balances[addrMarketing] = maxSupply * 75 / 1000; kycAddressState[addrMarketing] = true; emit Transfer(address(0), addrMarketing, balances[addrMarketing]); _totalSupply = maxSupply * 40 / 100; }",1
0x33d1a1a2d781d395eace70e69423c594e52f1a8b.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileCycleWithAssistance,contract AgileCycleWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x78a73b6cbc5d183ce56e786f6e905cadec63547b.sol,FabricTokenFundraiser,contract FabricTokenFundraiserConfig is FabricTokenConfig { uint constant CONVERSION_RATE = 9000; uint constant TOKENS_HARD_CAP = 71250 * (10**3) * DECIMALS_FACTOR; uint constant START_DATE = 1518688800; uint constant END_DATE = 1522576800; uint constant TOKENS_LOCKED_CORE_TEAM = 12 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 7 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = START_DATE + 1 years; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = START_DATE + 180 days; uint constant TOKENS_BOUNTY_PROGRAM = 1 * (10**6) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 50000000000 wei; uint constant MIN_CONTRIBUTION = 0.1 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 9 ether; },1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1.sol,SetherToken,"contract SetherToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SetherToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,contract WhaleGiveaway1 { address public Owner = msg.sender; uint constant public minEligibility = 0.999001 ether; function() public payable { },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,FlowerCore,"contract FlowerCore is FlowerAuction, Ownable { uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; uint256 public constant GEN0_STARTING_PRICE = 10 finney; uint256 public constant GEN0_AUCTION_DURATION = 1 days; uint256 public promoCreatedCount; uint256 public gen0CreatedCount; constructor() public { stopped = true; rootAddress = msg.sender; adminAddress = msg.sender; _createFlower(0, 0, 0, uint256(-1), address(0)); }",1
0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180.sol,JungleScratch,contract JungleScratch is Owned { using SafeMath for uint; uint public LimitBottom = 0.02 ether; uint public LimitTop = 0.1 ether; address public Drawer; struct Game { bytes32 SecretKey_P; bool isPlay; bool isPay; uint Result; uint Time; address Buyer; uint value; },1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,GTO,contract GTO is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint256 public _totalSupply = 10 ** 14; uint256 public _originalBuyPrice = 45 * 10**7; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; address[] private buyers; uint8 public _icoPercent = 10; uint256 public _icoSupply = _totalSupply * _icoPercent / 100; uint256 public _minimumBuy = 3 * 10 ** 17; uint256 public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0x20461ad484795e3db0a18a825b34f55768f77819.sol,FF_Game,contract FF_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x72636c350431895fc6ee718b92bcc5b4fbd70304.sol,preSale3,contract preSale3 is Ownable { using SafeMath for uint; AgroTechFarmToken public token; bool public preSale3Finished = false; string public constant name = ; address public multisig; address public preSale = 0x02Dcc61022771015b1408323D29C790066CBe2e4; address public preSale1 = 0xfafbb19945fc2d79828e4c5813a619d5683074ba; address public preSale2 = 0x62451D37Ca2EC1f0499996Bc3C7e2BAF258E9729; uint public rate; uint public start; uint public end; uint public hardcap; address public restricted; uint public restrictedPercent; function preSale3() public { token = AgroTechFarmToken(0xa55ffAeA5c8cf32B550F663bf17d4F7b739534ff); multisig = 0x227917ac3C1F192874d43031cF4D40fd40Ae6127; rate = 83333333333000000000; start = 1520640000; end = 1522047600; hardcap = 500000000000000000000; restricted = 0xbcCd749ecCCee5B4898d0E38D2a536fa84Ea9Ef6; restrictedPercent = 35; },1
0x00f9f4f3ced5d4f6aedea8a92414206557df7167.sol,SNL,"contract SNL is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 500000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function SNL() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0xeba4ce0d799fe901f3af52c0e0f088d026b11c81.sol,CFNDCrowdsale,contract CFNDCrowdsale { Token public tokenReward; address public creator; address public owner = 0x56D215183E48881f10D1FaEb9325cf02171B16B7; uint256 private price; modifier isCreator() { require(msg.sender == creator); _; },1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0x89b5eaec2702ab0ff33ca397b3e66c7d925d5144.sol,Soccer,"contract Soccer { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; struct Token { address owner; uint256 price; }",1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkExchange,"contract WolkExchange is WolkProtocol, WolkTGE { uint256 public maxPerExchangeBP = 50; address public exchangeFormula; bool public exchangeIsRunning = false; modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x7271f8fdd7693dca37b40403080abe89ae740168.sol,Game,contract Game { address constant private PROMO = 0x51A2BF880F4db7713E95498833308ffE4D61d080; uint constant public PROMO_PERCENT = 15; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.01 ether; uint constant public LAST_DEPOSIT_PERCENT = 5; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0x515c5f699ba46bb43f720914b5615e00aa160871.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0e915b35cc269b2dfc8bbd8e4a88ed4884a53efc.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false ; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint startTimeInSeconds, uint durationInMinutes, uint szaboCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; price = szaboCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xbcdc85a62e5f29930a43cc20d15fe96786873084.sol,ENJOY,contract ENJOY { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0x0254ffd95dd7c8e27d4c7a32e24464196efcc852.sol,BEATA,"contract BEATA is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BEATA() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd745a7883a6bd19389b6b9dc8580c2ff873f0cd1.sol,Earthpayment,"contract Earthpayment is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 7; uint256 public constant INITIAL_SUPPLY = 21000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Earthpayment() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2.sol,CryptoEngineer,contract CryptoEngineer is PullPayment{ address public administrator; uint256 public prizePool = 0; uint256 public numberOfEngineer = 8; uint256 public numberOfBoosts = 5; address public gameSponsor; uint256 public gameSponsorPrice = 0.32 ether; uint256 public VIRUS_MINING_PERIOD = 86400; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public BASE_PRICE = 0.01 ether; address public miningWarAddress; CryptoMiningWarInterface public MiningWar; mapping(address => Player) public players; mapping(uint256 => BoostData) public boostData; mapping(uint256 => EngineerData) public engineers; mapping(address => bool) public miniGames; struct Player { mapping(uint256 => uint256) engineersCount; uint256 virusNumber; uint256 research; uint256 lastUpdateTime; bool endLoadOldData; },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,AceDice,contract AceDice is usingOraclize { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint64 public oraclizeGasLimit; uint public oraclizeGasPrice; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0xdcb5410ef70f59a5a2839fc6d4d0b2ca981f5e2d.sol,CoinMmc,"contract CoinMmc { address public admin_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; address public account_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 initSupply = 1000000000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; _add_lock_account(0x6efB62605A66E32582c37b835F81Bc91A6a8fb2e, mul(80000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0x0ba46c0fC6a5C206855cEf215222e347E1559eDf, mul(120000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0xE269695D497387DfEAFE12b0b3B54441683F63C8, mul(100000000000,10**uint256(decimals)), 1628351160); }",1
0x840b875acfd1034723a23cb079184c7b56a89b90.sol,DSG_Dice,contract DSG_Dice{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0xdccedb215833b58c8c624abe5b5c715844248816.sol,QuiZ_blIZ,contract QuiZ_blIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xa4fd4ba726139d42d7b7cf18a064600cafac4f97.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 3; uint256 public constant INITIAL_SUPPLY = 70000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBetting,contract MatchBetting { using SafeMath for uint256; struct Team { string name; mapping(address => uint) bettingContribution; mapping(address => uint) ledgerBettingContribution; uint totalAmount; uint totalParticipants; },1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x07c206f253605a9ac4e21a9cf99d7841e8636468.sol,RYCSale,"contract RYCSale { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; address public owner; uint public amountRaised; uint public refundAmount; uint public rate = 5000; uint public constant LOW_RANGE_RATE = 1; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; bool public paused = false; RYCToken public tokenReward; mapping(address => uint256) public balanceOf; mapping(address => uint256) public contributions; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event Pause(); event Unpause(); modifier beforeDeadline() {require (currentTime() < endTime); _;}",1
0xee53ca3ae3d296c0f2a128138d12a0a3a60fa1f5.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge { function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileCycle,contract AgileCycle { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0x219014ef0fdf1b9b0d4e9e453e021573b7082bed.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180.sol,JungleScratch,contract JungleScratch is Owned { using SafeMath for uint; uint public LimitBottom = 0.02 ether; uint public LimitTop = 0.1 ether; address public Drawer; struct Game { bytes32 SecretKey_P; bool isPlay; bool isPay; uint Result; uint Time; address Buyer; uint value; },1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x92949bd74c4d21852a3d9f7dfb841fad2833302b.sol,basisneuro,"contract basisneuro is ERC20Interface { string public name = ""http: uint8 public decimals = 18; string public symbol = ""http: uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public JUSTed; event Message(string message); function JUST() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 232 * 1e18; JUSTed = true; }",1
0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa.sol,quizgame,contract quizgame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0xa5dc0165b798779ac80acc84c4da4ee77b79843f.sol,EosPizzaSliceDonationraiser,contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig { uint constant CONVERSION_RATE = 100000; uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR; uint constant START_DATE = 1520630542; uint constant END_DATE = 1526603720; uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.05 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 4999 ether; },1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameFinance,"contract BurnupGameFinance is BurnupGameOwnership, PullPayment { BurnupHoldingCore burnupHolding; function BurnupGameFinance(address burnupHoldingAddress) public { burnupHolding = BurnupHoldingCore(burnupHoldingAddress); }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0xedbc41b7d0330860be1dd8d682b2e868ae6da6e4.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0xedebe7749b91a475918750842256f23fbe8e3029.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49.sol,Base,contract Base { using SafeMath for uint256; uint public createTime = now; address public owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeControl,"contract CryptoRomeControl { event ContractUpgrade(address newContract); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); address public ownerPrimary; address public ownerSecondary; address public ownerWallet; address public cryptoRomeWallet; mapping(address => uint8) public otherOperators; address public improvementContract; bool public paused = false; constructor() public { ownerPrimary = msg.sender; ownerSecondary = msg.sender; ownerWallet = msg.sender; cryptoRomeWallet = msg.sender; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff.sol,BeezGold,"contract BeezGold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 165 * 1 days; uint public round2 = now + 130 * 1 days; uint public round1 = now + 35 * 1 days; uint256 public totalSupply = 70000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25700e8; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0x654186811320885fC24C318E70a119A43279c1BE; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b.sol,SMCT,"contract SMCT is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function SMCT() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x0dc11b7ed751594906bce3a7091952b30528ee7e.sol,DickMeasurementContest,contract DickMeasurementContest { uint lastBlock; address owner; modifier onlyowner { require (msg.sender == owner); _; },1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0x7241496a3fad5b8fd93b647399f57d7c835d2385.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 88000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0xece7814a9691a94e7f3d9354155e21cfb291e13b.sol,AlmightyKeyChain,"contract AlmightyKeyChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function AlmightyKeyChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xdc99adde3a358e5ff62fff3f26b2296f8cca2306.sol,TokenFactoryCN,"contract TokenFactoryCN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 900000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TokenFactoryCN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x1ed81e904acfa95ca1ffe224ee7aa89f2bf5ef9c.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x1f0d1de1558582ad6f13763f477119a1455502af.sol,Exchange,contract Exchange is ContractReceiver { using SafeMath for uint256; using BytesLib for bytes; struct Order { address owner; bool active; address sellToken; address buyToken; address ring; uint256 amount; uint256 priceMul; uint256 priceDiv; },1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x4d81198dc71ffd13917da27d1a3f8599ac690535.sol,DSG_Dice,contract DSG_Dice{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0xec987914ade432ce9806f418787a4ed0b0e77000.sol,LuckyDice,"contract LuckyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) { if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw; _; }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,CoolPandaToken,"contract CoolPandaToken is ERC20, Lockable { using SafeMath for uint256; uint256 public decimals = 18; address public fundWallet = 0x071961b88F848D09C3d988E8814F38cbAE755C44; uint256 public tokenPrice; function balanceOf(address _addr) external view returns (uint256) { return balances[_addr]; }",1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0xf331f7887d31714dce936d9a9846e6afbe82e0a0.sol,Ico,"contract Ico is Owned { enum State { Runned, Paused, Finished, Expired, Failed }",1
0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 exchange = 1000000; uint256 endICO = 0; address admin; constructor() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; endICO=block.timestamp+(60*60*24*31); }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0x375fe03d186747e455e4ebbc235e9df083c7fe92.sol,QUEST_X,contract QUEST_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xa44fb3aa5c8465512b806145a8f9b60e74f3f851.sol,PITSTOP,"contract PITSTOP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =10000000e18; uint public target0drop = 500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x29c690419841e126b74981e4709e43916ac80f64.sol,QQ_game,contract QQ_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb.sol,OXO,contract OXO is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x5576250692275701efde5eeb51596e2d9460790b.sol,UserDataManager,contract UserDataManager { using NameFilter for string; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; struct Player { address addr; bytes32 name; uint256 laff; },1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55.sol,OrganicumOrders,contract OrganicumOrders { struct order { uint256 balance; uint256 tokens; },1
0x6fff3806bbac52a20e0d79bc538d527f6a22c96b.sol,Token,"contract Token is ERC20, Stoppable { bytes32 public symbol; string public name; uint256 public decimals = 18; TokenLogic public logic; function Token(string name_, bytes32 symbol_) { name = name_; symbol = symbol_; }",1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0x56b7f2a2d6f70d88b991e6c7b8005e0a13a9b379.sol,CryptoCurrencyExchange,"contract CryptoCurrencyExchange is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CryptoCurrencyExchange() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xa2038ce672658f492fcd9e4fdaa1a3c530011a8a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,ERC721dAppCaps,"contract ERC721dAppCaps is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721, Ownable, Fallback { event BoughtToken(address indexed buyer, uint256 tokenId); string public constant company = ; string public constant contact = ""https: string public constant author = ; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MAX_LENGTH = 100000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescriptions; mapping(uint256 => string) specialQualities; mapping(uint256 => string) tokenClasses; mapping(uint256 => string) iptcKeywords; constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 10; uint256 public blocksBeforeTargetShoot = 40; constructor() public { },1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xec6ce30daf8195a65c83a29025bd334bc9481ca0.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 60000e18; uint public target0drop = 200; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0xefe17f088be79ba802b60ea84ebafb255ea18aa4.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,GenericCrowdsale,"contract GenericCrowdsale is Ownable { using SafeMath for uint256; enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}",1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsContest,contract CSportsContestBase { struct Team { address owner; int32 score; uint32 place; bool holdsEntryFee; bool ownsPlayerTokens; uint32[] playerTokenIds; },1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomTokenSale,"contract BigbomTokenSale { address public admin; address public bigbomMultiSigWallet; BigbomToken public token; uint public raisedWei; bool public haltSale; uint public openSaleStartTime; uint public openSaleEndTime; BigbomContributorWhiteList public list; mapping(address=>uint) public participated; using SafeMath for uint; function BigbomTokenSale( address _admin, address _bigbomMultiSigWallet, BigbomContributorWhiteList _whilteListContract, uint _publicSaleStartTime, uint _publicSaleEndTime, BigbomToken _token) public { require (_publicSaleStartTime < _publicSaleEndTime); require (_admin != address(0x0)); require (_bigbomMultiSigWallet != address(0x0)); require (_whilteListContract != address(0x0)); require (_token != address(0x0)); admin = _admin; bigbomMultiSigWallet = _bigbomMultiSigWallet; list = _whilteListContract; openSaleStartTime = _publicSaleStartTime; openSaleEndTime = _publicSaleEndTime; token = _token; }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Mortal,contract Mortal is Owner { function close() external onlyOwner { selfdestruct(owner); },1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x6d074dfa6111404ee8be2c9f024e32c9fffda1b7.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyPilot,"contract HorseyPilot { using SafeMath for uint256; event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x72f1295238a6a0d95631ad9f81b829c486861057.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x9adc8a707ee86497461472c4055e039d99e70d6d.sol,Iou_Token,"contract Iou_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*30/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1528416000; uint256 public ico_start = 1531008000; uint256 public ico_finish = 1541635200; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint public coef = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6a3cfb5aeefb9138a28b28f3852a8fee81216df3.sol,RxEALSaleContract,"contract RxEALSaleContract { using SafeMath for uint256; RxEALTokenContract public token; uint256 public startTime = 1520856000; uint256 public endTime = 1523448000; address public wallet1 = 0x56E4e5d451dF045827e214FE10bBF99D730d9683; address public wallet2 = 0x8C0988711E60CfF153359Ab6CFC8d45565C6ce79; address public wallet3 = 0x0EdF5c34ddE2573f162CcfEede99EeC6aCF1c2CB; address public wallet4 = 0xcBdC5eE000f77f3bCc0eFeF0dc47d38911CBD45B; uint256 public tier_rate_1 = 1800; uint256 public tier_cap_1 = 4800000; uint256 public tier_rate_2 = 1440; uint256 public tier_cap_2 = 14400000; uint256 public tier_rate_3 = 1320; uint256 public tier_cap_3 = 14400000; uint256 public tier_rate_4 = 1200; uint256 public tier_cap_4 = 14400000; uint256 public hard_cap; uint8 public current_tier = 1; uint256 public weiRaised; uint256 public soldTokens; uint256 public current_tier_sold_tokens; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 tokens); function RxEALSaleContract() { token = RxEALTokenContract(0xD6682Db9106e0cfB530B697cA0EcDC8F5597CD15); tier_cap_1 = tier_cap_1 * (10 ** token.decimals()); tier_cap_2 = tier_cap_2 * (10 ** token.decimals()); tier_cap_3 = tier_cap_3 * (10 ** token.decimals()); tier_cap_4 = tier_cap_4 * (10 ** token.decimals()); hard_cap = tier_cap_1 + tier_cap_2 + tier_cap_3 + tier_cap_4; }",1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x35d76c3db8e826907d2a977500b54b3914ecc020.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,Ownable,contract Ownable { address public owner; address public bot; function Ownable() public { owner = msg.sender; },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,EthercraftFarm,"contract EthercraftFarm is Ownable, ReentrancyGuard, Destructible, TokenDestructible, Pausable { using SafeMath for uint8; using SafeMath for uint256; event Prepped(address indexed shop, address indexed object, uint256 iterations); event Reapped(address indexed object, uint256 balance); mapping (address => mapping (address => uint256)) public balanceOfToken; mapping (address => uint256) public totalOfToken; function() payable public { }",1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9.sol,XenoxCoin,"contract XenoxCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x0232ba609782cea145ec3663f52cf7aeb4ac773c.sol,Withdrawable,"contract Withdrawable is PermissionGroups { event TokenWithdraw(ERC20 token, uint amount, address sendTo); function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin { require(token.transfer(sendTo, amount)); TokenWithdraw(token, amount, sendTo); }",1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb.sol,try_it,contract try_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x56cd53067e5acd557dbbfb4c66580dfb9722962a.sol,CryptoMoviesToken,"contract CryptoMoviesToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; uint256 private firstStepLimit = 1.2 ether; uint256 private secondStepLimit = 5 ether; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e2354b2ea4a6312009b228d5171bf6a02c51150.sol,THE_GAME,contract THE_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0xedebe7749b91a475918750842256f23fbe8e3029.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x279f9f9b73bfdbe14e4912a6d5f7442ecdf97b37.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,Ownable,contract Ownable { address public owner; address public bot; function Ownable() public { owner = msg.sender; },1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1.sol,SetherToken,"contract SetherToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SetherToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,FlowerCore,"contract FlowerCore is FlowerAuction, Ownable { uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; uint256 public constant GEN0_STARTING_PRICE = 10 finney; uint256 public constant GEN0_AUCTION_DURATION = 1 days; uint256 public promoCreatedCount; uint256 public gen0CreatedCount; constructor() public { stopped = true; rootAddress = msg.sender; adminAddress = msg.sender; _createFlower(0, 0, 0, uint256(-1), address(0)); }",1
0xde745420248e0dde0cf774b5db8d59c96982b3a2.sol,Payout,contract Payout { ERC20Basic HorseToken; address payoutPoolAddress; address owner; address dev; address devTokensVestingAddress; bool payoutPaused; bool payoutSetup; uint256 public payoutPoolAmount; mapping(address => bool) public hasClaimed; constructor() public { HorseToken = ERC20Basic(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B); payoutPoolAddress = address(0xf783A81F046448c38f3c863885D9e99D10209779); dev = address(0x1F92771237Bd5eae04e91B4B6F1d1a78D41565a2); devTokensVestingAddress = address(0x44935883932b0260C6B1018Cf6436650BD52a257); owner = msg.sender; },1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xa2201234a4652a704f5539058ccb9ab6ebcd486b.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 5; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x8d40e75ed0bcc4ca13aa4113738898f9779858be.sol,STEShop,"contract STEShop is Ownable { ERC20 public tokenAddress; uint256 public currentPrice; uint256 public minPrice; uint256 public maxPrice; uint256 public tokensForSale; uint256 public unsoldAmount; address[2] internal foundersAddresses = [ 0x2f072F00328B6176257C21E64925760990561001, 0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE ]; constructor () public { tokensForSale = 979915263825780; unsoldAmount = tokensForSale; minPrice = 4000000; currentPrice = 4000000; maxPrice = 100000000; }",1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa.sol,quizgame,contract quizgame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0x0d9a437282ba395664ed7d26df2377659a7e16af.sol,SaleTracker,"contract SaleTracker is Pausable { using SafeMath for uint256; event PurchaseMade (address indexed _from, bytes8 _paymentCode, uint256 _value); mapping(address => uint256) public purchases; address[] public purchaserAddresses; bool public enforceAddressMatch; function SaleTracker(bool _enforceAddressMatch) { enforceAddressMatch = _enforceAddressMatch; pause(); }",1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0x4cdee773fd90f91e98b7d33db5c12376deee3b08.sol,NEBC,"contract NEBC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 390000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function NEBC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1a7208627ffe43a69f13f3c393a41712fa4a7831.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xd6aca5b766853f7879d153fdb7567be356dd46ec.sol,ExeniumToken,"contract ExeniumToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 8; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function ExeniumToken() public {}",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,JcashRegistrar,"contract JcashRegistrarInterface { event ReceiveEthEvent(address indexed from, uint256 value); event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value); event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value); event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event ReplenishEthEvent(address indexed from, uint256 value); event WithdrawEthEvent(address indexed to, uint256 value); event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value); event PauseEvent(); event UnpauseEvent(); function withdrawEth(uint256 _weivalue) external; function withdrawToken(address _tokenAddress, uint256 _weivalue) external; function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function isProcessedTx(bytes32 _txHash) public view returns (bool); }",1
0x2d92102bf50c111d59b93f7a10bafd13e770ed61.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0x035611f47a13f3603109152952f0034c674959ba.sol,ReservationFund,"contract ReservationFund is ICrowdsaleReservationFund, Ownable, SafeMath { bool public crowdsaleFinished = false; mapping(address => uint256) contributions; mapping(address => uint256) tokensToIssue; mapping(address => uint256) bonusTokensToIssue; ISimpleCrowdsale public crowdsale; event RefundPayment(address contributor, uint256 etherAmount); event TransferToFund(address contributor, uint256 etherAmount); event FinishCrowdsale(); function ReservationFund(address _owner) public Ownable(_owner) { }",1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0x52b5a68d069a6c9b2f36f279e9d936557fe8d29c.sol,BridgeX_Network,"contract BridgeX_Network is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd359e3f53b5d4e11b8b11dc0772448f380accf3c.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x000621424c60951cb69e9d75d64b79813846d498.sol,HasNoEther,contract HasNoEther is Ownable { function HasNoEther() payable { require(msg.value == 0); },1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x000621424c60951cb69e9d75d64b79813846d498.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x5ae96153d99dfdd7a6b471451afe0f564e10b934.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public price; uint public percentRate = 100; uint public softcap; bool public refundOn = false; bool public isSoftcapOn = false; mapping (address => uint) balances; CommonSale public nextSale; MintableToken public token; function setSoftcap(uint newSoftcap) onlyOwner { isSoftcapOn = true; softcap = newSoftcap; },1
0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol,LimeEyes,contract LimeEyes { address private _dev; struct Artwork { string _title; address _owner; bool _visible; uint256 _basePrice; uint256 _purchases; address[] _shareholders; mapping (address => bool) _hasShares; mapping (address => uint256) _shares; },1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x18b67380942d56c09001a3764ce1aa9e64644433.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0x5576250692275701efde5eeb51596e2d9460790b.sol,UserDataManager,contract UserDataManager { using NameFilter for string; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; struct Player { address addr; bytes32 name; uint256 laff; },1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,Presale,"contract Presale is AccessService, Random { ELHeroToken tokenContract; mapping (uint16 => uint16) public cardPresaleCounter; mapping (address => uint16[]) OwnerToPresale; uint256 public jackpotBalance; event CardPreSelled(address indexed buyer, uint16 protoId); event Jackpot(address indexed _winner, uint256 _value, uint16 _type); constructor(address _nftAddr) public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; tokenContract = ELHeroToken(_nftAddr); cardPresaleCounter[1] = 20; cardPresaleCounter[2] = 20; cardPresaleCounter[3] = 20; cardPresaleCounter[4] = 20; cardPresaleCounter[5] = 20; cardPresaleCounter[6] = 20; cardPresaleCounter[7] = 20; cardPresaleCounter[8] = 20; cardPresaleCounter[9] = 20; cardPresaleCounter[10] = 20; cardPresaleCounter[11] = 20; cardPresaleCounter[12] = 20; cardPresaleCounter[13] = 20; cardPresaleCounter[14] = 20; cardPresaleCounter[15] = 20; cardPresaleCounter[16] = 20; cardPresaleCounter[17] = 20; cardPresaleCounter[18] = 20; cardPresaleCounter[19] = 20; cardPresaleCounter[20] = 20; cardPresaleCounter[21] = 20; cardPresaleCounter[22] = 20; cardPresaleCounter[23] = 20; cardPresaleCounter[24] = 20; cardPresaleCounter[25] = 20; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x7638a5f444eab0281ca1abff2c8029cbb806a566.sol,XOXOCoin,"contract XOXOCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 200000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x33ac37240f71629294de98e0b51f904fda17a366.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxBuyback,"contract ATxBuybackInterface { event EtherReceived(uint amount); event TokenExchanged( address recepient, address token, uint tokenAmount, uint etherAmount, uint feeAmount, address feeReceiver, uint price ); }",1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0xeed618c15d12c635c3c319aee7bded2e2879aea0.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private _owner; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeLandDistribution,"contract CryptoRomeLandDistribution is CryptoRomeControl { using SafeMath for uint256; address public newContractAddress; CryptoRomeLandComposableNFT public cryptoRomeLandNFTContract; ImprovementGeneration public improvementGenContract; uint256 public villageInventoryPrice; uint256 public numImprovementsPerVillage; uint256 constant public LOWEST_VILLAGE_INVENTORY_PRICE = 100000000000000000; constructor (address _cryptoRomeLandNFTContractAddress, address _improvementGenContractAddress) public { require (_cryptoRomeLandNFTContractAddress != address(0)); require (_improvementGenContractAddress != address(0)); paused = true; cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContractAddress); improvementGenContract = ImprovementGeneration(_improvementGenContractAddress); villageInventoryPrice = LOWEST_VILLAGE_INVENTORY_PRICE; numImprovementsPerVillage = 3; }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0xf030b8fbe57c4498298449fc78a0f7054a5ef76d.sol,ArkToken,"contract ArkToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; mapping (uint256 => Animal) public arkData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => uint256) public babies; mapping (uint256 => uint256[2]) public babyMommas; mapping (uint256 => uint256) public mates; mapping (uint256 => uint256) public babyMakinPrice; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public birtherBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Birth(address indexed _birther, uint256 indexed _mom, uint256 _dad, uint256 indexed _baby); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 1.5 ether; uint256 private finalCap = 3.0 ether; struct Animal { uint256 price; uint256 lastPrice; address owner; address birther; uint256 birtherPct; uint8 gender; }",1
0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc.sol,SBITokenCrowdsale,"contract SBITokenCrowdsale is Owned, CrowdsaleParameters { using SafeMath for uint256; string public name = ; SBIToken private token; address public bank; address saleWalletAddress; uint private tokenMultiplier = 10; uint public totalCollected = 0; uint public saleStartTimestamp; uint public saleStopTimestamp; uint public saleGoal; bool public goalReached = false; uint public preicoTokensPerEth = 27314; uint public tokensPerEth = 10500; mapping (address => uint256) private investmentRecords; address crowdsaleAddress = this; uint256 public constant saleStartDate = 1530403200; uint256 public constant saleEndDate = 1535759940; uint256 public constant preSaleStartDate = 1529020800; uint256 public constant preSaleEndDate = 1530403140; uint public preSaleAmount = 5800000; event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther); event FundTransfer(address indexed from, address indexed to, uint indexed amount); function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public { token = SBIToken(_tokenAddress); bank = _bankAddress; tokenMultiplier = tokenMultiplier ** token.decimals(); saleWalletAddress = generalSaleWallet.addr; saleGoal = generalSaleWallet.amount; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x929e488770ae5218cf4bb5387a390bd36b2135dd.sol,QUIZ_QUIZ,contract QUIZ_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x36ed5fbd27abf98f7081f1692ce48abab37db172.sol,Quiz_BliZ,contract Quiz_BliZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0x7562eacac20093065c37ec6111baae15f152958c.sol,AICrypto,"contract AICrypto is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function AICrypto() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x708a64eba17df26cd7085c494b725160ba1a6b7d.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State {Active, Refunding, Closed}",1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x7229bb50da9c01b28b9f1aace7711605d88afbd3.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x0524Fe637b77A6F5f0b3a024f7fD9Fe1E688A291; }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0xa21c9a3ae47103b1fd1dfa04766c4d00c19e1ff6.sol,CryptoOscarsToken,"contract CryptoOscarsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,SRNMagicBox,"contract SRNMagicBox is ServerControl, TokenReceiver { GirlOps girlOps; GenesFactory genesFactory; SRNG SRNGInstance; string public name; uint public keyRequired; address public keyAddress; address public prizePoolAddress; uint public boxPrice; uint[] public prizeIndex; uint[] public prizeRange; uint[] public NCards; uint[] public RCards; uint[] public SRCards; uint[] public SSRCards; event SendGirlFail(address _to, uint _type); constructor(string _name, address _girlAddress, address _SRNGAddress, address _genesFactoryAddress, address _prizePoolAddress, address _keyAddress, uint _keyRequired, uint _boxPrice) public { name = _name; girlOps = GirlOps(_girlAddress); SRNGInstance = SRNG(_SRNGAddress); genesFactory = GenesFactory(_genesFactoryAddress); prizePoolAddress = _prizePoolAddress; keyAddress = _keyAddress; keyRequired = _keyRequired; boxPrice = _boxPrice; }",1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xee53ca3ae3d296c0f2a128138d12a0a3a60fa1f5.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge { function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x0174312e4aef436606ffdeb4d05d22fb68f36ba0.sol,LatiumSeller,contract LatiumSeller { address private constant _latiumAddress = 0xBb31037f997553BEc50510a635d231A35F8EC640; Latium private constant _latium = Latium(_latiumAddress); uint256 private _etherAmount = 0; uint256 private constant _tokenPrice = 10 finney; uint256 private _minimumPurchase = 10 * 10 ** uint256(_latium.decimals()); address public owner; function LatiumSeller() { owner = msg.sender; },1
0x64d581770b541b5609140232fc12f47bbe0fe6bc.sol,MonetoSale,"contract MonetoSale { Moneto public token; address public beneficiary; address public alfatokenteam; uint public alfatokenFee; uint public amountRaised; uint public tokenSold; uint public constant PRE_SALE_START = 1523952000; uint public constant PRE_SALE_END = 1526543999; uint public constant SALE_START = 1528617600; uint public constant SALE_END = 1531209599; uint public constant PRE_SALE_MAX_CAP = 2531250 * 10**18; uint public constant SALE_MAX_CAP = 300312502 * 10**17; uint public constant SALE_MIN_CAP = 2500 ether; uint public constant PRE_SALE_PRICE = 1250; uint public constant SALE_PRICE = 1000; uint public constant PRE_SALE_MIN_BUY = 10 * 10**18; uint public constant SALE_MIN_BUY = 1 * 10**18; uint public constant PRE_SALE_1WEEK_BONUS = 35; uint public constant PRE_SALE_2WEEK_BONUS = 15; uint public constant PRE_SALE_3WEEK_BONUS = 5; uint public constant PRE_SALE_4WEEK_BONUS = 0; uint public constant SALE_1WEEK_BONUS = 10; uint public constant SALE_2WEEK_BONUS = 7; uint public constant SALE_3WEEK_BONUS = 5; uint public constant SALE_4WEEK_BONUS = 3; mapping (address => uint) public icoBuyers; Stages public stage; enum Stages { Deployed, Ready, Ended, Canceled }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xeafd8b734e32aec64c4b445e9da401427ef63a3a.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,Etherumble,contract Etherumble { struct PlayerBets { address addPlayer; uint amount; },1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x28a9824cc26361fe97417a60d5bd1225853db46d.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsAuth,contract CSportsAuth is CSportsConstants { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; address public commissionerAddress; bool public paused = false; bool public isDevelopment = true; modifier onlyUnderDevelopment() { require(isDevelopment == true); _; },1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x0e2354b2ea4a6312009b228d5171bf6a02c51150.sol,THE_GAME,contract THE_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xdb209c97e0de799bbf14e3377307780ddc26be4e.sol,DarkPay,"contract DarkPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 365 * 1 days; uint public round1 = now + 364 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 16000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x024bf21EDAd749461Bf2E0830bC1F7b282bcea7C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x7271f8fdd7693dca37b40403080abe89ae740168.sol,Game,contract Game { address constant private PROMO = 0x51A2BF880F4db7713E95498833308ffE4D61d080; uint constant public PROMO_PERCENT = 15; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.01 ether; uint constant public LAST_DEPOSIT_PERCENT = 5; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1.sol,Crowdsale,"contract Crowdsale is Owned, Stateful { uint public etherPriceUSDWEI; address public beneficiary; uint public totalLimitUSDWEI; uint public minimalSuccessUSDWEI; uint public collectedUSDWEI; uint public crowdsaleStartTime; uint public crowdsaleFinishTime; struct Investor { uint amountTokens; uint amountWei; }",1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180.sol,JungleScratch,contract JungleScratch is Owned { using SafeMath for uint; uint public LimitBottom = 0.02 ether; uint public LimitTop = 0.1 ether; address public Drawer; struct Game { bytes32 SecretKey_P; bool isPlay; bool isPay; uint Result; uint Time; address Buyer; uint value; },1
0x83d3abc4e75885db350ace57f99c3a3e00286fe8.sol,BetaCoin,"contract BetaCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xb387be1e10d56bd7c6849b7be9d6aad564854d72.sol,Alfa_quiZ,contract Alfa_quiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,contract WhaleGiveaway1 { address public Owner = msg.sender; uint constant public minEligibility = 0.999001 ether; function() public payable { },1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event FeePaid(address indexed from, address indexed to, uint256 value); event VoidAccount(address indexed from, address indexed to, uint256 value); event Bonus(uint256 value); event Burn(uint256 value); string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 3000000000 * 10 ** uint256(decimals); uint256 public EthPerToken = 300000; uint256 public ChargeFee = 2; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x777777764382a3ae5e7631570583893bfdea7e05.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0x4ee1ba168551379fd8a59e2e918ff9ee109a6abf.sol,PlayerBook,"contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private owner; TeamDreamHubInterface public TeamDreamHub_; TeamDreamInterface public TeamDream_; MSFun.Data private msData; function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamDream_.requiredDevSignatures(), _whatFunction));}",1
0x56b7f2a2d6f70d88b991e6c7b8005e0a13a9b379.sol,CryptoCurrencyExchange,"contract CryptoCurrencyExchange is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CryptoCurrencyExchange() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,Participant,"contract Participant { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; address public owner; uint public daily; constructor(address _owner, uint _daily) public { owner = _owner; daily = _daily; }",1
0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561.sol,Hanabira,"contract Hanabira is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 5000000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 5000000000e8; uint public target0drop = 70000; uint public progress0drop = 0; address multisig = 0x587aF154ddFB78fe97B7F02FC17D4Eca338AF325; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsAuth,contract CSportsAuth is CSportsConstants { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; address public commissionerAddress; bool public paused = false; bool public isDevelopment = true; modifier onlyUnderDevelopment() { require(isDevelopment == true); _; },1
0xdcb5410ef70f59a5a2839fc6d4d0b2ca981f5e2d.sol,CoinMmc,"contract CoinMmc { address public admin_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; address public account_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 initSupply = 1000000000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; _add_lock_account(0x6efB62605A66E32582c37b835F81Bc91A6a8fb2e, mul(80000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0x0ba46c0fC6a5C206855cEf215222e347E1559eDf, mul(120000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0xE269695D497387DfEAFE12b0b3B54441683F63C8, mul(100000000000,10**uint256(decimals)), 1628351160); }",1
0x2cf02304f36effd519be79850d21335684c6073e.sol,AccEthRegCenter,contract AccEthRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xb429ecbd7cda1cb82cbe0ae9044310d2f74de67c.sol,SmzTradingContract,contract SmzTradingContract { address public constant RECEIVER_ADDRESS = 0xf3eB3CA356c111ECb418D457e55A3A3D185faf61; uint256 public constant ACCEPTED_AMOUNT = 3 ether; uint256 public RECEIVER_PAYOUT_THRESHOLD = 100 ether; address public constant END_ADDRESS = 0x3559e34004b944906Bc727a40d7568a98bDc42d3; uint256 public constant END_AMOUNT = 0.39 ether; bool public ended = false; mapping(address => bool) public addressesAllowed; mapping(address => bool) public addressesDeposited; address public manager; function SmzTradingContract() public { manager = msg.sender; },1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponSales,"contract WeaponSales is WeaponToken { event Purchase(address indexed owner, uint256 unitPrice, uint32 amount); function buyWeapon(uint256 _weaponId) public payable returns (uint256 id) { id = _generateWeapon(msg.sender, _weaponId); Transfer(address(0), msg.sender, id); Purchase(msg.sender, weaponModels[_weaponId].price, 1); }",1
0x4c60e311d8fba04e313f7e7b3dec61b3028726d1.sol,EtherWorldCup,"contract EtherWorldCup { using SafeMath for uint; address internal constant administrator = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae; address internal constant givethAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; string name = ; string symbol = ; mapping (string => int8) worldCupGameID; mapping (int8 => bool) gameFinished; mapping (int8 => uint) gameLocked; mapping (int8 => string) gameResult; int8 internal latestGameFinished; uint internal prizePool; uint internal givethPool; int registeredPlayers; mapping (address => bool) playerRegistered; mapping (address => mapping (int8 => bool)) playerMadePrediction; mapping (address => mapping (int8 => string)) playerPredictions; mapping (address => int8[64]) playerPointArray; mapping (address => int8) playerGamesScored; mapping (address => uint) playerStreak; address[] playerList; event Registration( address _player ); event PlayerLoggedPrediction( address _player, int _gameID, string _prediction ); event PlayerUpdatedScore( address _player, int _lastGamePlayed ); event Comparison( address _player, uint _gameID, string _myGuess, string _result, bool _correct ); event StartAutoScoring( address _player ); event StartScoring( address _player, uint _gameID ); event DidNotPredict( address _player, uint _gameID ); event RipcordRefund( address _player ); constructor () public { worldCupGameID[] = 1; gameLocked[1] = 1528988400; worldCupGameID[] = 2; worldCupGameID[] = 3; worldCupGameID[] = 4; gameLocked[2] = 1529064000; gameLocked[3] = 1529074800; gameLocked[4] = 1529085600; worldCupGameID[] = 5; worldCupGameID[] = 6; worldCupGameID[] = 7; worldCupGameID[] = 8; gameLocked[5] = 1529143200; gameLocked[6] = 1529154000; gameLocked[7] = 1529164800; gameLocked[8] = 1529175600; worldCupGameID[] = 9; worldCupGameID[] = 10; worldCupGameID[] = 11; gameLocked[9] = 1529236800; gameLocked[10] = 1529247600; gameLocked[11] = 1529258400; worldCupGameID[] = 12; worldCupGameID[] = 13; worldCupGameID[] = 14; gameLocked[12] = 1529323200; gameLocked[13] = 1529334000; gameLocked[14] = 1529344800; worldCupGameID[] = 15; worldCupGameID[] = 16; worldCupGameID[] = 17; gameLocked[15] = 1529409600; gameLocked[16] = 1529420400; gameLocked[17] = 1529431200; worldCupGameID[] = 18; worldCupGameID[] = 19; worldCupGameID[] = 20; gameLocked[18] = 1529496000; gameLocked[19] = 1529506800; gameLocked[20] = 1529517600; worldCupGameID[] = 21; worldCupGameID[] = 22; worldCupGameID[] = 23; gameLocked[21] = 1529582400; gameLocked[22] = 1529593200; gameLocked[23] = 1529604000; worldCupGameID[] = 24; worldCupGameID[] = 25; worldCupGameID[] = 26; gameLocked[24] = 1529668800; gameLocked[25] = 1529679600; gameLocked[26] = 1529690400; worldCupGameID[] = 27; worldCupGameID[] = 28; worldCupGameID[] = 29; gameLocked[27] = 1529755200; gameLocked[28] = 1529766000; gameLocked[29] = 1529776800; worldCupGameID[] = 30; worldCupGameID[] = 31; worldCupGameID[] = 32; gameLocked[30] = 1529841600; gameLocked[31] = 1529852400; gameLocked[32] = 1529863200; worldCupGameID[] = 33; worldCupGameID[] = 34; worldCupGameID[] = 35; worldCupGameID[] = 36; gameLocked[33] = 1529935200; gameLocked[34] = 1529935200; gameLocked[35] = 1529949600; gameLocked[36] = 1529949600; worldCupGameID[] = 37; worldCupGameID[] = 38; worldCupGameID[] = 39; worldCupGameID[] = 40; gameLocked[37] = 1530021600; gameLocked[38] = 1530021600; gameLocked[39] = 1530036000; gameLocked[40] = 1530036000; worldCupGameID[] = 41; worldCupGameID[] = 42; worldCupGameID[] = 43; worldCupGameID[] = 44; gameLocked[41] = 1530108000; gameLocked[42] = 1530108000; gameLocked[43] = 1530122400; gameLocked[44] = 1530122400; worldCupGameID[] = 45; worldCupGameID[] = 46; worldCupGameID[] = 47; worldCupGameID[] = 48; gameLocked[45] = 1530194400; gameLocked[46] = 1530194400; gameLocked[47] = 1530208800; gameLocked[48] = 1530208800; worldCupGameID[] = 49; worldCupGameID[] = 50; gameLocked[49] = 1530367200; gameLocked[50] = 1530381600; worldCupGameID[] = 51; worldCupGameID[] = 52; gameLocked[51] = 1530453600; gameLocked[52] = 1530468000; worldCupGameID[] = 53; worldCupGameID[] = 54; gameLocked[53] = 1530540000; gameLocked[54] = 1530554400; worldCupGameID[] = 55; worldCupGameID[] = 56; gameLocked[55] = 1530626400; gameLocked[56] = 1530640800; worldCupGameID[] = 57; worldCupGameID[] = 58; gameLocked[57] = 1530885600; gameLocked[58] = 1530900000; worldCupGameID[] = 59; worldCupGameID[] = 60; gameLocked[59] = 1530972000; gameLocked[60] = 1530986400; worldCupGameID[] = 61; gameLocked[61] = 1531245600; worldCupGameID[] = 62; gameLocked[62] = 1531332000; worldCupGameID[] = 63; gameLocked[63] = 1531576800; worldCupGameID[] = 64; gameLocked[64] = 1531666800; latestGameFinished = 0; }",1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add.sol,AllYours,contract AllYours { address private _platformAddress = 0xbE9C1088FEEB8B48A96Da0231062eA757D0a9613; uint private _totalEth = 0.06 ether; uint128 private _oneceEth = 0.02 ether; uint256 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xf2017c92b068935bf56fea38f9d2c01f184ef14c.sol,WorldToken,"contract WorldToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 268000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function WorldToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5a889cba88c2c7cc67652c2de4e46fc4b9aba9ce.sol,DSG_Turntable,contract DSG_Turntable{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint256 blockNumber; uint256 bet; },1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x1b332629b45136a3614fafcd927c8ea31d7cd717.sol,Bandit,"contract Bandit is usingOraclize, DSSafeAddSub { function () public payable {}",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x72f1295238a6a0d95631ad9f81b829c486861057.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x25d3b1550e518ba8d7581cad811285e005902faa.sol,SheetMusic,"contract SheetMusic is OwnableContract { enum NoteLength { WHOLE_NOTE, DOTTED_HALF_NOTE, HALF_NOTE, DOTTED_QUARTER_NOTE, QUARTER_NOTE, DOTTED_EIGHTH_NOTE, EIGHTH_NOTE, DOTTED_SIXTEENTH_NOTE, SIXTEENTH_NOTE }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x873e4037cfacfaa6837c913604c2de51f2b179d0.sol,IRideSale,contract IRideSale { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x402cd1fa4ba4296f5503d1e86214b77ec7cfe840.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public starttime; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken; tokenReward = token(addressOfTokenUsedAsReward); starttime = now; }",1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkTGE,"contract WolkTGE is Wolk { mapping (address => uint256) contribution; mapping (address => uint256) presaleLimit; mapping (address => bool) presaleContributor; uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals; uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals; uint256 public presale_start_block; uint256 public start_block; uint256 public end_block; function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){ require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock)); presale_start_block = _presaleStartBlock; start_block = _startBlock; end_block = _endBlock; multisigWallet = _wolkWallet; wolkSale = _wolkSale; settlers[msg.sender] = true; return true; }",1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9214ec02cb71cba0ada6896b8da260736a67ab10.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xa44fb3aa5c8465512b806145a8f9b60e74f3f851.sol,PITSTOP,"contract PITSTOP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =10000000e18; uint public target0drop = 500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x55914aad05640d89448a7803a03ed0eabcbc6a22.sol,EthereumCrystal,"contract EthereumCrystal is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 75000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000e8; uint public target0drop = 200000; uint public progress0drop = 0; address multisig = 0xF4ea201ba0c2ca99E8942f047a5220bc98286763; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x21ae174c592cbb476819344a895d0e9219f5cc79.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 1 hours; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool mutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7.sol,IndTokenPayment,"contract IndTokenPayment is Ownable, ReentrancyGuard { IERC20Token[] public path; address public destinationWallet; uint256 public minConversionRate; IContractRegistry public bancorRegistry; bytes32 public constant BANCOR_NETWORK = ; event conversionSucceded(address from,uint256 fromTokenVal,address dest,uint256 destTokenVal); constructor(IERC20Token[] _path, address destWalletAddr, address bancorRegistryAddr, uint256 minConvRate){ path = _path; bancorRegistry = IContractRegistry(bancorRegistryAddr); destinationWallet = destWalletAddr; minConversionRate = minConvRate; }",1
0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,contract FreeEth { address public Owner = msg.sender; function() public payable{},1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51.sol,EtherColor,"contract EtherColor is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; mapping (uint256 => uint256) private colorIndexToPreviousPrice; mapping (uint256 => address[5]) private colorIndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Color { string name; }",1
0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x70f187ea2ebcf5b94aa7819f41c92f9a9dc4c200.sol,LifePasswordAI,"contract LifePasswordAI is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 680000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function LifePasswordAI() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5149474fd339e95271304b5b28f6e456a24c0e25.sol,MNSPAY,"contract MNSPAY is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function MNSPAY() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x2ada0cddb716033e52c3d591ad12a59103230e52.sol,SGEICO,contract SGEICO { Token public tokenReward; address public creator; address public owner = 0x8dfFcCE1d47C6325340712AB1B8fD7328075730C; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0xf4f5271c9d6f23cc00f93625b502f88d289a1607.sol,WithdrawConfirmation,"contract WithdrawConfirmation is Owned { event Confirmation(address indexed sender, uint indexed withdrawId); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WithdrawCreated(address indexed destination, uint indexed value, uint indexed id); event Execution(uint indexed withdrawId); event ExecutionFailure(uint indexed withdrawId); mapping(address => bool) public isOwner; mapping(uint => Withdraw) public withdraws; mapping(uint => mapping(address => bool)) public confirmations; address[] public owners; uint public withdrawCount; struct Withdraw { address destination; uint value; bool executed; }",1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0xda830afa460526071d3d149e898fead664f0a4bb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x54d445898cbafb7cf48597e495251183207767ae.sol,FasterProfit,contract FasterProfit { address constant private PROMO = 0xA93c13B3E3561e5e2A1a20239486D03A16d1Fc4b; uint constant public MULTIPLIER = 110; uint constant public MAX_DEPOSIT = 1 ether; uint public currentReceiverIndex = 0; uint public MIN_DEPOSIT = 0.01 ether; uint public txnCount = 0; uint private PROMO_PERCENT = 0; uint constant public LAST_DEPOSIT_PERCENT = 20; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x5a757fb240ac70dbead4f9e1508f24a91da70ee5.sol,SilentToken,"contract SilentToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 2500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileCycleWithAssistance,contract AgileCycleWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Lotthereum,"contract Lotthereum is Mortal, SafeMath { Game[] private games; mapping (address => uint) private balances; struct Game { uint id; uint pointer; uint maxNumberOfBets; uint minAmountByBet; uint prize; uint currentRound; Round[] rounds; }",1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0x588f4ee97a2085c95420a45684a898d4b5906ba1.sol,SPAM,contract SPAM is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public SPAMed; event Message(string message); function SPAM() public { owner = msg.sender; totalSupply = 9999 * 1e18; stdBalance = 9999 * 1e18; SPAMed = true; },1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0xa181b8c9f6b43b8252c6c9826cf5feba362b542e.sol,CryptoStamps,"contract CryptoStamps is ERC721 { event stampBirth(uint256 tokenId, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private firstStepLimit = 1.28 ether; mapping (uint256 => address) public stampIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public stampIndexToApproved; mapping (uint256 => uint256) private stampIndexToPrice; mapping(uint256 => uint256) public stampIndextotransactions; uint256 public totaletherstransacted; uint256 public totaltransactions; uint256 public stampCreatedCount; mapping (uint256 => bool) public stampIndextodissolved; mapping (uint256 => address) public dissolvedIndexToApproved; struct Stamp { uint256 birthtime; }",1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xd37df7051977462c84d2a89cd78a0a91ff85d645.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7.sol,IndTokenPayment,"contract IndTokenPayment is Ownable, ReentrancyGuard { IERC20Token[] public path; address public destinationWallet; uint256 public minConversionRate; IContractRegistry public bancorRegistry; bytes32 public constant BANCOR_NETWORK = ; event conversionSucceded(address from,uint256 fromTokenVal,address dest,uint256 destTokenVal); constructor(IERC20Token[] _path, address destWalletAddr, address bancorRegistryAddr, uint256 minConvRate){ path = _path; bancorRegistry = IContractRegistry(bancorRegistryAddr); destinationWallet = destWalletAddr; minConversionRate = minConvRate; }",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x791af5fcb5198c9f469d66b934864dab43d7f044.sol,Verus,"contract Verus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 200000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xCC1967c9EF99848803bc744e881eF84F59CE2b34 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x402cd1fa4ba4296f5503d1e86214b77ec7cfe840.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public starttime; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken; tokenReward = token(addressOfTokenUsedAsReward); starttime = now; }",1
0xeb0335a35d10cab0c0d615d999d657a50cfd44f0.sol,asssderf,"contract asssderf { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1546508000; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); if (msg.value == 0) { require (block.timestamp > partyTime && hodlers[msg.sender] > 0); uint value = hodlers[msg.sender]; hodlers[msg.sender] = 0; msg.sender.transfer(value); Party(msg.sender, value); }",1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsAuth,contract CSportsAuth is CSportsConstants { event ContractUpgrade(address newContract); address public ceoAddress; address public cfoAddress; address public cooAddress; address public commissionerAddress; bool public paused = false; bool public isDevelopment = true; modifier onlyUnderDevelopment() { require(isDevelopment == true); _; },1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0x0dea9b8e6bf08d6859e29256942916f0cfb884fb.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0x299187bb996599f7fc82df025ee8964cafe3085a.sol,Challenge,contract Challenge { address public owner; address public previous_owner; address public creator; bytes32 public flag_hash = 0xfa9b079005103147ac67299be9119fb4a47e29801f2d8d5025f36b248ce23695; function Challenge() public { owner = msg.sender; creator = msg.sender; },1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0xa2201234a4652a704f5539058ccb9ab6ebcd486b.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 5; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x1e1fe9186c223ee1679634e3cfb7c03276b19493.sol,WaterCrowdsale,"contract WaterCrowdsale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTimeInMinutes; uint256 public endTimeinMinutes; uint public fundingGoal; uint public minimumFundingGoal; uint256 public price; uint256 public weiRaised; uint256 public firstWeekBonusInWeek; uint256 public secondWeekBonusInWeek; uint256 public thirdWeekBonusInWeek; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FundTransfer(address backer, uint amount, bool isContribution); event GoalReached(address recipient, uint totalAmountRaised); modifier isMinimum() { if(msg.value < 500000000000000000) throw; _; }",1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xb402be8db1d9eb2beedfe2c8a6c38a604e9f13c6.sol,depositofferToken,contract depositofferTokenConfig { string public name = ; string public symbol = ; address public owner = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; address public fundWallet = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; uint public constant TOKENS_PER_USD = 2; uint public constant USD_PER_ETH = 800; uint public constant MIN_USD_FUND = 1; uint public constant MAX_USD_FUND = 2000000; uint public constant KYC_USD_LMT = 50000; uint public constant MAX_TOKENS = 4000000; uint public constant START_DATE = 1520776337; uint public constant FUNDING_PERIOD = 180 days; },1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0x00346fddca107aec034a367b7324f0d6419bf4b9.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, address addressOfTokenUsedAsReward ) public{ beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = (0.00001 ether)/100000 ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x4055bd5a000d97bfca86d71386dc85001eb738f6.sol,Imt,contract Imt{ address owner; constructor() public payable{ owner = msg.sender; },1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add.sol,AllYours,contract AllYours { address private _platformAddress = 0xbE9C1088FEEB8B48A96Da0231062eA757D0a9613; uint private _totalEth = 0.06 ether; uint128 private _oneceEth = 0.02 ether; uint256 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0x2732dd0f79f6cf4f257232ea2291ffbab2c18c15.sol,CoinFlipperDSG,contract CoinFlipperDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Mortal,contract Mortal is Owned { function kill() { if (msg.sender == owner) selfdestruct(owner); },1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x83e969a451253f1026e388ba2e3eef6aaa4cbca4.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0x000621424c60951cb69e9d75d64b79813846d498.sol,HasNoEther,contract HasNoEther is Ownable { function HasNoEther() payable { require(msg.value == 0); },1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x3ac0d29eaf16eb423e07387274a05a1e16a8472b.sol,LuckyNumber,"contract LuckyNumber { address owner; uint winningNumber = uint(keccak256(now, owner)) % 10; function LuckyNumber() public { owner = msg.sender; }",1
0xc398891b43f1b91158dca87c63a88b80d000c248.sol,IBIT,"contract IBIT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000021e8; uint public target0drop = 5000000; uint public progress0drop = 0; address multisig = 0x723D0666908ADdc626C29407F0B5e7C0881b5185; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreRefundVault,"contract IRBPreRefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x17478cc05e51da20a27bbdf66fbe4a16aae81842.sol,AuctionPotato,"contract AuctionPotato { using SafeMath for uint256; address public owner; uint public startTime; uint public endTime; string public infoUrl; string name; bool started; uint public potato; uint oldPotato; uint oldHighestBindingBid; address creatureOwner; address creature_newOwner; event CreatureOwnershipTransferred(address indexed _from, address indexed _to); bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); constructor() public { blockerWithdraw = false; blockerPay = false; owner = msg.sender; creatureOwner = owner; highestBindingBid = 2000000000000000; potato = 0; started = false; name = ; infoUrl = ""https: }",1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x0460dcb54214fdf68302b4c733ad7ed827dd6592.sol,evequiz,contract evequiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x733237b46b1fd6bd3266c9b6daae1c018a9d9493.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 65000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,Owned,contract Owned { address private Owner; function Owned() public{ Owner = msg.sender; },1
0x1d91b86e5c7b5e85a61eaaea9762958747712826.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x6f84faf2ce621f5a4ba161f055a56daffbf78b04.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x8b548505babfd983fc45210499b44e340bb85d76.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256 public totalHedgelyWinnings; uint256 public totalHedgelyInvested; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event EndSession( uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; }",1
0x0254ffd95dd7c8e27d4c7a32e24464196efcc852.sol,BEATA,"contract BEATA is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BEATA() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0xecbd0854075009d23360c62da07047efc2312144.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale () public { beneficiary = 0x1e19E36928bA65184669d8A7e7A37d8B061B9022; fundingGoal = 0.0022 * 1 ether; deadline = now + 40 * 1 minutes; price = 0.00058 * 1 ether; tokenReward = token(0xe8EF8d9d9Ff515720A62d2E2f14f3b5b677C6670); }",1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x2af8b34f04e93c79ee3a1f300a019f29869d896a.sol,SiliconValleyToken,"contract SiliconValleyToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function SiliconValleyToken() public {}",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,FundForwarder,"contract FundForwarder is Escapable { Campaign public beneficiary; function FundForwarder( Campaign _beneficiary, address _escapeHatchCaller, address _escapeHatchDestination ) Escapable(_escapeHatchCaller, _escapeHatchDestination) { beneficiary = _beneficiary; }",1
0x4d3b775a793aa40e52e5ebd76d1904318fcf4989.sol,TokenERC20,contract TokenERC20 is Ownable{ token public tokenReward = token(0x778E763C4a09c74b2de221b4D3c92d8c7f27a038); uint256 public bili = 7500; uint256 public endtime = 1540051199; uint256 public amount; address public addr = 0x2aCf431877107176c88B6300830C6b696d744344; address public addr2 = 0x6090275ca0AD1b36e651bCd3C696622b96a25cFF; function TokenERC20( ) public { },1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x299187bb996599f7fc82df025ee8964cafe3085a.sol,Challenge,contract Challenge { address public owner; address public previous_owner; address public creator; bytes32 public flag_hash = 0xfa9b079005103147ac67299be9119fb4a47e29801f2d8d5025f36b248ce23695; function Challenge() public { owner = msg.sender; creator = msg.sender; },1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x4209f9bbb4e4dd48dbd84701fcaaab1d492b5a05.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0xfef5497bc53a69875e02ae5b14eeff668f09a729.sol,Infinity,"contract Infinity { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public initAmount; uint256 public amountProportion; uint256 public dividend; uint256 public jackpot; uint256 public jackpotProportion; uint256 public scientists; uint256 public promotionRatio; uint256 public duration; bool public activated = false; address public developerAddr; uint256 public rId; uint256 public sId; mapping (uint256 => Indatasets.Round) public round; mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage; mapping (address => Indatasets.Player) public player; mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; mapping (uint256 => mapping (address => uint256)) public playerRoundSid; mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount; uint256[] amountLimit = [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]; constructor() public { developerAddr = msg.sender; }",1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x41104edb2cefbb66cc28b17d507f0b4ba559f455.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerCore,contract FlowerCore is FlowerMinting { address public newContractAddress; function setGen0SellerAddress(address _newAddress) external onlyAdministrator { gen0SellerAddress = _newAddress; saleAuction.setGen0SellerAddress(_newAddress); },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0xa2038ce672658f492fcd9e4fdaa1a3c530011a8a.sol,MultiHolderVault,"contract MultiHolderVault is HolderBase, RefundVault { using SafeMath for uint256; function MultiHolderVault(address _wallet, uint256 _ratioCoeff) public HolderBase(_ratioCoeff) RefundVault(_wallet) {}",1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xda11e959bcaaba5f88dbf4d866e270c78bc84b76.sol,EBP,"contract EBP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x32d782c283924f1e40b2a839b8121564b7b9142e.sol,SUPER_Q,contract SUPER_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xd5670cdb0d6e6d9eedfdbaceb97d5774466f0b23.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; event RedButton(uint value, uint totalSupply); function payout(address _to) public onlyCLevel { _payout(_to, this.balance); }",1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0xb387be1e10d56bd7c6849b7be9d6aad564854d72.sol,Alfa_quiZ,contract Alfa_quiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xeed618c15d12c635c3c319aee7bded2e2879aea0.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private _owner; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb.sol,try_it,contract try_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x17478cc05e51da20a27bbdf66fbe4a16aae81842.sol,AuctionPotato,"contract AuctionPotato { using SafeMath for uint256; address public owner; uint public startTime; uint public endTime; string public infoUrl; string name; bool started; uint public potato; uint oldPotato; uint oldHighestBindingBid; address creatureOwner; address creature_newOwner; event CreatureOwnershipTransferred(address indexed _from, address indexed _to); bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); constructor() public { blockerWithdraw = false; blockerPay = false; owner = msg.sender; creatureOwner = owner; highestBindingBid = 2000000000000000; potato = 0; started = false; name = ; infoUrl = ""https: }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkExchange,"contract WolkExchange is WolkProtocol, WolkTGE { uint256 public maxPerExchangeBP = 50; address public exchangeFormula; bool public exchangeIsRunning = false; modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }",1
0x6a5e59fbaea3e07737fbafceb600cbde5a295f24.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0xdb209c97e0de799bbf14e3377307780ddc26be4e.sol,DarkPay,"contract DarkPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 365 * 1 days; uint public round1 = now + 364 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 16000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x024bf21EDAd749461Bf2E0830bC1F7b282bcea7C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x83d3abc4e75885db350ace57f99c3a3e00286fe8.sol,BetaCoin,"contract BetaCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x290d7f8b8d7da1e92903405a74667c934ca8f086.sol,Wallet,"contract Wallet { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0x0174312e4aef436606ffdeb4d05d22fb68f36ba0.sol,LatiumSeller,contract LatiumSeller { address private constant _latiumAddress = 0xBb31037f997553BEc50510a635d231A35F8EC640; Latium private constant _latium = Latium(_latiumAddress); uint256 private _etherAmount = 0; uint256 private constant _tokenPrice = 10 finney; uint256 private _minimumPurchase = 10 * 10 ** uint256(_latium.decimals()); address public owner; function LatiumSeller() { owner = msg.sender; },1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x744a31ede5422355d9c2bd8c44c710404336ca84.sol,NFTsCrowdsaleBase,"contract NFTsCrowdsaleBase is Superuser, INFTsCrowdsale { using SafeMath for uint256; ERC20 public erc20Contract; ERC721 public erc721Contract; uint public eth2erc20; struct Auction { bytes32 id; address seller; uint256 price; uint256 startAt; uint256 endAt; uint256 tokenId; }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xdc8d902c34f2257b8569dc9bc4f58cc149ed6e48.sol,GitmanIssue,"contract GitmanIssue { address private mediator; address public parent; string public owner; string public repository; string public issue; constructor (string ownerId, string repositoryId, string issueId, address mediatorAddress) public payable { parent = msg.sender; mediator = mediatorAddress; owner = ownerId; repository = repositoryId; issue = issueId; }",1
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol,PLAY_iQuiz,contract PLAY_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,NoOwnerEx,contract NoOwnerEx is NoOwner { function reclaimEther(address _to) external onlyOwner { _to.transfer(address(this).balance); },1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0x29c690419841e126b74981e4709e43916ac80f64.sol,QQ_game,contract QQ_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6c221dea36d48512947bde8aeb58811db50dbf6f.sol,PartnerContract,contract PartnerContract { function() external payable { if(msg.value == 0) { uint part = address(this).balance / 2; address(0x6B6e4B338b4D5f7D847DaB5492106751C57b7Ff0).transfer(part); address(0xe09f3630663B6b86e82D750b00206f8F8C6F8aD4).transfer(part); },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x00f9f4f3ced5d4f6aedea8a92414206557df7167.sol,SNL,"contract SNL is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 500000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function SNL() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x25d3b1550e518ba8d7581cad811285e005902faa.sol,SheetMusic,"contract SheetMusic is OwnableContract { enum NoteLength { WHOLE_NOTE, DOTTED_HALF_NOTE, HALF_NOTE, DOTTED_QUARTER_NOTE, QUARTER_NOTE, DOTTED_EIGHTH_NOTE, EIGHTH_NOTE, DOTTED_SIXTEENTH_NOTE, SIXTEENTH_NOTE }",1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x1ec7345ee1780d847b29f65aa0ecf70cb278966e.sol,EtherTv,"contract EtherTv is Ownable { using SafeMath for uint256; Show[] private shows; uint256 public devOwed; mapping (address => uint256) public userDividends; event ShowPurchased( uint256 _tokenId, address oldOwner, address newOwner, uint256 price, uint256 nextPrice ); uint256 constant private FIRST_CAP = 0.5 ether; uint256 constant private SECOND_CAP = 1.0 ether; uint256 constant private THIRD_CAP = 3.0 ether; uint256 constant private FINAL_CAP = 5.0 ether; struct Show { uint256 price; uint256 payout; address owner; }",1
0xaa4250216f77a79fd9983642a987f708f1fe7504.sol,CutiePluginBase,"contract CutiePluginBase is PluginInterface, Pausable { function isPluginInterface() public pure returns (bool) { return true; }",1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Base,contract Base { using SafeMath for uint256; uint public createTime = now; address public owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc.sol,SBITokenCrowdsale,"contract SBITokenCrowdsale is Owned, CrowdsaleParameters { using SafeMath for uint256; string public name = ; SBIToken private token; address public bank; address saleWalletAddress; uint private tokenMultiplier = 10; uint public totalCollected = 0; uint public saleStartTimestamp; uint public saleStopTimestamp; uint public saleGoal; bool public goalReached = false; uint public preicoTokensPerEth = 27314; uint public tokensPerEth = 10500; mapping (address => uint256) private investmentRecords; address crowdsaleAddress = this; uint256 public constant saleStartDate = 1530403200; uint256 public constant saleEndDate = 1535759940; uint256 public constant preSaleStartDate = 1529020800; uint256 public constant preSaleEndDate = 1530403140; uint public preSaleAmount = 5800000; event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther); event FundTransfer(address indexed from, address indexed to, uint indexed amount); function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public { token = SBIToken(_tokenAddress); bank = _bankAddress; tokenMultiplier = tokenMultiplier ** token.decimals(); saleWalletAddress = generalSaleWallet.addr; saleGoal = generalSaleWallet.amount; }",1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0x1da73fc09ea07781482994036a0eecc7e6952dfb.sol,TydoIco,"contract TydoIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; uint256[] public bonuses; uint256[] public bonusEnds; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken, uint256[] _bonuses, uint256[] _bonusEnds) Owned() public { require(_bonuses.length == _bonusEnds.length); for(uint8 i = 0; i < _bonuses.length; i++) { require(_bonuses[i] > 0); if (i > 0) { }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x56d06701fd44a4a857cb96b266f505a2832950c5.sol,Child,contract Child is Base { Main g_Main; constructor(Main main) public { require(main != address(0)); g_Main = main; g_Main.SetAuth(this); },1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0x299187bb996599f7fc82df025ee8964cafe3085a.sol,Challenge,contract Challenge { address public owner; address public previous_owner; address public creator; bytes32 public flag_hash = 0xfa9b079005103147ac67299be9119fb4a47e29801f2d8d5025f36b248ce23695; function Challenge() public { owner = msg.sender; creator = msg.sender; },1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa41aa09607ca80ee60d2ce166d4c02a71860e5c5.sol,XTVToken,"contract XTVToken is XTVNetworkGuard, ERC20Token { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 18; address public fullfillTeamAddress; address public fullfillFounder; address public fullfillAdvisors; address public XTVNetworkContractAddress; bool public airdropActive; uint public startTime; uint public endTime; uint public XTVAirDropped; uint public XTVBurned; mapping(address => bool) public claimed; uint256 public constant INITIAL_SUPPLY = 500000000; uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000000000; uint256 private constant TOKEN_MULTIPLIER = 1000000; uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER; uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER; uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER; uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER; uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500; modifier isAirdropActive() { require(airdropActive); _; }",1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xdfa66ec49cf0102fb8906ee3dd6a70597d9720d4.sol,DEKS,"contract DEKS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000e8; uint public target0drop = 12000; uint public progress0drop = 0; address multisig = 0xae4B0D603B563A3b26a585e5cF43f1Fb6f75295C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0xa28b5854df048bcd5eec522fada1c6b7ea006aae.sol,FIREDICE,"contract FIREDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb.sol,try_it,contract try_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9.sol,XenoxCoin,"contract XenoxCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponSales,"contract WeaponSales is WeaponToken { event Purchase(address indexed owner, uint256 unitPrice, uint32 amount); function buyWeapon(uint256 _weaponId) public payable returns (uint256 id) { id = _generateWeapon(msg.sender, _weaponId); Transfer(address(0), msg.sender, id); Purchase(msg.sender, weaponModels[_weaponId].price, 1); }",1
0x2671bf62fdf173cfcb4b178d1a563ca84a349dc3.sol,D_QUIZ,contract D_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x33147d0f721ddfd82408dd1c890eff4ad7ecd80e.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xd745a7883a6bd19389b6b9dc8580c2ff873f0cd1.sol,Earthpayment,"contract Earthpayment is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 7; uint256 public constant INITIAL_SUPPLY = 21000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Earthpayment() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FrostByte,"contract FrostByte is FBT { event tokenBought(uint256 totalTokensBought, uint256 Price); event etherSent(uint256 total); string public name; uint8 public decimals; string public symbol; string public version = ; function FrostByte() { name = ; decimals = 4; symbol = ; pieceprice = 1 ether / 256; datestart = now; }",1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0x28a40acf39b1d3c932f42dd8068ad00a5ad6448f.sol,LudumToken,contract LudumToken is StandardToken { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public constant maximumSupply = 100000000000000000000000000; address public ethDepositAddress; address public teamFundAddress; address public operationsFundAddress; address public marketingFundAddress; bool public isFinalized; uint public constant crowdsaleStart = 1503921600; uint public constant crowdsaleEnd = 1506340800; uint public constant teamPercent = 10; uint public constant operationsPercent = 10; uint public constant marketingPercent = 5; function ludumTokensPerEther() constant returns(uint) { if (now < crowdsaleStart || now > crowdsaleEnd) { return 0; },1
0x58a687bb4a7a4220e65f9b6f913580e5bec4a7bc.sol,EnergiPlus,"contract EnergiPlus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 35000e8; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0x4e0134dB37A5c67E1572BE270C1E34C5f67cdBc0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0xd9e982e827d19a9dca6fe607be4c52d0ff14a697.sol,UserDataManager,contract UserDataManager { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x92ccb32f34ca7abf1e0f5ba9b0167b607ea6b5ac.sol,LO_QUIZ,contract LO_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0x56cd53067e5acd557dbbfb4c66580dfb9722962a.sol,CryptoMoviesToken,"contract CryptoMoviesToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; uint256 private firstStepLimit = 1.2 ether; uint256 private secondStepLimit = 5 ether; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0xb42fc86a49d6b772bb43cd031157d4aa557e387a.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc398891b43f1b91158dca87c63a88b80d000c248.sol,IBIT,"contract IBIT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000021e8; uint public target0drop = 5000000; uint public progress0drop = 0; address multisig = 0x723D0666908ADdc626C29407F0B5e7C0881b5185; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,withdrawable,"contract withdrawable is Ownable { event ReceiveEther(address _from, uint256 _value); event WithdrawEther(address _to, uint256 _value); event WithdrawToken(address _token, address _to, uint256 _value); function () payable public { emit ReceiveEther(msg.sender, msg.value); }",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0x46580533db92c418a79f91b46df70283daef7f99.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x881f21d3e2d2d4f48d815f41bea8dbdcf0e24e50.sol,DepositVault,"contract DepositVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyPilot,"contract HorseyPilot { using SafeMath for uint256; event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xc35d0837d49aa399022e133ba141b85d8809b137.sol,FUS,"contract FUS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint256 public constant INITIAL_SUPPLY = 100000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function FUS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,DetherBank,"contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath { using BytesLib for bytes; event receiveDth(address _from, uint amount); event receiveEth(address _from, uint amount); event sendDth(address _from, uint amount); event sendEth(address _from, uint amount); mapping(address => uint) public dthShopBalance; mapping(address => uint) public dthTellerBalance; mapping(address => uint) public ethShopBalance; mapping(address => uint) public ethTellerBalance; ERC223Basic public dth; bool public isInit = false; function setDth (address _dth) external onlyOwner { require(!isInit); dth = ERC223Basic(_dth); isInit = true; }",1
