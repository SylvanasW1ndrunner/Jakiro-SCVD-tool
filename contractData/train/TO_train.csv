file,contract,code,label
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf47f923b91422f47645f41425601c44f6b464300.sol,DAOT,"contract DAOT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 43 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 32 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x766f28c22028b55b0bc6d7c56ad006a10403847b.sol,BuckySalary,contract BuckySalary is Ownable { address[] public staff; mapping(address => uint) public eth; function BuckySalary() public { },1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0x5a757fb240ac70dbead4f9e1508f24a91da70ee5.sol,SilentToken,"contract SilentToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 2500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x28a9824cc26361fe97417a60d5bd1225853db46d.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0xf0ccca32cd300356629216eb301ec6649c7c6adb.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x737f626cf046992e961afa140c748cf604e013b9.sol,DiceDSG,contract DiceDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,FundForwarder,"contract FundForwarder is Escapable { Campaign public beneficiary; function FundForwarder( Campaign _beneficiary, address _escapeHatchCaller, address _escapeHatchDestination ) Escapable(_escapeHatchCaller, _escapeHatchDestination) { beneficiary = _beneficiary; }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0xeba4ce0d799fe901f3af52c0e0f088d026b11c81.sol,CFNDCrowdsale,contract CFNDCrowdsale { Token public tokenReward; address public creator; address public owner = 0x56D215183E48881f10D1FaEb9325cf02171B16B7; uint256 private price; modifier isCreator() { require(msg.sender == creator); _; },1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0x20d4ec1b92cc4570c74efd968d04660b8fcc0406.sol,PornLoversToken,"contract PornLoversToken is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 91; event LogBonusSet(address indexed _address, uint256 _amount); function virtualBalanceOf(address _owner) internal view returns (uint256) { return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0; }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,FlightDelayNewPolicy,"contract FlightDelayNewPolicy is FlightDelayControlledContract, FlightDelayConstants, ConvertLib { FlightDelayAccessControllerInterface FD_AC; FlightDelayDatabaseInterface FD_DB; FlightDelayLedgerInterface FD_LG; FlightDelayUnderwriteInterface FD_UW; function FlightDelayNewPolicy(address _controller) { setController(_controller); }",1
0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x33ac37240f71629294de98e0b51f904fda17a366.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x54d445898cbafb7cf48597e495251183207767ae.sol,FasterProfit,contract FasterProfit { address constant private PROMO = 0xA93c13B3E3561e5e2A1a20239486D03A16d1Fc4b; uint constant public MULTIPLIER = 110; uint constant public MAX_DEPOSIT = 1 ether; uint public currentReceiverIndex = 0; uint public MIN_DEPOSIT = 0.01 ether; uint public txnCount = 0; uint private PROMO_PERCENT = 0; uint constant public LAST_DEPOSIT_PERCENT = 20; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,MainSale,"contract MainSale is Ownable { using SafeMath for uint256; event TokensPurchased(address indexed buyer, uint256 ether_amount); event MainSaleClosed(); HeroOrigenToken public token = new HeroOrigenToken(); address public multisigVault = 0x1706024467ef8C9C4648Da6FC35f2C995Ac79CF6; uint256 public totalReceived = 0; uint256 public hardcap = 250000 ether; uint256 public minimum = 10 ether; uint256 public altDeposits = 0; uint256 public start = 1511178900; bool public saleOngoing = true; modifier isSaleOn() { require(start <= now && saleOngoing); _; }",1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0x8545f796587f83a865b509d14115a5831121cefc.sol,Choicemining,"contract Choicemining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 25 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 11000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 50; uint256 public tokensPerEth = 25000e18; uint public target0drop = 4500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xaadb05f449072d275833baf7c82e8fca4ee46575.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RNTMultiSigWallet,"contract RNTMultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event Pause(); event Unpause(); uint constant public MAX_OWNER_COUNT = 10; uint constant public ADMINS_COUNT = 2; mapping(uint => WalletTransaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; mapping(address => bool) public isAdmin; address[] public owners; address[] public admins; uint public required; uint public transactionCount; bool public paused = false; struct WalletTransaction { address sender; address destination; uint value; bytes data; bool executed; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x2931b36154a10bde01373af56623705d128155b5.sol,CryptoDuels,contract CryptoDuels is Owned { using SafeMath for uint; struct PLAYER { uint wad; uint lastJoin; uint lastDuel; uint listPosition; },1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xdc99adde3a358e5ff62fff3f26b2296f8cca2306.sol,TokenFactoryCN,"contract TokenFactoryCN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 900000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TokenFactoryCN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0xf48d72e5a2419c0c6f5822854b7bb7bf135d1623.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,GTO,contract GTO is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint256 public _totalSupply = 10 ** 14; uint256 public _originalBuyPrice = 45 * 10**7; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; address[] private buyers; uint8 public _icoPercent = 10; uint256 public _icoSupply = _totalSupply * _icoPercent / 100; uint256 public _minimumBuy = 3 * 10 ** 17; uint256 public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0x0248f089a622b74cebaa62573605af9a44966bf1.sol,Ethraffle,contract Ethraffle { struct Contestant { address addr; uint raffleId; },1
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; uint256 public winningMultiplier; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event Winning( address _to, uint256 _amount, uint256 _session, uint256 _winningOption, uint _blockNumber ); event EndSession( address _sessionEnder, uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); function Hedgely() public { owner = msg.sender; sessionBlockSize = 100; sessionNumber = 0; numPlayers = 0; resetMarket(); }",1
0x217fdc3f4f5061bf75a0c1c8515c8330926277da.sol,BFC,"contract BFC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint256 public constant INITIAL_SUPPLY = 2000000000 * (10 ** uint256(decimals)); uint public amountRaised; uint256 public buyPrice = 50000; bool public crowdsaleClosed; function BFC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1ec7345ee1780d847b29f65aa0ecf70cb278966e.sol,EtherTv,"contract EtherTv is Ownable { using SafeMath for uint256; Show[] private shows; uint256 public devOwed; mapping (address => uint256) public userDividends; event ShowPurchased( uint256 _tokenId, address oldOwner, address newOwner, uint256 price, uint256 nextPrice ); uint256 constant private FIRST_CAP = 0.5 ether; uint256 constant private SECOND_CAP = 1.0 ether; uint256 constant private THIRD_CAP = 3.0 ether; uint256 constant private FINAL_CAP = 5.0 ether; struct Show { uint256 price; uint256 payout; address owner; }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x41dab199a4aa0e14434473f689aecfcb1c8e520c.sol,MultiSigERC20Token,"contract MultiSigERC20Token { uint constant public MAX_OWNER_COUNT = 50; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address[] public owners; uint256 public required; uint public transactionCount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => MetaTransaction) public transactions; mapping (address => uint256) public withdrawalLimit; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; struct MetaTransaction { address source; address destination; uint value; bool executed; uint operation; string reason; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,AceDice,contract AceDice is usingOraclize { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint64 public oraclizeGasLimit; uint public oraclizeGasPrice; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Mortal,contract Mortal is Owner { function close() external onlyOwner { selfdestruct(owner); },1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x2732dd0f79f6cf4f257232ea2291ffbab2c18c15.sol,CoinFlipperDSG,contract CoinFlipperDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x9224ca23168a20bc1b5e2a1627edf783e193d39c.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x0e73fac981d22a0511b42f757186c3514ce60c4e.sol,Htlc,"contract Htlc { enum State { Created, Refunded, Redeemed }",1
0xf030b8fbe57c4498298449fc78a0f7054a5ef76d.sol,ArkToken,"contract ArkToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; mapping (uint256 => Animal) public arkData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => uint256) public babies; mapping (uint256 => uint256[2]) public babyMommas; mapping (uint256 => uint256) public mates; mapping (uint256 => uint256) public babyMakinPrice; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public birtherBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Birth(address indexed _birther, uint256 indexed _mom, uint256 _dad, uint256 indexed _baby); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 1.5 ether; uint256 private finalCap = 3.0 ether; struct Animal { uint256 price; uint256 lastPrice; address owner; address birther; uint256 birtherPct; uint8 gender; }",1
0x1e4dfaf4840fd9f4f4deb7e89437b37c4b8efdc5.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; address public airdrop; address public ethaddrc; uint256 public buyPrice = 40000; uint256 public times; uint256 public shuliang = 100000000 ether; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( address _ethadd, uint256 initialSupply, address _airdrop ) public { airdrop = _airdrop; totalSupply = initialSupply * 10 ** uint256(decimals); balances[airdrop] = totalSupply; ethaddrc = _ethadd; times = now; }",1
0x897d6c6772b85bf25b46c6f6da454133478ea6ab.sol,Neutrino81,contract Neutrino81 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0x5a757fb240ac70dbead4f9e1508f24a91da70ee5.sol,SilentToken,"contract SilentToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 2500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,FundCrowdsale,"contract FundCrowdsale is Ownable, Pausable, Destructible { using SafeMath for uint; address public beneficiary; address public fundAddress; uint public fundingGoal; uint public amountRaised; uint8 public decimals = 18; uint public numTokenPerEth; uint public maxTokenNum; ABAToken public tokenAddress; DateTime public dateTime; mapping(address => uint256) public balanceOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function FundCrowdsale(){ beneficiary = 0x63759be273413954Ea91778a720E51c3d7Bc1F7F; fundAddress = 0x00f60Dd7De6689b07095a922043aF529cd6A817d; fundingGoal = 3000 * 1 ether; numTokenPerEth = 2833; maxTokenNum = fundingGoal*numTokenPerEth * 10 ** uint256(decimals); tokenAddress = ABAToken(0x7C2AF3a86B4bf47E6Ee63AD9bde7B3B0ba7F95da); dateTime = new DateTime(); }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0x33914fa445969ded631bf4c33d8882c225386620.sol,CutiePluginBase,"contract CutiePluginBase is PluginInterface, Pausable { function isPluginInterface() public pure returns (bool) { return true; }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0xdde1cddbbc4bfc0d2e9f5b2957456a2b651aaa6b.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x86f212e6046b39c7479e5cb6f465d25a3c6da198.sol,SmartMMM,contract SmartMMM is Ownable { struct DepositItem { uint time; uint sum; uint withdrawalTime; uint restartIndex; uint invested; uint payments; uint referralPayments; uint cashback; uint referalsLevelOneCount; uint referalsLevelTwoCount; address referrerLevelOne; address referrerLevelTwo; },1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xbcdc85a62e5f29930a43cc20d15fe96786873084.sol,ENJOY,contract ENJOY { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x64ef6612a67de3fa96accb645ae46a3c09227928.sol,Economeme,"contract Economeme is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; uint256 public submissionPool; uint256 public submissionPrice; uint256 public endingBalance; mapping (uint256 => Meme) public memeData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public creatorBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Creation(address indexed _creator, uint256 _tokenId, uint256 _timestamp); uint256 private firstCap = 0.02 ether; uint256 private secondCap = 0.5 ether; uint256 private thirdCap = 2.0 ether; uint256 private finalCap = 5.0 ether; struct Meme { uint256 price; address owner; address creator; }",1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0x8b3934dd548be05022a8484ac41b8303ec4a88b3.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x451a4bf6b23294636e0162557d7ccea4a5fc9489.sol,UBCC,"contract UBCC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 413000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function UBCC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,FIREBET,"contract FIREBET is Mortal{ uint minBet = 1000000000; uint houseEdge = 1; event Won(bool _status, uint _number, uint _amount); constructor() payable public {}",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x2821fb31998e60d220ff52af6299872f25a3e149.sol,MiniMeToken,contract MiniMeToken is Controlled { using SafeMath for uint256; string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x40b10014a17e997e8e55594cbfb4f085c5ec815b.sol,MultiSig,"contract MultiSig is owned { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0x1fe2401bd6f4de5eff1661086440297baa9a2e12.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge{ function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2671bf62fdf173cfcb4b178d1a563ca84a349dc3.sol,D_QUIZ,contract D_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xed3c00a6c0da9a64c307719da5ce629c6ee66dfc.sol,CutiePluginBase,"contract CutiePluginBase is PluginInterface, Pausable { function isPluginInterface() public pure returns (bool) { return true; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0x588f4ee97a2085c95420a45684a898d4b5906ba1.sol,SPAM,contract SPAM is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public SPAMed; event Message(string message); function SPAM() public { owner = msg.sender; totalSupply = 9999 * 1e18; stdBalance = 9999 * 1e18; SPAMed = true; },1
0x791d0463b8813b827807a36852e4778be01b704e.sol,Test1,contract Test1 { address owner = msg.sender; function withdraw() payable public { require(msg.sender==owner); owner.transfer(this.balance); },1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x1ec7345ee1780d847b29f65aa0ecf70cb278966e.sol,EtherTv,"contract EtherTv is Ownable { using SafeMath for uint256; Show[] private shows; uint256 public devOwed; mapping (address => uint256) public userDividends; event ShowPurchased( uint256 _tokenId, address oldOwner, address newOwner, uint256 price, uint256 nextPrice ); uint256 constant private FIRST_CAP = 0.5 ether; uint256 constant private SECOND_CAP = 1.0 ether; uint256 constant private THIRD_CAP = 3.0 ether; uint256 constant private FINAL_CAP = 5.0 ether; struct Show { uint256 price; uint256 payout; address owner; }",1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x6c17472a51c3d32a7f216d1622b212d42f53056d.sol,BLAINetworkToken,"contract BLAINetworkToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 600000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BLAINetworkToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x21857261ad06753cee383716e87422168102a453.sol,Doubler,contract Doubler{ uint public price = 1 wei; address public winner = msg.sender; function() public payable { require(msg.value >= price); if (msg.value > price){ msg.sender.transfer(msg.value - price); },1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); Upgrade(msg.sender, migrationAgent, value); }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x0f292cc21a59f248ca34ed159db0262f2f97d2f1.sol,Alfa_QUIZ,contract Alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51.sol,EtherColor,"contract EtherColor is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; mapping (uint256 => uint256) private colorIndexToPreviousPrice; mapping (uint256 => address[5]) private colorIndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Color { string name; }",1
0x53d428716900eae876ad1d7e4535e796b5faeda2.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 20; uint256 public tokensPerEth = 40000e18; uint public target0drop = 5024; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x52b5a68d069a6c9b2f36f279e9d936557fe8d29c.sol,BridgeX_Network,"contract BridgeX_Network is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0x53d428716900eae876ad1d7e4535e796b5faeda2.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 20; uint256 public tokensPerEth = 40000e18; uint public target0drop = 5024; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9214ec02cb71cba0ada6896b8da260736a67ab10.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6d2b61eb73a67ce199ed479cad46a2a864c331b8.sol,Donut,"contract Donut { using Cylinder for Cylinder.Data; using Random for Random.Data; uint[14] public BETS = [ 0.01 ether, 0.02 ether, 0.04 ether, 0.05 ether, 0.07 ether, 0.08 ether, 0.1 ether, 0.15 ether, 0.2 ether, 0.3 ether, 0.4 ether, 0.5 ether, 0.8 ether, 1 ether ]; struct GameToFinish{ uint8 game; uint64 blockNumber; uint64 height; }",1
0x6dfe212d1461014be1781b0be710dda1c036d8ef.sol,ZTST,"contract ZTST is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 30000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 50 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function ZTST() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,NSPToken,"contract NSPToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public constant INITIAL_SUPPLY = 1000; uint256 public price = 10 ** 15; bool public halted = false; function NSPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x39f9d4f50f1eb55948ba1e4a9a8432b1a371caf3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,GenericCrowdsale,"contract GenericCrowdsale is Ownable { using SafeMath for uint256; enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}",1
0xf31619a15518dce0613a514e6672d1f84f6e7fe7.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x8b548505babfd983fc45210499b44e340bb85d76.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256 public totalHedgelyWinnings; uint256 public totalHedgelyInvested; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event EndSession( uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; }",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x7638a5f444eab0281ca1abff2c8029cbb806a566.sol,XOXOCoin,"contract XOXOCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 200000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Forwarder,"contract Forwarder { address private parentAddress = 0x7aeCf441966CA8486F4cBAa62fa9eF2D557f9ba7; address[] private owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; event ForwarderDeposited(address from, uint value, bytes data); constructor() public { }",1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,SRNMagicBox,"contract SRNMagicBox is ServerControl, TokenReceiver { GirlOps girlOps; GenesFactory genesFactory; SRNG SRNGInstance; string public name; uint public keyRequired; address public keyAddress; address public prizePoolAddress; uint public boxPrice; uint[] public prizeIndex; uint[] public prizeRange; uint[] public NCards; uint[] public RCards; uint[] public SRCards; uint[] public SSRCards; event SendGirlFail(address _to, uint _type); constructor(string _name, address _girlAddress, address _SRNGAddress, address _genesFactoryAddress, address _prizePoolAddress, address _keyAddress, uint _keyRequired, uint _boxPrice) public { name = _name; girlOps = GirlOps(_girlAddress); SRNGInstance = SRNG(_SRNGAddress); genesFactory = GenesFactory(_genesFactoryAddress); prizePoolAddress = _prizePoolAddress; keyAddress = _keyAddress; keyRequired = _keyRequired; boxPrice = _boxPrice; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,Crowdsale,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x00346fddca107aec034a367b7324f0d6419bf4b9.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, address addressOfTokenUsedAsReward ) public{ beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = (0.00001 ether)/100000 ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6a3cfb5aeefb9138a28b28f3852a8fee81216df3.sol,RxEALSaleContract,"contract RxEALSaleContract { using SafeMath for uint256; RxEALTokenContract public token; uint256 public startTime = 1520856000; uint256 public endTime = 1523448000; address public wallet1 = 0x56E4e5d451dF045827e214FE10bBF99D730d9683; address public wallet2 = 0x8C0988711E60CfF153359Ab6CFC8d45565C6ce79; address public wallet3 = 0x0EdF5c34ddE2573f162CcfEede99EeC6aCF1c2CB; address public wallet4 = 0xcBdC5eE000f77f3bCc0eFeF0dc47d38911CBD45B; uint256 public tier_rate_1 = 1800; uint256 public tier_cap_1 = 4800000; uint256 public tier_rate_2 = 1440; uint256 public tier_cap_2 = 14400000; uint256 public tier_rate_3 = 1320; uint256 public tier_cap_3 = 14400000; uint256 public tier_rate_4 = 1200; uint256 public tier_cap_4 = 14400000; uint256 public hard_cap; uint8 public current_tier = 1; uint256 public weiRaised; uint256 public soldTokens; uint256 public current_tier_sold_tokens; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 tokens); function RxEALSaleContract() { token = RxEALTokenContract(0xD6682Db9106e0cfB530B697cA0EcDC8F5597CD15); tier_cap_1 = tier_cap_1 * (10 ** token.decimals()); tier_cap_2 = tier_cap_2 * (10 ** token.decimals()); tier_cap_3 = tier_cap_3 * (10 ** token.decimals()); tier_cap_4 = tier_cap_4 * (10 ** token.decimals()); hard_cap = tier_cap_1 + tier_cap_2 + tier_cap_3 + tier_cap_4; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0xefe17f088be79ba802b60ea84ebafb255ea18aa4.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x0e2354b2ea4a6312009b228d5171bf6a02c51150.sol,THE_GAME,contract THE_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1fe2401bd6f4de5eff1661086440297baa9a2e12.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge{ function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0xa614bbfc9f7411ac008c78bfdd1a7f9e0e5180db.sol,Control,contract Control is QUASI { function Control() payable QUASI() public {},1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bec76a319d3b97523f50137ba20ec63746ac49a.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0xdfa66ec49cf0102fb8906ee3dd6a70597d9720d4.sol,DEKS,"contract DEKS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000e8; uint public target0drop = 12000; uint public progress0drop = 0; address multisig = 0xae4B0D603B563A3b26a585e5cF43f1Fb6f75295C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0xdae46fadfd30e7b6de74937626adf09d947ecc62.sol,PreIco,"contract PreIco is SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public manager; address public reserveManager; address public escrow; address public reserveEscrow; uint constant BASE = 1000000000000000000; uint public tokensSupplied = 0; uint public bountySupplied = 0; uint public constant SOFT_CAPACITY = 166666 * BASE; uint public constant TOKENS_SUPPLY = 600000 * BASE; uint public constant BOUNTY_SUPPLY = 350000 * BASE; uint public constant totalSupply = TOKENS_SUPPLY + BOUNTY_SUPPLY; uint public constant TOKEN_PRICE = 3000000000000000; uint tokenAmount1 = 200000 * BASE; uint tokenAmount2 = 200000 * BASE; uint tokenAmount3 = 200000 * BASE; uint tokenPriceMultiply1 = 1; uint tokenPriceDivide1 = 1; uint tokenPriceMultiply2 = 1041667; uint tokenPriceDivide2 = 1000000; uint tokenPriceMultiply3 = 1083333; uint tokenPriceDivide3 = 1000000; uint[] public tokenPriceMultiplies; uint[] public tokenPriceDivides; uint[] public tokenAmounts; mapping(address => uint) public ethBalances; uint[] public prices; uint[] public amounts; mapping(address => uint) private balances; uint public constant defaultDeadline = 1515679200; uint public deadline = defaultDeadline; bool public isIcoStopped = false; address[] public allowedTokens; mapping(address => uint) public tokenAmount; mapping(address => uint) public tokenPrice; address[] public usersList; mapping(address => bool) isUserInList; uint numberOfUsersReturned = 0; mapping(address => address[]) public userTokens; mapping(address => mapping(address => uint)) public userTokensValues; event BuyTokens(address indexed _user, uint _ethValue, uint _boughtTokens); event BuyTokensWithTokens(address indexed _user, address indexed _token, uint _tokenValue, uint _boughtTokens); event GiveReward(address indexed _to, uint _value); event IcoStoppedManually(); event IcoRunnedManually(); event WithdrawEther(address indexed _escrow, uint _ethValue); event WithdrawToken(address indexed _escrow, address indexed _token, uint _value); event ReturnEthersFor(address indexed _user, uint _value); event ReturnTokensFor(address indexed _user, address indexed _token, uint _value); event AddToken(address indexed _token, uint _amount, uint _price); event RemoveToken(address indexed _token); event MoveTokens(address indexed _from, address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyManager { assert(msg.sender == manager || msg.sender == reserveManager); _; }",1
0x53b363a63c6c4dfd09121fa9cf1a1279c1c02077.sol,SocialMarketingCoin,"contract SocialMarketingCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 1800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xDbFBA8bc4b511927BD5EF5c876682ed512B65E24; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x36fef0a32d493fa86d6281205b924456597aae5d.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0460dcb54214fdf68302b4c733ad7ed827dd6592.sol,evequiz,contract evequiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x000621424c60951cb69e9d75d64b79813846d498.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,CoolPandaToken,"contract CoolPandaToken is ERC20, Lockable { using SafeMath for uint256; uint256 public decimals = 18; address public fundWallet = 0x071961b88F848D09C3d988E8814F38cbAE755C44; uint256 public tokenPrice; function balanceOf(address _addr) external view returns (uint256) { return balances[_addr]; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xe34443095f78099675b165f07559e9b48450c77e.sol,Depay,contract Depay { address public developer; uint public donations; function Depay() public { developer = msg.sender; },1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xeba4ce0d799fe901f3af52c0e0f088d026b11c81.sol,CFNDCrowdsale,contract CFNDCrowdsale { Token public tokenReward; address public creator; address public owner = 0x56D215183E48881f10D1FaEb9325cf02171B16B7; uint256 private price; modifier isCreator() { require(msg.sender == creator); _; },1
0x7562eacac20093065c37ec6111baae15f152958c.sol,AICrypto,"contract AICrypto is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function AICrypto() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x7909d3c14e5fb93a508582d04d11093585ebc084.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x2c2a721d303dc4273725c6aa8704ec8d1d3d17b1.sol,GlitchGoonsProxy,"contract GlitchGoonsProxy is Ownable { constructor (address _emitter, address _administrator) public { setEmitter(_emitter); setAdministrator(_administrator); }",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x33147d0f721ddfd82408dd1c890eff4ad7ecd80e.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0xe3147bc1046fab87292e1b743c1e657b37262496.sol,AccessCrowdsale,"contract AccessCrowdsale is Whitelisted { using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1550102400; preSaleDeadline = 1552608000; mainSaleStartdate = 1552611600; mainSaleDeadline = 1560643200; price = 0.0004 ether; tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b); }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x0d9a437282ba395664ed7d26df2377659a7e16af.sol,SaleTracker,"contract SaleTracker is Pausable { using SafeMath for uint256; event PurchaseMade (address indexed _from, bytes8 _paymentCode, uint256 _value); mapping(address => uint256) public purchases; address[] public purchaserAddresses; bool public enforceAddressMatch; function SaleTracker(bool _enforceAddressMatch) { enforceAddressMatch = _enforceAddressMatch; pause(); }",1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0xe34443095f78099675b165f07559e9b48450c77e.sol,Depay,contract Depay { address public developer; uint public donations; function Depay() public { developer = msg.sender; },1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,GTO,contract GTO is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint256 public _totalSupply = 10 ** 14; uint256 public _originalBuyPrice = 45 * 10**7; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; address[] private buyers; uint8 public _icoPercent = 10; uint256 public _icoSupply = _totalSupply * _icoPercent / 100; uint256 public _minimumBuy = 3 * 10 ** 17; uint256 public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x56ba2ee7890461f463f7be02aac3099f6d5811a8.sol,CATToken,"contract CATToken is StandardToken { using SafeMath for uint256; string public constant HIDDEN_CAP = ; event CreatedCAT(address indexed _creator, uint256 _amountOfCAT); event CATRefundedForWei(address indexed _refunder, uint256 _amountOfWei); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public executor; address public devETHDestination; address public devCATDestination; address public reserveCATDestination; bool public saleHasEnded; bool public minCapReached; bool public allowRefund; mapping (address => uint256) public ETHContributed; uint256 public totalETHRaised; uint256 public saleStartBlock; uint256 public saleEndBlock; uint256 public saleFirstEarlyBirdEndBlock; uint256 public saleSecondEarlyBirdEndBlock; uint256 public constant DEV_PORTION = 20; uint256 public constant RESERVE_PORTION = 1; uint256 public constant ADDITIONAL_PORTION = DEV_PORTION + RESERVE_PORTION; uint256 public constant SECURITY_ETHER_CAP = 1000000 ether; uint256 public constant CAT_PER_ETH_BASE_RATE = 300; uint256 public constant CAT_PER_ETH_FIRST_EARLY_BIRD_RATE = 330; uint256 public constant CAT_PER_ETH_SECOND_EARLY_BIRD_RATE = 315; function CATToken( address _devETHDestination, address _devCATDestination, address _reserveCATDestination, uint256 _saleStartBlock, uint256 _saleEndBlock ) { if (_devETHDestination == address(0x0)) throw; if (_devCATDestination == address(0x0)) throw; if (_reserveCATDestination == address(0x0)) throw; if (_saleEndBlock <= block.number) throw; if (_saleEndBlock <= _saleStartBlock) throw; executor = msg.sender; saleHasEnded = false; minCapReached = false; allowRefund = false; devETHDestination = _devETHDestination; devCATDestination = _devCATDestination; reserveCATDestination = _reserveCATDestination; totalETHRaised = 0; saleStartBlock = _saleStartBlock; saleEndBlock = _saleEndBlock; saleFirstEarlyBirdEndBlock = saleStartBlock + 6171; saleSecondEarlyBirdEndBlock = saleFirstEarlyBirdEndBlock + 12342; totalSupply = 0; }",1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0x83d3abc4e75885db350ace57f99c3a3e00286fe8.sol,BetaCoin,"contract BetaCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,Destroyable,contract Destroyable is Ownable{ function destroy() public onlyOwner{ selfdestruct(owner); },1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,MainSale,"contract MainSale is Ownable { using SafeMath for uint256; event TokensPurchased(address indexed buyer, uint256 ether_amount); event MainSaleClosed(); HeroOrigenToken public token = new HeroOrigenToken(); address public multisigVault = 0x1706024467ef8C9C4648Da6FC35f2C995Ac79CF6; uint256 public totalReceived = 0; uint256 public hardcap = 250000 ether; uint256 public minimum = 10 ether; uint256 public altDeposits = 0; uint256 public start = 1511178900; bool public saleOngoing = true; modifier isSaleOn() { require(start <= now && saleOngoing); _; }",1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0xaadb05f449072d275833baf7c82e8fca4ee46575.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x56ba2ee7890461f463f7be02aac3099f6d5811a8.sol,CATToken,"contract CATToken is StandardToken { using SafeMath for uint256; string public constant HIDDEN_CAP = ; event CreatedCAT(address indexed _creator, uint256 _amountOfCAT); event CATRefundedForWei(address indexed _refunder, uint256 _amountOfWei); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public executor; address public devETHDestination; address public devCATDestination; address public reserveCATDestination; bool public saleHasEnded; bool public minCapReached; bool public allowRefund; mapping (address => uint256) public ETHContributed; uint256 public totalETHRaised; uint256 public saleStartBlock; uint256 public saleEndBlock; uint256 public saleFirstEarlyBirdEndBlock; uint256 public saleSecondEarlyBirdEndBlock; uint256 public constant DEV_PORTION = 20; uint256 public constant RESERVE_PORTION = 1; uint256 public constant ADDITIONAL_PORTION = DEV_PORTION + RESERVE_PORTION; uint256 public constant SECURITY_ETHER_CAP = 1000000 ether; uint256 public constant CAT_PER_ETH_BASE_RATE = 300; uint256 public constant CAT_PER_ETH_FIRST_EARLY_BIRD_RATE = 330; uint256 public constant CAT_PER_ETH_SECOND_EARLY_BIRD_RATE = 315; function CATToken( address _devETHDestination, address _devCATDestination, address _reserveCATDestination, uint256 _saleStartBlock, uint256 _saleEndBlock ) { if (_devETHDestination == address(0x0)) throw; if (_devCATDestination == address(0x0)) throw; if (_reserveCATDestination == address(0x0)) throw; if (_saleEndBlock <= block.number) throw; if (_saleEndBlock <= _saleStartBlock) throw; executor = msg.sender; saleHasEnded = false; minCapReached = false; allowRefund = false; devETHDestination = _devETHDestination; devCATDestination = _devCATDestination; reserveCATDestination = _reserveCATDestination; totalETHRaised = 0; saleStartBlock = _saleStartBlock; saleEndBlock = _saleEndBlock; saleFirstEarlyBirdEndBlock = saleStartBlock + 6171; saleSecondEarlyBirdEndBlock = saleFirstEarlyBirdEndBlock + 12342; totalSupply = 0; }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa614bbfc9f7411ac008c78bfdd1a7f9e0e5180db.sol,Control,contract Control is QUASI { function Control() payable QUASI() public {},1
0x72b2670e55139934d6445348dc6eab4089b12576.sol,TakeoutController,contract TakeoutController { address owner; address takeoutWallet; HourglassInterface private Hourglass; constructor() public { Hourglass = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); takeoutWallet = 0xf783A81F046448c38f3c863885D9e99D10209779; owner = msg.sender; },1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0x9c406e291f41eb50f152dec37196d01f751b5656.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x6bec76a319d3b97523f50137ba20ec63746ac49a.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x540dc09d343835ce0aef9bc3c3007de936c72b81.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xfef5497bc53a69875e02ae5b14eeff668f09a729.sol,Infinity,"contract Infinity { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public initAmount; uint256 public amountProportion; uint256 public dividend; uint256 public jackpot; uint256 public jackpotProportion; uint256 public scientists; uint256 public promotionRatio; uint256 public duration; bool public activated = false; address public developerAddr; uint256 public rId; uint256 public sId; mapping (uint256 => Indatasets.Round) public round; mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage; mapping (address => Indatasets.Player) public player; mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; mapping (uint256 => mapping (address => uint256)) public playerRoundSid; mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount; uint256[] amountLimit = [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]; constructor() public { developerAddr = msg.sender; }",1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Lotthereum,"contract Lotthereum is Mortal, SafeMath { Game[] private games; mapping (address => uint) private balances; struct Game { uint id; uint pointer; uint maxNumberOfBets; uint minAmountByBet; uint prize; uint currentRound; Round[] rounds; }",1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe0a8a9b7c821d9bbd66b826129d4cf1b219ebb3a.sol,CryptoRides,"contract CryptoRides is ERC721 { event Created(uint256 tokenId, string name, bytes7 plateNumber, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, bytes7 plateNumber); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public tokenIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; mapping (uint256 => uint256) private tokenIdToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Ride { string name; bytes7 plateNumber; }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,BitcoinX,"contract BitcoinX is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 911; iEthealSale public crowdsale; event LogBonusSet(address indexed _address, uint256 _amount); function BitcoinX(address _crowdsale) { crowdsale = iEthealSale(_crowdsale); }",1
0xdc8d902c34f2257b8569dc9bc4f58cc149ed6e48.sol,GitmanIssue,"contract GitmanIssue { address private mediator; address public parent; string public owner; string public repository; string public issue; constructor (string ownerId, string repositoryId, string issueId, address mediatorAddress) public payable { parent = msg.sender; mediator = mediatorAddress; owner = ownerId; repository = repositoryId; issue = issueId; }",1
0x72b2670e55139934d6445348dc6eab4089b12576.sol,TakeoutController,contract TakeoutController { address owner; address takeoutWallet; HourglassInterface private Hourglass; constructor() public { Hourglass = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); takeoutWallet = 0xf783A81F046448c38f3c863885D9e99D10209779; owner = msg.sender; },1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable, Pausable, Destructible, Contactable { enum Stages { none, icoStart, icoEnd }",1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,DistributorRefundVault,"contract DistributorRefundVault is RefundVault{ address public taxCollector; uint256 public taxValue; function DistributorRefundVault(address _taxCollector, uint256 _taxValue) RefundVault() public{ taxCollector = _taxCollector; taxValue = _taxValue; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0x330e24d4aa0a60acac8f9fe6d674d3cf1e8042c6.sol,LocalEthereumEscrows,contract LocalEthereumEscrows { address public arbitrator; address public owner; address public relayer; uint32 public requestCancellationMinimumTime; uint256 public feesAvailableForWithdraw; uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; uint8 constant ACTION_BUYER_CANCEL = 0x02; uint8 constant ACTION_SELLER_CANCEL = 0x03; uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04; uint8 constant ACTION_RELEASE = 0x05; uint8 constant ACTION_DISPUTE = 0x06; event Created(bytes32 _tradeHash); event SellerCancelDisabled(bytes32 _tradeHash); event SellerRequestedCancel(bytes32 _tradeHash); event CancelledBySeller(bytes32 _tradeHash); event CancelledByBuyer(bytes32 _tradeHash); event Released(bytes32 _tradeHash); event DisputeResolved(bytes32 _tradeHash); struct Escrow { bool exists; uint32 sellerCanCancelAfter; uint128 totalGasFeesSpentByRelayer; },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is TimedCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; }",1
0x70b86b328b14b2f58f137436607cff45e4545617.sol,quiz_BLZ,contract quiz_BLZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xfef5497bc53a69875e02ae5b14eeff668f09a729.sol,Infinity,"contract Infinity { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public initAmount; uint256 public amountProportion; uint256 public dividend; uint256 public jackpot; uint256 public jackpotProportion; uint256 public scientists; uint256 public promotionRatio; uint256 public duration; bool public activated = false; address public developerAddr; uint256 public rId; uint256 public sId; mapping (uint256 => Indatasets.Round) public round; mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage; mapping (address => Indatasets.Player) public player; mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; mapping (uint256 => mapping (address => uint256)) public playerRoundSid; mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount; mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount; uint256[] amountLimit = [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]; constructor() public { developerAddr = msg.sender; }",1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x12a31ba664df56d0d3c7a8dfb15f676db4203184.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2af8b34f04e93c79ee3a1f300a019f29869d896a.sol,SiliconValleyToken,"contract SiliconValleyToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function SiliconValleyToken() public {}",1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0x0e73fac981d22a0511b42f757186c3514ce60c4e.sol,Htlc,"contract Htlc { enum State { Created, Refunded, Redeemed }",1
0xdcb5410ef70f59a5a2839fc6d4d0b2ca981f5e2d.sol,CoinMmc,"contract CoinMmc { address public admin_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; address public account_address = 0x64b33dB1Cc804e7CA51D9c21F132567923D7BA00; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 initSupply = 1000000000000; uint256 public totalSupply = 0; constructor() payable public { totalSupply = mul(initSupply, 10**uint256(decimals)); balances[account_address] = totalSupply; _add_lock_account(0x6efB62605A66E32582c37b835F81Bc91A6a8fb2e, mul(80000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0x0ba46c0fC6a5C206855cEf215222e347E1559eDf, mul(120000000000,10**uint256(decimals)), 1596815160); _add_lock_account(0xE269695D497387DfEAFE12b0b3B54441683F63C8, mul(100000000000,10**uint256(decimals)), 1628351160); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x53b363a63c6c4dfd09121fa9cf1a1279c1c02077.sol,SocialMarketingCoin,"contract SocialMarketingCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 1800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xDbFBA8bc4b511927BD5EF5c876682ed512B65E24; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,Owned,contract Owned { address private Owner; function Owned() public{ Owner = msg.sender; },1
0x6d2b61eb73a67ce199ed479cad46a2a864c331b8.sol,Donut,"contract Donut { using Cylinder for Cylinder.Data; using Random for Random.Data; uint[14] public BETS = [ 0.01 ether, 0.02 ether, 0.04 ether, 0.05 ether, 0.07 ether, 0.08 ether, 0.1 ether, 0.15 ether, 0.2 ether, 0.3 ether, 0.4 ether, 0.5 ether, 0.8 ether, 1 ether ]; struct GameToFinish{ uint8 game; uint64 blockNumber; uint64 height; }",1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xefbabed10b8fcfca001ffee2752e88e5dd56c1a2.sol,DubaiGreenBlockChain,"contract DubaiGreenBlockChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function DubaiGreenBlockChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x64b09d1a4b01db659fc36b72de0361f2c6c521b1.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0xd84e469c31efc9c67dbadd25c0a04006a5d30c05.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1500000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 300000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 999 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x04c21da065bda1f4780495693ff1b952468ee151.sol,GameX,contract GameX { using SafeMath for uint256; string public name = ; string public symbol = ; mapping(address => bool) admins; bool public activated = false; uint public compot; uint minFee = 0.01 ether; uint maxFee = 1 ether; uint minLucky = 0.1 ether; uint retryfee = 0.02 ether; uint16 public luckynum = 2; uint16 public fuckynum = 90; uint lastnumtime = now; uint public noncex = 1; uint public timeslucky; uint public times6; uint public times7; uint public times8; uint public times9; uint public timesno; uint public timesfucky; uint16 public limit6 = 79; uint16 public limit7 = 86; uint16 public limit8 = 92; uint16 public limit9 = 97; uint16 public reward6 = 11; uint16 public reward7 = 13; uint16 public reward8 = 16; uint16 public reward9 = 23; uint16 public inmax = 100; uint private lastPlayer; uint public jackpot = 0; uint public maskpot = 0; uint public gameTotalGen = 0; uint public _iD; mapping(address => player) public player_; mapping(uint => address) public addrXid; struct player { uint16[] playerNum; uint16 playerTotal; uint id; uint playerWin; uint playerGen; uint playerWinPot; uint RetryTimes; uint lastRetryTime; bool hasRetry; address Aff; uint totalGen; bool hasAddTime; },1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x3116c449b8980e50df1047886c6042300bef9b96.sol,CryptoColors,"contract CryptoColors is ERC721 { event Released(uint256 tokenId, string name, address owner); event ColorSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private constant PROMO_CREATION_LIMIT = 1000000; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; address public ceoAddress; uint256 public promoCreatedCount; struct Color{ uint8 R; uint8 G; uint8 B; string name; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0xf331f7887d31714dce936d9a9846e6afbe82e0a0.sol,Ico,"contract Ico is Owned { enum State { Runned, Paused, Finished, Expired, Failed }",1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x56cd53067e5acd557dbbfb4c66580dfb9722962a.sol,CryptoMoviesToken,"contract CryptoMoviesToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; uint256 private firstStepLimit = 1.2 ether; uint256 private secondStepLimit = 5 ether; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x0f35d82007119dc339af57b29dc8ae794b92926c.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,GTO,contract GTO is ERC20Interface { uint8 public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint256 public _totalSupply = 10 ** 14; uint256 public _originalBuyPrice = 45 * 10**7; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; address[] private buyers; uint8 public _icoPercent = 10; uint256 public _icoSupply = _totalSupply * _icoPercent / 100; uint256 public _minimumBuy = 3 * 10 ** 17; uint256 public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x330af5ff0b2f883c86de0ec09f3456d686bdc93e.sol,BetOnMe,"contract BetOnMe is StandardToken { string public name = ; string public symbol = ; address public coinMaster; event UpdatedInformation(string newName, string newSymbol); function BetOnMe() public { supplyNum = 1000000000000 * (10 ** 18); decimals = 18; coinMaster = msg.sender; mapBalances[coinMaster] = supplyNum; }",1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28.sol,BoltToken,"contract BoltToken is ERC20{ address owner = msg.sender; bool public canPurchase = false; mapping (address => uint) balances; mapping (address => uint) roundContributions; address[] roundContributionsIndexes; mapping (address => mapping (address => uint)) allowed; uint public currentSupply = 0; uint public totalSupply = 32032000000000000000000000; uint public round = 0; uint public roundFunds = 0; uint public roundReward = 200200000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public isToken = true; string public tokenSaleAgreement = ""https: uint contributionsDistribStep = 0; event Contribution(address indexed from, uint value); event RoundEnd(uint roundNumber); function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; }",1
0xf48d72e5a2419c0c6f5822854b7bb7bf135d1623.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1d91b86e5c7b5e85a61eaaea9762958747712826.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xa20f317e3b6fe80ff76ee908860ecdb3edea4893.sol,TwelveHourFastTrain,contract TwelveHourFastTrain { address public owner; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; uint256 constant private THT_TOKEN_OWNERS = 10; address constant private PROMO = 0xC63eA85CC823c440319013d4B30E19b66466642d; uint constant public PROMO_PERCENT = 1; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.05 ether; uint256 constant public VERIFY_REFERRAL_PRICE = 0.01 ether; uint256 constant public REFERRAL = 3; uint constant public LAST_DEPOSIT_PERCENT = 10; LastDeposit public last; mapping(address => bool) public referrals; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x87c260900c391559fd2816c9fbf078de37e2f520.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6a47296deae50b8cde16aebd5de8c82231c711d6.sol,F_game,contract F_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,FlowerCore,"contract FlowerCore is FlowerAuction, Ownable { uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; uint256 public constant GEN0_STARTING_PRICE = 10 finney; uint256 public constant GEN0_AUCTION_DURATION = 1 days; uint256 public promoCreatedCount; uint256 public gen0CreatedCount; constructor() public { stopped = true; rootAddress = msg.sender; adminAddress = msg.sender; _createFlower(0, 0, 0, uint256(-1), address(0)); }",1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x89234fab776fb68ec3c33529aa66f09b69a7b5f0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,CanReclaimToken,contract CanReclaimToken is Ownable { function reclaimToken(IERC20 token) external onlyOwner { if (address(token) == address(0)) { owner().transfer(address(this).balance); return; },1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6a47296deae50b8cde16aebd5de8c82231c711d6.sol,F_game,contract F_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0x36351289a2263902189515f83138528f2382b12f.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreRefundVault,"contract IRBPreRefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add.sol,AllYours,contract AllYours { address private _platformAddress = 0xbE9C1088FEEB8B48A96Da0231062eA757D0a9613; uint private _totalEth = 0.06 ether; uint128 private _oneceEth = 0.02 ether; uint256 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpBase,contract BdpBaseData { address public ownerAddress; address public managerAddress; address[16] public contracts; bool public paused = false; bool public setupCompleted = false; bytes8 public version; },1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x05e7039c7afd77157845d9a4f1750b8ca93ec378.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, bytes32 depositID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => mapping(bytes32 => uint)) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x4bb12d68c795462c12ec30ad82421218d9c32a7d.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public percent; mapping(address => uint256) public percentOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event RewardToken(address backer, uint amount, uint percent); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward, uint initPercent ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken * 1 wei; tokenReward = token(addressOfTokenUsedAsReward); percent = initPercent; }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x55914aad05640d89448a7803a03ed0eabcbc6a22.sol,EthereumCrystal,"contract EthereumCrystal is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 75000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000e8; uint public target0drop = 200000; uint public progress0drop = 0; address multisig = 0xF4ea201ba0c2ca99E8942f047a5220bc98286763; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x1c8c70478e92abc44843245bd6d88035236b4ed9.sol,MajorityGame,contract MajorityGameFactory { address[] private deployedGames; address[] private endedGames; address private adminAddress; mapping(address => uint) private gameAddressIdMap; uint private gameCount = 38; uint private endedGameCount = 0; modifier adminOnly() { require(msg.sender == adminAddress); _; },1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x0cf1125c00b054044aa4f0fc8c4807ec98216fbb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0xde2481f649283ac66d5df892bf3ebb74096933ac.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x0e8160745966d2109c568230ef515b0dddea1599.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public endFirstBonus; uint public endSecondBonus; uint public endThirdBonus; uint public hardCap; uint public price; uint public minPurchase; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, address addressOfTokenUsedAsReward, uint tokensPerEth, uint _minPurchase, uint fundingGoalInWei, uint hardCapInWei, uint startTimeInSeconds, uint durationInMinutes, uint _endFirstBonus, uint _endSecondBonus, uint _endThirdBonus ) public { beneficiary = ifSuccessfulSendTo; tokenReward = token(addressOfTokenUsedAsReward); price = tokensPerEth; minPurchase = _minPurchase; fundingGoal = fundingGoalInWei; hardCap = hardCapInWei; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; endFirstBonus = _endFirstBonus; endSecondBonus = _endSecondBonus; endThirdBonus = _endThirdBonus; }",1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x2ada0cddb716033e52c3d591ad12a59103230e52.sol,SGEICO,contract SGEICO { Token public tokenReward; address public creator; address public owner = 0x8dfFcCE1d47C6325340712AB1B8fD7328075730C; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x4ee1ba168551379fd8a59e2e918ff9ee109a6abf.sol,PlayerBook,"contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private owner; TeamDreamHubInterface public TeamDreamHub_; TeamDreamInterface public TeamDream_; MSFun.Data private msData; function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamDream_.requiredDevSignatures(), _whatFunction));}",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xc551c26e420f710be3fca711d2bff247cd332c3a.sol,CulturePhilosophyFaithChain,"contract CulturePhilosophyFaithChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CulturePhilosophyFaithChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0x53a123ce484b42581b2587624347a9f40e5972c2.sol,MINOTEX_STORE,"contract MINOTEX_STORE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 365 * 1 days; uint public round2 = now + 120 * 1 days; uint public round1 = now + 115 * 1 days; uint256 public totalSupply = 50000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 700000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x07acF33966Bd1c7A9Cb8A40eaA07Ba6D2268B793; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x27f2bf478f7d0c431328a56005b68432d18f26c5.sol,QUIK_QUIZ,contract QUIK_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xeb0335a35d10cab0c0d615d999d657a50cfd44f0.sol,asssderf,"contract asssderf { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1546508000; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); if (msg.value == 0) { require (block.timestamp > partyTime && hodlers[msg.sender] > 0); uint value = hodlers[msg.sender]; hodlers[msg.sender] = 0; msg.sender.transfer(value); Party(msg.sender, value); }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0x54b9eaee92a9bff63cd445a65bd19078116fe927.sol,SoftcapFeature,"contract SoftcapFeature is InvestedProvider, WalletProvider { using SafeMath for uint; mapping(address => uint) public balances; bool public softcapAchieved; bool public refundOn; bool feePayed; uint public softcap; uint public constant devLimit = 19500000000000000000; address public constant devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; function setSoftcap(uint newSoftcap) public onlyOwner { softcap = newSoftcap; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x4d4d55dbdc229fc5ba788d74dff2d583056d86bb.sol,Ccl,contract Ccl{ address owner; constructor() public payable{ owner = msg.sender; },1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,PassToken,"contract PassToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 4; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x2cf02304f36effd519be79850d21335684c6073e.sol,AccEthRegCenter,contract AccEthRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x37b38b8d7b66a6e2e435847f86d9febe8142bf12.sol,NixmaCash,"contract NixmaCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 3000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xa4ec44afee34feffbae5ce4218d3c06ebd70455e.sol,BallotSB52,contract BallotSB52 { using SafeMath for uint; uint public phiWon; uint public neWon; Superbowl52 bettingContract; mapping (address => bool) voted; mapping (address => uint) votes; uint public constant votingPeriod = 7 days; uint public votingStart; uint public votingEnd; uint public validResult; bool public closed; uint public totalVoters; uint public threshold; uint public votingReward; mapping (address => uint) stake; uint public majorityReward; bool public tie; mapping (address => bool) claimed; function BallotSB52(uint th) public payable { validResult = 0; closed = false; votingStart = now; votingEnd = now + 7 days; bettingContract = Superbowl52(msg.sender); totalVoters = 0; threshold = th; tie = false; votingReward = 0; },1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0x710b592bf7eaa59e8046c83519f092def346b6df.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x1ec7345ee1780d847b29f65aa0ecf70cb278966e.sol,EtherTv,"contract EtherTv is Ownable { using SafeMath for uint256; Show[] private shows; uint256 public devOwed; mapping (address => uint256) public userDividends; event ShowPurchased( uint256 _tokenId, address oldOwner, address newOwner, uint256 price, uint256 nextPrice ); uint256 constant private FIRST_CAP = 0.5 ether; uint256 constant private SECOND_CAP = 1.0 ether; uint256 constant private THIRD_CAP = 3.0 ether; uint256 constant private FINAL_CAP = 5.0 ether; struct Show { uint256 price; uint256 payout; address owner; }",1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameFinance,"contract BurnupGameFinance is BurnupGameOwnership, PullPayment { BurnupHoldingCore burnupHolding; function BurnupGameFinance(address burnupHoldingAddress) public { burnupHolding = BurnupHoldingCore(burnupHoldingAddress); }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0x0e3de3b0e3d617fd8d1d8088639ba877feb4d742.sol,IceRockPay,"contract IceRockPay is ERC20Basic, Ownable { event Payout(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint256 totalSupply_; uint8 public constant decimals = 18; enum States { Sale, Stop }",1
0x64bb42f7012cbfef9e036dd8929cbc9d61c7c3ca.sol,OneInTen,"contract OneInTen { function call_lucky(address contract_address, address contract_owner) public payable { uint8 guess = uint8(keccak256(now, contract_owner)) % 10; LuckyNumber(contract_address).takeAGuess.value(msg.value)(guess); require(this.balance > 0); msg.sender.transfer(this.balance); }",1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xdccedb215833b58c8c624abe5b5c715844248816.sol,QuiZ_blIZ,contract QuiZ_blIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0xedbc41b7d0330860be1dd8d682b2e868ae6da6e4.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xaadb05f449072d275833baf7c82e8fca4ee46575.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x7430984e1d05d5f447c747123dd26845f6f17544.sol,ZethrBankroll,"contract ZethrBankroll is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event DevWithdraw(uint amountTotal, uint amountPerPerson); event EtherLogged(uint amountReceived, address sender); event BankrollInvest(uint amountReceived); event DailyTokenAdmin(address gameContract); event DailyTokensSent(address gameContract, uint tokens); event DailyTokensReceived(address gameContract, uint tokens); uint constant public MAX_OWNER_COUNT = 10; uint constant public MAX_WITHDRAW_PCT_DAILY = 15; uint constant public MAX_WITHDRAW_PCT_TX = 5; uint constant internal resetTimer = 1 days; address internal zethrAddress; ZTHInterface public ZTHTKN; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public isWhitelisted; mapping (address => uint) public dailyTokensPerContract; address internal divCardAddress; address[] public owners; address[] public whiteListedContracts; uint public required; uint public transactionCount; uint internal dailyResetTime; uint internal dailyTknLimit; uint internal tknsDispensedToday; bool internal reEntered = false; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x18df60ddaeba4393e5cc6ecfc1e5bb1d20dd6239.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FrostByte,"contract FrostByte is FBT { event tokenBought(uint256 totalTokensBought, uint256 Price); event etherSent(uint256 total); string public name; uint8 public decimals; string public symbol; string public version = ; function FrostByte() { name = ; decimals = 4; symbol = ; pieceprice = 1 ether / 256; datestart = now; }",1
0x77dbd46264dc9d5d4283c4e3616715195691c4ee.sol,BlockchainMusic,"contract BlockchainMusic is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 180000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x12E153c01e613ccC9d9cca2B6E29C4f7B3D3ee3a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreRefundVault,"contract IRBPreRefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x6c2fa6691b237c9e453926d8d484d4c5ab635db5.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000; uint256 exchange = 1000000; uint256 endICO = 1527812056; address admin; function PiperToken() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; }",1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x64bb42f7012cbfef9e036dd8929cbc9d61c7c3ca.sol,OneInTen,"contract OneInTen { function call_lucky(address contract_address, address contract_owner) public payable { uint8 guess = uint8(keccak256(now, contract_owner)) % 10; LuckyNumber(contract_address).takeAGuess.value(msg.value)(guess); require(this.balance > 0); msg.sender.transfer(this.balance); }",1
0x18b67380942d56c09001a3764ce1aa9e64644433.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x20d4477cb25186cc87e85185cfea792dd28bfca5.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0xb4910fe410240d2b79c557250adc767a9bc930c1.sol,Bidding,contract Bidding is Pausable { struct Auction { uint256 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; },1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0x0f4cafdce3737601c598bcfd4bbd69f75786ba40.sol,MagnusSale,"contract MagnusSale is Ownable, Pausable { using SafeMath for uint256; MagnusCoin internal token; uint256 public start; uint256 public end; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 internal weiRaised; uint256 public peggedETHUSD; uint256 public hardCap; uint256 internal reservedTokens; uint256 public baseRateInCents; mapping (address => uint256) public contributions; uint256 internal fiatCurrencyRaisedInEquivalentWeiValue = 0; uint256 public weiRaisedIncludingFiatCurrencyRaised; bool internal isPresale; bool public isRefunding = false; address internal multiFirstWallet=0x9B7eDe5f815551279417C383779f1E455765cD6E; address internal multiSecondWallet=0x377Cc6d225cc49E450ee192d679950665Ae22e2C; address internal multiThirdWallet=0xD0377e0dC9334124803E38CBf92eFdDB7A43caC8; event ContributionReceived(address indexed buyer, bool presale, uint256 rate, uint256 value, uint256 tokens); event PegETHUSD(uint256 pegETHUSD); function MagnusSale( ) public { peggedETHUSD = 1210; address _token=0x1a7CC52cA652Ac5df72A7fA4b131cB9312dD3423; hardCap = 40000000000000000000000; reservedTokens = 0; isPresale = false; minFundingGoalWei = 1000000000000000000000; minContributionWei = 300000000000000000; maxContributionWei = 10000000000000000000000; baseRateInCents = 42; start = 1517144812; uint256 _durationHours=4400; token = MagnusCoin(_token); end = start.add(_durationHours.mul(1 hours)); }",1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,PassToken,"contract PassToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 4; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x28ac63a28c8edf8267bcadfd6161d4105a735041.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 10; uint256 public blocksBeforeTargetShoot = 40; constructor() public { },1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0x777777764382a3ae5e7631570583893bfdea7e05.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,MainSale,contract MainSale is Ownable { using SafeMath for uint256; ShareToken public shrToken; bool public isIcoRunning = false; uint256 public tokenPriceInCent = 2; uint256 public ethUsdRateInCent = 0; uint256 constant E2 = 10**2; function () external payable { require (isIcoRunning); require (ethUsdRateInCent != 0); require (shrToken.isWhitelisted(msg.sender)); uint256 tokens = msg.value.mul(ethUsdRateInCent).mul(E2).div(tokenPriceInCent).div(10**18); uint256 totalIssuedTokens = shrToken.totalMainSaleTokenIssued(); uint256 totalMainSaleLimit = shrToken.totalMainSaleTokenLimit(); if (totalIssuedTokens.add(tokens) > totalMainSaleLimit) { uint256 tokensAvailable = totalMainSaleLimit.sub(totalIssuedTokens); uint256 tokensToRefund = tokens.sub(tokensAvailable); uint256 ethToRefundInWei = tokensToRefund.mul(tokenPriceInCent).mul(10**18).div(E2).div(ethUsdRateInCent); msg.sender.transfer(ethToRefundInWei); tokens = tokensAvailable; isIcoRunning = false; },1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,FundCrowdsale,"contract FundCrowdsale is Ownable, Pausable, Destructible { using SafeMath for uint; address public beneficiary; address public fundAddress; uint public fundingGoal; uint public amountRaised; uint8 public decimals = 18; uint public numTokenPerEth; uint public maxTokenNum; ABAToken public tokenAddress; DateTime public dateTime; mapping(address => uint256) public balanceOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function FundCrowdsale(){ beneficiary = 0x63759be273413954Ea91778a720E51c3d7Bc1F7F; fundAddress = 0x00f60Dd7De6689b07095a922043aF529cd6A817d; fundingGoal = 3000 * 1 ether; numTokenPerEth = 2833; maxTokenNum = fundingGoal*numTokenPerEth * 10 ** uint256(decimals); tokenAddress = ABAToken(0x7C2AF3a86B4bf47E6Ee63AD9bde7B3B0ba7F95da); dateTime = new DateTime(); }",1
0x0f35d82007119dc339af57b29dc8ae794b92926c.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x1da73fc09ea07781482994036a0eecc7e6952dfb.sol,TydoIco,"contract TydoIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; uint256[] public bonuses; uint256[] public bonusEnds; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken, uint256[] _bonuses, uint256[] _bonusEnds) Owned() public { require(_bonuses.length == _bonusEnds.length); for(uint8 i = 0; i < _bonuses.length; i++) { require(_bonuses[i] > 0); if (i > 0) { }",1
0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x422401a78d6fb4727f96cc435884ecf5ce16f527.sol,FollowersToken,contract FollowersToken is ERC721 { string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private firstStepLimit = 6.4 ether; uint256 private secondStepLimit = 120.9324 ether; uint256 private thirdStepLimit = 792.5423 ether; bool private isPresale; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; mapping (uint256 => uint256) private personIndexToPriceLevel; address public ceoAddress; address public cooAddress; struct Person { string name; },1
0x897d6c6772b85bf25b46c6f6da454133478ea6ab.sol,Neutrino81,contract Neutrino81 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x7204f236b3ac144e119d9ac00717204c581a1845.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561.sol,Hanabira,"contract Hanabira is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 5000000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 5000000000e8; uint public target0drop = 70000; uint public progress0drop = 0; address multisig = 0x587aF154ddFB78fe97B7F02FC17D4Eca338AF325; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e416dd32359a7825ef580ff2527c3280c1e07fa.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x777777764382a3ae5e7631570583893bfdea7e05.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,Fallback,contract Fallback is Ownable { mapping(address => uint) public contributions; function fallback() public { contributions[msg.sender] = 1000 * (1 ether); },1
0x5a757fb240ac70dbead4f9e1508f24a91da70ee5.sol,SilentToken,"contract SilentToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 2500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa28b5854df048bcd5eec522fada1c6b7ea006aae.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x000621424c60951cb69e9d75d64b79813846d498.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x5a94fef3eb9c2ab0a83680136d0de092115cbc39.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, address addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 1 ether; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6c2fa6691b237c9e453926d8d484d4c5ab635db5.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000; uint256 exchange = 1000000; uint256 endICO = 1527812056; address admin; function PiperToken() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; }",1
0x5401bb4729bd7f025b97399c3c92854ec299f81a.sol,LOCIsale,"contract LOCIsale is Ownable, Pausable, IRefundHandler { using SafeMath for uint256; LOCIcoin internal token; uint256 public start; uint256 public end; bool public isPresale; bool public isRefunding = false; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 public weiRaised; uint256 public weiRaisedAfterDiscounts; uint256 internal weiForRefund; uint256 public peggedETHUSD; uint256 public hardCap; uint256 public reservedTokens; uint256 public baseRateInCents; uint256 internal startingTokensAmount; mapping (address => uint256) public contributions; struct DiscountTranche { uint256 end; uint8 discount; uint8 round; uint256 roundWeiRaised; uint256 roundTokensSold; }",1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,FTXToken,"contract FTXToken is StandardToken, Ownable { string public constant NAME = ; string public constant SYMBOL = ; string public constant VERSION = ; uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**18; uint256 public constant FINTRUX_RESERVE_FTX = 10000000 * 10**18; uint256 public constant CROSS_RESERVE_FTX = 5000000 * 10**18; uint256 public constant TEAM_RESERVE_FTX = 10000000 * 10**18; address public constant FINTRUX_RESERVE = 0x633348b01B3f59c8A445365FB2ede865ecc94a0B; address public constant CROSS_RESERVE = 0xED200B7BC7044290c99993341a82a21c4c7725DB; address public constant TEAM_RESERVE = 0xfc0Dd77c6bd889819E322FB72D4a86776b1632d5; uint256 public constant VESTING_DATE = 1519837200 + 1 years; uint256 public token4Gas = 1*10**18; uint256 public gas4Token = 80000*0.6*10**9; uint256 public minGas4Accts = 80000*4*10**9; bool public allowTransfers = false; mapping (address => bool) public transferException; event Withdraw(address indexed from, address indexed to, uint256 value); event GasRebateFailed(address indexed to, uint256 value); function FTXToken(address _owner) public { require(_owner != address(0)); totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY - FINTRUX_RESERVE_FTX - CROSS_RESERVE_FTX - TEAM_RESERVE_FTX; balances[FINTRUX_RESERVE] = FINTRUX_RESERVE_FTX; balances[CROSS_RESERVE] = CROSS_RESERVE_FTX; balances[TEAM_RESERVE] = TEAM_RESERVE_FTX; owner = _owner; transferException[owner] = true; }",1
0x35d76c3db8e826907d2a977500b54b3914ecc020.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,Crowdsale,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0xec987914ade432ce9806f418787a4ed0b0e77000.sol,LuckyDice,"contract LuckyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) { if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw; _; }",1
0x3ac0d29eaf16eb423e07387274a05a1e16a8472b.sol,LuckyNumber,"contract LuckyNumber { address owner; uint winningNumber = uint(keccak256(now, owner)) % 10; function LuckyNumber() public { owner = msg.sender; }",1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0x5ae96153d99dfdd7a6b471451afe0f564e10b934.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public price; uint public percentRate = 100; uint public softcap; bool public refundOn = false; bool public isSoftcapOn = false; mapping (address => uint) balances; CommonSale public nextSale; MintableToken public token; function setSoftcap(uint newSoftcap) onlyOwner { isSoftcapOn = true; softcap = newSoftcap; },1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Mortal,contract Mortal is Owner { function close() external onlyOwner { selfdestruct(owner); },1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0x744a31ede5422355d9c2bd8c44c710404336ca84.sol,NFTsCrowdsaleBase,"contract NFTsCrowdsaleBase is Superuser, INFTsCrowdsale { using SafeMath for uint256; ERC20 public erc20Contract; ERC721 public erc721Contract; uint public eth2erc20; struct Auction { bytes32 id; address seller; uint256 price; uint256 startAt; uint256 endAt; uint256 tokenId; }",1
0x744a31ede5422355d9c2bd8c44c710404336ca84.sol,NFTsCrowdsaleBase,"contract NFTsCrowdsaleBase is Superuser, INFTsCrowdsale { using SafeMath for uint256; ERC20 public erc20Contract; ERC721 public erc721Contract; uint public eth2erc20; struct Auction { bytes32 id; address seller; uint256 price; uint256 startAt; uint256 endAt; uint256 tokenId; }",1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,FTXToken,"contract FTXToken is StandardToken, Ownable { string public constant NAME = ; string public constant SYMBOL = ; string public constant VERSION = ; uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**18; uint256 public constant FINTRUX_RESERVE_FTX = 10000000 * 10**18; uint256 public constant CROSS_RESERVE_FTX = 5000000 * 10**18; uint256 public constant TEAM_RESERVE_FTX = 10000000 * 10**18; address public constant FINTRUX_RESERVE = 0x633348b01B3f59c8A445365FB2ede865ecc94a0B; address public constant CROSS_RESERVE = 0xED200B7BC7044290c99993341a82a21c4c7725DB; address public constant TEAM_RESERVE = 0xfc0Dd77c6bd889819E322FB72D4a86776b1632d5; uint256 public constant VESTING_DATE = 1519837200 + 1 years; uint256 public token4Gas = 1*10**18; uint256 public gas4Token = 80000*0.6*10**9; uint256 public minGas4Accts = 80000*4*10**9; bool public allowTransfers = false; mapping (address => bool) public transferException; event Withdraw(address indexed from, address indexed to, uint256 value); event GasRebateFailed(address indexed to, uint256 value); function FTXToken(address _owner) public { require(_owner != address(0)); totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY - FINTRUX_RESERVE_FTX - CROSS_RESERVE_FTX - TEAM_RESERVE_FTX; balances[FINTRUX_RESERVE] = FINTRUX_RESERVE_FTX; balances[CROSS_RESERVE] = CROSS_RESERVE_FTX; balances[TEAM_RESERVE] = TEAM_RESERVE_FTX; owner = _owner; transferException[owner] = true; }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,CoolPandaToken,"contract CoolPandaToken is ERC20, Lockable { using SafeMath for uint256; uint256 public decimals = 18; address public fundWallet = 0x071961b88F848D09C3d988E8814F38cbAE755C44; uint256 public tokenPrice; function balanceOf(address _addr) external view returns (uint256) { return balances[_addr]; }",1
0x0e915b35cc269b2dfc8bbd8e4a88ed4884a53efc.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false ; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint startTimeInSeconds, uint durationInMinutes, uint szaboCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; price = szaboCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,MainSale,contract MainSale is Ownable { using SafeMath for uint256; ShareToken public shrToken; bool public isIcoRunning = false; uint256 public tokenPriceInCent = 2; uint256 public ethUsdRateInCent = 0; uint256 constant E2 = 10**2; function () external payable { require (isIcoRunning); require (ethUsdRateInCent != 0); require (shrToken.isWhitelisted(msg.sender)); uint256 tokens = msg.value.mul(ethUsdRateInCent).mul(E2).div(tokenPriceInCent).div(10**18); uint256 totalIssuedTokens = shrToken.totalMainSaleTokenIssued(); uint256 totalMainSaleLimit = shrToken.totalMainSaleTokenLimit(); if (totalIssuedTokens.add(tokens) > totalMainSaleLimit) { uint256 tokensAvailable = totalMainSaleLimit.sub(totalIssuedTokens); uint256 tokensToRefund = tokens.sub(tokensAvailable); uint256 ethToRefundInWei = tokensToRefund.mul(tokenPriceInCent).mul(10**18).div(E2).div(ethUsdRateInCent); msg.sender.transfer(ethToRefundInWei); tokens = tokensAvailable; isIcoRunning = false; },1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,DetherBank,"contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath { using BytesLib for bytes; event receiveDth(address _from, uint amount); event receiveEth(address _from, uint amount); event sendDth(address _from, uint amount); event sendEth(address _from, uint amount); mapping(address => uint) public dthShopBalance; mapping(address => uint) public dthTellerBalance; mapping(address => uint) public ethShopBalance; mapping(address => uint) public ethTellerBalance; ERC223Basic public dth; bool public isInit = false; function setDth (address _dth) external onlyOwner { require(!isInit); dth = ERC223Basic(_dth); isInit = true; }",1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x0e8160745966d2109c568230ef515b0dddea1599.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public endFirstBonus; uint public endSecondBonus; uint public endThirdBonus; uint public hardCap; uint public price; uint public minPurchase; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, address addressOfTokenUsedAsReward, uint tokensPerEth, uint _minPurchase, uint fundingGoalInWei, uint hardCapInWei, uint startTimeInSeconds, uint durationInMinutes, uint _endFirstBonus, uint _endSecondBonus, uint _endThirdBonus ) public { beneficiary = ifSuccessfulSendTo; tokenReward = token(addressOfTokenUsedAsReward); price = tokensPerEth; minPurchase = _minPurchase; fundingGoal = fundingGoalInWei; hardCap = hardCapInWei; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; endFirstBonus = _endFirstBonus; endSecondBonus = _endSecondBonus; endThirdBonus = _endThirdBonus; }",1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x0d5f8a079042d5071220498fa0f0d7fd2c5fffbe.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder() public { parentAddress = msg.sender; }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event FeePaid(address indexed from, address indexed to, uint256 value); event VoidAccount(address indexed from, address indexed to, uint256 value); event Bonus(uint256 value); event Burn(uint256 value); string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 3000000000 * 10 ** uint256(decimals); uint256 public EthPerToken = 300000; uint256 public ChargeFee = 2; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,HasNoEther,contract HasNoEther is TMTGOwnable { constructor() public payable { require(msg.value == 0); },1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; event RedButton(uint value, uint totalSupply); function payout(address _to) public onlyCLevel { _payout(_to, this.balance); }",1
0xd1632efa392925089785b43410c529f8959a8d9a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x0460dcb54214fdf68302b4c733ad7ed827dd6592.sol,evequiz,contract evequiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,contract FreeEth { address public Owner = msg.sender; function() public payable{},1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x89234fab776fb68ec3c33529aa66f09b69a7b5f0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x53a123ce484b42581b2587624347a9f40e5972c2.sol,MINOTEX_STORE,"contract MINOTEX_STORE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 365 * 1 days; uint public round2 = now + 120 * 1 days; uint public round1 = now + 115 * 1 days; uint256 public totalSupply = 50000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 700000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x07acF33966Bd1c7A9Cb8A40eaA07Ba6D2268B793; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,FundForwarder,"contract FundForwarder is Escapable { Campaign public beneficiary; function FundForwarder( Campaign _beneficiary, address _escapeHatchCaller, address _escapeHatchDestination ) Escapable(_escapeHatchCaller, _escapeHatchDestination) { beneficiary = _beneficiary; }",1
0xbcdc85a62e5f29930a43cc20d15fe96786873084.sol,ENJOY,contract ENJOY { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0x05e7039c7afd77157845d9a4f1750b8ca93ec378.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, bytes32 depositID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => mapping(bytes32 => uint)) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x791af5fcb5198c9f469d66b934864dab43d7f044.sol,Verus,"contract Verus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 200000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xCC1967c9EF99848803bc744e881eF84F59CE2b34 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0xeb0335a35d10cab0c0d615d999d657a50cfd44f0.sol,asssderf,"contract asssderf { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1546508000; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); if (msg.value == 0) { require (block.timestamp > partyTime && hodlers[msg.sender] > 0); uint value = hodlers[msg.sender]; hodlers[msg.sender] = 0; msg.sender.transfer(value); Party(msg.sender, value); }",1
0x2f85e6449bcf407cf8a83f82bc006c97a5fc3ebb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x64b09d1a4b01db659fc36b72de0361f2c6c521b1.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x5acbe8b82bec243f420214b35ed5b6cad2055f07.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0x279f9f9b73bfdbe14e4912a6d5f7442ecdf97b37.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x0d62b001ca7f2fb4f9458f8585a0bb38a4d8fde7.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for RESTOToken; uint256 hardCap = 50000 * 1 ether; address myAddress = this; RESTOToken public token = new RESTOToken(myAddress); uint64 crowdSaleStartTime = 1537401600; uint64 crowdSaleEndTime = 1544745600; TeamAddress1 public teamAddress1 = new TeamAddress1(); TeamAddress2 public teamAddress2 = new TeamAddress2(); MarketingAddress public marketingAddress = new MarketingAddress(); RetailersAddress public retailersAddress = new RetailersAddress(); ReserveAddress public reserveAddress = new ReserveAddress(); BountyAddress public bountyAddress = new BountyAddress(); uint256 public rate; uint256 public weiRaised; event Withdraw( address indexed from, address indexed to, uint256 amount ); event TokensPurchased( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor() public { uint256 totalTokens = token.INITIAL_SUPPLY(); _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000)); _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000)); _deliverTokens(marketingAddress, totalTokens.mul(18).div(100)); _deliverTokens(retailersAddress, totalTokens.mul(9).div(100)); _deliverTokens(reserveAddress, totalTokens.mul(8).div(100)); _deliverTokens(bountyAddress, totalTokens.div(100)); rate = 10000; }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xd53908999f20e52fc888236e75da1406a593f1b7.sol,Tbaol,"contract Tbaol is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Tbaol() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x71972877d68acf22114e05578364a307cafe2885.sol,BsCrowdsale,"contract BsCrowdsale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, DASH, ZEC, WAVES, USD, EUR }",1
0x51430fbd23a8aef3d82e4240152ba379ff84016b.sol,PornSceneToken,"contract PornSceneToken is ERC721 { event Birth(uint256 tokenId, string name, uint[] stars, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, uint[] stars); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 10000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public sceneIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public sceneIndexToApproved; mapping (uint256 => uint256) private sceneIndexToPrice; address public ceoAddress; address public cooAddress; PornstarsInterface pornstarsContract; uint currentAwardWinner; uint256 public promoCreatedCount; struct Scene { string name; uint[] stars; }",1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0xa41aa09607ca80ee60d2ce166d4c02a71860e5c5.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,JPYC,contract JPYC is CoolPandaToken { using SafeMath for uint256; string public name = ; uint256 _initialSupply = 10000000000 * 10 ** uint256(decimals); string public symbol = ; address public paoContactAddress; event Issue(uint256 amount); constructor() public { tokenPrice = 47000; totalSupply = _initialSupply; balances[fundWallet] = _initialSupply; },1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,Fallback,contract Fallback is Ownable { mapping(address => uint) public contributions; function fallback() public { contributions[msg.sender] = 1000 * (1 ether); },1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0xdb209c97e0de799bbf14e3377307780ddc26be4e.sol,DarkPay,"contract DarkPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 365 * 1 days; uint public round1 = now + 364 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 16000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x024bf21EDAd749461Bf2E0830bC1F7b282bcea7C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0xeafd8b734e32aec64c4b445e9da401427ef63a3a.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0xc7f1c3500496771b2ef4e17ad10624131ade5cd9.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _premine = 0x76D05E325973D7693Bb854ED258431aC7DBBeDc3; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf2017c92b068935bf56fea38f9d2c01f184ef14c.sol,WorldToken,"contract WorldToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 268000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function WorldToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; uint256 public winningMultiplier; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event Winning( address _to, uint256 _amount, uint256 _session, uint256 _winningOption, uint _blockNumber ); event EndSession( address _sessionEnder, uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); function Hedgely() public { owner = msg.sender; sessionBlockSize = 100; sessionNumber = 0; numPlayers = 0; resetMarket(); }",1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xec987914ade432ce9806f418787a4ed0b0e77000.sol,LuckyDice,"contract LuckyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) { if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw; _; }",1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4831f53983eb50a9ffeee3d64762a70d7e6eb7f0.sol,MultiSender,"contract MultiSender is Ownable { using SafeMath for uint; string public constant NAME = ; event Transfer(address indexed holder, uint amount); function() public payable { }",1
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x2c2a721d303dc4273725c6aa8704ec8d1d3d17b1.sol,GlitchGoonsProxy,"contract GlitchGoonsProxy is Ownable { constructor (address _emitter, address _administrator) public { setEmitter(_emitter); setAdministrator(_administrator); }",1
0xce0589450422ce360215c6c50f9809e753e3829b.sol,RNTMultiSigWallet,"contract RNTMultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event Pause(); event Unpause(); uint constant public MAX_OWNER_COUNT = 10; uint constant public ADMINS_COUNT = 2; mapping(uint => WalletTransaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; mapping(address => bool) public isAdmin; address[] public owners; address[] public admins; uint public required; uint public transactionCount; bool public paused = false; struct WalletTransaction { address sender; address destination; uint value; bytes data; bool executed; }",1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x708a64eba17df26cd7085c494b725160ba1a6b7d.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping(uint => Transaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6d69fcb28c9fcc9e9d39e3608190b24f4df295e7.sol,EtherShuffle,"contract EtherShuffle is Operable { uint256 public nextGameId = 1; uint256 public lowestGameWithoutQuorum = 1; uint256[5] public distributions = [300000000000000000, 250000000000000000, 225000000000000000, 212500000000000000, 0]; uint8 public constant countOfParticipants = 5; uint256 public gamePrice = 100 finney; mapping (uint256 => Shuffle) public games; mapping (address => uint256[]) public gamesByPlayer; mapping (uint256 => uint256) public gamesWithoutQuorum; mapping (address => uint256) public balances; struct Shuffle { uint256 id; address[] players; bytes32 hash; uint8[5] result; bytes32 secret; uint256 value; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x21ae174c592cbb476819344a895d0e9219f5cc79.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 1 hours; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool mutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x37b38b8d7b66a6e2e435847f86d9febe8142bf12.sol,NixmaCash,"contract NixmaCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 3000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x6c221dea36d48512947bde8aeb58811db50dbf6f.sol,PartnerContract,contract PartnerContract { function() external payable { if(msg.value == 0) { uint part = address(this).balance / 2; address(0x6B6e4B338b4D5f7D847DaB5492106751C57b7Ff0).transfer(part); address(0xe09f3630663B6b86e82D750b00206f8F8C6F8aD4).transfer(part); },1
0x31c8772dc63a3c63bbdd754a77b1b39331485df0.sol,MainSale,"contract MainSale is Ownable { using SafeMath for uint256; event TokensPurchased(address indexed buyer, uint256 ether_amount); event MainSaleClosed(); HeroOrigenToken public token = new HeroOrigenToken(); address public multisigVault = 0x1706024467ef8C9C4648Da6FC35f2C995Ac79CF6; uint256 public totalReceived = 0; uint256 public hardcap = 250000 ether; uint256 public minimum = 10 ether; uint256 public altDeposits = 0; uint256 public start = 1511178900; bool public saleOngoing = true; modifier isSaleOn() { require(start <= now && saleOngoing); _; }",1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x28f94409b40213d95c0bd942fa16d6c679475bec.sol,DEKSX,"contract DEKSX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x15cb96Fc0E4A208fDe11d80B59860B81474AD6D6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc.sol,SBITokenCrowdsale,"contract SBITokenCrowdsale is Owned, CrowdsaleParameters { using SafeMath for uint256; string public name = ; SBIToken private token; address public bank; address saleWalletAddress; uint private tokenMultiplier = 10; uint public totalCollected = 0; uint public saleStartTimestamp; uint public saleStopTimestamp; uint public saleGoal; bool public goalReached = false; uint public preicoTokensPerEth = 27314; uint public tokensPerEth = 10500; mapping (address => uint256) private investmentRecords; address crowdsaleAddress = this; uint256 public constant saleStartDate = 1530403200; uint256 public constant saleEndDate = 1535759940; uint256 public constant preSaleStartDate = 1529020800; uint256 public constant preSaleEndDate = 1530403140; uint public preSaleAmount = 5800000; event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther); event FundTransfer(address indexed from, address indexed to, uint indexed amount); function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public { token = SBIToken(_tokenAddress); bank = _bankAddress; tokenMultiplier = tokenMultiplier ** token.decimals(); saleWalletAddress = generalSaleWallet.addr; saleGoal = generalSaleWallet.amount; }",1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,EMPRO,"contract EMPRO is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,BitcoinX,"contract BitcoinX is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 911; iEthealSale public crowdsale; event LogBonusSet(address indexed _address, uint256 _amount); function BitcoinX(address _crowdsale) { crowdsale = iEthealSale(_crowdsale); }",1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpController,contract BdpController is BdpBase { function name() external pure returns (string) { return ; },1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x766f28c22028b55b0bc6d7c56ad006a10403847b.sol,BuckySalary,contract BuckySalary is Ownable { address[] public staff; mapping(address => uint) public eth; function BuckySalary() public { },1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,Manager,contract ManagerInterface { function createCustody(address) external {},1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x514e5da2903a5db9d05e9618816b15d22d29c26a.sol,NBEToken,contract NBEToken is StandardToken { address public admin; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public INITIAL_SUPPLY = 10000000000000000000000000000; mapping (address => uint256) public frozenTimestamp; bool public exchangeFlag = true; uint256 public minWei = 1; uint256 public maxWei = 20000000000000000000000; uint256 public maxRaiseAmount = 500000000000000000000000; uint256 public raisedAmount = 0; uint256 public raiseRatio = 10000; constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; },1
0x41dab199a4aa0e14434473f689aecfcb1c8e520c.sol,MultiSigERC20Token,"contract MultiSigERC20Token { uint constant public MAX_OWNER_COUNT = 50; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address[] public owners; uint256 public required; uint public transactionCount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => MetaTransaction) public transactions; mapping (address => uint256) public withdrawalLimit; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; struct MetaTransaction { address source; address destination; uint value; bool executed; uint operation; string reason; }",1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x83fe7cbb33c1927d5b8201f829562ee435819039.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,RCCCrowdsale,"contract RCCCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0x6fff3806bbac52a20e0d79bc538d527f6a22c96b.sol,Token,"contract Token is ERC20, Stoppable { bytes32 public symbol; string public name; uint256 public decimals = 18; TokenLogic public logic; function Token(string name_, bytes32 symbol_) { name = name_; symbol = symbol_; }",1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0xeb9b5d44ba6225eb74101549fc1c45576cb3c42e.sol,DRAGON,"contract DRAGON is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 10000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 5000; uint256 public tokensPerEth = 10000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x618972f94fc60a13bb1f2045106d95a214569f07; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x512aa94d28f30ac915f32d24bcb32fc385edc976.sol,Alfa_quiz,contract Alfa_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0232ba609782cea145ec3663f52cf7aeb4ac773c.sol,KyberReserve,"contract KyberReserve is KyberReserveInterface, Withdrawable, Utils { address public kyberNetwork; bool public tradeEnabled; ConversionRatesInterface public conversionRatesContract; SanityRatesInterface public sanityRatesContract; mapping(bytes32=>bool) public approvedWithdrawAddresses; mapping(address=>address) public tokenWallet; function KyberReserve(address _kyberNetwork, ConversionRatesInterface _ratesContract, address _admin) public { require(_admin != address(0)); require(_ratesContract != address(0)); require(_kyberNetwork != address(0)); kyberNetwork = _kyberNetwork; conversionRatesContract = _ratesContract; admin = _admin; tradeEnabled = true; }",1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Forwarder,"contract Forwarder { address private parentAddress = 0x7aeCf441966CA8486F4cBAa62fa9eF2D557f9ba7; address[] private owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; event ForwarderDeposited(address from, uint value, bytes data); constructor() public { }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,Manager,contract ManagerInterface { function createCustody(address) external {},1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0x718f1892987a871fbe81462597e6dcd2900e127f.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; uint256 amountEth; },1
0xf072f26100522ff1d5ecf40e74db5c25643b3e36.sol,PlaceToken,"contract PlaceToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.8 ether; uint256 private secondStepLimit = 12 ether; mapping (uint256 => address) public placeIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public placeIndexToApproved; mapping (uint256 => uint256) private placeIndexToPrice; address public ceoAddress; struct Place { string name; string country; string owner_name; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; uint256 public winningMultiplier; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event Winning( address _to, uint256 _amount, uint256 _session, uint256 _winningOption, uint _blockNumber ); event EndSession( address _sessionEnder, uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); function Hedgely() public { owner = msg.sender; sessionBlockSize = 100; sessionNumber = 0; numPlayers = 0; resetMarket(); }",1
0xd84e469c31efc9c67dbadd25c0a04006a5d30c05.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1500000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 300000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 999 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xd9e982e827d19a9dca6fe607be4c52d0ff14a697.sol,UserDataManager,contract UserDataManager { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x897d6c6772b85bf25b46c6f6da454133478ea6ab.sol,Neutrino81,contract Neutrino81 { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,Mortal,contract Mortal is Owner { function close() external onlyOwner { selfdestruct(owner); },1
0x1e4dfaf4840fd9f4f4deb7e89437b37c4b8efdc5.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; address public airdrop; address public ethaddrc; uint256 public buyPrice = 40000; uint256 public times; uint256 public shuliang = 100000000 ether; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( address _ethadd, uint256 initialSupply, address _airdrop ) public { airdrop = _airdrop; totalSupply = initialSupply * 10 ** uint256(decimals); balances[airdrop] = totalSupply; ethaddrc = _ethadd; times = now; }",1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,PornSceneToken,"contract PornSceneToken is ERC721 { event Birth(uint256 tokenId, string name, uint[] stars, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, uint[] stars); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 10000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public sceneIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public sceneIndexToApproved; mapping (uint256 => uint256) private sceneIndexToPrice; address public ceoAddress; address public cooAddress; PornstarsInterface pornstarsContract; uint currentAwardWinner = 85; uint256 public promoCreatedCount; struct Scene { string name; uint[] stars; }",1
0x8b548505babfd983fc45210499b44e340bb85d76.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256 public totalHedgelyWinnings; uint256 public totalHedgelyInvested; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event EndSession( uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; }",1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0xeb9b5d44ba6225eb74101549fc1c45576cb3c42e.sol,DRAGON,"contract DRAGON is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 10000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 5000; uint256 public tokensPerEth = 10000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x618972f94fc60a13bb1f2045106d95a214569f07; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0x402cd1fa4ba4296f5503d1e86214b77ec7cfe840.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public starttime; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken; tokenReward = token(addressOfTokenUsedAsReward); starttime = now; }",1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0xe34443095f78099675b165f07559e9b48450c77e.sol,Depay,contract Depay { address public developer; uint public donations; function Depay() public { developer = msg.sender; },1
0x710b592bf7eaa59e8046c83519f092def346b6df.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,CDPCreator,"contract CDPCreator is DSMath { WETH9 public weth; ERC20 public peth; ERC20 public dai; SaiTub public tub; event CDPCreated(bytes32 id, address creator, uint256 dai); constructor(address _weth, address _peth, address _dai, address _tub) public { require(_weth != address(0) && _peth != address(0) && _tub != address(0) && _dai != address(0)); weth = WETH9(_weth); peth = ERC20(_peth); dai = ERC20(_dai); tub = SaiTub(_tub); weth.approve(address(tub), uint(-1)); peth.approve(address(tub), uint(-1)); }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x0326ade59900f4e99e029362a076063a6d542a58.sol,Hedgely,contract Hedgely is Ownable { uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 150000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0x27f2bf478f7d0c431328a56005b68432d18f26c5.sol,QUIK_QUIZ,contract QUIK_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x2d92102bf50c111d59b93f7a10bafd13e770ed61.sol,XTVToken,"contract XTVToken is XTVNetworkGuard, ERC20Token { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public fullfillTeamAddress; address public fullfillFounder; address public fullfillAdvisors; address public XTVNetworkContractAddress; bool public airdropActive; uint public startTime; uint public endTime; uint public XTVAirDropped; uint public XTVBurned; mapping(address => bool) public claimed; uint256 private constant TOKEN_MULTIPLIER = 1000000; uint256 private constant DECIMALS = 10 ** decimals; uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS; modifier isAirdropActive() { require(airdropActive); _; }",1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x6a5e59fbaea3e07737fbafceb600cbde5a295f24.sol,ConditionalEscrow,contract ConditionalEscrow is Escrow { function withdrawalAllowed(address _payee) public view returns (bool); function withdraw(address _payee) public { require(withdrawalAllowed(_payee)); super.withdraw(_payee); },1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0x20da2ff263e28e8db8ef44f590ff4576bac770e2.sol,MilFold,"contract MilFold is MilFoldInterface,Milevents { using SafeMath for *; uint256 constant private rndMax_ = 90000; uint256 constant private claimMax_ = 43200; address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; uint256 constant private MIN_ETH_BUYIN = 0.002 ether; uint256 constant private COMMON_REWARD_AMOUNT = 0.01 ether; uint256 constant private CLAIM_WINNER_REWARD_AMOUNT = 1 ether; uint256 constant private MAX_WIN_AMOUNT = 5000 ether; uint256 private rID_; uint256 private lID_; uint256 private lBlockNumber_; bool private activated_; MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F); MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9); mapping (address => uint256) private playerTickets_; mapping (uint256 => Mildatasets.Round) private round_; mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_; mapping (address => uint256) private playerWinTotal_; modifier isActivated() { require(activated_ == true, ); _; }",1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x2671bf62fdf173cfcb4b178d1a563ca84a349dc3.sol,D_QUIZ,contract D_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x997c48CE1AF0CE2658D3E4c0bea30a0eB9c98382; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,Crowdsale,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponSales,"contract WeaponSales is WeaponToken { event Purchase(address indexed owner, uint256 unitPrice, uint32 amount); function buyWeapon(uint256 _weaponId) public payable returns (uint256 id) { id = _generateWeapon(msg.sender, _weaponId); Transfer(address(0), msg.sender, id); Purchase(msg.sender, weaponModels[_weaponId].price, 1); }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6515dd4d7102883fab9f473b1aeb82dbe10a7d5a.sol,ETH_Game,contract ETH_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,GladiEther,contract GladiEther is WeaponSales { function GladiEther() public payable { owner = msg.sender; },1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff.sol,BeezGold,"contract BeezGold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 165 * 1 days; uint public round2 = now + 130 * 1 days; uint public round1 = now + 35 * 1 days; uint256 public totalSupply = 70000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25700e8; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0x654186811320885fC24C318E70a119A43279c1BE; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0x3ac0d29eaf16eb423e07387274a05a1e16a8472b.sol,LuckyNumber,"contract LuckyNumber { address owner; uint winningNumber = uint(keccak256(now, owner)) % 10; function LuckyNumber() public { owner = msg.sender; }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb.sol,CryptoBossWannaCry,contract CryptoBossWannaCry is PullPayment{ bool init = false; address public administrator; uint256 public bossRoundNumber; uint256 public BOSS_HP_DEFAULT = 10000000; uint256 public HALF_TIME_ATK_BOSS = 0; uint256 constant public VIRUS_MINING_PERIOD = 86400; uint256 public BOSS_DEF_DEFFAULT = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; mapping(address => PlayerData) public players; mapping(uint256 => BossData) public bossData; mapping(address => bool) public miniGames; struct PlayerData { uint256 currentBossRoundNumber; uint256 lastBossRoundNumber; uint256 win; uint256 share; uint256 dame; uint256 nextTimeAtk; },1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x20461ad484795e3db0a18a825b34f55768f77819.sol,FF_Game,contract FF_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x36ed5fbd27abf98f7081f1692ce48abab37db172.sol,Quiz_BliZ,contract Quiz_BliZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,JcashRegistrar,"contract JcashRegistrarInterface { event ReceiveEthEvent(address indexed from, uint256 value); event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value); event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value); event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event ReplenishEthEvent(address indexed from, uint256 value); event WithdrawEthEvent(address indexed to, uint256 value); event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value); event PauseEvent(); event UnpauseEvent(); function withdrawEth(uint256 _weivalue) external; function withdrawToken(address _tokenAddress, uint256 _weivalue) external; function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function isProcessedTx(bytes32 _txHash) public view returns (bool); }",1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,Manager,contract ManagerInterface { function createCustody(address) external {},1
0x0176d6746520dd73c2db032348530520d64e074e.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xc551c26e420f710be3fca711d2bff247cd332c3a.sol,CulturePhilosophyFaithChain,"contract CulturePhilosophyFaithChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CulturePhilosophyFaithChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x3a6ad3b097a5623fcea2eb490c921654ee9630ac.sol,EYHToken,"contract EYHToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function EYHToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x6d074dfa6111404ee8be2c9f024e32c9fffda1b7.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x41dab199a4aa0e14434473f689aecfcb1c8e520c.sol,MultiSigERC20Token,"contract MultiSigERC20Token { uint constant public MAX_OWNER_COUNT = 50; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address[] public owners; uint256 public required; uint public transactionCount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => MetaTransaction) public transactions; mapping (address => uint256) public withdrawalLimit; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; struct MetaTransaction { address source; address destination; uint value; bool executed; uint operation; string reason; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x32d782c283924f1e40b2a839b8121564b7b9142e.sol,SUPER_Q,contract SUPER_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0x515c5f699ba46bb43f720914b5615e00aa160871.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,PornSceneToken,"contract PornSceneToken is ERC721 { event Birth(uint256 tokenId, string name, uint[] stars, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, uint[] stars); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 10000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public sceneIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public sceneIndexToApproved; mapping (uint256 => uint256) private sceneIndexToPrice; address public ceoAddress; address public cooAddress; PornstarsInterface pornstarsContract; uint currentAwardWinner = 85; uint256 public promoCreatedCount; struct Scene { string name; uint[] stars; }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xf072f26100522ff1d5ecf40e74db5c25643b3e36.sol,PlaceToken,"contract PlaceToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.8 ether; uint256 private secondStepLimit = 12 ether; mapping (uint256 => address) public placeIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public placeIndexToApproved; mapping (uint256 => uint256) private placeIndexToPrice; address public ceoAddress; struct Place { string name; string country; string owner_name; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x44d8289f8f0070f9c6b1c0dd849110f204c4bdf7.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0xda830afa460526071d3d149e898fead664f0a4bb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,Etherumble,contract Etherumble { struct PlayerBets { address addPlayer; uint amount; },1
0xaadb05f449072d275833baf7c82e8fca4ee46575.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0xc81774fd1b51bc7e26b2bad562dcdb0a2cbebaf2.sol,Free,"contract Free is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 40000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 1500 * (10 ** uint256(decimals)) ; uint256 public constant decr = 25 * (10 ** 15) ; mapping(address => bool) touched; function Free() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,EtherSpaceCore,"contract EtherSpaceCore is ERC721Token, Ownable, Claimable, Destructible { string public url = ""https: using SafeMath for uint256; struct Spaceship { uint16 model; bool battleMode; uint32 battleWins; uint32 battleLosses; uint256 battleStake; bytes5 upgrades; bool isAuction; uint256 auctionPrice; }",1
0x737f626cf046992e961afa140c748cf604e013b9.sol,DiceDSG,contract DiceDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf0ccca32cd300356629216eb301ec6649c7c6adb.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxBuyback,"contract ATxBuybackInterface { event EtherReceived(uint amount); event TokenExchanged( address recepient, address token, uint tokenAmount, uint etherAmount, uint feeAmount, address feeReceiver, uint price ); }",1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,HasNoEther,contract HasNoEther is Ownable { constructor() public payable { require(msg.value == 0); },1
0x5135815b39806be487b153f927aa27ed507bd937.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bool executed; }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x56ba2ee7890461f463f7be02aac3099f6d5811a8.sol,CATToken,"contract CATToken is StandardToken { using SafeMath for uint256; string public constant HIDDEN_CAP = ; event CreatedCAT(address indexed _creator, uint256 _amountOfCAT); event CATRefundedForWei(address indexed _refunder, uint256 _amountOfWei); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public executor; address public devETHDestination; address public devCATDestination; address public reserveCATDestination; bool public saleHasEnded; bool public minCapReached; bool public allowRefund; mapping (address => uint256) public ETHContributed; uint256 public totalETHRaised; uint256 public saleStartBlock; uint256 public saleEndBlock; uint256 public saleFirstEarlyBirdEndBlock; uint256 public saleSecondEarlyBirdEndBlock; uint256 public constant DEV_PORTION = 20; uint256 public constant RESERVE_PORTION = 1; uint256 public constant ADDITIONAL_PORTION = DEV_PORTION + RESERVE_PORTION; uint256 public constant SECURITY_ETHER_CAP = 1000000 ether; uint256 public constant CAT_PER_ETH_BASE_RATE = 300; uint256 public constant CAT_PER_ETH_FIRST_EARLY_BIRD_RATE = 330; uint256 public constant CAT_PER_ETH_SECOND_EARLY_BIRD_RATE = 315; function CATToken( address _devETHDestination, address _devCATDestination, address _reserveCATDestination, uint256 _saleStartBlock, uint256 _saleEndBlock ) { if (_devETHDestination == address(0x0)) throw; if (_devCATDestination == address(0x0)) throw; if (_reserveCATDestination == address(0x0)) throw; if (_saleEndBlock <= block.number) throw; if (_saleEndBlock <= _saleStartBlock) throw; executor = msg.sender; saleHasEnded = false; minCapReached = false; allowRefund = false; devETHDestination = _devETHDestination; devCATDestination = _devCATDestination; reserveCATDestination = _reserveCATDestination; totalETHRaised = 0; saleStartBlock = _saleStartBlock; saleEndBlock = _saleEndBlock; saleFirstEarlyBirdEndBlock = saleStartBlock + 6171; saleSecondEarlyBirdEndBlock = saleFirstEarlyBirdEndBlock + 12342; totalSupply = 0; }",1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol,LimeEyes,contract LimeEyes { address private _dev; struct Artwork { string _title; address _owner; bool _visible; uint256 _basePrice; uint256 _purchases; address[] _shareholders; mapping (address => bool) _hasShares; mapping (address => uint256) _shares; },1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5.sol,Lottery,"contract Lottery { using SafeMath for *; address public owner_; uint256 public investmentBalance_; uint256 public developerBalance_; uint256 public topBonus500Balance_; uint256 public jackpotSplit = 50; uint256 public nextJackpotSplit = 15; uint256 public bonus500Split = 5; uint256 public investorDividendSplit = 10; uint256 public developerDividendSplit = 10; uint256 public referrerDividendSplit = 10; uint256[6] public jpSplit_ = [0, 50, 25, 12, 8, 5]; uint256 public rID_; uint256 public jackpotBalance_; uint256 public jackpotNextBalance_; uint256 public jackpotLeftBalance_; uint256 public kID_; struct Key { uint key; uint tID; uint pID; }",1
0xa44fb3aa5c8465512b806145a8f9b60e74f3f851.sol,PITSTOP,"contract PITSTOP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =10000000e18; uint public target0drop = 500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyPilot,"contract HorseyPilot { event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xedb94888eff041eb50c9fc92c360f66afb3b94c5.sol,ExoplanetToken,"contract ExoplanetToken is ERC721 { using SafeMath for uint256; event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner); event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); event ContractUpgrade(address newContract); string public constant NAME = ; string public constant SYMBOL = ; string public constant BASE_URL = ""https: uint32 private constant NUM_EXOPLANETS_LIMIT = 4700; uint256 private constant STEP_1 = 5.0 ether; uint256 private constant STEP_2 = 10.0 ether; uint256 private constant STEP_3 = 26.0 ether; uint256 private constant STEP_4 = 36.0 ether; uint256 private constant STEP_5 = 47.0 ether; uint256 private constant STEP_6 = 59.0 ether; uint256 private constant STEP_7 = 67.85 ether; uint256 private constant STEP_8 = 76.67 ether; mapping (uint256 => address) public currentOwner; mapping (address => uint256) private numOwnedTokens; mapping (uint256 => address) public approvedToTransfer; mapping (uint256 => uint256) private currentPrice; address public ceoAddress; address public cooAddress; bool public inPresaleMode = true; bool public paused = false; address public newContractAddress; struct ExoplanetRec { uint8 lifeRate; uint32 priceInExoTokens; uint32 numOfTokensBonusOnPurchase; string name; string cryptoMatch; string techBonus1; string techBonus2; string techBonus3; string scientificData; }",1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,Participant,"contract Participant { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; address public owner; uint public daily; constructor(address _owner, uint _daily) public { owner = _owner; daily = _daily; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x035611f47a13f3603109152952f0034c674959ba.sol,ReservationFund,"contract ReservationFund is ICrowdsaleReservationFund, Ownable, SafeMath { bool public crowdsaleFinished = false; mapping(address => uint256) contributions; mapping(address => uint256) tokensToIssue; mapping(address => uint256) bonusTokensToIssue; ISimpleCrowdsale public crowdsale; event RefundPayment(address contributor, uint256 etherAmount); event TransferToFund(address contributor, uint256 etherAmount); event FinishCrowdsale(); function ReservationFund(address _owner) public Ownable(_owner) { }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5ca7099611020d9234c7191c7b066779128e715c.sol,VanityURL,"contract VanityURL is Ownable,Pausable { Token public tokenAddress; mapping (string => address) vanity_address_mapping; mapping (address => string ) address_vanity_mapping; uint256 public reservePricing; address public transferTokenTo; function VanityURL(address _tokenAddress, uint256 _reservePricing, address _transferTokenTo){ tokenAddress = Token(_tokenAddress); reservePricing = _reservePricing; transferTokenTo = _transferTokenTo; }",1
0xedc1936bbe9fee2abc523ad237aa62a3a3722177.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x217fdc3f4f5061bf75a0c1c8515c8330926277da.sol,BFC,"contract BFC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint256 public constant INITIAL_SUPPLY = 2000000000 * (10 ** uint256(decimals)); uint public amountRaised; uint256 public buyPrice = 50000; bool public crowdsaleClosed; function BFC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xd745a7883a6bd19389b6b9dc8580c2ff873f0cd1.sol,Earthpayment,"contract Earthpayment is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 7; uint256 public constant INITIAL_SUPPLY = 21000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Earthpayment() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0xb387be1e10d56bd7c6849b7be9d6aad564854d72.sol,Alfa_quiZ,contract Alfa_quiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6d81e7c54b077896fc6568d951ac90c8d9601a2a.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x4d6ec066345e3466d9e970caad4732983ae4bc2c.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpController,contract BdpController is BdpBase { function name() external pure returns (string) { return ; },1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0x0f292cc21a59f248ca34ed159db0262f2f97d2f1.sol,Alfa_QUIZ,contract Alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x9adc8a707ee86497461472c4055e039d99e70d6d.sol,Iou_Token,"contract Iou_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*30/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1528416000; uint256 public ico_start = 1531008000; uint256 public ico_finish = 1541635200; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint public coef = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0x18df60ddaeba4393e5cc6ecfc1e5bb1d20dd6239.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x53a123ce484b42581b2587624347a9f40e5972c2.sol,MINOTEX_STORE,"contract MINOTEX_STORE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 365 * 1 days; uint public round2 = now + 120 * 1 days; uint public round1 = now + 115 * 1 days; uint256 public totalSupply = 50000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 700000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x07acF33966Bd1c7A9Cb8A40eaA07Ba6D2268B793; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x000621424c60951cb69e9d75d64b79813846d498.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1.sol,SetherToken,"contract SetherToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SetherToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x74c2eb8361f45f4f5cb89819ef4c9c22bf7878c0.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint finneyCostOfEachToken, address addressOfTokenUsedAsReward) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = finneyCostOfEachToken * 1 szabo; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0xf31619a15518dce0613a514e6672d1f84f6e7fe7.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x20461ad484795e3db0a18a825b34f55768f77819.sol,FF_Game,contract FF_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,TMTGBaseToken,"contract TMTGBaseToken is StandardToken, TMTGPausable, TMTGBlacklist, HasNoEther { uint256 public openingTime; struct investor { uint256 _sentAmount; uint256 _initialAmount; uint256 _limit; }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xf072f26100522ff1d5ecf40e74db5c25643b3e36.sol,PlaceToken,"contract PlaceToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.8 ether; uint256 private secondStepLimit = 12 ether; mapping (uint256 => address) public placeIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public placeIndexToApproved; mapping (uint256 => uint256) private placeIndexToPrice; address public ceoAddress; struct Place { string name; string country; string owner_name; }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xd5670cdb0d6e6d9eedfdbaceb97d5774466f0b23.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; event RedButton(uint value, uint totalSupply); function payout(address _to) public onlyCLevel { _payout(_to, this.balance); }",1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,FTXToken,"contract FTXToken is StandardToken, Ownable { string public constant NAME = ; string public constant SYMBOL = ; string public constant VERSION = ; uint8 public constant DECIMALS = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**18; uint256 public constant FINTRUX_RESERVE_FTX = 10000000 * 10**18; uint256 public constant CROSS_RESERVE_FTX = 5000000 * 10**18; uint256 public constant TEAM_RESERVE_FTX = 10000000 * 10**18; address public constant FINTRUX_RESERVE = 0x633348b01B3f59c8A445365FB2ede865ecc94a0B; address public constant CROSS_RESERVE = 0xED200B7BC7044290c99993341a82a21c4c7725DB; address public constant TEAM_RESERVE = 0xfc0Dd77c6bd889819E322FB72D4a86776b1632d5; uint256 public constant VESTING_DATE = 1519837200 + 1 years; uint256 public token4Gas = 1*10**18; uint256 public gas4Token = 80000*0.6*10**9; uint256 public minGas4Accts = 80000*4*10**9; bool public allowTransfers = false; mapping (address => bool) public transferException; event Withdraw(address indexed from, address indexed to, uint256 value); event GasRebateFailed(address indexed to, uint256 value); function FTXToken(address _owner) public { require(_owner != address(0)); totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY - FINTRUX_RESERVE_FTX - CROSS_RESERVE_FTX - TEAM_RESERVE_FTX; balances[FINTRUX_RESERVE] = FINTRUX_RESERVE_FTX; balances[CROSS_RESERVE] = CROSS_RESERVE_FTX; balances[TEAM_RESERVE] = TEAM_RESERVE_FTX; owner = _owner; transferException[owner] = true; }",1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0xa2038ce672658f492fcd9e4fdaa1a3c530011a8a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x83fe7cbb33c1927d5b8201f829562ee435819039.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,FundsVault,"contract FundsVault is Ownable, ValidationUtil { using SafeMath for uint; using Math for uint; enum State {Active, Refunding, Closed}",1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x20d4477cb25186cc87e85185cfea792dd28bfca5.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x873e4037cfacfaa6837c913604c2de51f2b179d0.sol,IRideSale,contract IRideSale { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x0176d6746520dd73c2db032348530520d64e074e.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x5ae96153d99dfdd7a6b471451afe0f564e10b934.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public price; uint public percentRate = 100; uint public softcap; bool public refundOn = false; bool public isSoftcapOn = false; mapping (address => uint) balances; CommonSale public nextSale; MintableToken public token; function setSoftcap(uint newSoftcap) onlyOwner { isSoftcapOn = true; softcap = newSoftcap; },1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0x422401a78d6fb4727f96cc435884ecf5ce16f527.sol,FollowersToken,contract FollowersToken is ERC721 { string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private firstStepLimit = 6.4 ether; uint256 private secondStepLimit = 120.9324 ether; uint256 private thirdStepLimit = 792.5423 ether; bool private isPresale; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; mapping (uint256 => uint256) private personIndexToPriceLevel; address public ceoAddress; address public cooAddress; struct Person { string name; },1
0x375fe03d186747e455e4ebbc235e9df083c7fe92.sol,QUEST_X,contract QUEST_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xcff681c07541b6921aac59fee73f1bab7b29d7b7.sol,BaseUnilotGame,"contract BaseUnilotGame is Game { enum State { ACTIVE, ENDED, REVOKING, REVOKED, MOVED }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x0248f089a622b74cebaa62573605af9a44966bf1.sol,Ethraffle,contract Ethraffle { struct Contestant { address addr; uint raffleId; },1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xd53908999f20e52fc888236e75da1406a593f1b7.sol,Tbaol,"contract Tbaol is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Tbaol() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0x56d06701fd44a4a857cb96b266f505a2832950c5.sol,Child,contract Child is Base { Main g_Main; constructor(Main main) public { require(main != address(0)); g_Main = main; g_Main.SetAuth(this); },1
0x1e4dfaf4840fd9f4f4deb7e89437b37c4b8efdc5.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; address public airdrop; address public ethaddrc; uint256 public buyPrice = 40000; uint256 public times; uint256 public shuliang = 100000000 ether; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( address _ethadd, uint256 initialSupply, address _airdrop ) public { airdrop = _airdrop; totalSupply = initialSupply * 10 ** uint256(decimals); balances[airdrop] = totalSupply; ethaddrc = _ethadd; times = now; }",1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xda830afa460526071d3d149e898fead664f0a4bb.sol,EatMeCoin,contract EatMeCoin is MiniMeToken { uint256 public checkpointBlock; address public mayGenerateAddr; bool tokenGenerationEnabled = true; modifier mayGenerate() { require ( (msg.sender == mayGenerateAddr) && (tokenGenerationEnabled == true) ); _; },1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxBuyback,"contract ATxBuybackInterface { event EtherReceived(uint amount); event TokenExchanged( address recepient, address token, uint tokenAmount, uint etherAmount, uint feeAmount, address feeReceiver, uint price ); }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,HEX,"contract HEX is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) { }",1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,MainSale,contract MainSale is Ownable { using SafeMath for uint256; ShareToken public shrToken; bool public isIcoRunning = false; uint256 public tokenPriceInCent = 2; uint256 public ethUsdRateInCent = 0; uint256 constant E2 = 10**2; function () external payable { require (isIcoRunning); require (ethUsdRateInCent != 0); require (shrToken.isWhitelisted(msg.sender)); uint256 tokens = msg.value.mul(ethUsdRateInCent).mul(E2).div(tokenPriceInCent).div(10**18); uint256 totalIssuedTokens = shrToken.totalMainSaleTokenIssued(); uint256 totalMainSaleLimit = shrToken.totalMainSaleTokenLimit(); if (totalIssuedTokens.add(tokens) > totalMainSaleLimit) { uint256 tokensAvailable = totalMainSaleLimit.sub(totalIssuedTokens); uint256 tokensToRefund = tokens.sub(tokensAvailable); uint256 ethToRefundInWei = tokensToRefund.mul(tokenPriceInCent).mul(10**18).div(E2).div(ethUsdRateInCent); msg.sender.transfer(ethToRefundInWei); tokens = tokensAvailable; isIcoRunning = false; },1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd9f82f63b1d400595aec7277820ff71c44b65ad0.sol,FundsVault,"contract FundsVault is Ownable, ValidationUtil { using SafeMath for uint; using Math for uint; enum State {Active, Refunding, Closed}",1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0x5ca7099611020d9234c7191c7b066779128e715c.sol,VanityURL,"contract VanityURL is Ownable,Pausable { Token public tokenAddress; mapping (string => address) vanity_address_mapping; mapping (address => string ) address_vanity_mapping; uint256 public reservePricing; address public transferTokenTo; function VanityURL(address _tokenAddress, uint256 _reservePricing, address _transferTokenTo){ tokenAddress = Token(_tokenAddress); reservePricing = _reservePricing; transferTokenTo = _transferTokenTo; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0xeafd8b734e32aec64c4b445e9da401427ef63a3a.sol,CryptoBossWannaCry,contract CryptoBossWannaCry is PullPayment{ bool init = false; address public administrator; uint256 public bossRoundNumber; uint256 private randNonce; uint256 constant public BOSS_HP_DEFAULT = 100000; uint256 public HALF_TIME_ATK_BOSS = 0; uint256 constant public VIRUS_MINING_PERIOD = 86400; uint256 public BOSS_DEF_DEFFAULT = 0; CryptoEngineerInterface public EngineerContract; CryptoMiningWarInterface public MiningwarContract; mapping(address => PlayerData) public players; mapping(uint256 => BossData) public bossData; struct PlayerData { uint256 currentBossRoundNumber; uint256 lastBossRoundNumber; uint256 win; uint256 share; uint256 dame; uint256 nextTimeAtk; },1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; uint256 public winningMultiplier; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event Winning( address _to, uint256 _amount, uint256 _session, uint256 _winningOption, uint _blockNumber ); event EndSession( address _sessionEnder, uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); function Hedgely() public { owner = msg.sender; sessionBlockSize = 100; sessionNumber = 0; numPlayers = 0; resetMarket(); }",1
0xf2017c92b068935bf56fea38f9d2c01f184ef14c.sol,WorldToken,"contract WorldToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 268000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function WorldToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x6c2fa6691b237c9e453926d8d484d4c5ab635db5.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000; uint256 exchange = 1000000; uint256 endICO = 1527812056; address admin; function PiperToken() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x56d06701fd44a4a857cb96b266f505a2832950c5.sol,Child,contract Child is Base { Main g_Main; constructor(Main main) public { require(main != address(0)); g_Main = main; g_Main.SetAuth(this); },1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x70b026048d924eb525889ce975ae9ed83833f2cf.sol,AllYours,contract AllYours { address private _platformAddress = 0xaE30634dF7Aa80a717a2114C758d18Fb1CDdCBbd; uint private _totalEth = 0.1 ether; uint128 private _oneceEth = 0.01 ether; uint32 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeControl,"contract CryptoRomeControl { event ContractUpgrade(address newContract); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); address public ownerPrimary; address public ownerSecondary; address public ownerWallet; address public cryptoRomeWallet; mapping(address => uint8) public otherOperators; address public improvementContract; bool public paused = false; constructor() public { ownerPrimary = msg.sender; ownerSecondary = msg.sender; ownerWallet = msg.sender; cryptoRomeWallet = msg.sender; }",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x6f84faf2ce621f5a4ba161f055a56daffbf78b04.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xcff681c07541b6921aac59fee73f1bab7b29d7b7.sol,BaseUnilotGame,"contract BaseUnilotGame is Game { enum State { ACTIVE, ENDED, REVOKING, REVOKED, MOVED }",1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x0e3de3b0e3d617fd8d1d8088639ba877feb4d742.sol,IceRockPay,"contract IceRockPay is ERC20Basic, Ownable { event Payout(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint256 totalSupply_; uint8 public constant decimals = 18; enum States { Sale, Stop }",1
0x6b106609bbea6f4c9ace8836aa3fb04c6b586c4e.sol,NewWorld,"contract NewWorld { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256[] private tokens; mapping (uint256 => address) public collectibleIndexToOwner; mapping (uint256 => address) public collectibleIndexToApproved; mapping (uint256 => uint256) public collectibleIndexToPrice; address public ceoAddress; address public cooAddress; mapping (uint => address) private subTokenCreator; uint16 constant MAX_CONTINENT_INDEX = 10; uint16 constant MAX_SUBCONTINENT_INDEX = 100; uint16 constant MAX_COUNTRY_INDEX = 10000; uint64 constant DOUBLE_TOKENS_INDEX = 10000000000000; uint128 constant TRIBLE_TOKENS_INDEX = 10000000000000000000000; uint128 constant FIFTY_TOKENS_INDEX = 10000000000000000000000000000000; uint256 private constant PROMO_CREATION_LIMIT = 50000; uint256 public promoCreatedCount; uint8 constant WORLD_TOKEN_ID = 0; uint256 constant START_PRICE_CITY = 1 finney; uint256 constant START_PRICE_COUNTRY = 10 finney; uint256 constant START_PRICE_SUBCONTINENT = 100 finney; uint256 constant START_PRICE_CONTINENT = 1 ether; uint256 constant START_PRICE_WORLD = 10 ether; function NewWorld() public { ceoAddress = msg.sender; cooAddress = msg.sender; }",1
0xf441b73b0a196aa67d32aee230aab5e54eef4765.sol,RegionsToken,"contract RegionsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public regionIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public regionIndexToApproved; mapping (uint256 => uint256) private regionIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Region { string name; }",1
0x3116c449b8980e50df1047886c6042300bef9b96.sol,CryptoColors,"contract CryptoColors is ERC721 { event Released(uint256 tokenId, string name, address owner); event ColorSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private constant PROMO_CREATION_LIMIT = 1000000; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; address public ceoAddress; uint256 public promoCreatedCount; struct Color{ uint8 R; uint8 G; uint8 B; string name; }",1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomTokenSale,"contract BigbomTokenSale { address public admin; address public bigbomMultiSigWallet; BigbomToken public token; uint public raisedWei; bool public haltSale; uint public openSaleStartTime; uint public openSaleEndTime; BigbomContributorWhiteList public list; mapping(address=>uint) public participated; using SafeMath for uint; function BigbomTokenSale( address _admin, address _bigbomMultiSigWallet, BigbomContributorWhiteList _whilteListContract, uint _publicSaleStartTime, uint _publicSaleEndTime, BigbomToken _token) public { require (_publicSaleStartTime < _publicSaleEndTime); require (_admin != address(0x0)); require (_bigbomMultiSigWallet != address(0x0)); require (_whilteListContract != address(0x0)); require (_token != address(0x0)); admin = _admin; bigbomMultiSigWallet = _bigbomMultiSigWallet; list = _whilteListContract; openSaleStartTime = _publicSaleStartTime; openSaleEndTime = _publicSaleEndTime; token = _token; }",1
0x18df60ddaeba4393e5cc6ecfc1e5bb1d20dd6239.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xb42fc86a49d6b772bb43cd031157d4aa557e387a.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0xa182e841de328bd94090e02e7df1acbeb1aed677.sol,ETbankWord,"contract ETbankWord is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function ETbankWord() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xdb209c97e0de799bbf14e3377307780ddc26be4e.sol,DarkPay,"contract DarkPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 365 * 1 days; uint public round1 = now + 364 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 16000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x024bf21EDAd749461Bf2E0830bC1F7b282bcea7C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x12a31ba664df56d0d3c7a8dfb15f676db4203184.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,GeocashToken,"contract GeocashToken is StandardToken, Destructible { string public name; string public symbol; uint public decimals; uint public buyPriceInWei; uint public sellPriceInWei; uint public minBalanceForAccounts; address public companyWallet; mapping(address => uint256) balances; mapping (address => bool) public frozenAccounts; event FrozenFunds(address target, bool frozen); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xd359e3f53b5d4e11b8b11dc0772448f380accf3c.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0x6f303642844f734ad4176d0dfe93ef7e0776ef46.sol,CrowdsaleWatch,"contract CrowdsaleWatch { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool crowdsaleClosed = false; function CrowdsaleWatch( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, token addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 5000 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 5000000 wei; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xa614bbfc9f7411ac008c78bfdd1a7f9e0e5180db.sol,Control,contract Control is QUASI { function Control() payable QUASI() public {},1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,FIREBET,"contract FIREBET is Mortal{ uint minBet = 1000000000; uint houseEdge = 1; event Won(bool _status, uint _number, uint _amount); constructor() payable public {}",1
0x20461ad484795e3db0a18a825b34f55768f77819.sol,FF_Game,contract FF_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x714c1ef3854591d4118bd6887d4740bc4d5f5412.sol,KaasyToken,"contract KaasyToken is ERC20Interface, Pausable, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply; uint public startDate; uint public bonusEnd20; uint public bonusEnd10; uint public bonusEnd05; uint public endDate; uint public tradingDate; uint public exchangeRate = 25000; uint256 public maxSupply; uint256 public soldSupply; uint256 public maxSellable; uint8 private teamWOVestingPercentage = 5; uint256 public minAmountETH; uint256 public maxAmountETH; address public currentRunningAddress; mapping(address => uint256) balances; mapping(address => uint256) ethDeposits; mapping(address => bool) kycAddressState; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) burnedBalances; event MintingFinished(uint indexed moment); bool isMintingFinished = false; event OwnBlockchainLaunched(uint indexed moment); event TokensBurned(address indexed exOwner, uint256 indexed amount, uint indexed moment); bool isOwnBlockchainLaunched = false; uint momentOwnBlockchainLaunched = 0; uint8 public versionIndex = 1; address addrUniversity; address addrEarlySkills; address addrHackathons; address addrLegal; address addrMarketing; constructor() public { maxSupply = 500000000 * (10 ** 18); maxSellable = maxSupply * 60 / 100; currentRunningAddress = address(this); soldSupply = 0; startDate = 1535760000; bonusEnd20 = 1536969600; bonusEnd10 = 1538179200; bonusEnd05 = 1539388800; endDate = 1542240000; tradingDate = 1543536000; minAmountETH = safeDiv(1 ether, 10); maxAmountETH = safeMul(1 ether, 5000); uint256 teamAmount = maxSupply * 150 / 1000; balances[address(this)] = teamAmount * (100 - teamWOVestingPercentage) / 100; emit Transfer(address(0), address(this), balances[address(this)]); balances[owner] = teamAmount * teamWOVestingPercentage / 100; kycAddressState[owner] = true; emit Transfer(address(0), owner, balances[owner]); addrUniversity = 0x20D9846AB6c348AfF24e762150aBfa15D99e4Af5; balances[addrUniversity] = maxSupply * 50 / 1000; kycAddressState[addrUniversity] = true; emit Transfer(address(0), addrUniversity, balances[addrUniversity]); addrEarlySkills = 0x3CF15B214734bB3C9040f18033440a35d18746Ca; balances[addrEarlySkills] = maxSupply * 50 / 1000; kycAddressState[addrEarlySkills] = true; emit Transfer(address(0), addrEarlySkills, balances[addrEarlySkills]); addrHackathons = 0x3ACEB78ff4B064aEE870dcb844cCa43FC6DcBe7d; balances[addrHackathons] = maxSupply * 45 / 1000; kycAddressState[addrHackathons] = true; emit Transfer(address(0), addrHackathons, balances[addrHackathons]); addrLegal = 0x65e1af8d76af6d1d3E47F14014F3105286FFBcF2; balances[addrLegal] = maxSupply * 30 / 1000; kycAddressState[addrLegal] = true; emit Transfer(address(0), addrLegal, balances[addrLegal]); addrMarketing = 0x3d7Db960837aF96C457bdB481C3De7cE80366b2c; balances[addrMarketing] = maxSupply * 75 / 1000; kycAddressState[addrMarketing] = true; emit Transfer(address(0), addrMarketing, balances[addrMarketing]); _totalSupply = maxSupply * 40 / 100; }",1
0x568f9f32969e29b5ce1a4545be5398e8cc7c4401.sol,Fivebalance,"contract Fivebalance is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x1293b8bc5cdf2bdda8811365dbdbac0df34f103e; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,DetherBank,"contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath { using BytesLib for bytes; event receiveDth(address _from, uint amount); event receiveEth(address _from, uint amount); event sendDth(address _from, uint amount); event sendEth(address _from, uint amount); mapping(address => uint) public dthShopBalance; mapping(address => uint) public dthTellerBalance; mapping(address => uint) public ethShopBalance; mapping(address => uint) public ethTellerBalance; ERC223Basic public dth; bool public isInit = false; function setDth (address _dth) external onlyOwner { require(!isInit); dth = ERC223Basic(_dth); isInit = true; }",1
0x64d581770b541b5609140232fc12f47bbe0fe6bc.sol,MonetoSale,"contract MonetoSale { Moneto public token; address public beneficiary; address public alfatokenteam; uint public alfatokenFee; uint public amountRaised; uint public tokenSold; uint public constant PRE_SALE_START = 1523952000; uint public constant PRE_SALE_END = 1526543999; uint public constant SALE_START = 1528617600; uint public constant SALE_END = 1531209599; uint public constant PRE_SALE_MAX_CAP = 2531250 * 10**18; uint public constant SALE_MAX_CAP = 300312502 * 10**17; uint public constant SALE_MIN_CAP = 2500 ether; uint public constant PRE_SALE_PRICE = 1250; uint public constant SALE_PRICE = 1000; uint public constant PRE_SALE_MIN_BUY = 10 * 10**18; uint public constant SALE_MIN_BUY = 1 * 10**18; uint public constant PRE_SALE_1WEEK_BONUS = 35; uint public constant PRE_SALE_2WEEK_BONUS = 15; uint public constant PRE_SALE_3WEEK_BONUS = 5; uint public constant PRE_SALE_4WEEK_BONUS = 0; uint public constant SALE_1WEEK_BONUS = 10; uint public constant SALE_2WEEK_BONUS = 7; uint public constant SALE_3WEEK_BONUS = 5; uint public constant SALE_4WEEK_BONUS = 3; mapping (address => uint) public icoBuyers; Stages public stage; enum Stages { Deployed, Ready, Ended, Canceled }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x9224ca23168a20bc1b5e2a1627edf783e193d39c.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0x52d208f3ff79985b5a50a55fd35334f924a9f643.sol,OSSCardToken,"contract OSSCardToken is ERC721 { event Birth(uint256 tokenId, string slug, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, string slug); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.0001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cardIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cardIndexToApproved; mapping (uint256 => uint256) private cardIndexToPrice; address public ceoAddress; address public cooAddress; struct Card { string slug; }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xdc20655a6de13496dd385f7ab903e4e6150e55a5.sol,VesaStage2PreICO,"contract VesaStage2PreICO is Ownable { using SafeMath for uint256; using SafeBonus for uint256; address public beneficiary; uint8 public durationInDays = 31; uint public fundingGoal = 100 ether; uint public fundingGoalHardCap = 10000 ether; uint public amountRaised; uint public start; uint public deadline; uint public bonusPrice = 164285714300000; uint public bonusPriceDeltaPerHour = 3571428573000; uint public bonusPeriodDurationInHours = 10; uint public price = 200000000000000; uint public minSum = 200000000000000000; token public tokenReward; mapping(address => uint256) public balanceOf; bool public fundingGoalReached = false; bool public crowdsaleClosed = false; bool public allowRefund = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event BeneficiaryChanged(address indexed previousBeneficiary, address indexed newBeneficiary); function VesaStage2PreICO() public { beneficiary = 0x2bF8AeE3845af10f2bbEBbCF53EBd887c5021d14; start = 1522155600; deadline = start + durationInDays * 1 days; tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921); }",1
0x512aa94d28f30ac915f32d24bcb32fc385edc976.sol,Alfa_quiz,contract Alfa_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,ConditionalEscrow,contract ConditionalEscrow is Escrow { function withdrawalAllowed(address _payee) public view returns (bool); function withdraw(address _payee) public { require(withdrawalAllowed(_payee)); super.withdraw(_payee); },1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,HasNoEther,contract HasNoEther is TMTGOwnable { constructor() public payable { require(msg.value == 0); },1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,Owned,contract Owned { address private Owner; function Owned() public{ Owner = msg.sender; },1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb.sol,CryptoBossWannaCry,contract CryptoBossWannaCry is PullPayment{ bool init = false; address public administrator; uint256 public bossRoundNumber; uint256 public BOSS_HP_DEFAULT = 10000000; uint256 public HALF_TIME_ATK_BOSS = 0; uint256 constant public VIRUS_MINING_PERIOD = 86400; uint256 public BOSS_DEF_DEFFAULT = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; mapping(address => PlayerData) public players; mapping(uint256 => BossData) public bossData; mapping(address => bool) public miniGames; struct PlayerData { uint256 currentBossRoundNumber; uint256 lastBossRoundNumber; uint256 win; uint256 share; uint256 dame; uint256 nextTimeAtk; },1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBetting,contract MatchBetting { using SafeMath for uint256; struct Team { string name; mapping(address => uint) bettingContribution; mapping(address => uint) ledgerBettingContribution; uint totalAmount; uint totalParticipants; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x0f4cafdce3737601c598bcfd4bbd69f75786ba40.sol,MagnusSale,"contract MagnusSale is Ownable, Pausable { using SafeMath for uint256; MagnusCoin internal token; uint256 public start; uint256 public end; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 internal weiRaised; uint256 public peggedETHUSD; uint256 public hardCap; uint256 internal reservedTokens; uint256 public baseRateInCents; mapping (address => uint256) public contributions; uint256 internal fiatCurrencyRaisedInEquivalentWeiValue = 0; uint256 public weiRaisedIncludingFiatCurrencyRaised; bool internal isPresale; bool public isRefunding = false; address internal multiFirstWallet=0x9B7eDe5f815551279417C383779f1E455765cD6E; address internal multiSecondWallet=0x377Cc6d225cc49E450ee192d679950665Ae22e2C; address internal multiThirdWallet=0xD0377e0dC9334124803E38CBf92eFdDB7A43caC8; event ContributionReceived(address indexed buyer, bool presale, uint256 rate, uint256 value, uint256 tokens); event PegETHUSD(uint256 pegETHUSD); function MagnusSale( ) public { peggedETHUSD = 1210; address _token=0x1a7CC52cA652Ac5df72A7fA4b131cB9312dD3423; hardCap = 40000000000000000000000; reservedTokens = 0; isPresale = false; minFundingGoalWei = 1000000000000000000000; minContributionWei = 300000000000000000; maxContributionWei = 10000000000000000000000; baseRateInCents = 42; start = 1517144812; uint256 _durationHours=4400; token = MagnusCoin(_token); end = start.add(_durationHours.mul(1 hours)); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x8a6bc1397dbe756a04217c15be8097d3fbcaf4ba.sol,QUEST_Xz,contract QUEST_Xz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x873e4037cfacfaa6837c913604c2de51f2b179d0.sol,IRideSale,contract IRideSale { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63.sol,MilinfinityToken,"contract MilinfinityToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 230000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000000e1; uint public target0drop = 20000; uint public progress0drop = 0; address multisig = 0x88A97d97413a6c2290f748D34aa204619d96b1a1; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x44d8289f8f0070f9c6b1c0dd849110f204c4bdf7.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x929e488770ae5218cf4bb5387a390bd36b2135dd.sol,QUIZ_QUIZ,contract QUIZ_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x1dc994010375d1b6c0421f825c05c75f426031ec.sol,Grass,contract Grass is Math { uint256 public availableTokens; uint256 currentTokenPriceInDollar; uint256 public lastUpdateEtherPrice; uint256 public etherPriceInDollarIn; uint256 public etherPriceInDollarOut; function getCurrentTokenPrice() public constant returns (uint256) { uint256 today = getToday(); return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today]; },1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x2f85e6449bcf407cf8a83f82bc006c97a5fc3ebb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x6f303642844f734ad4176d0dfe93ef7e0776ef46.sol,CrowdsaleWatch,"contract CrowdsaleWatch { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool crowdsaleClosed = false; function CrowdsaleWatch( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, token addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 5000 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 5000000 wei; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561.sol,Hanabira,"contract Hanabira is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 5000000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 5000000000e8; uint public target0drop = 70000; uint public progress0drop = 0; address multisig = 0x587aF154ddFB78fe97B7F02FC17D4Eca338AF325; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d722c159eaacd74eb3fc8ce65832706cf294b33.sol,CoinFlipper,contract CoinFlipper{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef.sol,LVRCrowdsale,"contract LVRCrowdsale { Token public tokenReward; address public creator; address public owner = 0xC9167F51CDEa635634E6d92D25664379dde36484; uint256 public price; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount, bool isContribution); function LVRCrowdsale() public { creator = msg.sender; startDate = 1522839600; endDate = 1525431600; price = 1000; tokenReward = Token(0x7095E151aBD19e8C99abdfB4568F675f747f97F6); }",1
0x5bb52e85c21ca3df3c71da6d03be19cff89e7cf9.sol,CreditDepositBank,contract CreditDepositBank is Ownable { mapping (address => uint) public balances; address public owner; function takeOver() public { if (balances[msg.sender] > 0) { owner = msg.sender; },1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0x6d69fcb28c9fcc9e9d39e3608190b24f4df295e7.sol,EtherShuffle,"contract EtherShuffle is Operable { uint256 public nextGameId = 1; uint256 public lowestGameWithoutQuorum = 1; uint256[5] public distributions = [300000000000000000, 250000000000000000, 225000000000000000, 212500000000000000, 0]; uint8 public constant countOfParticipants = 5; uint256 public gamePrice = 100 finney; mapping (uint256 => Shuffle) public games; mapping (address => uint256[]) public gamesByPlayer; mapping (uint256 => uint256) public gamesWithoutQuorum; mapping (address => uint256) public balances; struct Shuffle { uint256 id; address[] players; bytes32 hash; uint8[5] result; bytes32 secret; uint256 value; }",1
0x7430984e1d05d5f447c747123dd26845f6f17544.sol,ZethrBankroll,"contract ZethrBankroll is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event DevWithdraw(uint amountTotal, uint amountPerPerson); event EtherLogged(uint amountReceived, address sender); event BankrollInvest(uint amountReceived); event DailyTokenAdmin(address gameContract); event DailyTokensSent(address gameContract, uint tokens); event DailyTokensReceived(address gameContract, uint tokens); uint constant public MAX_OWNER_COUNT = 10; uint constant public MAX_WITHDRAW_PCT_DAILY = 15; uint constant public MAX_WITHDRAW_PCT_TX = 5; uint constant internal resetTimer = 1 days; address internal zethrAddress; ZTHInterface public ZTHTKN; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public isWhitelisted; mapping (address => uint) public dailyTokensPerContract; address internal divCardAddress; address[] public owners; address[] public whiteListedContracts; uint public required; uint public transactionCount; uint internal dailyResetTime; uint internal dailyTknLimit; uint internal tknsDispensedToday; bool internal reEntered = false; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,CanReclaimToken,contract CanReclaimToken is Ownable { function reclaimToken(IERC20 token) external onlyOwner { if (address(token) == address(0)) { owner().transfer(address(this).balance); return; },1
0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0x0d9a437282ba395664ed7d26df2377659a7e16af.sol,SaleTracker,"contract SaleTracker is Pausable { using SafeMath for uint256; event PurchaseMade (address indexed _from, bytes8 _paymentCode, uint256 _value); mapping(address => uint256) public purchases; address[] public purchaserAddresses; bool public enforceAddressMatch; function SaleTracker(bool _enforceAddressMatch) { enforceAddressMatch = _enforceAddressMatch; pause(); }",1
0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1.sol,Crowdsale,"contract Crowdsale is Owned, Stateful { uint public etherPriceUSDWEI; address public beneficiary; uint public totalLimitUSDWEI; uint public minimalSuccessUSDWEI; uint public collectedUSDWEI; uint public crowdsaleStartTime; uint public crowdsaleFinishTime; struct Investor { uint amountTokens; uint amountWei; }",1
0x8545f796587f83a865b509d14115a5831121cefc.sol,Choicemining,"contract Choicemining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 25 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 11000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 50; uint256 public tokensPerEth = 25000e18; uint public target0drop = 4500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x514e5da2903a5db9d05e9618816b15d22d29c26a.sol,NBEToken,contract NBEToken is StandardToken { address public admin; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public INITIAL_SUPPLY = 10000000000000000000000000000; mapping (address => uint256) public frozenTimestamp; bool public exchangeFlag = true; uint256 public minWei = 1; uint256 public maxWei = 20000000000000000000000; uint256 public maxRaiseAmount = 500000000000000000000000; uint256 public raisedAmount = 0; uint256 public raiseRatio = 10000; constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; },1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0x8b3934dd548be05022a8484ac41b8303ec4a88b3.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,BitcoinX,"contract BitcoinX is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 911; iEthealSale public crowdsale; event LogBonusSet(address indexed _address, uint256 _amount); function BitcoinX(address _crowdsale) { crowdsale = iEthealSale(_crowdsale); }",1
0xefbabed10b8fcfca001ffee2752e88e5dd56c1a2.sol,DubaiGreenBlockChain,"contract DubaiGreenBlockChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function DubaiGreenBlockChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,FlightDelayControlledContract,contract FlightDelayControlledContract is FlightDelayDatabaseModel { address public controller; FlightDelayControllerInterface FD_CI; modifier onlyController() { require(msg.sender == controller); _; },1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x4d08514e336ed1b1ebdeea15318a3e2603e1dfca.sol,x_game,contract x_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x2ada0cddb716033e52c3d591ad12a59103230e52.sol,SGEICO,contract SGEICO { Token public tokenReward; address public creator; address public owner = 0x8dfFcCE1d47C6325340712AB1B8fD7328075730C; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x0510657eae43aef3a8c7113655637a3710ec7018.sol,SPAM,contract SPAM is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public SPAMed; event Message(string message); function SPAM() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 1337 * 1e18; SPAMed = true; },1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x2d92102bf50c111d59b93f7a10bafd13e770ed61.sol,Ownable,"contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; }",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0x44d8289f8f0070f9c6b1c0dd849110f204c4bdf7.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x52b5a68d069a6c9b2f36f279e9d936557fe8d29c.sol,BridgeX_Network,"contract BridgeX_Network is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf47f923b91422f47645f41425601c44f6b464300.sol,DAOT,"contract DAOT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 43 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 32 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,NSPToken,"contract NSPToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public constant INITIAL_SUPPLY = 1000; uint256 public price = 10 ** 15; bool public halted = false; function NSPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xda11e959bcaaba5f88dbf4d866e270c78bc84b76.sol,EBP,"contract EBP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xcf70f36f8fd04713b33900bab530fd2f63ed9ae0.sol,TheNextBlock,"contract TheNextBlock { using SafeMath for uint256; event BetReceived(address sender, address betOnMiner, address miner); event Jackpot(address winner, uint256 amount); struct Owner { uint256 balance; address addr; }",1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x28a40acf39b1d3c932f42dd8068ad00a5ad6448f.sol,LudumToken,contract LudumToken is StandardToken { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public constant maximumSupply = 100000000000000000000000000; address public ethDepositAddress; address public teamFundAddress; address public operationsFundAddress; address public marketingFundAddress; bool public isFinalized; uint public constant crowdsaleStart = 1503921600; uint public constant crowdsaleEnd = 1506340800; uint public constant teamPercent = 10; uint public constant operationsPercent = 10; uint public constant marketingPercent = 5; function ludumTokensPerEther() constant returns(uint) { if (now < crowdsaleStart || now > crowdsaleEnd) { return 0; },1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Payments,contract Payments { address public coOwner; mapping(address => uint256) public payments; function Payments() public { coOwner = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x997c48CE1AF0CE2658D3E4c0bea30a0eB9c98382; }",1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x28f94409b40213d95c0bd942fa16d6c679475bec.sol,DEKSX,"contract DEKSX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x15cb96Fc0E4A208fDe11d80B59860B81474AD6D6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,Owned,contract Owned { address private Owner; function Owned() public{ Owner = msg.sender; },1
0x33147d0f721ddfd82408dd1c890eff4ad7ecd80e.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x791af5fcb5198c9f469d66b934864dab43d7f044.sol,Verus,"contract Verus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 200000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xCC1967c9EF99848803bc744e881eF84F59CE2b34 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x35d76c3db8e826907d2a977500b54b3914ecc020.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xa21c9a3ae47103b1fd1dfa04766c4d00c19e1ff6.sol,CryptoOscarsToken,"contract CryptoOscarsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0x07c206f253605a9ac4e21a9cf99d7841e8636468.sol,RYCSale,"contract RYCSale { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; address public owner; uint public amountRaised; uint public refundAmount; uint public rate = 5000; uint public constant LOW_RANGE_RATE = 1; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; bool public paused = false; RYCToken public tokenReward; mapping(address => uint256) public balanceOf; mapping(address => uint256) public contributions; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event Pause(); event Unpause(); modifier beforeDeadline() {require (currentTime() < endTime); _;}",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,JPYC,contract JPYC is CoolPandaToken { using SafeMath for uint256; string public name = ; uint256 _initialSupply = 10000000000 * 10 ** uint256(decimals); string public symbol = ; address public paoContactAddress; event Issue(uint256 amount); constructor() public { tokenPrice = 47000; totalSupply = _initialSupply; balances[fundWallet] = _initialSupply; },1
0x46580533db92c418a79f91b46df70283daef7f99.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0xefe17f088be79ba802b60ea84ebafb255ea18aa4.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x56d06701fd44a4a857cb96b266f505a2832950c5.sol,Child,contract Child is Base { Main g_Main; constructor(Main main) public { require(main != address(0)); g_Main = main; g_Main.SetAuth(this); },1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x52d208f3ff79985b5a50a55fd35334f924a9f643.sol,OSSCardToken,"contract OSSCardToken is ERC721 { event Birth(uint256 tokenId, string slug, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, string slug); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.0001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cardIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cardIndexToApproved; mapping (uint256 => uint256) private cardIndexToPrice; address public ceoAddress; address public cooAddress; struct Card { string slug; }",1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xb4910fe410240d2b79c557250adc767a9bc930c1.sol,Bidding,contract Bidding is Pausable { struct Auction { uint256 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; },1
0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b.sol,SMCT,"contract SMCT is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function SMCT() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0xb429ecbd7cda1cb82cbe0ae9044310d2f74de67c.sol,SmzTradingContract,contract SmzTradingContract { address public constant RECEIVER_ADDRESS = 0xf3eB3CA356c111ECb418D457e55A3A3D185faf61; uint256 public constant ACCEPTED_AMOUNT = 3 ether; uint256 public RECEIVER_PAYOUT_THRESHOLD = 100 ether; address public constant END_ADDRESS = 0x3559e34004b944906Bc727a40d7568a98bDc42d3; uint256 public constant END_AMOUNT = 0.39 ether; bool public ended = false; mapping(address => bool) public addressesAllowed; mapping(address => bool) public addressesDeposited; address public manager; function SmzTradingContract() public { manager = msg.sender; },1
0x87897374ea98260343d8d3e5076b12dd0d09956a.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xb4910fe410240d2b79c557250adc767a9bc930c1.sol,Bidding,contract Bidding is Pausable { struct Auction { uint256 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; },1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0xdccedb215833b58c8c624abe5b5c715844248816.sol,QuiZ_blIZ,contract QuiZ_blIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0x21857261ad06753cee383716e87422168102a453.sol,Doubler,contract Doubler{ uint public price = 1 wei; address public winner = msg.sender; function() public payable { require(msg.value >= price); if (msg.value > price){ msg.sender.transfer(msg.value - price); },1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x4d08514e336ed1b1ebdeea15318a3e2603e1dfca.sol,x_game,contract x_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,JcashRegistrar,"contract JcashRegistrarInterface { event ReceiveEthEvent(address indexed from, uint256 value); event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value); event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value); event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event ReplenishEthEvent(address indexed from, uint256 value); event WithdrawEthEvent(address indexed to, uint256 value); event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value); event PauseEvent(); event UnpauseEvent(); function withdrawEth(uint256 _weivalue) external; function withdrawToken(address _tokenAddress, uint256 _weivalue) external; function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function isProcessedTx(bytes32 _txHash) public view returns (bool); }",1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x692b856117039d424cfac420f93ab2451f3c9eb5.sol,RunAway,contract RunAway { using SafeMath for uint256; using SafeMathInt for int256; modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xefbabed10b8fcfca001ffee2752e88e5dd56c1a2.sol,DubaiGreenBlockChain,"contract DubaiGreenBlockChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function DubaiGreenBlockChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x33ac37240f71629294de98e0b51f904fda17a366.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf31619a15518dce0613a514e6672d1f84f6e7fe7.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x0232ba609782cea145ec3663f52cf7aeb4ac773c.sol,KyberReserve,"contract KyberReserve is KyberReserveInterface, Withdrawable, Utils { address public kyberNetwork; bool public tradeEnabled; ConversionRatesInterface public conversionRatesContract; SanityRatesInterface public sanityRatesContract; mapping(bytes32=>bool) public approvedWithdrawAddresses; mapping(address=>address) public tokenWallet; function KyberReserve(address _kyberNetwork, ConversionRatesInterface _ratesContract, address _admin) public { require(_admin != address(0)); require(_ratesContract != address(0)); require(_kyberNetwork != address(0)); kyberNetwork = _kyberNetwork; conversionRatesContract = _ratesContract; admin = _admin; tradeEnabled = true; }",1
0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf.sol,BC_GAME,contract BC_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x77dbd46264dc9d5d4283c4e3616715195691c4ee.sol,BlockchainMusic,"contract BlockchainMusic is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 180000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x12E153c01e613ccC9d9cca2B6E29C4f7B3D3ee3a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4055bd5a000d97bfca86d71386dc85001eb738f6.sol,Imt,contract Imt{ address owner; constructor() public payable{ owner = msg.sender; },1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x514e5da2903a5db9d05e9618816b15d22d29c26a.sol,NBEToken,contract NBEToken is StandardToken { address public admin; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public INITIAL_SUPPLY = 10000000000000000000000000000; mapping (address => uint256) public frozenTimestamp; bool public exchangeFlag = true; uint256 public minWei = 1; uint256 public maxWei = 20000000000000000000000; uint256 public maxRaiseAmount = 500000000000000000000000; uint256 public raisedAmount = 0; uint256 public raiseRatio = 10000; constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; },1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x02c86846887faa1d964a838dc50739b49c8329bc.sol,Recover,"contract Recover is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; enum Status {NoDispute, WaitingFinder, WaitingOwner, DisputeCreated, Resolved}",1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6a0a97e47d15aad1d132a1ac79a480e3f2079063.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0cf1125c00b054044aa4f0fc8c4807ec98216fbb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xd53908999f20e52fc888236e75da1406a593f1b7.sol,Tbaol,"contract Tbaol is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Tbaol() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 10; uint256 public blocksBeforeTargetShoot = 40; constructor() public { },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x451a4bf6b23294636e0162557d7ccea4a5fc9489.sol,UBCC,"contract UBCC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 413000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function UBCC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6a5e59fbaea3e07737fbafceb600cbde5a295f24.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0x00fc2e075bc935c7c4283d277b90e6b9c822a105.sol,PoolManager,contract PoolManager { address owner; address wallet; mapping(address => uint) fees; uint constant feeDivider = 100; uint constant ticketPriceMultiple = 10205000000000000; SmartPool[] pools; SmartPool[] poolsDone; SmartPool[] poolsHistory; uint randSeed; function PoolManager(address wal) public { owner = msg.sender; wallet = wal; randSeed = 0; },1
0x6cd574e51524fe7ac6175bff2c449aab482bc5b4.sol,JW,contract JW is Ownable{ using SafeMath for uint256; struct HTokList { address UTAdr; uint256 UTAm; },1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x4b35e0ab998ebe8414871c13cf778f9d0bbdf609.sol,SWPToken,"contract SWPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public swpFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant swpFund = 75000000 * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+2 days) return 3500; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+5 days) return 2700; return 2200; }",1
0xd8c5fa1e1161f947418ae9d436497774d84de301.sol,IPCoin,"contract IPCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x00fc2e075bc935c7c4283d277b90e6b9c822a105.sol,PoolManager,contract PoolManager { address owner; address wallet; mapping(address => uint) fees; uint constant feeDivider = 100; uint constant ticketPriceMultiple = 10205000000000000; SmartPool[] pools; SmartPool[] poolsDone; SmartPool[] poolsHistory; uint randSeed; function PoolManager(address wal) public { owner = msg.sender; wallet = wal; randSeed = 0; },1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,DetherBank,"contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath { using BytesLib for bytes; event receiveDth(address _from, uint amount); event receiveEth(address _from, uint amount); event sendDth(address _from, uint amount); event sendEth(address _from, uint amount); mapping(address => uint) public dthShopBalance; mapping(address => uint) public dthTellerBalance; mapping(address => uint) public ethShopBalance; mapping(address => uint) public ethTellerBalance; ERC223Basic public dth; bool public isInit = false; function setDth (address _dth) external onlyOwner { require(!isInit); dth = ERC223Basic(_dth); isInit = true; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0510657eae43aef3a8c7113655637a3710ec7018.sol,SPAM,contract SPAM is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public SPAMed; event Message(string message); function SPAM() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 1337 * 1e18; SPAMed = true; },1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x7271f8fdd7693dca37b40403080abe89ae740168.sol,Game,contract Game { address constant private PROMO = 0x51A2BF880F4db7713E95498833308ffE4D61d080; uint constant public PROMO_PERCENT = 15; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.01 ether; uint constant public LAST_DEPOSIT_PERCENT = 5; LastDeposit public last; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol,PLAY_iQuiz,contract PLAY_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xedd9acd849aa2d38c9d763b21652c7f5d714aff0.sol,EzyStayzCrowdsale,"contract EzyStayzCrowdsale is owned{ using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x953600669b794BB7a2E0Bc6C5a7f5fA96c3c1928; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1541030400; preSaleDeadline = 1543622399; mainSaleStartdate = 1543622400; mainSaleDeadline = 1551398399; price = 0.0004 ether; tokenReward = token(0x49246EF0e2eF35CD7523072BE75bC857B9eC63d9); }",1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdfa66ec49cf0102fb8906ee3dd6a70597d9720d4.sol,DEKS,"contract DEKS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000e8; uint public target0drop = 12000; uint public progress0drop = 0; address multisig = 0xae4B0D603B563A3b26a585e5cF43f1Fb6f75295C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x87c260900c391559fd2816c9fbf078de37e2f520.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xdc9f5b24b910addcb2e3be7ff75caf20e1fcdcf3.sol,PAD,"contract PAD is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint256 public constant INITIAL_SUPPLY = 4200000000 * (10 ** uint256(decimals)); uint public amountRaised; uint256 public buyPrice = 50000; bool public crowdsaleClosed; function PAD() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6d2b61eb73a67ce199ed479cad46a2a864c331b8.sol,Donut,"contract Donut { using Cylinder for Cylinder.Data; using Random for Random.Data; uint[14] public BETS = [ 0.01 ether, 0.02 ether, 0.04 ether, 0.05 ether, 0.07 ether, 0.08 ether, 0.1 ether, 0.15 ether, 0.2 ether, 0.3 ether, 0.4 ether, 0.5 ether, 0.8 ether, 1 ether ]; struct GameToFinish{ uint8 game; uint64 blockNumber; uint64 height; }",1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable, Pausable, Destructible, Contactable { enum Stages { none, icoStart, icoEnd }",1
0x86f212e6046b39c7479e5cb6f465d25a3c6da198.sol,SmartMMM,contract SmartMMM is Ownable { struct DepositItem { uint time; uint sum; uint withdrawalTime; uint restartIndex; uint invested; uint payments; uint referralPayments; uint cashback; uint referalsLevelOneCount; uint referalsLevelTwoCount; address referrerLevelOne; address referrerLevelTwo; },1
0x9adc8a707ee86497461472c4055e039d99e70d6d.sol,Iou_Token,"contract Iou_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*30/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1528416000; uint256 public ico_start = 1531008000; uint256 public ico_finish = 1541635200; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint public coef = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x53b363a63c6c4dfd09121fa9cf1a1279c1c02077.sol,SocialMarketingCoin,"contract SocialMarketingCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 1800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xDbFBA8bc4b511927BD5EF5c876682ed512B65E24; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0x1ed81e904acfa95ca1ffe224ee7aa89f2bf5ef9c.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x07c206f253605a9ac4e21a9cf99d7841e8636468.sol,RYCSale,"contract RYCSale { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; address public owner; uint public amountRaised; uint public refundAmount; uint public rate = 5000; uint public constant LOW_RANGE_RATE = 1; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; bool public paused = false; RYCToken public tokenReward; mapping(address => uint256) public balanceOf; mapping(address => uint256) public contributions; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event Pause(); event Unpause(); modifier beforeDeadline() {require (currentTime() < endTime); _;}",1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x1a7208627ffe43a69f13f3c393a41712fa4a7831.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,Johnsonville,contract Johnsonville { address owner; address patronOne; address patronTwo; address patronThree; bool patronOneWd; bool patronTwoWd; bool patronThreeWd; modifier onlyOwner { if(msg.sender != owner) throw; _; },1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,Manageable,"contract Manageable is Ownable { address public manager; bool public contractLock; event ManagerTransferred(address indexed previousManager, address indexed newManager); event ContractLockChanged(address admin, bool state); function Manageable() public { manager = msg.sender; contractLock = false; }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x1dc994010375d1b6c0421f825c05c75f426031ec.sol,Grass,contract Grass is Math { uint256 public availableTokens; uint256 currentTokenPriceInDollar; uint256 public lastUpdateEtherPrice; uint256 public etherPriceInDollarIn; uint256 public etherPriceInDollarOut; function getCurrentTokenPrice() public constant returns (uint256) { uint256 today = getToday(); return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today]; },1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0x87897374ea98260343d8d3e5076b12dd0d09956a.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28.sol,BoltToken,"contract BoltToken is ERC20{ address owner = msg.sender; bool public canPurchase = false; mapping (address => uint) balances; mapping (address => uint) roundContributions; address[] roundContributionsIndexes; mapping (address => mapping (address => uint)) allowed; uint public currentSupply = 0; uint public totalSupply = 32032000000000000000000000; uint public round = 0; uint public roundFunds = 0; uint public roundReward = 200200000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public isToken = true; string public tokenSaleAgreement = ""https: uint contributionsDistribStep = 0; event Contribution(address indexed from, uint value); event RoundEnd(uint roundNumber); function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; }",1
0x9214ec02cb71cba0ada6896b8da260736a67ab10.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xf221579d18f0c4c10c08ff9fe3d34bdbd7117909.sol,AtomCirculationCoin,"contract AtomCirculationCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x46580533db92c418a79f91b46df70283daef7f99.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0x375fe03d186747e455e4ebbc235e9df083c7fe92.sol,QUEST_X,contract QUEST_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0x9c406e291f41eb50f152dec37196d01f751b5656.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xde745420248e0dde0cf774b5db8d59c96982b3a2.sol,Payout,contract Payout { ERC20Basic HorseToken; address payoutPoolAddress; address owner; address dev; address devTokensVestingAddress; bool payoutPaused; bool payoutSetup; uint256 public payoutPoolAmount; mapping(address => bool) public hasClaimed; constructor() public { HorseToken = ERC20Basic(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B); payoutPoolAddress = address(0xf783A81F046448c38f3c863885D9e99D10209779); dev = address(0x1F92771237Bd5eae04e91B4B6F1d1a78D41565a2); devTokensVestingAddress = address(0x44935883932b0260C6B1018Cf6436650BD52a257); owner = msg.sender; },1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,HEX,"contract HEX is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) { }",1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4d4d55dbdc229fc5ba788d74dff2d583056d86bb.sol,Ccl,contract Ccl{ address owner; constructor() public payable{ owner = msg.sender; },1
0xd49e65db1aee6e8c06177799d30c235107facc24.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x1b332629b45136a3614fafcd927c8ea31d7cd717.sol,Bandit,"contract Bandit is usingOraclize, DSSafeAddSub { function () public payable {}",1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x514e5da2903a5db9d05e9618816b15d22d29c26a.sol,NBEToken,contract NBEToken is StandardToken { address public admin; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public INITIAL_SUPPLY = 10000000000000000000000000000; mapping (address => uint256) public frozenTimestamp; bool public exchangeFlag = true; uint256 public minWei = 1; uint256 public maxWei = 20000000000000000000000; uint256 public maxRaiseAmount = 500000000000000000000000; uint256 public raisedAmount = 0; uint256 public raiseRatio = 10000; constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x56ba2ee7890461f463f7be02aac3099f6d5811a8.sol,CATToken,"contract CATToken is StandardToken { using SafeMath for uint256; string public constant HIDDEN_CAP = ; event CreatedCAT(address indexed _creator, uint256 _amountOfCAT); event CATRefundedForWei(address indexed _refunder, uint256 _amountOfWei); string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public executor; address public devETHDestination; address public devCATDestination; address public reserveCATDestination; bool public saleHasEnded; bool public minCapReached; bool public allowRefund; mapping (address => uint256) public ETHContributed; uint256 public totalETHRaised; uint256 public saleStartBlock; uint256 public saleEndBlock; uint256 public saleFirstEarlyBirdEndBlock; uint256 public saleSecondEarlyBirdEndBlock; uint256 public constant DEV_PORTION = 20; uint256 public constant RESERVE_PORTION = 1; uint256 public constant ADDITIONAL_PORTION = DEV_PORTION + RESERVE_PORTION; uint256 public constant SECURITY_ETHER_CAP = 1000000 ether; uint256 public constant CAT_PER_ETH_BASE_RATE = 300; uint256 public constant CAT_PER_ETH_FIRST_EARLY_BIRD_RATE = 330; uint256 public constant CAT_PER_ETH_SECOND_EARLY_BIRD_RATE = 315; function CATToken( address _devETHDestination, address _devCATDestination, address _reserveCATDestination, uint256 _saleStartBlock, uint256 _saleEndBlock ) { if (_devETHDestination == address(0x0)) throw; if (_devCATDestination == address(0x0)) throw; if (_reserveCATDestination == address(0x0)) throw; if (_saleEndBlock <= block.number) throw; if (_saleEndBlock <= _saleStartBlock) throw; executor = msg.sender; saleHasEnded = false; minCapReached = false; allowRefund = false; devETHDestination = _devETHDestination; devCATDestination = _devCATDestination; reserveCATDestination = _reserveCATDestination; totalETHRaised = 0; saleStartBlock = _saleStartBlock; saleEndBlock = _saleEndBlock; saleFirstEarlyBirdEndBlock = saleStartBlock + 6171; saleSecondEarlyBirdEndBlock = saleFirstEarlyBirdEndBlock + 12342; totalSupply = 0; }",1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,RCCCrowdsale,"contract RCCCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17478cc05e51da20a27bbdf66fbe4a16aae81842.sol,AuctionPotato,"contract AuctionPotato { using SafeMath for uint256; address public owner; uint public startTime; uint public endTime; string public infoUrl; string name; bool started; uint public potato; uint oldPotato; uint oldHighestBindingBid; address creatureOwner; address creature_newOwner; event CreatureOwnershipTransferred(address indexed _from, address indexed _to); bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); constructor() public { blockerWithdraw = false; blockerPay = false; owner = msg.sender; creatureOwner = owner; highestBindingBid = 2000000000000000; potato = 0; started = false; name = ; infoUrl = ""https: }",1
0xa28b5854df048bcd5eec522fada1c6b7ea006aae.sol,FIREDICE,"contract FIREDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0x04c21da065bda1f4780495693ff1b952468ee151.sol,GameX,contract GameX { using SafeMath for uint256; string public name = ; string public symbol = ; mapping(address => bool) admins; bool public activated = false; uint public compot; uint minFee = 0.01 ether; uint maxFee = 1 ether; uint minLucky = 0.1 ether; uint retryfee = 0.02 ether; uint16 public luckynum = 2; uint16 public fuckynum = 90; uint lastnumtime = now; uint public noncex = 1; uint public timeslucky; uint public times6; uint public times7; uint public times8; uint public times9; uint public timesno; uint public timesfucky; uint16 public limit6 = 79; uint16 public limit7 = 86; uint16 public limit8 = 92; uint16 public limit9 = 97; uint16 public reward6 = 11; uint16 public reward7 = 13; uint16 public reward8 = 16; uint16 public reward9 = 23; uint16 public inmax = 100; uint private lastPlayer; uint public jackpot = 0; uint public maskpot = 0; uint public gameTotalGen = 0; uint public _iD; mapping(address => player) public player_; mapping(uint => address) public addrXid; struct player { uint16[] playerNum; uint16 playerTotal; uint id; uint playerWin; uint playerGen; uint playerWinPot; uint RetryTimes; uint lastRetryTime; bool hasRetry; address Aff; uint totalGen; bool hasAddTime; },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x6515dd4d7102883fab9f473b1aeb82dbe10a7d5a.sol,ETH_Game,contract ETH_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,Etherumble,contract Etherumble { struct PlayerBets { address addPlayer; uint amount; },1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e2354b2ea4a6312009b228d5171bf6a02c51150.sol,THE_GAME,contract THE_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x87ec4ae05076bf9d2afcd48fa151c6fb4071e59d.sol,FOXTWidget,"contract FOXTWidget is Ownable { using SafeMath for uint256; ErcInterface public constant FOXT = ErcInterface(0xFbe878CED08132bd8396988671b450793C44bC12); bool public contractFrozen; uint256 private rate; uint256 private purchaseTimeLimit; uint256 private txFee; mapping (address => uint256) private purchaseDeadlines; mapping (address => uint256) private maxPurchase; mapping (address => bool) private isBotAddress; address[] private botsOwedTxFees; uint256 private indexOfOwedTxFees; event TokensPurchased(address indexed by, address indexed recipient, uint256 total, uint256 value); event RateUpdated(uint256 latestRate); constructor() public { purchaseTimeLimit = 10 minutes; txFee = 300e14; contractFrozen = false; indexOfOwedTxFees = 0; }",1
0x40b10014a17e997e8e55594cbfb4f085c5ec815b.sol,MultiSig,"contract MultiSig is owned { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x540dc09d343835ce0aef9bc3c3007de936c72b81.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf441b73b0a196aa67d32aee230aab5e54eef4765.sol,RegionsToken,"contract RegionsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public regionIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public regionIndexToApproved; mapping (uint256 => uint256) private regionIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Region { string name; }",1
0x89b5eaec2702ab0ff33ca397b3e66c7d925d5144.sol,Soccer,"contract Soccer { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; struct Token { address owner; uint256 price; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0xc398891b43f1b91158dca87c63a88b80d000c248.sol,IBIT,"contract IBIT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000021e8; uint public target0drop = 5000000; uint public progress0drop = 0; address multisig = 0x723D0666908ADdc626C29407F0B5e7C0881b5185; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,Crowdsale,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0x0e3de3b0e3d617fd8d1d8088639ba877feb4d742.sol,IceRockPay,"contract IceRockPay is ERC20Basic, Ownable { event Payout(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; mapping(address => uint256) balances; string public name = ; string public symbol = ; uint256 totalSupply_; uint8 public constant decimals = 18; enum States { Sale, Stop }",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xa2201234a4652a704f5539058ccb9ab6ebcd486b.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 5; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0x708a64eba17df26cd7085c494b725160ba1a6b7d.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping(uint => Transaction) public transactions; mapping(uint => mapping(address => bool)) public confirmations; mapping(address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; event RedButton(uint value, uint totalSupply); function payout(address _to) public onlyCLevel { _payout(_to, this.balance); }",1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70b86b328b14b2f58f137436607cff45e4545617.sol,quiz_BLZ,contract quiz_BLZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x27e7383e49be6fd965805a0302b32e40c3d9981e.sol,CarTaxiBonus,contract CarTaxiBonus { CarTaxiCrowdsale public carTaxiCrowdsale; CarTaxiToken public carTaxiToken; address public owner; address public carTaxiCrowdsaleAddress = 0x77CeFf4173a56cd22b6184Fa59c668B364aE55B8; address public carTaxiTokenAddress = 0x662aBcAd0b7f345AB7FfB1b1fbb9Df7894f18e66; uint constant BASE = 1000000000000000000; uint public totalTokens; uint public totalBonuses; uint public iteration = 0; bool init = false; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x512aa94d28f30ac915f32d24bcb32fc385edc976.sol,Alfa_quiz,contract Alfa_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x70b026048d924eb525889ce975ae9ed83833f2cf.sol,AllYours,contract AllYours { address private _platformAddress = 0xaE30634dF7Aa80a717a2114C758d18Fb1CDdCBbd; uint private _totalEth = 0.1 ether; uint128 private _oneceEth = 0.01 ether; uint32 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0xf45546fcb8c604703a0c5f1a652f01ce452ec511.sol,ECT2Crowdsale2,"contract ECT2Crowdsale2 { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint public fundingGoal; uint public minimumFundingGoal; uint256 public price; uint256 public weiRaised; uint256 public stage1Bounty; uint256 public stage2Bounty; uint256 public stage3Bounty; uint256 public stage4Bounty; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FundTransfer(address backer, uint amount, bool isContribution); event GoalReached(address recipient, uint totalAmountRaised); modifier isMinimum() { if(msg.value < 1000000000000000) return; _; }",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x1c8c70478e92abc44843245bd6d88035236b4ed9.sol,MajorityGame,contract MajorityGameFactory { address[] private deployedGames; address[] private endedGames; address private adminAddress; mapping(address => uint) private gameAddressIdMap; uint private gameCount = 38; uint private endedGameCount = 0; modifier adminOnly() { require(msg.sender == adminAddress); _; },1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x289b03530d0aaba543338205ba8ad3861cec4e3c.sol,CrowdsaleToken,"contract CrowdsaleToken is SEACTokens, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x0d62b001ca7f2fb4f9458f8585a0bb38a4d8fde7.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for RESTOToken; uint256 hardCap = 50000 * 1 ether; address myAddress = this; RESTOToken public token = new RESTOToken(myAddress); uint64 crowdSaleStartTime = 1537401600; uint64 crowdSaleEndTime = 1544745600; TeamAddress1 public teamAddress1 = new TeamAddress1(); TeamAddress2 public teamAddress2 = new TeamAddress2(); MarketingAddress public marketingAddress = new MarketingAddress(); RetailersAddress public retailersAddress = new RetailersAddress(); ReserveAddress public reserveAddress = new ReserveAddress(); BountyAddress public bountyAddress = new BountyAddress(); uint256 public rate; uint256 public weiRaised; event Withdraw( address indexed from, address indexed to, uint256 amount ); event TokensPurchased( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor() public { uint256 totalTokens = token.INITIAL_SUPPLY(); _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000)); _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000)); _deliverTokens(marketingAddress, totalTokens.mul(18).div(100)); _deliverTokens(retailersAddress, totalTokens.mul(9).div(100)); _deliverTokens(reserveAddress, totalTokens.mul(8).div(100)); _deliverTokens(bountyAddress, totalTokens.div(100)); rate = 10000; }",1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x39f9d4f50f1eb55948ba1e4a9a8432b1a371caf3.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable, Pausable, Destructible, Contactable { enum Stages { none, icoStart, icoEnd }",1
0xc7f1c3500496771b2ef4e17ad10624131ade5cd9.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _premine = 0x76D05E325973D7693Bb854ED258431aC7DBBeDc3; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x20c476bb4c7aa64f919278fb9c09e880583beb4c.sol,X3ProfitMainFundTransfer,contract X3ProfitMainFundTransfer { uint public constant maxBalance = 340282366920938463463374607431768211456 wei; address public constant ADDRESS_EIFP2_CONTRACT = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3; address public constant ADDRESS_ADMIN = 0x6249046Af9FB588bb4E70e62d9403DD69239bdF5; bool private isResend = false; function () external payable { if(msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 0.1 ether && !isResend)){ if(ADDRESS_EIFP2_CONTRACT.balance > maxBalance) { ADDRESS_ADMIN.transfer(address(this).balance); return; },1
0x33d1a1a2d781d395eace70e69423c594e52f1a8b.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,Johnsonville,contract Johnsonville { address owner; address patronOne; address patronTwo; address patronThree; bool patronOneWd; bool patronTwoWd; bool patronThreeWd; modifier onlyOwner { if(msg.sender != owner) throw; _; },1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FBT,"contract FBT is ERC20 { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bytes1) addresslevels; mapping (address => uint256) feebank; uint256 public totalSupply; uint256 public pieceprice; uint256 public datestart; uint256 public totalaccumulated; address dev1 = 0xFAB873F0f71dCa84CA33d959C8f017f886E10C63; address dev2 = 0xD7E9aB6a7a5f303D3Cd17DcaEFF254D87757a1F8; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); refundFees(); return true; }",1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x287fda15f8f002e5df9f536f10bbfc0816960f36.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 900000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xdae46fadfd30e7b6de74937626adf09d947ecc62.sol,PreIco,"contract PreIco is SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public manager; address public reserveManager; address public escrow; address public reserveEscrow; uint constant BASE = 1000000000000000000; uint public tokensSupplied = 0; uint public bountySupplied = 0; uint public constant SOFT_CAPACITY = 166666 * BASE; uint public constant TOKENS_SUPPLY = 600000 * BASE; uint public constant BOUNTY_SUPPLY = 350000 * BASE; uint public constant totalSupply = TOKENS_SUPPLY + BOUNTY_SUPPLY; uint public constant TOKEN_PRICE = 3000000000000000; uint tokenAmount1 = 200000 * BASE; uint tokenAmount2 = 200000 * BASE; uint tokenAmount3 = 200000 * BASE; uint tokenPriceMultiply1 = 1; uint tokenPriceDivide1 = 1; uint tokenPriceMultiply2 = 1041667; uint tokenPriceDivide2 = 1000000; uint tokenPriceMultiply3 = 1083333; uint tokenPriceDivide3 = 1000000; uint[] public tokenPriceMultiplies; uint[] public tokenPriceDivides; uint[] public tokenAmounts; mapping(address => uint) public ethBalances; uint[] public prices; uint[] public amounts; mapping(address => uint) private balances; uint public constant defaultDeadline = 1515679200; uint public deadline = defaultDeadline; bool public isIcoStopped = false; address[] public allowedTokens; mapping(address => uint) public tokenAmount; mapping(address => uint) public tokenPrice; address[] public usersList; mapping(address => bool) isUserInList; uint numberOfUsersReturned = 0; mapping(address => address[]) public userTokens; mapping(address => mapping(address => uint)) public userTokensValues; event BuyTokens(address indexed _user, uint _ethValue, uint _boughtTokens); event BuyTokensWithTokens(address indexed _user, address indexed _token, uint _tokenValue, uint _boughtTokens); event GiveReward(address indexed _to, uint _value); event IcoStoppedManually(); event IcoRunnedManually(); event WithdrawEther(address indexed _escrow, uint _ethValue); event WithdrawToken(address indexed _escrow, address indexed _token, uint _value); event ReturnEthersFor(address indexed _user, uint _value); event ReturnTokensFor(address indexed _user, address indexed _token, uint _value); event AddToken(address indexed _token, uint _amount, uint _price); event RemoveToken(address indexed _token); event MoveTokens(address indexed _from, address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyManager { assert(msg.sender == manager || msg.sender == reserveManager); _; }",1
0xa614bbfc9f7411ac008c78bfdd1a7f9e0e5180db.sol,Control,contract Control is QUASI { function Control() payable QUASI() public {},1
0x57bfffd48366f78e787e167419c8c05cdb849ede.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0xf221579d18f0c4c10c08ff9fe3d34bdbd7117909.sol,AtomCirculationCoin,"contract AtomCirculationCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkTGE,"contract WolkTGE is Wolk { mapping (address => uint256) contribution; mapping (address => uint256) presaleLimit; mapping (address => bool) presaleContributor; uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals; uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals; uint256 public presale_start_block; uint256 public start_block; uint256 public end_block; function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){ require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock)); presale_start_block = _presaleStartBlock; start_block = _startBlock; end_block = _endBlock; multisigWallet = _wolkWallet; wolkSale = _wolkSale; settlers[msg.sender] = true; return true; }",1
0x2931b36154a10bde01373af56623705d128155b5.sol,CryptoDuels,contract CryptoDuels is Owned { using SafeMath for uint; struct PLAYER { uint wad; uint lastJoin; uint lastDuel; uint listPosition; },1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0x7638a5f444eab0281ca1abff2c8029cbb806a566.sol,XOXOCoin,"contract XOXOCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 200000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,GladiEther,contract GladiEther is WeaponSales { function GladiEther() public payable { owner = msg.sender; },1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x72b2670e55139934d6445348dc6eab4089b12576.sol,TakeoutController,contract TakeoutController { address owner; address takeoutWallet; HourglassInterface private Hourglass; constructor() public { Hourglass = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); takeoutWallet = 0xf783A81F046448c38f3c863885D9e99D10209779; owner = msg.sender; },1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0x410af23334e26aa13c1f3e630bae006bdd313264.sol,ClearToken,"contract ClearToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x58558971833807aca62cff89017f78465405ce11.sol,Vitamin,"contract Vitamin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Vitamin() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant PAYBACK_PERMILLE = 2; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee, uint _discount ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x1dc994010375d1b6c0421f825c05c75f426031ec.sol,Grass,contract Grass is Math { uint256 public availableTokens; uint256 currentTokenPriceInDollar; uint256 public lastUpdateEtherPrice; uint256 public etherPriceInDollarIn; uint256 public etherPriceInDollarOut; function getCurrentTokenPrice() public constant returns (uint256) { uint256 today = getToday(); return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today]; },1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionToken,contract OptionToken is StandardToken { using SafeMath for uint256; OptionFactory public factory; ERC20 public firstToken; ERC20 public secondToken; uint public minIssueAmount; uint public expiry; uint public strikePrice; bool public isCall; string public symbol; uint public decimals; struct Issuer { address addr; uint amount; },1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x6f84faf2ce621f5a4ba161f055a56daffbf78b04.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0x1c80bf91b30c17019149acdb5ddc3dcb89122c8c.sol,QUICK_GAME,contract QUICK_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0f5ee401de162cd163b6ff46318eef2727dbb9fc.sol,MOIRAICO,"contract MOIRAICO { enum State { Preico, Ico, Successful }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x6a0a97e47d15aad1d132a1ac79a480e3f2079063.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x31e0bad1c91a49ca863e7fc63b53dc03441bbf2f.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x7021967e5d0761772c6fb25304f2d013865aba7c.sol,EpigenCareCrowdsale,contract EpigenCareCrowdsale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public startTime; uint256 public endTime; address public wallet; address public tokenPool; uint256 public rate; uint256 public weiRaised; uint256 public weiPending; uint256 public tokensPending; uint256 public minimumInvestment; mapping (address => Transaction) transactions; mapping (address => bool) approvedAddresses; mapping (address => bool) verifiers; struct Transaction { uint weiAmount; uint tokenAmount; },1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x7204f236b3ac144e119d9ac00717204c581a1845.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x6a5e59fbaea3e07737fbafceb600cbde5a295f24.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x25d14913c49b7e7808453044f7e2f12b89693dda.sol,CXE,"contract CXE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 2800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 500000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf331f7887d31714dce936d9a9846e6afbe82e0a0.sol,Ico,"contract Ico is Owned { enum State { Runned, Paused, Finished, Expired, Failed }",1
0x0174312e4aef436606ffdeb4d05d22fb68f36ba0.sol,LatiumSeller,contract LatiumSeller { address private constant _latiumAddress = 0xBb31037f997553BEc50510a635d231A35F8EC640; Latium private constant _latium = Latium(_latiumAddress); uint256 private _etherAmount = 0; uint256 private constant _tokenPrice = 10 finney; uint256 private _minimumPurchase = 10 * 10 ** uint256(_latium.decimals()); address public owner; function LatiumSeller() { owner = msg.sender; },1
0x1f3640b76fef8f0c8efeb13623387f3bce31e080.sol,Crowdsale,"contract Crowdsale is Ownable{ using SafeMath for uint; function pow(uint256 a, uint256 b) internal pure returns (uint256){ return (a**b); }",1
0xdfa66ec49cf0102fb8906ee3dd6a70597d9720d4.sol,DEKS,"contract DEKS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000e8; uint public target0drop = 12000; uint public progress0drop = 0; address multisig = 0xae4B0D603B563A3b26a585e5cF43f1Fb6f75295C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4d3b775a793aa40e52e5ebd76d1904318fcf4989.sol,TokenERC20,contract TokenERC20 is Ownable{ token public tokenReward = token(0x778E763C4a09c74b2de221b4D3c92d8c7f27a038); uint256 public bili = 7500; uint256 public endtime = 1540051199; uint256 public amount; address public addr = 0x2aCf431877107176c88B6300830C6b696d744344; address public addr2 = 0x6090275ca0AD1b36e651bCd3C696622b96a25cFF; function TokenERC20( ) public { },1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0x41b909cd4cda90f04d0aaf4097727544fd8ae47a.sol,XCTCrowdSale,contract XCTCrowdSale is SafeMath { address public beneficiary; uint256 public startBlock = 4969760; uint256 public constant hardCap = 4000 ether; uint256 public amountRaised; function XCTCrowdSale(address _beneficiary) public { beneficiary = _beneficiary; amountRaised = 0; },1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0x4d4d55dbdc229fc5ba788d74dff2d583056d86bb.sol,Ccl,contract Ccl{ address owner; constructor() public payable{ owner = msg.sender; },1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0xd90df6771085c94cfe850d35f7bbd36c77cd0847.sol,TokenFactoryCN,"contract TokenFactoryCN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TokenFactoryCN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x568f9f32969e29b5ce1a4545be5398e8cc7c4401.sol,Fivebalance,"contract Fivebalance is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x1293b8bc5cdf2bdda8811365dbdbac0df34f103e; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,TMTGBaseToken,"contract TMTGBaseToken is StandardToken, TMTGPausable, TMTGBlacklist, HasNoEther { uint256 public openingTime; struct investor { uint256 _sentAmount; uint256 _initialAmount; uint256 _limit; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0xf221579d18f0c4c10c08ff9fe3d34bdbd7117909.sol,AtomCirculationCoin,"contract AtomCirculationCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0x05e7039c7afd77157845d9a4f1750b8ca93ec378.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, bytes32 depositID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => mapping(bytes32 => uint)) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0xeba4ce0d799fe901f3af52c0e0f088d026b11c81.sol,CFNDCrowdsale,contract CFNDCrowdsale { Token public tokenReward; address public creator; address public owner = 0x56D215183E48881f10D1FaEb9325cf02171B16B7; uint256 private price; modifier isCreator() { require(msg.sender == creator); _; },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0x57ae3a491f4555e1eed37338d1b8b5222935f28a.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 1000; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x28f94409b40213d95c0bd942fa16d6c679475bec.sol,DEKSX,"contract DEKSX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x15cb96Fc0E4A208fDe11d80B59860B81474AD6D6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf48d72e5a2419c0c6f5822854b7bb7bf135d1623.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol,LimeEyes,contract LimeEyes { address private _dev; struct Artwork { string _title; address _owner; bool _visible; uint256 _basePrice; uint256 _purchases; address[] _shareholders; mapping (address => bool) _hasShares; mapping (address => uint256) _shares; },1
0x4831f53983eb50a9ffeee3d64762a70d7e6eb7f0.sol,MultiSender,"contract MultiSender is Ownable { using SafeMath for uint; string public constant NAME = ; event Transfer(address indexed holder, uint amount); function() public payable { }",1
0x54c716c88a3eb59f41e69f15d6714616fea64ed9.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint finneyCostOfEachToken, address addressOfTokenUsedAsReward) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = finneyCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x4b9d8e37bd266fe27adc45a31a6e1c2b9ca18737.sol,E_GAME,contract E_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0xec6ce30daf8195a65c83a29025bd334bc9481ca0.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 60000e18; uint public target0drop = 200; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsContest,contract CSportsContestBase { struct Team { address owner; int32 score; uint32 place; bool holdsEntryFee; bool ownsPlayerTokens; uint32[] playerTokenIds; },1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d5f8a079042d5071220498fa0f0d7fd2c5fffbe.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder() public { parentAddress = msg.sender; }",1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x1f0d1de1558582ad6f13763f477119a1455502af.sol,Exchange,contract Exchange is ContractReceiver { using SafeMath for uint256; using BytesLib for bytes; struct Order { address owner; bool active; address sellToken; address buyToken; address ring; uint256 amount; uint256 priceMul; uint256 priceDiv; },1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x726b61fa2a732c5946dd5059cad6f6f838c5ccfe.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionId); event Revocation(address sender, bytes32 transactionId); event Submission(bytes32 transactionId); event Execution(bytes32 transactionId); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0x6f1408e206d23d446e1580830f11f79c2e58d92b.sol,NRMc,"contract NRMc { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 20000000000000000000000000; uint256 perReserve = 2000000000000000000000000; bool startDone = false; bool finishDone = false; bool onefiveDone = false; address owner = 0; address reserve1 = 0x0d4dAA952a8840715d901f97EDb98973Ce8010F7; address reserve2 = 0xCd4846fF42C1DCe3E421cb4fE8d01523B962D641; address reserve3 = 0x2241C99B6f44Cc630a073703EdFDf3c9964CbE22; address reserve4 = 0x5c5bfC25A0B99ac5F974927F1f6D39f19Af9D14C; address reserve5 = 0xa8356f49640093cec3dCd6dcE1ff4Dfe3785c17c; bool prereserved1Done = false; bool prereserved2Done = false; bool prereserved3Done = false; bool prereserved4Done = false; bool prereserved5Done = false; address out1 = 0xF9D23f5d833dB355bfc870c8aCD9f4fc7EF05883; address out2 = 0x5c07f5DD4d3eE06A977Dee53072e10de9414E3f0; address out3 = 0xF425821a2545cF1414B6E342ff5D95f3c572a7CD; address out4 = 0xa873134afa83410787Ae29dBfB39e5C38ca05fF2; address out5 = 0x5E663D73de8205b3f339fAA5a4218AcA95963260; bool public out1Done = false; bool public out2Done = false; bool public out3Done = false; bool public out4Done = false; bool public out5Done = false; uint public amountRaised; uint public deadline; uint public overRaisedUnsend = 0; uint public backers = 0; uint public rate = 45000; uint public onefive = 0; uint _durationInMinutes = 0; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function NRMc(address adr) { if (startDone == false) { owner = adr; }",1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,PassToken,"contract PassToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 4; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,GenericCrowdsale,"contract GenericCrowdsale is Ownable { using SafeMath for uint256; enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}",1
0x72636c350431895fc6ee718b92bcc5b4fbd70304.sol,preSale3,contract preSale3 is Ownable { using SafeMath for uint; AgroTechFarmToken public token; bool public preSale3Finished = false; string public constant name = ; address public multisig; address public preSale = 0x02Dcc61022771015b1408323D29C790066CBe2e4; address public preSale1 = 0xfafbb19945fc2d79828e4c5813a619d5683074ba; address public preSale2 = 0x62451D37Ca2EC1f0499996Bc3C7e2BAF258E9729; uint public rate; uint public start; uint public end; uint public hardcap; address public restricted; uint public restrictedPercent; function preSale3() public { token = AgroTechFarmToken(0xa55ffAeA5c8cf32B550F663bf17d4F7b739534ff); multisig = 0x227917ac3C1F192874d43031cF4D40fd40Ae6127; rate = 83333333333000000000; start = 1520640000; end = 1522047600; hardcap = 500000000000000000000; restricted = 0xbcCd749ecCCee5B4898d0E38D2a536fa84Ea9Ef6; restrictedPercent = 35; },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xc81774fd1b51bc7e26b2bad562dcdb0a2cbebaf2.sol,Free,"contract Free is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 40000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 1500 * (10 ** uint256(decimals)) ; uint256 public constant decr = 25 * (10 ** 15) ; mapping(address => bool) touched; function Free() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint manusSent; }",1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xa20f317e3b6fe80ff76ee908860ecdb3edea4893.sol,TwelveHourFastTrain,contract TwelveHourFastTrain { address public owner; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; uint256 constant private THT_TOKEN_OWNERS = 10; address constant private PROMO = 0xC63eA85CC823c440319013d4B30E19b66466642d; uint constant public PROMO_PERCENT = 1; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.05 ether; uint256 constant public VERIFY_REFERRAL_PRICE = 0.01 ether; uint256 constant public REFERRAL = 3; uint constant public LAST_DEPOSIT_PERCENT = 10; LastDeposit public last; mapping(address => bool) public referrals; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x9224ca23168a20bc1b5e2a1627edf783e193d39c.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x5149474fd339e95271304b5b28f6e456a24c0e25.sol,MNSPAY,"contract MNSPAY is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function MNSPAY() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x6dfe212d1461014be1781b0be710dda1c036d8ef.sol,ZTST,"contract ZTST is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 30000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 50 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function ZTST() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0x47423b0fdb181ecab813c908307e9795c0272db7.sol,EtherToken,"contract EtherToken is UnlimitedAllowanceToken, Ownable{ using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; event Issuance(uint256 _amount); event Destruction(uint256 _amount); bool public enabled; address public safetyWallet; function EtherToken() public { enabled = true; safetyWallet = msg.sender; }",1
0x2c2a721d303dc4273725c6aa8704ec8d1d3d17b1.sol,GlitchGoonsProxy,"contract GlitchGoonsProxy is Ownable { constructor (address _emitter, address _administrator) public { setEmitter(_emitter); setAdministrator(_administrator); }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x997c48CE1AF0CE2658D3E4c0bea30a0eB9c98382; }",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FBT,"contract FBT is ERC20 { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bytes1) addresslevels; mapping (address => uint256) feebank; uint256 public totalSupply; uint256 public pieceprice; uint256 public datestart; uint256 public totalaccumulated; address dev1 = 0xFAB873F0f71dCa84CA33d959C8f017f886E10C63; address dev2 = 0xD7E9aB6a7a5f303D3Cd17DcaEFF254D87757a1F8; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); refundFees(); return true; }",1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff.sol,BeezGold,"contract BeezGold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 165 * 1 days; uint public round2 = now + 130 * 1 days; uint public round1 = now + 35 * 1 days; uint256 public totalSupply = 70000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25700e8; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0x654186811320885fC24C318E70a119A43279c1BE; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8545f796587f83a865b509d14115a5831121cefc.sol,Choicemining,"contract Choicemining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 25 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 11000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 50; uint256 public tokensPerEth = 25000e18; uint public target0drop = 4500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x41104edb2cefbb66cc28b17d507f0b4ba559f455.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x75cb629408d1ea387df0a1f755e0bc371a5fa036.sol,GoodLuckCasino,"contract GoodLuckCasino is Ownable{ using SafeMath for uint; event LOG_Deposit(bytes32 userID, address walletAddr, uint amount); event LOG_Withdraw(address user, uint amount); event LOG_Bankroll(address sender, uint value); event LOG_OwnerWithdraw(address _to, uint _val); event LOG_ContractStopped(); event LOG_ContractResumed(); bool public isStopped; mapping (bytes32 => uint[]) depositList; modifier onlyIfNotStopped { require(!isStopped); _; }",1
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x0f35d82007119dc339af57b29dc8ae794b92926c.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x0d62b001ca7f2fb4f9458f8585a0bb38a4d8fde7.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; using SafeERC20 for RESTOToken; uint256 hardCap = 50000 * 1 ether; address myAddress = this; RESTOToken public token = new RESTOToken(myAddress); uint64 crowdSaleStartTime = 1537401600; uint64 crowdSaleEndTime = 1544745600; TeamAddress1 public teamAddress1 = new TeamAddress1(); TeamAddress2 public teamAddress2 = new TeamAddress2(); MarketingAddress public marketingAddress = new MarketingAddress(); RetailersAddress public retailersAddress = new RetailersAddress(); ReserveAddress public reserveAddress = new ReserveAddress(); BountyAddress public bountyAddress = new BountyAddress(); uint256 public rate; uint256 public weiRaised; event Withdraw( address indexed from, address indexed to, uint256 amount ); event TokensPurchased( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor() public { uint256 totalTokens = token.INITIAL_SUPPLY(); _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000)); _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000)); _deliverTokens(marketingAddress, totalTokens.mul(18).div(100)); _deliverTokens(retailersAddress, totalTokens.mul(9).div(100)); _deliverTokens(reserveAddress, totalTokens.mul(8).div(100)); _deliverTokens(bountyAddress, totalTokens.div(100)); rate = 10000; }",1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0xf47f923b91422f47645f41425601c44f6b464300.sol,DAOT,"contract DAOT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 43 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 32 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x4bb12d68c795462c12ec30ad82421218d9c32a7d.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public percent; mapping(address => uint256) public percentOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event RewardToken(address backer, uint amount, uint percent); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward, uint initPercent ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken * 1 wei; tokenReward = token(addressOfTokenUsedAsReward); percent = initPercent; }",1
0x5576250692275701efde5eeb51596e2d9460790b.sol,UserDataManager,contract UserDataManager { using NameFilter for string; address private admin = msg.sender; uint256 public registrationFee_ = 0; mapping(uint256 => UserDataManagerReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; struct Player { address addr; bytes32 name; uint256 laff; },1
0x7430984e1d05d5f447c747123dd26845f6f17544.sol,ZethrBankroll,"contract ZethrBankroll is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event DevWithdraw(uint amountTotal, uint amountPerPerson); event EtherLogged(uint amountReceived, address sender); event BankrollInvest(uint amountReceived); event DailyTokenAdmin(address gameContract); event DailyTokensSent(address gameContract, uint tokens); event DailyTokensReceived(address gameContract, uint tokens); uint constant public MAX_OWNER_COUNT = 10; uint constant public MAX_WITHDRAW_PCT_DAILY = 15; uint constant public MAX_WITHDRAW_PCT_TX = 5; uint constant internal resetTimer = 1 days; address internal zethrAddress; ZTHInterface public ZTHTKN; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public isWhitelisted; mapping (address => uint) public dailyTokensPerContract; address internal divCardAddress; address[] public owners; address[] public whiteListedContracts; uint public required; uint public transactionCount; uint internal dailyResetTime; uint internal dailyTknLimit; uint internal tknsDispensedToday; bool internal reEntered = false; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x72f1295238a6a0d95631ad9f81b829c486861057.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5ae5a356aee6cea184a757c6bddd5b0aa4d38a07.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,MultiOwner,"contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x9224ca23168a20bc1b5e2a1627edf783e193d39c.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf441b73b0a196aa67d32aee230aab5e54eef4765.sol,RegionsToken,"contract RegionsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public regionIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public regionIndexToApproved; mapping (uint256 => uint256) private regionIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Region { string name; }",1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x0176d6746520dd73c2db032348530520d64e074e.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x70f187ea2ebcf5b94aa7819f41c92f9a9dc4c200.sol,LifePasswordAI,"contract LifePasswordAI is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 680000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function LifePasswordAI() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xedbc41b7d0330860be1dd8d682b2e868ae6da6e4.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBetting,contract MatchBetting { using SafeMath for uint256; struct Team { string name; mapping(address => uint) bettingContribution; mapping(address => uint) ledgerBettingContribution; uint totalAmount; uint totalParticipants; },1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FBT,"contract FBT is ERC20 { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bytes1) addresslevels; mapping (address => uint256) feebank; uint256 public totalSupply; uint256 public pieceprice; uint256 public datestart; uint256 public totalaccumulated; address dev1 = 0xFAB873F0f71dCa84CA33d959C8f017f886E10C63; address dev2 = 0xD7E9aB6a7a5f303D3Cd17DcaEFF254D87757a1F8; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); refundFees(); return true; }",1
0x72b2670e55139934d6445348dc6eab4089b12576.sol,TakeoutController,contract TakeoutController { address owner; address takeoutWallet; HourglassInterface private Hourglass; constructor() public { Hourglass = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); takeoutWallet = 0xf783A81F046448c38f3c863885D9e99D10209779; owner = msg.sender; },1
0x7241496a3fad5b8fd93b647399f57d7c835d2385.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 88000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x37b38b8d7b66a6e2e435847f86d9febe8142bf12.sol,NixmaCash,"contract NixmaCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 3000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e915b35cc269b2dfc8bbd8e4a88ed4884a53efc.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false ; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint startTimeInSeconds, uint durationInMinutes, uint szaboCostOfEachToken, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; price = szaboCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x4209f9bbb4e4dd48dbd84701fcaaab1d492b5a05.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x7909d3c14e5fb93a508582d04d11093585ebc084.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x6b106609bbea6f4c9ace8836aa3fb04c6b586c4e.sol,NewWorld,"contract NewWorld { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256[] private tokens; mapping (uint256 => address) public collectibleIndexToOwner; mapping (uint256 => address) public collectibleIndexToApproved; mapping (uint256 => uint256) public collectibleIndexToPrice; address public ceoAddress; address public cooAddress; mapping (uint => address) private subTokenCreator; uint16 constant MAX_CONTINENT_INDEX = 10; uint16 constant MAX_SUBCONTINENT_INDEX = 100; uint16 constant MAX_COUNTRY_INDEX = 10000; uint64 constant DOUBLE_TOKENS_INDEX = 10000000000000; uint128 constant TRIBLE_TOKENS_INDEX = 10000000000000000000000; uint128 constant FIFTY_TOKENS_INDEX = 10000000000000000000000000000000; uint256 private constant PROMO_CREATION_LIMIT = 50000; uint256 public promoCreatedCount; uint8 constant WORLD_TOKEN_ID = 0; uint256 constant START_PRICE_CITY = 1 finney; uint256 constant START_PRICE_COUNTRY = 10 finney; uint256 constant START_PRICE_SUBCONTINENT = 100 finney; uint256 constant START_PRICE_CONTINENT = 1 ether; uint256 constant START_PRICE_WORLD = 10 ether; function NewWorld() public { ceoAddress = msg.sender; cooAddress = msg.sender; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionToken,contract OptionToken is StandardToken { using SafeMath for uint256; OptionFactory public factory; ERC20 public firstToken; ERC20 public secondToken; uint public minIssueAmount; uint public expiry; uint public strikePrice; bool public isCall; string public symbol; uint public decimals; struct Issuer { address addr; uint amount; },1
0x0460dcb54214fdf68302b4c733ad7ed827dd6592.sol,evequiz,contract evequiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0xedc1936bbe9fee2abc523ad237aa62a3a3722177.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x78a73b6cbc5d183ce56e786f6e905cadec63547b.sol,FabricTokenFundraiser,contract FabricTokenFundraiserConfig is FabricTokenConfig { uint constant CONVERSION_RATE = 9000; uint constant TOKENS_HARD_CAP = 71250 * (10**3) * DECIMALS_FACTOR; uint constant START_DATE = 1518688800; uint constant END_DATE = 1522576800; uint constant TOKENS_LOCKED_CORE_TEAM = 12 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 7 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = START_DATE + 1 years; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = START_DATE + 180 days; uint constant TOKENS_BOUNTY_PROGRAM = 1 * (10**6) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 50000000000 wei; uint constant MIN_CONTRIBUTION = 0.1 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 9 ether; },1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,PornSceneToken,"contract PornSceneToken is ERC721 { event Birth(uint256 tokenId, string name, uint[] stars, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, uint[] stars); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 10000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public sceneIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public sceneIndexToApproved; mapping (uint256 => uint256) private sceneIndexToPrice; address public ceoAddress; address public cooAddress; PornstarsInterface pornstarsContract; uint currentAwardWinner = 85; uint256 public promoCreatedCount; struct Scene { string name; uint[] stars; }",1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4d6ec066345e3466d9e970caad4732983ae4bc2c.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x997c48CE1AF0CE2658D3E4c0bea30a0eB9c98382; }",1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,Presale,"contract Presale is AccessService, Random { ELHeroToken tokenContract; mapping (uint16 => uint16) public cardPresaleCounter; mapping (address => uint16[]) OwnerToPresale; uint256 public jackpotBalance; event CardPreSelled(address indexed buyer, uint16 protoId); event Jackpot(address indexed _winner, uint256 _value, uint16 _type); constructor(address _nftAddr) public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; tokenContract = ELHeroToken(_nftAddr); cardPresaleCounter[1] = 20; cardPresaleCounter[2] = 20; cardPresaleCounter[3] = 20; cardPresaleCounter[4] = 20; cardPresaleCounter[5] = 20; cardPresaleCounter[6] = 20; cardPresaleCounter[7] = 20; cardPresaleCounter[8] = 20; cardPresaleCounter[9] = 20; cardPresaleCounter[10] = 20; cardPresaleCounter[11] = 20; cardPresaleCounter[12] = 20; cardPresaleCounter[13] = 20; cardPresaleCounter[14] = 20; cardPresaleCounter[15] = 20; cardPresaleCounter[16] = 20; cardPresaleCounter[17] = 20; cardPresaleCounter[18] = 20; cardPresaleCounter[19] = 20; cardPresaleCounter[20] = 20; cardPresaleCounter[21] = 20; cardPresaleCounter[22] = 20; cardPresaleCounter[23] = 20; cardPresaleCounter[24] = 20; cardPresaleCounter[25] = 20; }",1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x4d442dd04432685febb4330bb6cf955f61d4da36.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10; uint256 public tokensPerEth = 10000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x1fe3825a3012e581843a483df1452fc2fa4f0bad.sol,JcashRegistrar,"contract JcashRegistrarInterface { event ReceiveEthEvent(address indexed from, uint256 value); event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value); event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value); event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value); event ReplenishEthEvent(address indexed from, uint256 value); event WithdrawEthEvent(address indexed to, uint256 value); event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value); event PauseEvent(); event UnpauseEvent(); function withdrawEth(uint256 _weivalue) external; function withdrawToken(address _tokenAddress, uint256 _weivalue) external; function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external; function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external; function isProcessedTx(bytes32 _txHash) public view returns (bool); }",1
0x1c8c70478e92abc44843245bd6d88035236b4ed9.sol,MajorityGame,contract MajorityGameFactory { address[] private deployedGames; address[] private endedGames; address private adminAddress; mapping(address => uint) private gameAddressIdMap; uint private gameCount = 38; uint private endedGameCount = 0; modifier adminOnly() { require(msg.sender == adminAddress); _; },1
0x718f1892987a871fbe81462597e6dcd2900e127f.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; uint256 amountEth; },1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0xa1edc78199a6e56fd52f69cf7c10f67ded15185d.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x37a857e007ba6ae7862bc5ab1104dd4396de7950.sol,TaskRegister,"contract TaskRegister is Upgradable, VanityLib { using SafeMath for uint256; enum TaskType { BITCOIN_ADDRESS_PREFIX }",1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0x9c406e291f41eb50f152dec37196d01f751b5656.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x7909d3c14e5fb93a508582d04d11093585ebc084.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x4055bd5a000d97bfca86d71386dc85001eb738f6.sol,Imt,contract Imt{ address owner; constructor() public payable{ owner = msg.sender; },1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0xd37df7051977462c84d2a89cd78a0a91ff85d645.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xec6ce30daf8195a65c83a29025bd334bc9481ca0.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 60000e18; uint public target0drop = 200; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdd40b5a5b00d8913f3e1d6bb5cbbcd18a956b215.sol,REPOExchange,contract REPOExchange is MintableToken { uint public deal_cancel_rate = 0; struct REPODeal { address lender; address borrower; address collateral; address pledge; uint collateralAmount; uint pledgeAmount; uint interest; uint lenderFee; uint borrowerFee; uint pledgeUntil; uint collateralUntil; uint endsAt; int state; },1
0x1da73fc09ea07781482994036a0eecc7e6952dfb.sol,TydoIco,"contract TydoIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; uint256[] public bonuses; uint256[] public bonusEnds; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken, uint256[] _bonuses, uint256[] _bonusEnds) Owned() public { require(_bonuses.length == _bonusEnds.length); for(uint8 i = 0; i < _bonuses.length; i++) { require(_bonuses[i] > 0); if (i > 0) { }",1
0x4209f9bbb4e4dd48dbd84701fcaaab1d492b5a05.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x54a5ca46eb8830520453d417dcdfd83c1bfb5f54.sol,BGS,"contract BGS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 120000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BGS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x422401a78d6fb4727f96cc435884ecf5ce16f527.sol,FollowersToken,contract FollowersToken is ERC721 { string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private firstStepLimit = 6.4 ether; uint256 private secondStepLimit = 120.9324 ether; uint256 private thirdStepLimit = 792.5423 ether; bool private isPresale; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; mapping (uint256 => uint256) private personIndexToPriceLevel; address public ceoAddress; address public cooAddress; struct Person { string name; },1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x330ac216a5a8ccd493f3b9e33a524be3c7124217.sol,Bonds,contract Bonds { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x71c11a3b3a13a2e4a23c760722691952319ac7b9.sol,Roulette,contract Roulette { uint betAmount; uint necessaryBalance; uint nextRoundTimestamp; address creator; uint256 maxAmountAllowedInTheBank; mapping (address => uint256) winnings; uint8[] payouts; uint8[] numberRange; struct Bet { address player; uint8 betType; uint8 number; },1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x0248f089a622b74cebaa62573605af9a44966bf1.sol,Ethraffle,contract Ethraffle { struct Contestant { address addr; uint raffleId; },1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0x20d4ec1b92cc4570c74efd968d04660b8fcc0406.sol,PornLoversToken,"contract PornLoversToken is HasNoTokens, AbstractVirtualToken { uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether; uint256 private constant VIRTUAL_COUNT = 91; event LogBonusSet(address indexed _address, uint256 _amount); function virtualBalanceOf(address _owner) internal view returns (uint256) { return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0; }",1
0x27f2bf478f7d0c431328a56005b68432d18f26c5.sol,QUIK_QUIZ,contract QUIK_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol,WIDEC,"contract WIDEC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0xC66BE798fb6fccb44893307a44186B19e20437cf ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xa181b8c9f6b43b8252c6c9826cf5feba362b542e.sol,CryptoStamps,"contract CryptoStamps is ERC721 { event stampBirth(uint256 tokenId, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private firstStepLimit = 1.28 ether; mapping (uint256 => address) public stampIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public stampIndexToApproved; mapping (uint256 => uint256) private stampIndexToPrice; mapping(uint256 => uint256) public stampIndextotransactions; uint256 public totaletherstransacted; uint256 public totaltransactions; uint256 public stampCreatedCount; mapping (uint256 => bool) public stampIndextodissolved; mapping (uint256 => address) public dissolvedIndexToApproved; struct Stamp { uint256 birthtime; }",1
0x2d35297a8f988a5d8bda3d63d398b529bba0b107.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { uint constant UPGRADE_FREEZE_TIME = 3 days; using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; address pendingVersion; uint pendingVersionTimestamp; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,NoOwnerEx,contract NoOwnerEx is NoOwner { function reclaimEther(address _to) external onlyOwner { _to.transfer(address(this).balance); },1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x20da2ff263e28e8db8ef44f590ff4576bac770e2.sol,MilFold,"contract MilFold is MilFoldInterface,Milevents { using SafeMath for *; uint256 constant private rndMax_ = 90000; uint256 constant private claimMax_ = 43200; address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; uint256 constant private MIN_ETH_BUYIN = 0.002 ether; uint256 constant private COMMON_REWARD_AMOUNT = 0.01 ether; uint256 constant private CLAIM_WINNER_REWARD_AMOUNT = 1 ether; uint256 constant private MAX_WIN_AMOUNT = 5000 ether; uint256 private rID_; uint256 private lID_; uint256 private lBlockNumber_; bool private activated_; MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F); MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9); mapping (address => uint256) private playerTickets_; mapping (uint256 => Mildatasets.Round) private round_; mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_; mapping (address => uint256) private playerWinTotal_; modifier isActivated() { require(activated_ == true, ); _; }",1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x4055bd5a000d97bfca86d71386dc85001eb738f6.sol,Imt,contract Imt{ address owner; constructor() public payable{ owner = msg.sender; },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x21ae174c592cbb476819344a895d0e9219f5cc79.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 1 hours; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool mutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x6eccca96d6a238aae183440beeff39d9ba81054c.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x27e7383e49be6fd965805a0302b32e40c3d9981e.sol,CarTaxiBonus,contract CarTaxiBonus { CarTaxiCrowdsale public carTaxiCrowdsale; CarTaxiToken public carTaxiToken; address public owner; address public carTaxiCrowdsaleAddress = 0x77CeFf4173a56cd22b6184Fa59c668B364aE55B8; address public carTaxiTokenAddress = 0x662aBcAd0b7f345AB7FfB1b1fbb9Df7894f18e66; uint constant BASE = 1000000000000000000; uint public totalTokens; uint public totalBonuses; uint public iteration = 0; bool init = false; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xedbc41b7d0330860be1dd8d682b2e868ae6da6e4.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x33147d0f721ddfd82408dd1c890eff4ad7ecd80e.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x70b86b328b14b2f58f137436607cff45e4545617.sol,quiz_BLZ,contract quiz_BLZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x535ab96be208f115302facee73ae976e9174ac0b.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,TMTGBaseToken,"contract TMTGBaseToken is StandardToken, TMTGPausable, TMTGBlacklist, HasNoEther { uint256 public openingTime; struct investor { uint256 _sentAmount; uint256 _initialAmount; uint256 _limit; }",1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0x2ada0cddb716033e52c3d591ad12a59103230e52.sol,SGEICO,contract SGEICO { Token public tokenReward; address public creator; address public owner = 0x8dfFcCE1d47C6325340712AB1B8fD7328075730C; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x25d14913c49b7e7808453044f7e2f12b89693dda.sol,CXE,"contract CXE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 2800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 500000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0xf030b8fbe57c4498298449fc78a0f7054a5ef76d.sol,ArkToken,"contract ArkToken is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; mapping (uint256 => Animal) public arkData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => uint256) public babies; mapping (uint256 => uint256[2]) public babyMommas; mapping (uint256 => uint256) public mates; mapping (uint256 => uint256) public babyMakinPrice; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public birtherBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Birth(address indexed _birther, uint256 indexed _mom, uint256 _dad, uint256 indexed _baby); uint256 private firstCap = 0.5 ether; uint256 private secondCap = 1.0 ether; uint256 private thirdCap = 1.5 ether; uint256 private finalCap = 3.0 ether; struct Animal { uint256 price; uint256 lastPrice; address owner; address birther; uint256 birtherPct; uint8 gender; }",1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,CampaignContract,contract CampaignContract { using SafeMath for uint256; address internal owner; uint256 public minUSD; uint256 public maxUSD; uint256 public maxContribution; uint256 public minContribution; struct KYCObject { bytes32 phone; bytes32 name; bytes32 occupation; bytes32 addressOne; bytes32 addressTwo; },1
0x568f9f32969e29b5ce1a4545be5398e8cc7c4401.sol,Fivebalance,"contract Fivebalance is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x1293b8bc5cdf2bdda8811365dbdbac0df34f103e; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreRefundVault,"contract IRBPreRefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Forwarder,"contract Forwarder { address private parentAddress = 0x7aeCf441966CA8486F4cBAa62fa9eF2D557f9ba7; address[] private owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; event ForwarderDeposited(address from, uint value, bytes data); constructor() public { }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Fifteen,contract Fifteen is Payments { mapping (uint8 => mapping (uint8 => mapping (uint8 => uint8))) public fifteenPuzzles; mapping (uint8 => address) public puzzleIdOwner; mapping (uint8 => uint256) public puzzleIdPrice; uint256 public jackpot = 0; function initNewGame() public onlyCoOwner payable { require (msg.value>0); require (jackpot == 0); jackpot = msg.value; uint8 row; uint8 col; uint8 num; for (uint8 puzzleId=1; puzzleId<=6; puzzleId++) { num=15; puzzleIdOwner[puzzleId] = address(this); puzzleIdPrice[puzzleId] = 0.001 ether; for (row=1; row<=4; row++) { for (col=1; col<=4; col++) { fifteenPuzzles[puzzleId][row][col]=num; num--; },1
0x0f292cc21a59f248ca34ed159db0262f2f97d2f1.sol,Alfa_QUIZ,contract Alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x0de197dc289d680e734ccab866d529505b2638db.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,Participant,"contract Participant { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; address public owner; uint public daily; constructor(address _owner, uint _daily) public { owner = _owner; daily = _daily; }",1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d9a437282ba395664ed7d26df2377659a7e16af.sol,SaleTracker,"contract SaleTracker is Pausable { using SafeMath for uint256; event PurchaseMade (address indexed _from, bytes8 _paymentCode, uint256 _value); mapping(address => uint256) public purchases; address[] public purchaserAddresses; bool public enforceAddressMatch; function SaleTracker(bool _enforceAddressMatch) { enforceAddressMatch = _enforceAddressMatch; pause(); }",1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0x44d8289f8f0070f9c6b1c0dd849110f204c4bdf7.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,EMPRO,"contract EMPRO is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0x294789e8b87f471caa39c4757204f945683091e5.sol,AMFC,"contract AMFC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 500000000 * (10 ** uint256(decimals)); address constant LOCK_ADDR = 0xF63Fb7657B11B408eEdD263fE0753E1665E7400a; uint256 constant LOCK_SUPPLY = 300000000 * (10 ** uint256(decimals)); uint256 constant UNLOCK_2Y = 200000000 * (10 ** uint256(decimals)); uint256 constant UNLOCK_1Y = 100000000 * (10 ** uint256(decimals)); uint256 constant OWNER_SUPPLY = INITIAL_SUPPLY - LOCK_SUPPLY; mapping(address => uint256) balanceLocked; mapping(address => uint256) lockAtTime; uint256 public buyPrice = 585; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = OWNER_SUPPLY; emit Transfer(0x0, msg.sender, OWNER_SUPPLY); balances[LOCK_ADDR] = LOCK_SUPPLY; emit Transfer(0x0, LOCK_ADDR, LOCK_SUPPLY); _lock(LOCK_ADDR); }",1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55.sol,OrganicumOrders,contract OrganicumOrders { struct order { uint256 balance; uint256 tokens; },1
0x58a687bb4a7a4220e65f9b6f913580e5bec4a7bc.sol,EnergiPlus,"contract EnergiPlus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 35000e8; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0x4e0134dB37A5c67E1572BE270C1E34C5f67cdBc0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc.sol,zeepay,"contract zeepay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x3c93bcB8dc2b78570B343dB9c6F56397Fe77164b ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0x27e7383e49be6fd965805a0302b32e40c3d9981e.sol,CarTaxiBonus,contract CarTaxiBonus { CarTaxiCrowdsale public carTaxiCrowdsale; CarTaxiToken public carTaxiToken; address public owner; address public carTaxiCrowdsaleAddress = 0x77CeFf4173a56cd22b6184Fa59c668B364aE55B8; address public carTaxiTokenAddress = 0x662aBcAd0b7f345AB7FfB1b1fbb9Df7894f18e66; uint constant BASE = 1000000000000000000; uint public totalTokens; uint public totalBonuses; uint public iteration = 0; bool init = false; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf0ccca32cd300356629216eb301ec6649c7c6adb.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc4aad17558fa95c8937d0856b2dad74c1a7a095f.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x0d722c159eaacd74eb3fc8ce65832706cf294b33.sol,CoinFlipper,contract CoinFlipper{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Administration,"contract Administration is SafeMath{ event Pause(); event Unpause(); event PriceRaise(); event PriceStop(); address public CEOAddress; address public CTOAddress; uint oneEth = 1 ether; uint public feeUnit = 1 finney; uint public preSaleDurance = 45 days; bool public paused = false; bool public pricePause = true; uint public startTime; uint public endTime; uint[3] raiseIndex = [ 3, 7, 5 ]; uint[3] rewardPercent = [ 15, 25, 30 ]; modifier onlyCEO() { require(msg.sender == CEOAddress); _; }",1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x64ef6612a67de3fa96accb645ae46a3c09227928.sol,Economeme,"contract Economeme is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; uint256 public submissionPool; uint256 public submissionPrice; uint256 public endingBalance; mapping (uint256 => Meme) public memeData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public creatorBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Creation(address indexed _creator, uint256 _tokenId, uint256 _timestamp); uint256 private firstCap = 0.02 ether; uint256 private secondCap = 0.5 ether; uint256 private thirdCap = 2.0 ether; uint256 private finalCap = 5.0 ether; struct Meme { uint256 price; address owner; address creator; }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x1f7ec3f8cd87864646358c54093618363bc2028d.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0x6bec76a319d3b97523f50137ba20ec63746ac49a.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Forwarder,"contract Forwarder { address private parentAddress = 0x7aeCf441966CA8486F4cBAa62fa9eF2D557f9ba7; address[] private owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; event ForwarderDeposited(address from, uint value, bytes data); constructor() public { }",1
0x383bf1fd04d0901bbd674a580e0a621fcbb4799b.sol,CryptoDoggies,"contract CryptoDoggies is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, bytes5 dna, uint256 price, address owner); event TokenSold( uint256 indexed tokenId, string name, bytes5 dna, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner ); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) private tokenIdToApproved; struct Doggy { string name; bytes5 dna; }",1
0x6ec75c4eddd6838049478ac386dacd74d53c22cd.sol,X2Equal,contract X2Equal { address Owner = msg.sender; function() public payable {},1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x27f2bf478f7d0c431328a56005b68432d18f26c5.sol,QUIK_QUIZ,contract QUIK_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,AceDice,contract AceDice is usingOraclize { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint64 public oraclizeGasLimit; uint public oraclizeGasPrice; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x2c82c73d5b34aa015989462b2948cd616a37641f.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6d69fcb28c9fcc9e9d39e3608190b24f4df295e7.sol,EtherShuffle,"contract EtherShuffle is Operable { uint256 public nextGameId = 1; uint256 public lowestGameWithoutQuorum = 1; uint256[5] public distributions = [300000000000000000, 250000000000000000, 225000000000000000, 212500000000000000, 0]; uint8 public constant countOfParticipants = 5; uint256 public gamePrice = 100 finney; mapping (uint256 => Shuffle) public games; mapping (address => uint256[]) public gamesByPlayer; mapping (uint256 => uint256) public gamesWithoutQuorum; mapping (address => uint256) public balances; struct Shuffle { uint256 id; address[] players; bytes32 hash; uint8[5] result; bytes32 secret; uint256 value; }",1
0x33ac37240f71629294de98e0b51f904fda17a366.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0xeb9b5d44ba6225eb74101549fc1c45576cb3c42e.sol,DRAGON,"contract DRAGON is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 10000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 5000; uint256 public tokensPerEth = 10000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x618972f94fc60a13bb1f2045106d95a214569f07; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x7369bdbcc09c083dccd99a048046c2bbfe96ba0c.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0xdc99adde3a358e5ff62fff3f26b2296f8cca2306.sol,TokenFactoryCN,"contract TokenFactoryCN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 900000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TokenFactoryCN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileCycleWithAssistance,contract AgileCycleWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; uint public promisedTokens; uint public raisedEther; bool public tokenReleaseAtStart; address public icoAddress; address public arbitrationAddress; bool public roundFailedToStart; address public projectWallet; address public juryOnlineWallet; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x330af5ff0b2f883c86de0ec09f3456d686bdc93e.sol,BetOnMe,"contract BetOnMe is StandardToken { string public name = ; string public symbol = ; address public coinMaster; event UpdatedInformation(string newName, string newSymbol); function BetOnMe() public { supplyNum = 1000000000000 * (10 ** 18); decimals = 18; coinMaster = msg.sender; mapBalances[coinMaster] = supplyNum; }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x0dea9b8e6bf08d6859e29256942916f0cfb884fb.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0xafa4d6513e811f6fea5134214ab3bb1df824c4a0.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x733237b46b1fd6bd3266c9b6daae1c018a9d9493.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 65000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x2d92102bf50c111d59b93f7a10bafd13e770ed61.sol,XTVToken,"contract XTVToken is XTVNetworkGuard, ERC20Token { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public fullfillTeamAddress; address public fullfillFounder; address public fullfillAdvisors; address public XTVNetworkContractAddress; bool public airdropActive; uint public startTime; uint public endTime; uint public XTVAirDropped; uint public XTVBurned; mapping(address => bool) public claimed; uint256 private constant TOKEN_MULTIPLIER = 1000000; uint256 private constant DECIMALS = 10 ** decimals; uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS; modifier isAirdropActive() { require(airdropActive); _; }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State {Active, Refunding, Closed}",1
0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3.sol,ButterCoin,"contract ButterCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 370 * 1 days; uint public round2 = now + 320 * 1 days; uint public round1 = now + 220 * 1 days; uint256 public totalSupply = 5000000000000000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000000000; uint public target0drop = 10; uint public progress0drop = 0; address multisig = 0x686E275CE6Fe968d1064C102613E6c23c78DC58a ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x01058f3806cc9c04e3542de8a284c902f3876f82.sol,TradeToken,"contract TradeToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 5000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TradeToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x1bb0a576936bce5d983e676073ac48ba49f12e05.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x6b106609bbea6f4c9ace8836aa3fb04c6b586c4e.sol,NewWorld,"contract NewWorld { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256[] private tokens; mapping (uint256 => address) public collectibleIndexToOwner; mapping (uint256 => address) public collectibleIndexToApproved; mapping (uint256 => uint256) public collectibleIndexToPrice; address public ceoAddress; address public cooAddress; mapping (uint => address) private subTokenCreator; uint16 constant MAX_CONTINENT_INDEX = 10; uint16 constant MAX_SUBCONTINENT_INDEX = 100; uint16 constant MAX_COUNTRY_INDEX = 10000; uint64 constant DOUBLE_TOKENS_INDEX = 10000000000000; uint128 constant TRIBLE_TOKENS_INDEX = 10000000000000000000000; uint128 constant FIFTY_TOKENS_INDEX = 10000000000000000000000000000000; uint256 private constant PROMO_CREATION_LIMIT = 50000; uint256 public promoCreatedCount; uint8 constant WORLD_TOKEN_ID = 0; uint256 constant START_PRICE_CITY = 1 finney; uint256 constant START_PRICE_COUNTRY = 10 finney; uint256 constant START_PRICE_SUBCONTINENT = 100 finney; uint256 constant START_PRICE_CONTINENT = 1 ether; uint256 constant START_PRICE_WORLD = 10 ether; function NewWorld() public { ceoAddress = msg.sender; cooAddress = msg.sender; }",1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { uint constant UPGRADE_FREEZE_TIME = 3 days; using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; address pendingVersion; uint pendingVersionTimestamp; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e.sol,Locksmith,"contract Locksmith is owned, logger, helper { uint public nonce; uint public m_proofs; bool public didProve; bytes32 public lock; string public protocol = ; struct proof { address prover; address receiver; string key; bytes32 lock; }",1
0x6515dd4d7102883fab9f473b1aeb82dbe10a7d5a.sol,ETH_Game,contract ETH_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e.sol,PerfectCoinControl,contract PerfectCoinControl is PerfectCoin { function PerfectCoinControl() payable PerfectCoin() public {},1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x4d3b775a793aa40e52e5ebd76d1904318fcf4989.sol,TokenERC20,contract TokenERC20 is Ownable{ token public tokenReward = token(0x778E763C4a09c74b2de221b4D3c92d8c7f27a038); uint256 public bili = 7500; uint256 public endtime = 1540051199; uint256 public amount; address public addr = 0x2aCf431877107176c88B6300830C6b696d744344; address public addr2 = 0x6090275ca0AD1b36e651bCd3C696622b96a25cFF; function TokenERC20( ) public { },1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x92ccb32f34ca7abf1e0f5ba9b0167b607ea6b5ac.sol,LO_QUIZ,contract LO_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xcf70f36f8fd04713b33900bab530fd2f63ed9ae0.sol,TheNextBlock,"contract TheNextBlock { using SafeMath for uint256; event BetReceived(address sender, address betOnMiner, address miner); event Jackpot(address winner, uint256 amount); struct Owner { uint256 balance; address addr; }",1
0x4d08514e336ed1b1ebdeea15318a3e2603e1dfca.sol,x_game,contract x_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0xa182e841de328bd94090e02e7df1acbeb1aed677.sol,ETbankWord,"contract ETbankWord is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function ETbankWord() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x3ff6acf819fb93bf101a035602c2f131d6a20b75.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0x05af72594440cf75c0fdcbbd9993fc26f62c7afc.sol,TwelveHourAuction,contract TwelveHourAuction { bool init = false; using SafeMath for uint256; address owner; uint256 public round = 0; uint256 public nextPot = 0; uint256 public profitTHT = 0; uint256 constant private THT_TOKEN_OWNERS = 10; uint256 constant private KEY_HOLDERS_DIVIDEND = 30; uint256 constant private REFERRAL = 10; uint256 constant private FINAL_POT = 30; uint256 constant private MARKETING = 5; uint256 constant private MAGINITUDE = 2 ** 64; uint256 constant private HALF_TIME = 12 hours; uint256 constant private KEY_PRICE_DEFAULT = 0.005 ether; uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public referrals; address[10] public teamMarketing; struct Game { uint256 round; uint256 finalPot; uint256 profitPerShare; address keyHolder; uint256 keyLevel; uint256 endTime; bool ended; },1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa.sol,quizgame,contract quizgame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0x4b5da69c6289bd71d643710d0a63bd4867808451.sol,JPYC,contract JPYC is CoolPandaToken { using SafeMath for uint256; string public name = ; uint256 _initialSupply = 10000000000 * 10 ** uint256(decimals); string public symbol = ; address public paoContactAddress; event Issue(uint256 amount); constructor() public { tokenPrice = 47000; totalSupply = _initialSupply; balances[fundWallet] = _initialSupply; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x58a687bb4a7a4220e65f9b6f913580e5bec4a7bc.sol,EnergiPlus,"contract EnergiPlus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 35000e8; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0x4e0134dB37A5c67E1572BE270C1E34C5f67cdBc0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol,LimeEyes,contract LimeEyes { address private _dev; struct Artwork { string _title; address _owner; bool _visible; uint256 _basePrice; uint256 _purchases; address[] _shareholders; mapping (address => bool) _hasShares; mapping (address => uint256) _shares; },1
0x8a6bc1397dbe756a04217c15be8097d3fbcaf4ba.sol,QUEST_Xz,contract QUEST_Xz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0xedb94888eff041eb50c9fc92c360f66afb3b94c5.sol,ExoplanetToken,"contract ExoplanetToken is ERC721 { using SafeMath for uint256; event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner); event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); event ContractUpgrade(address newContract); string public constant NAME = ; string public constant SYMBOL = ; string public constant BASE_URL = ""https: uint32 private constant NUM_EXOPLANETS_LIMIT = 4700; uint256 private constant STEP_1 = 5.0 ether; uint256 private constant STEP_2 = 10.0 ether; uint256 private constant STEP_3 = 26.0 ether; uint256 private constant STEP_4 = 36.0 ether; uint256 private constant STEP_5 = 47.0 ether; uint256 private constant STEP_6 = 59.0 ether; uint256 private constant STEP_7 = 67.85 ether; uint256 private constant STEP_8 = 76.67 ether; mapping (uint256 => address) public currentOwner; mapping (address => uint256) private numOwnedTokens; mapping (uint256 => address) public approvedToTransfer; mapping (uint256 => uint256) private currentPrice; address public ceoAddress; address public cooAddress; bool public inPresaleMode = true; bool public paused = false; address public newContractAddress; struct ExoplanetRec { uint8 lifeRate; uint32 priceInExoTokens; uint32 numOfTokensBonusOnPurchase; string name; string cryptoMatch; string techBonus1; string techBonus2; string techBonus3; string scientificData; }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,HasNoEther,contract HasNoEther is Ownable { constructor() public payable { require(msg.value == 0); },1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x4802fe0bf7eb3b3b0dce3ede89c575341f10e3e0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0xece7814a9691a94e7f3d9354155e21cfb291e13b.sol,AlmightyKeyChain,"contract AlmightyKeyChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function AlmightyKeyChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0xdc9f5b24b910addcb2e3be7ff75caf20e1fcdcf3.sol,PAD,"contract PAD is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; uint256 public constant INITIAL_SUPPLY = 4200000000 * (10 ** uint256(decimals)); uint public amountRaised; uint256 public buyPrice = 50000; bool public crowdsaleClosed; function PAD() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xdc8d902c34f2257b8569dc9bc4f58cc149ed6e48.sol,GitmanIssue,"contract GitmanIssue { address private mediator; address public parent; string public owner; string public repository; string public issue; constructor (string ownerId, string repositoryId, string issueId, address mediatorAddress) public payable { parent = msg.sender; mediator = mediatorAddress; owner = ownerId; repository = repositoryId; issue = issueId; }",1
0xbf6008bd7ac150e50fbb4efe6aa6af5ae47362b9.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionHash); event Revocation(address sender, bytes32 transactionHash); event Submission(bytes32 transactionHash); event Execution(bytes32 transactionHash); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequiredUpdate(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x6bd26bb09c992e09d2156b48f723e56e52eead9c.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0x7609a798cf9e86622364326f5d1e523a030e19b4.sol,XenoxToken,"contract XenoxToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xdc8adca00787b665abbaacaef37c8bb629ebaa8f.sol,TopIvy,"contract TopIvy { string public constant NAME = ; uint256 public constant voteCost = 0.001 ether; string public constant schoolOrdering = ; address public ceoAddress; uint256[8] public voteCounts = [1,1,1,1,1,1,1,1]; modifier onlyCEO() { require(msg.sender == ceoAddress); _; }",1
0x7229bb50da9c01b28b9f1aace7711605d88afbd3.sol,OysterPrePearl,"contract OysterPrePearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public funds = 0; address public owner; address public partner; bool public saleClosed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OysterPrePearl() public { owner = msg.sender; partner = 0x0524Fe637b77A6F5f0b3a024f7fD9Fe1E688A291; }",1
0x4d08514e336ed1b1ebdeea15318a3e2603e1dfca.sol,x_game,contract x_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,ERC721dAppCaps,"contract ERC721dAppCaps is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721, Ownable, Fallback { event BoughtToken(address indexed buyer, uint256 tokenId); string public constant company = ; string public constant contact = ""https: string public constant author = ; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MAX_LENGTH = 100000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescriptions; mapping(uint256 => string) specialQualities; mapping(uint256 => string) tokenClasses; mapping(uint256 => string) iptcKeywords; constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,EMPRO,"contract EMPRO is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyPilot,"contract HorseyPilot { event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,withdrawable,"contract withdrawable is Ownable { event ReceiveEther(address _from, uint256 _value); event WithdrawEther(address _to, uint256 _value); event WithdrawToken(address _token, address _to, uint256 _value); function () payable public { emit ReceiveEther(msg.sender, msg.value); }",1
0xf48d72e5a2419c0c6f5822854b7bb7bf135d1623.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x2671bf62fdf173cfcb4b178d1a563ca84a349dc3.sol,D_QUIZ,contract D_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6cd27bd3a3643da8145b152766aea2fef0a54670.sol,Simpl_iQuiz,contract Simpl_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4c60e311d8fba04e313f7e7b3dec61b3028726d1.sol,EtherWorldCup,"contract EtherWorldCup { using SafeMath for uint; address internal constant administrator = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae; address internal constant givethAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; string name = ; string symbol = ; mapping (string => int8) worldCupGameID; mapping (int8 => bool) gameFinished; mapping (int8 => uint) gameLocked; mapping (int8 => string) gameResult; int8 internal latestGameFinished; uint internal prizePool; uint internal givethPool; int registeredPlayers; mapping (address => bool) playerRegistered; mapping (address => mapping (int8 => bool)) playerMadePrediction; mapping (address => mapping (int8 => string)) playerPredictions; mapping (address => int8[64]) playerPointArray; mapping (address => int8) playerGamesScored; mapping (address => uint) playerStreak; address[] playerList; event Registration( address _player ); event PlayerLoggedPrediction( address _player, int _gameID, string _prediction ); event PlayerUpdatedScore( address _player, int _lastGamePlayed ); event Comparison( address _player, uint _gameID, string _myGuess, string _result, bool _correct ); event StartAutoScoring( address _player ); event StartScoring( address _player, uint _gameID ); event DidNotPredict( address _player, uint _gameID ); event RipcordRefund( address _player ); constructor () public { worldCupGameID[] = 1; gameLocked[1] = 1528988400; worldCupGameID[] = 2; worldCupGameID[] = 3; worldCupGameID[] = 4; gameLocked[2] = 1529064000; gameLocked[3] = 1529074800; gameLocked[4] = 1529085600; worldCupGameID[] = 5; worldCupGameID[] = 6; worldCupGameID[] = 7; worldCupGameID[] = 8; gameLocked[5] = 1529143200; gameLocked[6] = 1529154000; gameLocked[7] = 1529164800; gameLocked[8] = 1529175600; worldCupGameID[] = 9; worldCupGameID[] = 10; worldCupGameID[] = 11; gameLocked[9] = 1529236800; gameLocked[10] = 1529247600; gameLocked[11] = 1529258400; worldCupGameID[] = 12; worldCupGameID[] = 13; worldCupGameID[] = 14; gameLocked[12] = 1529323200; gameLocked[13] = 1529334000; gameLocked[14] = 1529344800; worldCupGameID[] = 15; worldCupGameID[] = 16; worldCupGameID[] = 17; gameLocked[15] = 1529409600; gameLocked[16] = 1529420400; gameLocked[17] = 1529431200; worldCupGameID[] = 18; worldCupGameID[] = 19; worldCupGameID[] = 20; gameLocked[18] = 1529496000; gameLocked[19] = 1529506800; gameLocked[20] = 1529517600; worldCupGameID[] = 21; worldCupGameID[] = 22; worldCupGameID[] = 23; gameLocked[21] = 1529582400; gameLocked[22] = 1529593200; gameLocked[23] = 1529604000; worldCupGameID[] = 24; worldCupGameID[] = 25; worldCupGameID[] = 26; gameLocked[24] = 1529668800; gameLocked[25] = 1529679600; gameLocked[26] = 1529690400; worldCupGameID[] = 27; worldCupGameID[] = 28; worldCupGameID[] = 29; gameLocked[27] = 1529755200; gameLocked[28] = 1529766000; gameLocked[29] = 1529776800; worldCupGameID[] = 30; worldCupGameID[] = 31; worldCupGameID[] = 32; gameLocked[30] = 1529841600; gameLocked[31] = 1529852400; gameLocked[32] = 1529863200; worldCupGameID[] = 33; worldCupGameID[] = 34; worldCupGameID[] = 35; worldCupGameID[] = 36; gameLocked[33] = 1529935200; gameLocked[34] = 1529935200; gameLocked[35] = 1529949600; gameLocked[36] = 1529949600; worldCupGameID[] = 37; worldCupGameID[] = 38; worldCupGameID[] = 39; worldCupGameID[] = 40; gameLocked[37] = 1530021600; gameLocked[38] = 1530021600; gameLocked[39] = 1530036000; gameLocked[40] = 1530036000; worldCupGameID[] = 41; worldCupGameID[] = 42; worldCupGameID[] = 43; worldCupGameID[] = 44; gameLocked[41] = 1530108000; gameLocked[42] = 1530108000; gameLocked[43] = 1530122400; gameLocked[44] = 1530122400; worldCupGameID[] = 45; worldCupGameID[] = 46; worldCupGameID[] = 47; worldCupGameID[] = 48; gameLocked[45] = 1530194400; gameLocked[46] = 1530194400; gameLocked[47] = 1530208800; gameLocked[48] = 1530208800; worldCupGameID[] = 49; worldCupGameID[] = 50; gameLocked[49] = 1530367200; gameLocked[50] = 1530381600; worldCupGameID[] = 51; worldCupGameID[] = 52; gameLocked[51] = 1530453600; gameLocked[52] = 1530468000; worldCupGameID[] = 53; worldCupGameID[] = 54; gameLocked[53] = 1530540000; gameLocked[54] = 1530554400; worldCupGameID[] = 55; worldCupGameID[] = 56; gameLocked[55] = 1530626400; gameLocked[56] = 1530640800; worldCupGameID[] = 57; worldCupGameID[] = 58; gameLocked[57] = 1530885600; gameLocked[58] = 1530900000; worldCupGameID[] = 59; worldCupGameID[] = 60; gameLocked[59] = 1530972000; gameLocked[60] = 1530986400; worldCupGameID[] = 61; gameLocked[61] = 1531245600; worldCupGameID[] = 62; gameLocked[62] = 1531332000; worldCupGameID[] = 63; gameLocked[63] = 1531576800; worldCupGameID[] = 64; gameLocked[64] = 1531666800; latestGameFinished = 0; }",1
0xc35d0837d49aa399022e133ba141b85d8809b137.sol,FUS,"contract FUS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint256 public constant INITIAL_SUPPLY = 100000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function FUS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x53d53464a636d61c928f3ab18ad76d378bbb359c.sol,BelezaNetwork,"contract BelezaNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; address multisig = 0x5021296614796dea5b223bdf15c9110e0e61dba1; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed = 0; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 20000000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ed81e904acfa95ca1ffe224ee7aa89f2bf5ef9c.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x2931b36154a10bde01373af56623705d128155b5.sol,CryptoDuels,contract CryptoDuels is Owned { using SafeMath for uint; struct PLAYER { uint wad; uint lastJoin; uint lastDuel; uint listPosition; },1
0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol,ICOBuyer,"contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale = 0x0; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool flag = true; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdd40b5a5b00d8913f3e1d6bb5cbbcd18a956b215.sol,REPOExchange,contract REPOExchange is MintableToken { uint public deal_cancel_rate = 0; struct REPODeal { address lender; address borrower; address collateral; address pledge; uint collateralAmount; uint pledgeAmount; uint interest; uint lenderFee; uint borrowerFee; uint pledgeUntil; uint collateralUntil; uint endsAt; int state; },1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x36fef0a32d493fa86d6281205b924456597aae5d.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x25d14913c49b7e7808453044f7e2f12b89693dda.sol,CXE,"contract CXE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 2800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 500000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x27e7383e49be6fd965805a0302b32e40c3d9981e.sol,CarTaxiBonus,contract CarTaxiBonus { CarTaxiCrowdsale public carTaxiCrowdsale; CarTaxiToken public carTaxiToken; address public owner; address public carTaxiCrowdsaleAddress = 0x77CeFf4173a56cd22b6184Fa59c668B364aE55B8; address public carTaxiTokenAddress = 0x662aBcAd0b7f345AB7FfB1b1fbb9Df7894f18e66; uint constant BASE = 1000000000000000000; uint public totalTokens; uint public totalBonuses; uint public iteration = 0; bool init = false; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x36ed5fbd27abf98f7081f1692ce48abab37db172.sol,Quiz_BliZ,contract Quiz_BliZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0x12a31ba664df56d0d3c7a8dfb15f676db4203184.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x1bb0a576936bce5d983e676073ac48ba49f12e05.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0xa4ec44afee34feffbae5ce4218d3c06ebd70455e.sol,BallotSB52,contract BallotSB52 { using SafeMath for uint; uint public phiWon; uint public neWon; Superbowl52 bettingContract; mapping (address => bool) voted; mapping (address => uint) votes; uint public constant votingPeriod = 7 days; uint public votingStart; uint public votingEnd; uint public validResult; bool public closed; uint public totalVoters; uint public threshold; uint public votingReward; mapping (address => uint) stake; uint public majorityReward; bool public tie; mapping (address => bool) claimed; function BallotSB52(uint th) public payable { validResult = 0; closed = false; votingStart = now; votingEnd = now + 7 days; bettingContract = Superbowl52(msg.sender); totalVoters = 0; threshold = th; tie = false; votingReward = 0; },1
0xda11e959bcaaba5f88dbf4d866e270c78bc84b76.sol,EBP,"contract EBP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6947335452cb7a452fc337c28cb0d597806c7672.sol,SmartWeddingContract,"contract SmartWeddingContract { event WrittenContractProposed(uint timestamp, string ipfsHash, address wallet); event Signed(uint timestamp, address wallet); event ContractSigned(uint timestamp); event AssetProposed(uint timestamp, string asset, address wallet); event AssetAddApproved(uint timestamp, string asset, address wallet); event AssetAdded(uint timestamp, string asset); event AssetRemoveApproved(uint timestamp, string asset, address wallet); event AssetRemoved(uint timestamp, string asset); event DivorceApproved(uint timestamp, address wallet); event Divorced(uint timestamp); event FundsSent(uint timestamp, address wallet, uint amount); event FundsReceived(uint timestamp, address wallet, uint amount); bool public signed = false; bool public divorced = false; mapping (address => bool) private hasSigned; mapping (address => bool) private hasDivorced; address public husbandAddress; address public wifeAddress; string public writtenContractIpfsHash; struct Asset { string data; uint husbandAllocation; uint wifeAllocation; bool added; bool removed; mapping (address => bool) hasApprovedAdd; mapping (address => bool) hasApprovedRemove; }",1
0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public EthPerToken = 300; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xc80143a2ffb9620ffc7e2e241bc8cec34599bd52.sol,HasNoEther,contract HasNoEther is TMTGOwnable { constructor() public payable { require(msg.value == 0); },1
0xbcdc85a62e5f29930a43cc20d15fe96786873084.sol,ENJOY,contract ENJOY { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x4cdee773fd90f91e98b7d33db5c12376deee3b08.sol,NEBC,"contract NEBC is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 390000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function NEBC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3.sol,CSportsContest,contract CSportsContestBase { struct Team { address owner; int32 score; uint32 place; bool holdsEntryFee; bool ownsPlayerTokens; uint32[] playerTokenIds; },1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,NSPToken,"contract NSPToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public constant INITIAL_SUPPLY = 1000; uint256 public price = 10 ** 15; bool public halted = false; function NSPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllRefundEscrow,contract ClinicAllRefundEscrow is RefundEscrow { using Math for uint256; struct RefundeeRecord { bool isRefunded; uint256 index; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0d722c159eaacd74eb3fc8ce65832706cf294b33.sol,CoinFlipper,contract CoinFlipper{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x01058f3806cc9c04e3542de8a284c902f3876f82.sol,TradeToken,"contract TradeToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 5000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TradeToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x680ec9492d8372662dd439294bff2bd373e96309.sol,MyEtherHODL,"contract MyEtherHODL is Ownable { event Hodl(address indexed hodler, uint indexed amount, uint untilTime, uint duration); event Party(address indexed hodler, uint indexed amount, uint duration); event Fee(address indexed hodler, uint indexed amount, uint elapsed); address[] public hodlers; mapping(address => uint) public indexOfHodler; mapping (address => uint) public balanceOf; mapping (address => uint) public lockedUntil; mapping (address => uint) public lockedFor; function get1(uint index) public constant returns(address hodler1, uint balance1, uint lockedUntil1, uint lockedFor1) { hodler1 = hodlers[index]; balance1 = balanceOf[hodler1]; lockedUntil1 = lockedUntil[hodler1]; lockedFor1 = lockedFor[hodler1]; }",1
0x2732dd0f79f6cf4f257232ea2291ffbab2c18c15.sol,CoinFlipperDSG,contract CoinFlipperDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint256 blockNumber; uint8 coin; uint256 bet; },1
0x8a6bc1397dbe756a04217c15be8097d3fbcaf4ba.sol,QUEST_Xz,contract QUEST_Xz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x6a47296deae50b8cde16aebd5de8c82231c711d6.sol,F_game,contract F_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x7909d3c14e5fb93a508582d04d11093585ebc084.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x4d81198dc71ffd13917da27d1a3f8599ac690535.sol,DSG_Dice,contract DSG_Dice{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,GladiEther,contract GladiEther is WeaponSales { function GladiEther() public payable { owner = msg.sender; },1
0x0e8160745966d2109c568230ef515b0dddea1599.sol,CrowdSale,"contract CrowdSale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public startTime; uint public deadline; uint public endFirstBonus; uint public endSecondBonus; uint public endThirdBonus; uint public hardCap; uint public price; uint public minPurchase; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event CrowdsaleClose(uint totalAmountRaised, bool fundingGoalReached); function CrowdSale( address ifSuccessfulSendTo, address addressOfTokenUsedAsReward, uint tokensPerEth, uint _minPurchase, uint fundingGoalInWei, uint hardCapInWei, uint startTimeInSeconds, uint durationInMinutes, uint _endFirstBonus, uint _endSecondBonus, uint _endThirdBonus ) public { beneficiary = ifSuccessfulSendTo; tokenReward = token(addressOfTokenUsedAsReward); price = tokensPerEth; minPurchase = _minPurchase; fundingGoal = fundingGoalInWei; hardCap = hardCapInWei; startTime = startTimeInSeconds; deadline = startTimeInSeconds + durationInMinutes * 1 minutes; endFirstBonus = _endFirstBonus; endSecondBonus = _endSecondBonus; endThirdBonus = _endThirdBonus; }",1
0x72d02f8c18d5452c6ed3f5515d7afe68c8a01f43.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,Fallback,contract Fallback is Ownable { mapping(address => uint) public contributions; function fallback() public { contributions[msg.sender] = 1000 * (1 ether); },1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xedd9acd849aa2d38c9d763b21652c7f5d714aff0.sol,EzyStayzCrowdsale,"contract EzyStayzCrowdsale is owned{ using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x953600669b794BB7a2E0Bc6C5a7f5fA96c3c1928; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1541030400; preSaleDeadline = 1543622399; mainSaleStartdate = 1543622400; mainSaleDeadline = 1551398399; price = 0.0004 ether; tokenReward = token(0x49246EF0e2eF35CD7523072BE75bC857B9eC63d9); }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x54a5ca46eb8830520453d417dcdfd83c1bfb5f54.sol,BGS,"contract BGS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 120000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BGS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xecbd0854075009d23360c62da07047efc2312144.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale () public { beneficiary = 0x1e19E36928bA65184669d8A7e7A37d8B061B9022; fundingGoal = 0.0022 * 1 ether; deadline = now + 40 * 1 minutes; price = 0.00058 * 1 ether; tokenReward = token(0xe8EF8d9d9Ff515720A62d2E2f14f3b5b677C6670); }",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x2742a7d469e34e277d6c306b2cb14a361c1ba254.sol,AllYours,contract AllYours { address private _platformAddress = 0x14551DeA29FAe64D84ba5670F7311E71a15e83e2; uint private _totalEth = 1 ether; uint128 private _oneceEth = 0.1 ether; uint32 private _period = 1; address private _owner; constructor() public{ _owner = msg.sender; },1
0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0.sol,ItemMarket,contract ItemMarket{ address public owner; uint16 public devFee = 500; uint256 public ItemCreatePrice = 0.02 ether; event ItemCreated(uint256 id); event ItemBought(uint256 id); event ItemWon(uint256 id); struct Item{ uint32 timer; uint256 timestamp; uint16 priceIncrease; uint256 price; uint256 amount; uint256 minPrice; uint16 creatorFee; uint16 previousFee; uint16 potFee; address creator; address owner; string quote; string name; },1
0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2.sol,LynchpinPrivateICO,contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba) { using SafeMath for uint256; LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5); address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba; uint256 public tokeninOneEther; uint256 public maxTokensToSell = 2000000 * 10**18; uint256 public tokenSold; bool crowdsaleClosed = false; uint256 LOCK_PERIOD_START = 1556668800; uint256 LOCK_PERIOD_9_MONTH = 1580515200; uint256 LOCK_PERIOD_10_MONTH = 1583020800; uint256 LOCK_PERIOD_11_MONTH = 1585699200; uint256 LOCK_PERIOD_END = 1588291200; mapping(address => uint256) public tokensOwed; mapping(address => uint256) public ethContribution; mapping(address => bool) public isWhitelisted; event LogAddedToWhitelist(address indexed _contributor); event LogTokenRateUpdated(uint256 _newRate); event LogSaleClosed(); constructor(uint256 _tokeninOneEther) public { require (_tokeninOneEther > 0); isWhitelisted[owner] = true; tokeninOneEther = _tokeninOneEther; emit LogTokenRateUpdated(_tokeninOneEther); },1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0x8b3934dd548be05022a8484ac41b8303ec4a88b3.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x89b5eaec2702ab0ff33ca397b3e66c7d925d5144.sol,Soccer,"contract Soccer { using SafeMath for uint256; event Birth(uint256 tokenId, uint256 startPrice); event TokenSold(uint256 indexed tokenId, uint256 price, address prevOwner, address winner); event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; struct Token { address owner; uint256 price; }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RCpro,"contract RCpro is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256[] public oneTokenInFiatWei; uint256[] public sendThreshold; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RCpro(address _tokenSaleContract, uint256[] _oneTokenInFiatWei, uint256[] _sendThreshold, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei[0] != 0 ); require ( _oneTokenInFiatWei.length == _sendThreshold.length ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; sendThreshold = _sendThreshold; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,Johnsonville,contract Johnsonville { address owner; address patronOne; address patronTwo; address patronThree; bool patronOneWd; bool patronTwoWd; bool patronThreeWd; modifier onlyOwner { if(msg.sender != owner) throw; _; },1
0xf47f923b91422f47645f41425601c44f6b464300.sol,DAOT,"contract DAOT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 43 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 32 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x77dbd46264dc9d5d4283c4e3616715195691c4ee.sol,BlockchainMusic,"contract BlockchainMusic is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 180000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x12E153c01e613ccC9d9cca2B6E29C4f7B3D3ee3a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e73fac981d22a0511b42f757186c3514ce60c4e.sol,Htlc,"contract Htlc { enum State { Created, Refunded, Redeemed }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,Presale,"contract Presale is AccessService, Random { ELHeroToken tokenContract; mapping (uint16 => uint16) public cardPresaleCounter; mapping (address => uint16[]) OwnerToPresale; uint256 public jackpotBalance; event CardPreSelled(address indexed buyer, uint16 protoId); event Jackpot(address indexed _winner, uint256 _value, uint16 _type); constructor(address _nftAddr) public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; tokenContract = ELHeroToken(_nftAddr); cardPresaleCounter[1] = 20; cardPresaleCounter[2] = 20; cardPresaleCounter[3] = 20; cardPresaleCounter[4] = 20; cardPresaleCounter[5] = 20; cardPresaleCounter[6] = 20; cardPresaleCounter[7] = 20; cardPresaleCounter[8] = 20; cardPresaleCounter[9] = 20; cardPresaleCounter[10] = 20; cardPresaleCounter[11] = 20; cardPresaleCounter[12] = 20; cardPresaleCounter[13] = 20; cardPresaleCounter[14] = 20; cardPresaleCounter[15] = 20; cardPresaleCounter[16] = 20; cardPresaleCounter[17] = 20; cardPresaleCounter[18] = 20; cardPresaleCounter[19] = 20; cardPresaleCounter[20] = 20; cardPresaleCounter[21] = 20; cardPresaleCounter[22] = 20; cardPresaleCounter[23] = 20; cardPresaleCounter[24] = 20; cardPresaleCounter[25] = 20; }",1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0x0099fe4ba54d6f91e7c3da9fc1c70b5c9c440516.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xdc20655a6de13496dd385f7ab903e4e6150e55a5.sol,VesaStage2PreICO,"contract VesaStage2PreICO is Ownable { using SafeMath for uint256; using SafeBonus for uint256; address public beneficiary; uint8 public durationInDays = 31; uint public fundingGoal = 100 ether; uint public fundingGoalHardCap = 10000 ether; uint public amountRaised; uint public start; uint public deadline; uint public bonusPrice = 164285714300000; uint public bonusPriceDeltaPerHour = 3571428573000; uint public bonusPeriodDurationInHours = 10; uint public price = 200000000000000; uint public minSum = 200000000000000000; token public tokenReward; mapping(address => uint256) public balanceOf; bool public fundingGoalReached = false; bool public crowdsaleClosed = false; bool public allowRefund = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event BeneficiaryChanged(address indexed previousBeneficiary, address indexed newBeneficiary); function VesaStage2PreICO() public { beneficiary = 0x2bF8AeE3845af10f2bbEBbCF53EBd887c5021d14; start = 1522155600; deadline = start + durationInDays * 1 days; tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921); }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xec987914ade432ce9806f418787a4ed0b0e77000.sol,LuckyDice,"contract LuckyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) { if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw; _; }",1
0x65171746deb1d6eee256455f77c350eceda34ae2.sol,AgroNest,"contract AgroNest is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 10000000e18; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Mortal,contract Mortal is Owned { function kill() { if (msg.sender == owner) selfdestruct(owner); },1
0x57bfffd48366f78e787e167419c8c05cdb849ede.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x36351289a2263902189515f83138528f2382b12f.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x726b61fa2a732c5946dd5059cad6f6f838c5ccfe.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionId); event Revocation(address sender, bytes32 transactionId); event Submission(bytes32 transactionId); event Execution(bytes32 transactionId); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0x0ef6d1808b129f77cc5fb3ef864acc06aa52fa3d.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb.sol,try_it,contract try_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0x0f35d82007119dc339af57b29dc8ae794b92926c.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xe34cae5cdc42afd4c68727a936908918b5faa675.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x929e488770ae5218cf4bb5387a390bd36b2135dd.sol,QUIZ_QUIZ,contract QUIZ_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol,WIDEC,"contract WIDEC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0xC66BE798fb6fccb44893307a44186B19e20437cf ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x64b09d1a4b01db659fc36b72de0361f2c6c521b1.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xd3fa5231c03de9f30c610c16b5576396fdaf6b19.sol,FOMO,contract FOMO is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public FOMOed; event Message(string message); function FOMO() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 232 * 1e18; FOMOed = true; },1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xeebf279ee18d7d7fc11cb945975db1a38eb94058.sol,MMOToken,contract MMOToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = ; string public constant symbol = ; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; },1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x29c690419841e126b74981e4709e43916ac80f64.sol,QQ_game,contract QQ_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x20d4ec1b92cc4570c74efd968d04660b8fcc0406.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x1da73fc09ea07781482994036a0eecc7e6952dfb.sol,TydoIco,"contract TydoIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; uint256[] public bonuses; uint256[] public bonusEnds; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken, uint256[] _bonuses, uint256[] _bonusEnds) Owned() public { require(_bonuses.length == _bonusEnds.length); for(uint8 i = 0; i < _bonuses.length; i++) { require(_bonuses[i] > 0); if (i > 0) { }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,EthercraftFarm,"contract EthercraftFarm is Ownable, ReentrancyGuard, Destructible, TokenDestructible, Pausable { using SafeMath for uint8; using SafeMath for uint256; event Prepped(address indexed shop, address indexed object, uint256 iterations); event Reapped(address indexed object, uint256 balance); mapping (address => mapping (address => uint256)) public balanceOfToken; mapping (address => uint256) public totalOfToken; function() payable public { }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0x6c17472a51c3d32a7f216d1622b212d42f53056d.sol,BLAINetworkToken,"contract BLAINetworkToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 600000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BLAINetworkToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,NKYS,"contract NKYS is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 30 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 7000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 35000; uint public progress0drop = 0; address multisig = 0xa30526D832d9A07596576c8D9de61BfEcCf08499; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0x1c80bf91b30c17019149acdb5ddc3dcb89122c8c.sol,QUICK_GAME,contract QUICK_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0e0a86c97a07856d68bf3387aeb9430dbab93245.sol,InterbetCore,contract InterbetCore { uint constant oddsDecimals = 2; uint constant feeRateDecimals = 1; uint public minMakerBetFund = 100 * 1 finney; uint public maxAllowedTakerBetsPerMakerBet = 100; uint public minAllowedStakeInPercentage = 1; address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xf051a2f404435d3413337aae24171342fddc8571.sol,FoxicoPool,"contract FoxicoPool is Ownable { using SafeMath for uint256; mapping (address => uint256) public deposited; mapping (address => uint256) public claimed; uint256 public startTime; uint256 public endTime; address public wallet; bool public refundEnabled; event Refunded(address indexed beneficiary, uint256 weiAmount); event AddDeposit(address indexed beneficiary, uint256 value); function setStartTime(uint256 _startTime) public onlyOwner{ startTime = _startTime; }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0xb387be1e10d56bd7c6849b7be9d6aad564854d72.sol,Alfa_quiZ,contract Alfa_quiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x71972877d68acf22114e05578364a307cafe2885.sol,BsCrowdsale,"contract BsCrowdsale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, DASH, ZEC, WAVES, USD, EUR }",1
0xeb914da749340266ac474f930c65c2ed4df89922.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0xd4c435f5b09f855c3317c8524cb1f586e42795fa.sol,CND,"contract CND is MiniMeToken { uint256 public constant IS_CND_CONTRACT_MAGIC_NUMBER = 0x1338; function CND(address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , true ) {}",1
0x44f12955189e3f01be5daf1dd9002ee4d774f42b.sol,AfterSchoolCrowdsaleToken,"contract AfterSchoolCrowdsaleToken is StandardToken, Ownable { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 18; address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90; uint PRICE = 5800; struct ContributorData { uint contributionAmount; uint tokensIssued; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xa28b5854df048bcd5eec522fada1c6b7ea006aae.sol,Mortal,contract Mortal is Ownable { function kill() public onlyOwner { selfdestruct(owner); },1
0x1b332629b45136a3614fafcd927c8ea31d7cd717.sol,Bandit,"contract Bandit is usingOraclize, DSSafeAddSub { function () public payable {}",1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x41b909cd4cda90f04d0aaf4097727544fd8ae47a.sol,XCTCrowdSale,contract XCTCrowdSale is SafeMath { address public beneficiary; uint256 public startBlock = 4969760; uint256 public constant hardCap = 4000 ether; uint256 public amountRaised; function XCTCrowdSale(address _beneficiary) public { beneficiary = _beneficiary; amountRaised = 0; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,CDPCreator,"contract CDPCreator is DSMath { WETH9 public weth; ERC20 public peth; ERC20 public dai; SaiTub public tub; event CDPCreated(bytes32 id, address creator, uint256 dai); constructor(address _weth, address _peth, address _dai, address _tub) public { require(_weth != address(0) && _peth != address(0) && _tub != address(0) && _dai != address(0)); weth = WETH9(_weth); peth = ERC20(_peth); dai = ERC20(_dai); tub = SaiTub(_tub); weth.approve(address(tub), uint(-1)); peth.approve(address(tub), uint(-1)); }",1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x2821fb31998e60d220ff52af6299872f25a3e149.sol,MiniMeToken,contract MiniMeToken is Controlled { using SafeMath for uint256; string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xf221579d18f0c4c10c08ff9fe3d34bdbd7117909.sol,AtomCirculationCoin,"contract AtomCirculationCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x5a94fef3eb9c2ab0a83680136d0de092115cbc39.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, address addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 1 ether; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x0dc11b7ed751594906bce3a7091952b30528ee7e.sol,DickMeasurementContest,contract DickMeasurementContest { uint lastBlock; address owner; modifier onlyowner { require (msg.sender == owner); _; },1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x718f1892987a871fbe81462597e6dcd2900e127f.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; uint256 amountEth; },1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2d35297a8f988a5d8bda3d63d398b529bba0b107.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable, Pausable, Destructible, Contactable { enum Stages { none, icoStart, icoEnd }",1
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,Testing,"contract Testing { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) withdrawalsgross; mapping(address => uint256) referrer; uint256 public step = 5; uint256 public bankrollpercentage = 10; uint256 public maximumpercent = 150; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.01 ether; uint256 public startTime = 1540214220; uint256 public randomizer = 456717097; uint256 private randNonce = 0; address public ownerWallet; address public owner; address promoter1 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; address promoter2 = 0xBFb297616fFa0124a288e212d1E6DF5299C9F8d0; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Lottery(address player, uint256 lotteryNumber, uint256 amount, uint256 result, bool isWin); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1.sol,EFTCrowdsale,contract EFTCrowdsale { Token public tokenReward; address public creator; address public owner = 0x515C1c5bA34880Bc00937B4a483E026b0956B364; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x9214ec02cb71cba0ada6896b8da260736a67ab10.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x00346fddca107aec034a367b7324f0d6419bf4b9.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, address addressOfTokenUsedAsReward ) public{ beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = (0.00001 ether)/100000 ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0x1f4215fe007ee5b170391241656a28a8bd13826e.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event FeePaid(address indexed from, address indexed to, uint256 value); event VoidAccount(address indexed from, address indexed to, uint256 value); event Bonus(uint256 value); event Burn(uint256 value); string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 3000000000 * 10 ** uint256(decimals); uint256 public EthPerToken = 300000; uint256 public ChargeFee = 2; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x720608228bda773fe22e816ee72463040f11c19e.sol,Presale,"contract Presale is CommonCrowdsale { uint public devLimit; uint public softcap; bool public refundOn; bool public softcapAchieved; bool public devWithdrawn; address public devWallet; address public nextSaleAgent; mapping (address => uint) public balances; function Presale() public { minInvestedLimit = 10000000000000000; price = 1000000000000000000000; bountyTokensPercent = 3; advisorsTokensPercent = 1; devTokensPercent = 4; foundersTokensPercent = 10; softcap = 20000000000000000000; hardcap = 63000000000000000000000; addBonus(7,42); addBonus(7,25); addBonus(7,11); start = 1513774800; end = 1516885200; devLimit = 7000000000000000000; wallet = 0x72EcAEB966176c50CfFc0Db53E4A2D3DbC0d538B; devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; bountyTokensWallet = 0x7E513B54e3a45B60d6f92c6CECE10C68977EEA8c; foundersTokensWallet = 0x4227859C5A9Bb4391Cc4735Aa655e980a3DD4380; advisorsTokensWallet = 0x6e740ef8618A7d822238F867c622373Df8B54a22; devTokensWallet = 0xCaDca9387E12F55997F46870DA28F0af1626A6d4; }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x32ceb540334300bcd53836a25a4bd64d607babd8.sol,BetGame,contract BetGame is DSStop { using SafeMath for uint256; struct Bet { address player; bytes32 secretHash; uint256 amount; uint roundId; bool isRevealed; uint nonce; bool guessOdd; bytes32 secret; },1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CryptoAtomsLogic,"contract CryptoAtomsLogic{ address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5; CaData public CaDataContract = CaData(CaDataAddress); CaCoreInterface private CaCoreContract; bool public pauseMode = false; bool public bonusMode = true; uint128 public newAtomFee = 1 finney; uint8[4] public levelupValues = [0, 2, 6, 12]; event NewSetRent(address sender, uint atom); event NewSetBuy(address sender, uint atom); event NewUnsetRent(address sender, uint atom); event NewUnsetBuy(address sender, uint atom); event NewAutoRentAtom(address sender, uint atom); event NewRentAtom(address sender, uint atom, address receiver, uint amount); event NewBuyAtom(address sender, uint atom, address receiver, uint amount); event NewEvolveAtom(address sender, uint atom); event NewBonusAtom(address sender, uint atom); function() public payable{}",1
0x412d9b16117acc557d6a51a93d907bd33526cd77.sol,GCASH_ERC20,"contract GCASH_ERC20 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 60 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 25000; uint public progress0drop = 0; address multisig = 0xF0E39fD8E168DEdAb1A9893406c3DeC0772FCd3b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0x035611f47a13f3603109152952f0034c674959ba.sol,ReservationFund,"contract ReservationFund is ICrowdsaleReservationFund, Ownable, SafeMath { bool public crowdsaleFinished = false; mapping(address => uint256) contributions; mapping(address => uint256) tokensToIssue; mapping(address => uint256) bonusTokensToIssue; ISimpleCrowdsale public crowdsale; event RefundPayment(address contributor, uint256 etherAmount); event TransferToFund(address contributor, uint256 etherAmount); event FinishCrowdsale(); function ReservationFund(address _owner) public Ownable(_owner) { }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0xc551c26e420f710be3fca711d2bff247cd332c3a.sol,CulturePhilosophyFaithChain,"contract CulturePhilosophyFaithChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function CulturePhilosophyFaithChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x6a3cfb5aeefb9138a28b28f3852a8fee81216df3.sol,RxEALSaleContract,"contract RxEALSaleContract { using SafeMath for uint256; RxEALTokenContract public token; uint256 public startTime = 1520856000; uint256 public endTime = 1523448000; address public wallet1 = 0x56E4e5d451dF045827e214FE10bBF99D730d9683; address public wallet2 = 0x8C0988711E60CfF153359Ab6CFC8d45565C6ce79; address public wallet3 = 0x0EdF5c34ddE2573f162CcfEede99EeC6aCF1c2CB; address public wallet4 = 0xcBdC5eE000f77f3bCc0eFeF0dc47d38911CBD45B; uint256 public tier_rate_1 = 1800; uint256 public tier_cap_1 = 4800000; uint256 public tier_rate_2 = 1440; uint256 public tier_cap_2 = 14400000; uint256 public tier_rate_3 = 1320; uint256 public tier_cap_3 = 14400000; uint256 public tier_rate_4 = 1200; uint256 public tier_cap_4 = 14400000; uint256 public hard_cap; uint8 public current_tier = 1; uint256 public weiRaised; uint256 public soldTokens; uint256 public current_tier_sold_tokens; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 tokens); function RxEALSaleContract() { token = RxEALTokenContract(0xD6682Db9106e0cfB530B697cA0EcDC8F5597CD15); tier_cap_1 = tier_cap_1 * (10 ** token.decimals()); tier_cap_2 = tier_cap_2 * (10 ** token.decimals()); tier_cap_3 = tier_cap_3 * (10 ** token.decimals()); tier_cap_4 = tier_cap_4 * (10 ** token.decimals()); hard_cap = tier_cap_1 + tier_cap_2 + tier_cap_3 + tier_cap_4; }",1
0xf17a9ad24372faaa27f0bb684e13413a3de84c4b.sol,SmokeCoinV_2,"contract SmokeCoinV_2 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 754654e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 22220000000; uint public target0drop = 4222; uint public progress0drop = 0; address multisig = 0xb7Ef2B8514A27bf63e8F5397Fd6DBDCa95809883; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0x1c80bf91b30c17019149acdb5ddc3dcb89122c8c.sol,QUICK_GAME,contract QUICK_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc.sol,alfa_Quiz,contract alfa_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkTGE,"contract WolkTGE is Wolk { mapping (address => uint256) contribution; mapping (address => uint256) presaleLimit; mapping (address => bool) presaleContributor; uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals; uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals; uint256 public presale_start_block; uint256 public start_block; uint256 public end_block; function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){ require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock)); presale_start_block = _presaleStartBlock; start_block = _startBlock; end_block = _endBlock; multisigWallet = _wolkWallet; wolkSale = _wolkSale; settlers[msg.sender] = true; return true; }",1
0x51e9244bae3fca7473fe48651dfd7db53aa55856.sol,RobTheBank,contract RobTheBank{ using SafeMath for uint256; uint256 public constant BASE_PRICE = 0.003 ether; address public owner; address public service; struct Big { uint256 totalKey; uint256 jackpotBalance; uint256 KeyProfit; mapping (address=>uint256) received; address winner; uint256 winnerProfit; },1
0x20c476bb4c7aa64f919278fb9c09e880583beb4c.sol,X3ProfitMainFundTransfer,contract X3ProfitMainFundTransfer { uint public constant maxBalance = 340282366920938463463374607431768211456 wei; address public constant ADDRESS_EIFP2_CONTRACT = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3; address public constant ADDRESS_ADMIN = 0x6249046Af9FB588bb4E70e62d9403DD69239bdF5; bool private isResend = false; function () external payable { if(msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 0.1 ether && !isResend)){ if(ADDRESS_EIFP2_CONTRACT.balance > maxBalance) { ADDRESS_ADMIN.transfer(address(this).balance); return; },1
0x07c206f253605a9ac4e21a9cf99d7841e8636468.sol,RYCSale,"contract RYCSale { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; address public owner; uint public amountRaised; uint public refundAmount; uint public rate = 5000; uint public constant LOW_RANGE_RATE = 1; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; bool public paused = false; RYCToken public tokenReward; mapping(address => uint256) public balanceOf; mapping(address => uint256) public contributions; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event Pause(); event Unpause(); modifier beforeDeadline() {require (currentTime() < endTime); _;}",1
0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180.sol,JungleScratch,contract JungleScratch is Owned { using SafeMath for uint; uint public LimitBottom = 0.02 ether; uint public LimitTop = 0.1 ether; address public Drawer; struct Game { bytes32 SecretKey_P; bool isPlay; bool isPay; uint Result; uint Time; address Buyer; uint value; },1
0x840b875acfd1034723a23cb079184c7b56a89b90.sol,DSG_Dice,contract DSG_Dice{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0x6f84faf2ce621f5a4ba161f055a56daffbf78b04.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x6f303642844f734ad4176d0dfe93ef7e0776ef46.sol,CrowdsaleWatch,"contract CrowdsaleWatch { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool crowdsaleClosed = false; function CrowdsaleWatch( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint etherCostOfEachToken, token addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 5000 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 5000000 wei; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x92d01e9128878aeca1db66695b22e420ccf27712.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x1fe2401bd6f4de5eff1661086440297baa9a2e12.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge{ function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9.sol,XenoxCoin,"contract XenoxCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x1c80bf91b30c17019149acdb5ddc3dcb89122c8c.sol,QUICK_GAME,contract QUICK_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x4831f53983eb50a9ffeee3d64762a70d7e6eb7f0.sol,MultiSender,"contract MultiSender is Ownable { using SafeMath for uint; string public constant NAME = ; event Transfer(address indexed holder, uint amount); function() public payable { }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0x2919336f7a427de135dc515fc5004b083d171ba4.sol,CryptoPokerBase,"contract CryptoPokerBase is Ownable { using SafeMath for uint256; enum CardStatus { Frozen, Tradable }",1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x53d428716900eae876ad1d7e4535e796b5faeda2.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 20; uint256 public tokensPerEth = 40000e18; uint public target0drop = 5024; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4b9d8e37bd266fe27adc45a31a6e1c2b9ca18737.sol,E_GAME,contract E_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0x58558971833807aca62cff89017f78465405ce11.sol,Vitamin,"contract Vitamin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function Vitamin() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567.sol,ERC721dAppCaps,"contract ERC721dAppCaps is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721, Ownable, Fallback { event BoughtToken(address indexed buyer, uint256 tokenId); string public constant company = ; string public constant contact = ""https: string public constant author = ; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MAX_LENGTH = 100000; uint256 currentPrice = 0; mapping(uint256 => uint256) tokenTypes; mapping(uint256 => string) tokenTitles; mapping(uint256 => string) tokenDescriptions; mapping(uint256 => string) specialQualities; mapping(uint256 => string) tokenClasses; mapping(uint256 => string) iptcKeywords; constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); }",1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0x5b0adb5a0f9e8551cb2502a0ad6307fad06121cb.sol,multiSendOxygen,"contract multiSendOxygen { function multipleOutputs (address address1, address address2,address address3, uint256 amt1, uint256 amt2,uint256 amt3) public payable { address1.transfer(amt1); address2.transfer(amt2); address3.transfer(amt3); }",1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xecbd0854075009d23360c62da07047efc2312144.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale () public { beneficiary = 0x1e19E36928bA65184669d8A7e7A37d8B061B9022; fundingGoal = 0.0022 * 1 ether; deadline = now + 40 * 1 minutes; price = 0.00058 * 1 ether; tokenReward = token(0xe8EF8d9d9Ff515720A62d2E2f14f3b5b677C6670); }",1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x766f28c22028b55b0bc6d7c56ad006a10403847b.sol,BuckySalary,contract BuckySalary is Ownable { address[] public staff; mapping(address => uint) public eth; function BuckySalary() public { },1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0xedc1936bbe9fee2abc523ad237aa62a3a3722177.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2cf02304f36effd519be79850d21335684c6073e.sol,AccEthRegCenter,contract AccEthRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x2919336f7a427de135dc515fc5004b083d171ba4.sol,CryptoPokerBase,"contract CryptoPokerBase is Ownable { using SafeMath for uint256; enum CardStatus { Frozen, Tradable }",1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0x728781e75735dc0962df3a51d7ef47e798a7107e.sol,WolkExchange,"contract WolkExchange is WolkProtocol, WolkTGE { uint256 public maxPerExchangeBP = 50; address public exchangeFormula; bool public exchangeIsRunning = false; modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }",1
0x2992221bc5f79681635c2b490cca47cac0a2bd7c.sol,try_me,contract try_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0x330e24d4aa0a60acac8f9fe6d674d3cf1e8042c6.sol,LocalEthereumEscrows,contract LocalEthereumEscrows { address public arbitrator; address public owner; address public relayer; uint32 public requestCancellationMinimumTime; uint256 public feesAvailableForWithdraw; uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; uint8 constant ACTION_BUYER_CANCEL = 0x02; uint8 constant ACTION_SELLER_CANCEL = 0x03; uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04; uint8 constant ACTION_RELEASE = 0x05; uint8 constant ACTION_DISPUTE = 0x06; event Created(bytes32 _tradeHash); event SellerCancelDisabled(bytes32 _tradeHash); event SellerRequestedCancel(bytes32 _tradeHash); event CancelledBySeller(bytes32 _tradeHash); event CancelledByBuyer(bytes32 _tradeHash); event Released(bytes32 _tradeHash); event DisputeResolved(bytes32 _tradeHash); struct Escrow { bool exists; uint32 sellerCanCancelAfter; uint128 totalGasFeesSpentByRelayer; },1
0xdc20655a6de13496dd385f7ab903e4e6150e55a5.sol,VesaStage2PreICO,"contract VesaStage2PreICO is Ownable { using SafeMath for uint256; using SafeBonus for uint256; address public beneficiary; uint8 public durationInDays = 31; uint public fundingGoal = 100 ether; uint public fundingGoalHardCap = 10000 ether; uint public amountRaised; uint public start; uint public deadline; uint public bonusPrice = 164285714300000; uint public bonusPriceDeltaPerHour = 3571428573000; uint public bonusPeriodDurationInHours = 10; uint public price = 200000000000000; uint public minSum = 200000000000000000; token public tokenReward; mapping(address => uint256) public balanceOf; bool public fundingGoalReached = false; bool public crowdsaleClosed = false; bool public allowRefund = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event BeneficiaryChanged(address indexed previousBeneficiary, address indexed newBeneficiary); function VesaStage2PreICO() public { beneficiary = 0x2bF8AeE3845af10f2bbEBbCF53EBd887c5021d14; start = 1522155600; deadline = start + durationInDays * 1 days; tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921); }",1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0xcf70f36f8fd04713b33900bab530fd2f63ed9ae0.sol,TheNextBlock,"contract TheNextBlock { using SafeMath for uint256; event BetReceived(address sender, address betOnMiner, address miner); event Jackpot(address winner, uint256 amount); struct Owner { uint256 balance; address addr; }",1
0x6a47296deae50b8cde16aebd5de8c82231c711d6.sol,F_game,contract F_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is TimedCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; }",1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0xef078a64e1593afee09912d18097bc49fa74c7a9.sol,ETHER_Game,contract ETHER_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a.sol,AceDice,contract AceDice is usingOraclize { uint constant HOUSE_EDGE_PERCENT = 2; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint64 public oraclizeGasLimit; uint public oraclizeGasPrice; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0x873e4037cfacfaa6837c913604c2de51f2b179d0.sol,IRideSale,contract IRideSale { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; uint256 public endDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x25d14913c49b7e7808453044f7e2f12b89693dda.sol,CXE,"contract CXE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 2800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 500000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,TiqpitCrowdsale,"contract TiqpitCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 constant private DECIMALS = 18; uint256 constant public RESERVED_TOKENS_BOUNTY = 10e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_FOUNDERS = 25e6 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_ADVISORS = 25e5 * (10 ** DECIMALS); uint256 constant public RESERVED_TOKENS_TIQPIT_SOLUTIONS = 625e5 * (10 ** DECIMALS); uint256 constant public MIN_INVESTMENT = 200 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_PRE_ICO = 1e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_PRE_ICO = 75e5 * (10 ** DECIMALS); uint256 constant public MINCAP_TOKENS_ICO = 5e6 * (10 ** DECIMALS); uint256 constant public MAXCAP_TOKENS_ICO = 3925e5 * (10 ** DECIMALS); uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO; uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO; uint256 public soldTokensPreIco = 0; uint256 public soldTokensIco = 0; uint256 public soldTokensTotal = 0; uint256 public preIcoRate = 2857; uint256 public firstRate = 2500; uint256 public secondRate = 2222; uint256 public thirdRate = 2000; uint256 public startTimePreIco = 0; uint256 public endTimePreIco = 0; uint256 public startTimeIco = 0; uint256 public endTimeIco = 0; uint256 public weiRaisedPreIco = 0; uint256 public weiRaisedIco = 0; uint256 public weiRaisedTotal = 0; TiqpitToken public token = new TiqpitToken(this); mapping (address => address) private lockedList; address private tiqpitSolutionsWallet; address private foundersWallet; address private advisorsWallet; address private bountyWallet; address public backendAddress; bool private hasPreIcoFailed = false; bool private hasIcoFailed = false; bool private isInitialDistributionDone = false; struct Purchase { uint256 refundableWei; uint256 burnableTiqs; }",1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,Etherumble,contract Etherumble { struct PlayerBets { address addPlayer; uint amount; },1
0x70f187ea2ebcf5b94aa7819f41c92f9a9dc4c200.sol,LifePasswordAI,"contract LifePasswordAI is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 680000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function LifePasswordAI() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0x18b67380942d56c09001a3764ce1aa9e64644433.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 exchange = 1000000; uint256 endICO = 0; address admin; constructor() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; endICO=block.timestamp+(60*60*24*31); }",1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x708a64eba17df26cd7085c494b725160ba1a6b7d.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State {Active, Refunding, Closed}",1
0x5ae5a356aee6cea184a757c6bddd5b0aa4d38a07.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant PAYBACK_PERMILLE = 2; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee, uint _discount ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0xc398891b43f1b91158dca87c63a88b80d000c248.sol,IBIT,"contract IBIT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000021e8; uint public target0drop = 5000000; uint public progress0drop = 0; address multisig = 0x723D0666908ADdc626C29407F0B5e7C0881b5185; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd48ec4bd0226c1decf0ea618ed35a76e8e272e86.sol,HEX,"contract HEX is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) { }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0xdc8d902c34f2257b8569dc9bc4f58cc149ed6e48.sol,GitmanIssue,"contract GitmanIssue { address private mediator; address public parent; string public owner; string public repository; string public issue; constructor (string ownerId, string repositoryId, string issueId, address mediatorAddress) public payable { parent = msg.sender; mediator = mediatorAddress; owner = ownerId; repository = repositoryId; issue = issueId; }",1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0x6a0a97e47d15aad1d132a1ac79a480e3f2079063.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x64ef6612a67de3fa96accb645ae46a3c09227928.sol,Economeme,"contract Economeme is ERC721, Ownable { using SafeMath for uint256; uint256 private totalTokens; uint256 public developerCut; uint256 public submissionPool; uint256 public submissionPrice; uint256 public endingBalance; mapping (uint256 => Meme) public memeData; mapping (uint256 => address) private tokenOwner; mapping (uint256 => address) private tokenApprovals; mapping (address => uint256[]) private ownedTokens; mapping(uint256 => uint256) private ownedTokensIndex; mapping (address => uint256) public creatorBalances; event Purchase(uint256 indexed _tokenId, address indexed _buyer, address indexed _seller, uint256 _purchasePrice); event Creation(address indexed _creator, uint256 _tokenId, uint256 _timestamp); uint256 private firstCap = 0.02 ether; uint256 private secondCap = 0.5 ether; uint256 private thirdCap = 2.0 ether; uint256 private finalCap = 5.0 ether; struct Meme { uint256 price; address owner; address creator; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x32d782c283924f1e40b2a839b8121564b7b9142e.sol,SUPER_Q,contract SUPER_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Fifteen,contract Fifteen is Payments { mapping (uint8 => mapping (uint8 => mapping (uint8 => uint8))) public fifteenPuzzles; mapping (uint8 => address) public puzzleIdOwner; mapping (uint8 => uint256) public puzzleIdPrice; uint256 public jackpot = 0; function initNewGame() public onlyCoOwner payable { require (msg.value>0); require (jackpot == 0); jackpot = msg.value; uint8 row; uint8 col; uint8 num; for (uint8 puzzleId=1; puzzleId<=6; puzzleId++) { num=15; puzzleIdOwner[puzzleId] = address(this); puzzleIdPrice[puzzleId] = 0.001 ether; for (row=1; row<=4; row++) { for (col=1; col<=4; col++) { fifteenPuzzles[puzzleId][row][col]=num; num--; },1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x5ae96153d99dfdd7a6b471451afe0f564e10b934.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public price; uint public percentRate = 100; uint public softcap; bool public refundOn = false; bool public isSoftcapOn = false; mapping (address => uint) balances; CommonSale public nextSale; MintableToken public token; function setSoftcap(uint newSoftcap) onlyOwner { isSoftcapOn = true; softcap = newSoftcap; },1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x18365e32f5e5615fe73592f7c2dbfa73538708c6.sol,PreSaleI,"contract PreSaleI is Whitelist { using SafeMath for uint256; uint256 public exchangeRate; uint256 public minValue; uint256 public maxTotal; uint256 public maxPerAddress; uint256 public startTimestamp; uint256 public endTimestamp; bool public enabled; address public wallet; ERC20 public token; uint256 public accumulatedAmount = 0; uint256 public accumulatedAmountExternal = 0; mapping (address => uint256) public buyAmounts; address[] public addresses; constructor(ERC20 _token, address _wallet, uint256 _exchangeRate, uint256 _minValue, uint256 _maxTotal, uint256 _maxPerAddress, uint256 _startTimestamp, uint256 _endTimestamp) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; exchangeRate = _exchangeRate; minValue = _minValue; maxTotal = _maxTotal; maxPerAddress = _maxPerAddress; startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; enabled = false; }",1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x737f626cf046992e961afa140c748cf604e013b9.sol,DiceDSG,contract DiceDSG{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) public usersBets; struct Bet { uint blockNumber; uint bet; bool[6] dice; },1
0xf11e1de7d9876a10b0742da19232f42456ead843.sol,DXEACoin,"contract DXEACoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 13 * 1 days; uint public round2 = now + 8 * 1 days; uint public round1 = now + 19 * 1 days; uint256 public totalSupply = 15000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 15500000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x24aD8dC3119672F5a50C2ed25Fd4708FEe589281; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x6f1408e206d23d446e1580830f11f79c2e58d92b.sol,NRMc,"contract NRMc { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 20000000000000000000000000; uint256 perReserve = 2000000000000000000000000; bool startDone = false; bool finishDone = false; bool onefiveDone = false; address owner = 0; address reserve1 = 0x0d4dAA952a8840715d901f97EDb98973Ce8010F7; address reserve2 = 0xCd4846fF42C1DCe3E421cb4fE8d01523B962D641; address reserve3 = 0x2241C99B6f44Cc630a073703EdFDf3c9964CbE22; address reserve4 = 0x5c5bfC25A0B99ac5F974927F1f6D39f19Af9D14C; address reserve5 = 0xa8356f49640093cec3dCd6dcE1ff4Dfe3785c17c; bool prereserved1Done = false; bool prereserved2Done = false; bool prereserved3Done = false; bool prereserved4Done = false; bool prereserved5Done = false; address out1 = 0xF9D23f5d833dB355bfc870c8aCD9f4fc7EF05883; address out2 = 0x5c07f5DD4d3eE06A977Dee53072e10de9414E3f0; address out3 = 0xF425821a2545cF1414B6E342ff5D95f3c572a7CD; address out4 = 0xa873134afa83410787Ae29dBfB39e5C38ca05fF2; address out5 = 0x5E663D73de8205b3f339fAA5a4218AcA95963260; bool public out1Done = false; bool public out2Done = false; bool public out3Done = false; bool public out4Done = false; bool public out5Done = false; uint public amountRaised; uint public deadline; uint public overRaisedUnsend = 0; uint public backers = 0; uint public rate = 45000; uint public onefive = 0; uint _durationInMinutes = 0; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function NRMc(address adr) { if (startDone == false) { owner = adr; }",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xc7f1c3500496771b2ef4e17ad10624131ade5cd9.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _premine = 0x76D05E325973D7693Bb854ED258431aC7DBBeDc3; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0xece7814a9691a94e7f3d9354155e21cfb291e13b.sol,AlmightyKeyChain,"contract AlmightyKeyChain is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function AlmightyKeyChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished; modifier canMint() { require(!mintingFinished); _; }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0x2974aa2c025aeac44bb8d284e33b9e7d527f0025.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge { function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0x1d4ccc31dab6ea20f461d329a0562c1c58412515.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x20da2ff263e28e8db8ef44f590ff4576bac770e2.sol,MilFold,"contract MilFold is MilFoldInterface,Milevents { using SafeMath for *; uint256 constant private rndMax_ = 90000; uint256 constant private claimMax_ = 43200; address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; uint256 constant private MIN_ETH_BUYIN = 0.002 ether; uint256 constant private COMMON_REWARD_AMOUNT = 0.01 ether; uint256 constant private CLAIM_WINNER_REWARD_AMOUNT = 1 ether; uint256 constant private MAX_WIN_AMOUNT = 5000 ether; uint256 private rID_; uint256 private lID_; uint256 private lBlockNumber_; bool private activated_; MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F); MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9); mapping (address => uint256) private playerTickets_; mapping (uint256 => Mildatasets.Round) private round_; mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_; mapping (address => uint256) private playerWinTotal_; modifier isActivated() { require(activated_ == true, ); _; }",1
0xd88577ed936819807612c0d4a17ade05adcdf1d3.sol,ZTRTokenSale,contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; },1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,GeocashToken,"contract GeocashToken is StandardToken, Destructible { string public name; string public symbol; uint public decimals; uint public buyPriceInWei; uint public sellPriceInWei; uint public minBalanceForAccounts; address public companyWallet; mapping(address => uint256) balances; mapping (address => bool) public frozenAccounts; event FrozenFunds(address target, bool frozen); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol,WIDEC,"contract WIDEC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0xC66BE798fb6fccb44893307a44186B19e20437cf ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xe3147bc1046fab87292e1b743c1e657b37262496.sol,AccessCrowdsale,"contract AccessCrowdsale is Whitelisted { using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1550102400; preSaleDeadline = 1552608000; mainSaleStartdate = 1552611600; mainSaleDeadline = 1560643200; price = 0.0004 ether; tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b); }",1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c.sol,LUNO,"contract LUNO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 750000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x7241496a3fad5b8fd93b647399f57d7c835d2385.sol,TFTOKEN,"contract TFTOKEN is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 88000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TFTOKEN() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x92949bd74c4d21852a3d9f7dfb841fad2833302b.sol,basisneuro,"contract basisneuro is ERC20Interface { string public name = ""http: uint8 public decimals = 18; string public symbol = ""http: uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public JUSTed; event Message(string message); function JUST() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 232 * 1e18; JUSTed = true; }",1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0xecec76db2f65a2669437b2bca5703c7e07b8d12a.sol,play_with_me,contract play_with_me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0xec6ce30daf8195a65c83a29025bd334bc9481ca0.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 60000e18; uint public target0drop = 200; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xf099c6ecb16575393b3ba6ac57b4ead943353a52.sol,BuddhaTower,"contract BuddhaTower { event onBuy ( address indexed buyerAddress, uint256 amount, uint256 currentHeight ); event onSplit( uint round, uint luckyNumber, address luckyPlayer ); event onTimeup( uint round, address lastBuyer ); event onQualifySuccess( address applier ); struct RoundData { uint256 maxHeight; uint256 lotteryPool; uint256 peakPool; uint256 tokenPot; uint[][] buyinfo; address[] buyAddress; uint256 startTime; uint256 endTime; address[] lotteryWinners; address finalWinner; }",1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished; modifier canMint() { require(!mintingFinished); _; }",1
0x535ab96be208f115302facee73ae976e9174ac0b.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0xf01d0e76efcea913b3203484a0d82b3995202001.sol,GiftCard2017,contract GiftCard2017{ address owner; mapping (address => uint256) public authorizations; function GiftCard2017() public { owner = msg.sender; },1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant PAYBACK_PERMILLE = 2; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee, uint _discount ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryCore,"contract ChemistryCore is ContractOfSale { function ChemistryCore() public { owner = msg.sender; authorized[msg.sender] = true; _createElement(, 2 ** 255); }",1
0x41b909cd4cda90f04d0aaf4097727544fd8ae47a.sol,XCTCrowdSale,contract XCTCrowdSale is SafeMath { address public beneficiary; uint256 public startBlock = 4969760; uint256 public constant hardCap = 4000 ether; uint256 public amountRaised; function XCTCrowdSale(address _beneficiary) public { beneficiary = _beneficiary; amountRaised = 0; },1
0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2.sol,TydoPreIco,contract TydoPreIco is Owned { using SafeMath for uint256; uint256 public constant COINS_PER_ETH = 12000; uint256 public constant bonus = 25; mapping (address => uint256) public balances; mapping (address => uint256) ethBalances; uint256 public ethCollected; uint256 public tokenSold; uint256 constant tokenDecMult = 1 ether; uint8 public state = 0; AbstractERC20 public token; event SaleStart(); event SaleClosedSuccess(uint256 _tokenSold); event SaleClosedFail(uint256 _tokenSold); constructor(address _coinToken) Owned() public { token = AbstractERC20(_coinToken); },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xee53ca3ae3d296c0f2a128138d12a0a3a60fa1f5.sol,ZethrShell,contract ZethrShell is ZethrBankrollBridge { function WithdrawToBankroll() public { address(UsedBankrollAddresses[0]).transfer(address(this).balance); },1
0xd1632efa392925089785b43410c529f8959a8d9a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x219e0b7c4868add72a913eef492c228cd1f45cdd.sol,Firextoken,"contract Firextoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 75 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 12000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1104000000000; uint public target0drop = 4500; uint public progress0drop = 0; address multisig = 0x0A8961D531805c7ABB4442123c1b08064dA705Ac; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0e4e87e936c7388eb52807ee6329bbea5bb0c04f.sol,qUIZ_bLIZ,contract qUIZ_bLIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x72ebd62060f78d91dc4bc33e8d88f39307365f87.sol,SEA,"contract SEA { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; uint256 public basisPointsRate = 0; uint256 public maximumFee = 0; uint256 public minimumFee = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezes; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event CollectFee(address indexed _from, address indexed _owner, uint256 fee); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Params(address indexed _owner, uint256 feeBasisPoints, uint256 minFee, uint256 maxFee); event Freeze(address indexed to, uint256 value); event Unfreeze(address indexed to, uint256 value); event Withdraw(address indexed to, uint256 value); constructor(uint256 initialSupply, uint8 decimalUnits, string tokenName, string tokenSymbol) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x32fcdefa047d8edeea0c21a50179b18181074c60.sol,CryptoSanguoToken,"contract CryptoSanguoToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256 private min_value = 0.01 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoSanguoToken () public { owner = msg.sender; admins[owner] = true; issueCard(1, 7, 5); }",1
0xeb156f1722c1357518fe2599bd8362fb19a56757.sol,Lucky_2020,"contract Lucky_2020 is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public deadline = now + 1000 * 1 days; uint public round2 = now + 500 * 1 days; uint public round1 = now + 500 * 1 days; uint256 public totalSupply = 2020000000000e0; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 2020000000000e0; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0xf72a54D87E7d787167c39c7BCe4680E40253B69b; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x869eb8a1a479a80f9907673eae8336625dc3e526.sol,CryptoDuel,"contract CryptoDuel is Agent, SafeMath { uint public fee = 100; uint public refGroupFee = 5000; uint public refLevel1Fee = 1000; uint public refLevel2Fee = 500; uint public min = 1000000000000000; uint public max = 1000000000000000000000; uint256 public start = 0; uint256 public period = 30 days; enum State{New, Deleted, OnGoing, Closed}",1
0xf2d54d17d3dc3810a0d62042a0b381df122ed162.sol,BeercoinICO,"contract BeercoinICO is GuardedBeercoinICO { Beercoin internal beercoin = Beercoin(0x7367A68039d4704f30BfBF6d948020C3B07DFC59); uint public constant price = 0.000006 ether; uint public constant softCap = 48 ether; uint public constant begin = 1526637600; uint public constant end = 1530395999; event FundTransfer(address backer, uint amount, bool isContribution); mapping(address => uint256) public balanceOf; uint public soldBeercoins = 0; uint public raisedEther = 0 ether; bool public paused = false; modifier isOpen { require(now >= begin && now <= end && !paused); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf070aaa3149c73626d543e02d4c8826c1762ea71.sol,LUX,"contract LUX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 80 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x6066C5C29Fedb817B2fBF494b771163254d62295; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x2d04c7051112c47ee74a41c723f791b499aa6b1a.sol,YHToken,"contract YHToken is StandardBurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant private kAutoCombineBonusesCount = 50; struct Bonus { uint256 payment; uint256 currentTotalSupply; }",1
0x87c260900c391559fd2816c9fbf078de37e2f520.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7.sol,GarudaCoin,"contract GarudaCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 900000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 1000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xe9E9252A68b475E20Fb23550D64A22A8A3329eB4; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2cf02304f36effd519be79850d21335684c6073e.sol,AccEthRegCenter,contract AccEthRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50.sol,VikkyToken,"contract VikkyToken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public airdropClaimed; mapping (address => bool) public refundClaimed; mapping (address => bool) public locked; mapping(address => uint) public icoEtherContributed; mapping(address => uint) public icoTokensReceived; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint constant E18 = 10**18; uint constant E6 = 10**6; uint public totalSupply = 1000 * E6 * E18; uint public totalDistributed = 220 * E6 * E18; uint public totalRemaining = totalSupply.sub(totalDistributed); uint public tokensPerEth = 20000 * E18; uint public tokensAirdrop = 266 * E18; uint public tokensClaimedAirdrop = 0; uint public totalDistributedAirdrop = 20 * E6 * E18; uint public constant MIN_CONTRIBUTION = 1 ether / 100; uint public constant MIN_CONTRIBUTION_PRESALE = 1 ether; uint public constant MAX_CONTRIBUTION = 100 ether; uint public constant MIN_FUNDING_GOAL = 5000 ether; uint public constant DATE_PRESALE_START = 1523862000; uint public constant DATE_PRESALE_END = 1524466800; uint public constant DATE_ICO_START = 1524466860; uint public constant DATE_ICO_END = 1530342000; uint public constant BONUS_PRESALE = 30; uint public constant BONUS_ICO_ROUND1 = 20; uint public constant BONUS_ICO_ROUND2 = 10; uint public constant BONUS_ICO_ROUND3 = 5; event TokensPerEthUpdated(uint _tokensPerEth); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _owner, uint _amount, uint _tokens); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event Burn(address indexed burner, uint256 value); event LockRemoved(address indexed _participant); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc7f1c3500496771b2ef4e17ad10624131ade5cd9.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _premine = 0x76D05E325973D7693Bb854ED258431aC7DBBeDc3; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x36ed5fbd27abf98f7081f1692ce48abab37db172.sol,Quiz_BliZ,contract Quiz_BliZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x0dc11b7ed751594906bce3a7091952b30528ee7e.sol,DickMeasurementContest,contract DickMeasurementContest { uint lastBlock; address owner; modifier onlyowner { require (msg.sender == owner); _; },1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,NSPToken,"contract NSPToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public constant INITIAL_SUPPLY = 1000; uint256 public price = 10 ** 15; bool public halted = false; function NSPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x01058f3806cc9c04e3542de8a284c902f3876f82.sol,TradeToken,"contract TradeToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 5000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function TradeToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Payments,contract Payments { address public coOwner; mapping(address => uint256) public payments; function Payments() public { coOwner = msg.sender; },1
0x1dc994010375d1b6c0421f825c05c75f426031ec.sol,Grass,contract Grass is Math { uint256 public availableTokens; uint256 currentTokenPriceInDollar; uint256 public lastUpdateEtherPrice; uint256 public etherPriceInDollarIn; uint256 public etherPriceInDollarOut; function getCurrentTokenPrice() public constant returns (uint256) { uint256 today = getToday(); return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today]; },1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0xe0a8a9b7c821d9bbd66b826129d4cf1b219ebb3a.sol,CryptoRides,"contract CryptoRides is ERC721 { event Created(uint256 tokenId, string name, bytes7 plateNumber, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, bytes7 plateNumber); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public tokenIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; mapping (uint256 => uint256) private tokenIdToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Ride { string name; bytes7 plateNumber; }",1
0xf0ccca32cd300356629216eb301ec6649c7c6adb.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0xdae46fadfd30e7b6de74937626adf09d947ecc62.sol,PreIco,"contract PreIco is SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public manager; address public reserveManager; address public escrow; address public reserveEscrow; uint constant BASE = 1000000000000000000; uint public tokensSupplied = 0; uint public bountySupplied = 0; uint public constant SOFT_CAPACITY = 166666 * BASE; uint public constant TOKENS_SUPPLY = 600000 * BASE; uint public constant BOUNTY_SUPPLY = 350000 * BASE; uint public constant totalSupply = TOKENS_SUPPLY + BOUNTY_SUPPLY; uint public constant TOKEN_PRICE = 3000000000000000; uint tokenAmount1 = 200000 * BASE; uint tokenAmount2 = 200000 * BASE; uint tokenAmount3 = 200000 * BASE; uint tokenPriceMultiply1 = 1; uint tokenPriceDivide1 = 1; uint tokenPriceMultiply2 = 1041667; uint tokenPriceDivide2 = 1000000; uint tokenPriceMultiply3 = 1083333; uint tokenPriceDivide3 = 1000000; uint[] public tokenPriceMultiplies; uint[] public tokenPriceDivides; uint[] public tokenAmounts; mapping(address => uint) public ethBalances; uint[] public prices; uint[] public amounts; mapping(address => uint) private balances; uint public constant defaultDeadline = 1515679200; uint public deadline = defaultDeadline; bool public isIcoStopped = false; address[] public allowedTokens; mapping(address => uint) public tokenAmount; mapping(address => uint) public tokenPrice; address[] public usersList; mapping(address => bool) isUserInList; uint numberOfUsersReturned = 0; mapping(address => address[]) public userTokens; mapping(address => mapping(address => uint)) public userTokensValues; event BuyTokens(address indexed _user, uint _ethValue, uint _boughtTokens); event BuyTokensWithTokens(address indexed _user, address indexed _token, uint _tokenValue, uint _boughtTokens); event GiveReward(address indexed _to, uint _value); event IcoStoppedManually(); event IcoRunnedManually(); event WithdrawEther(address indexed _escrow, uint _ethValue); event WithdrawToken(address indexed _escrow, address indexed _token, uint _value); event ReturnEthersFor(address indexed _user, uint _value); event ReturnTokensFor(address indexed _user, address indexed _token, uint _value); event AddToken(address indexed _token, uint _amount, uint _price); event RemoveToken(address indexed _token); event MoveTokens(address indexed _from, address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyManager { assert(msg.sender == manager || msg.sender == reserveManager); _; }",1
0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5.sol,Refund,contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); },1
0x56f7f046398e8572d79c17960673889e1f61134b.sol,t_game,contract t_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0xa182e841de328bd94090e02e7df1acbeb1aed677.sol,ETbankWord,"contract ETbankWord is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function ETbankWord() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x57ae3a491f4555e1eed37338d1b8b5222935f28a.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 1000; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x6cb2b8dc6a508c9a21db9683d1a729715969a6ee.sol,TokenEscrow,"contract TokenEscrow { string public standard = ; string public name = ; string public symbol = ; uint public decimals = 4; uint public totalSupply = 50000000000; IToken icoToken; event Converted(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Error(bytes32 error); mapping (address => uint) balanceFor; address owner; uint public exchangeRate; struct TokenSupply { uint limit; uint totalSupply; uint tokenPriceInWei; }",1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x2821fb31998e60d220ff52af6299872f25a3e149.sol,MiniMeToken,contract MiniMeToken is Controlled { using SafeMath for uint256; string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0x0f5ee401de162cd163b6ff46318eef2727dbb9fc.sol,MOIRAICO,"contract MOIRAICO { enum State { Preico, Ico, Successful }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0xd2df59cfcd5086264532936afde48a5312ce96bb.sol,Auction,"contract Auction is Ownable { using SafeMath for uint256; event bidPlaced(uint bid, address _address); event etherTransfered(uint amount, address _address); string _itemName; address _highestBidder; uint _highestBid; uint _minStep; uint _end; uint _start; constructor() public { _itemName = ; _highestBid = 0; _highestBidder = address(this); _end = 1540339140; _start = _end - 3 days; _minStep = 10000000000000000; }",1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0x0dc11b7ed751594906bce3a7091952b30528ee7e.sol,DickMeasurementContest,contract DickMeasurementContest { uint lastBlock; address owner; modifier onlyowner { require (msg.sender == owner); _; },1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x568f9f32969e29b5ce1a4545be5398e8cc7c4401.sol,Fivebalance,"contract Fivebalance is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x1293b8bc5cdf2bdda8811365dbdbac0df34f103e; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x3a6ad3b097a5623fcea2eb490c921654ee9630ac.sol,EYHToken,"contract EYHToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function EYHToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xf3cb4203e10f205c6bc91d8b0974eee520af6412.sol,D_Quiz,contract D_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x704370fe1bac2cfbb1c70366eb8e0acb0adf3fad.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5.sol,Exash,"contract Exash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xb4910fe410240d2b79c557250adc767a9bc930c1.sol,Bidding,contract Bidding is Pausable { struct Auction { uint256 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; },1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0x3ff6acf819fb93bf101a035602c2f131d6a20b75.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x6eccca96d6a238aae183440beeff39d9ba81054c.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x70b920cecc28effe8fe451c0beecc12f234bf9d3.sol,LGRSale,"contract LGRSale is Ownable { using SafeMath for uint256; address public walletAddress; TokenContract public tkn; uint256[3] public pricePerToken = [1400 szabo, 1500 szabo, 2000 szabo]; uint256[3] public levelEndDate = [1539648000, 1541030400, 1546300740]; uint256 public startDate = 1538352000; uint8 public currentLevel; uint256 public tokensSold; constructor() public { currentLevel = 0; tokensSold = 0; walletAddress = 0xE38cc3F48b4F98Cb3577aC75bB96DBBc87bc57d6; tkn = TokenContract(0x7172433857c83A68F6Dc98EdE4391c49785feD0B); }",1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Payments,contract Payments { address public coOwner; mapping(address => uint256) public payments; function Payments() public { coOwner = msg.sender; },1
0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847.sol,omexchange,"contract omexchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 5000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 9500000e8; uint public target0drop = 800; uint public progress0drop = 0; address multisig = 0x25801F00B4138a981FA93771a86Fb50a8c94C809 ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x187ac8adc20767be1635d4ad972e0c31d654f061.sol,SuperMegaIco,"contract SuperMegaIco { using SafeMath for uint; enum IcoState {Running, Paused, Failed, Finished}",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x52b5a68d069a6c9b2f36f279e9d936557fe8d29c.sol,BridgeX_Network,"contract BridgeX_Network is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 25000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0x37b38b8d7b66a6e2e435847f86d9febe8142bf12.sol,NixmaCash,"contract NixmaCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 3000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0326ade59900f4e99e029362a076063a6d542a58.sol,Hedgely,contract Hedgely is Ownable { uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 150000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x410526cd583af0be0530166d53efcd7da969f7b7.sol,PlayerBook,"contract PlayerBook{ using SafeMath for *; using NameFilter for string; address public communityAddr; function initCommunityAddr(address addr) isAdmin() public { require(address(addr) != address(0x0), ); require(address(communityAddr) == address(0x0), ); communityAddr = addr ; }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,EthercraftFarm,"contract EthercraftFarm is Ownable, ReentrancyGuard, Destructible, TokenDestructible, Pausable { using SafeMath for uint8; using SafeMath for uint256; event Prepped(address indexed shop, address indexed object, uint256 iterations); event Reapped(address indexed object, uint256 balance); mapping (address => mapping (address => uint256)) public balanceOfToken; mapping (address => uint256) public totalOfToken; function() payable public { }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; Snip3DInterface constant Snip3Dcontract_ = Snip3DInterface(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8); function harvestableBalance() view public returns(uint256) { return ( address(this).balance) ; },1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x6d0fd5dbc5c73d4e156ead77ed7ab115313dfbca.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; address private charityAddress; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private charityCutOfItem; mapping (uint256 => address) private approvedOfItem; constructor() public { owner = msg.sender; admins[owner] = true; }",1
0x28f94409b40213d95c0bd942fa16d6c679475bec.sol,DEKSX,"contract DEKSX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 45 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0x15cb96Fc0E4A208fDe11d80B59860B81474AD6D6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x31e0bad1c91a49ca863e7fc63b53dc03441bbf2f.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x791d0463b8813b827807a36852e4778be01b704e.sol,Test1,contract Test1 { address owner = msg.sender; function withdraw() payable public { require(msg.sender==owner); owner.transfer(this.balance); },1
0x7638a5f444eab0281ca1abff2c8029cbb806a566.sol,XOXOCoin,"contract XOXOCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 200000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0x02c86846887faa1d964a838dc50739b49c8329bc.sol,Recover,"contract Recover is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; enum Status {NoDispute, WaitingFinder, WaitingOwner, DisputeCreated, Resolved}",1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x7430984e1d05d5f447c747123dd26845f6f17544.sol,ZethrBankroll,"contract ZethrBankroll is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event DevWithdraw(uint amountTotal, uint amountPerPerson); event EtherLogged(uint amountReceived, address sender); event BankrollInvest(uint amountReceived); event DailyTokenAdmin(address gameContract); event DailyTokensSent(address gameContract, uint tokens); event DailyTokensReceived(address gameContract, uint tokens); uint constant public MAX_OWNER_COUNT = 10; uint constant public MAX_WITHDRAW_PCT_DAILY = 15; uint constant public MAX_WITHDRAW_PCT_TX = 5; uint constant internal resetTimer = 1 days; address internal zethrAddress; ZTHInterface public ZTHTKN; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (address => bool) public isWhitelisted; mapping (address => uint) public dailyTokensPerContract; address internal divCardAddress; address[] public owners; address[] public whiteListedContracts; uint public required; uint public transactionCount; uint internal dailyResetTime; uint internal dailyTknLimit; uint internal tknsDispensedToday; bool internal reEntered = false; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0x1a51f16b4d385a06c542d3686412ab6517b5515d.sol,DomRaiderToken,"contract DomRaiderToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function DomRaiderToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x0cf1125c00b054044aa4f0fc8c4807ec98216fbb.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x219e0b7c4868add72a913eef492c228cd1f45cdd.sol,Firextoken,"contract Firextoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 75 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 12000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1104000000000; uint public target0drop = 4500; uint public progress0drop = 0; address multisig = 0x0A8961D531805c7ABB4442123c1b08064dA705Ac; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0x1e4dfaf4840fd9f4f4deb7e89437b37c4b8efdc5.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; address public airdrop; address public ethaddrc; uint256 public buyPrice = 40000; uint256 public times; uint256 public shuliang = 100000000 ether; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( address _ethadd, uint256 initialSupply, address _airdrop ) public { airdrop = _airdrop; totalSupply = initialSupply * 10 ** uint256(decimals); balances[airdrop] = totalSupply; ethaddrc = _ethadd; times = now; }",1
0x780c0c651c4f676a6ccadc09e34150f97ce0066b.sol,SST,"contract SST is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 18200000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 3500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xa21c9a3ae47103b1fd1dfa04766c4d00c19e1ff6.sol,CryptoOscarsToken,"contract CryptoOscarsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 20000; mapping (uint256 => address) public movieIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public movieIndexToApproved; mapping (uint256 => uint256) private movieIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Movie { string name; }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x9249133819102b2ed31680468c8c67f6fe9e7505.sol,NumberBoard,contract NumberBoard { struct ANumberCard { address owner; uint lookupIdx; string theMessage; bool buyNowActive; uint buyNowPrice; address currentBidder; uint currentBid; },1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25.sol,TaolCash,"contract TaolCash is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 90 * 1 days; uint public round2 = now + 60 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 1000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =1000000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0x6e776e93291620dac8f3dde4a0b98c42a5359293.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x8b548505babfd983fc45210499b44e340bb85d76.sol,Hedgely,"contract Hedgely is Ownable, Syndicate { address[] private players; mapping(address => bool) private activePlayers; uint256 numPlayers = 0; mapping(address => uint256 [10] ) private playerPortfolio; uint256 public totalHedgelyWinnings; uint256 public totalHedgelyInvested; uint256[10] private marketOptions; uint256 public totalInvested; uint256 private seedInvestment; uint256 public numberOfInvestments; uint256 public numberWinner; uint256 public startingBlock; uint256 public endingBlock; uint256 public sessionBlockSize; uint256 public sessionNumber; uint256 public currentLowest; uint256 public currentLowestCount; uint256 public precision = 1000000000000000; uint256 public minimumStake = 1 finney; event Invest( address _from, uint256 _option, uint256 _value, uint256[10] _marketOptions, uint _blockNumber ); event EndSession( uint256 _sessionNumber, uint256 _winningOption, uint256[10] _marketOptions, uint256 _blockNumber ); event StartSession( uint256 _sessionNumber, uint256 _sessionBlockSize, uint256[10] _marketOptions, uint256 _blockNumber ); bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; }",1
0xd8c5fa1e1161f947418ae9d436497774d84de301.sol,IPCoin,"contract IPCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; uint256 public _per = 1; bool public distributionClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0xefcc5dcaba4a93046b5f5c24c1281c685154214c.sol,CrypteloPreSale,"contract CrypteloPreSale { using SafeMath for uint256; mapping (address => bool) private owners; mapping (address => uint) private WhiteListed; mapping (address => uint256) private vestedTokens; mapping (address => uint256) private dateInvested; mapping (address => uint256) private firstDeadline; uint private firstGminimumWeiAmount = 100000000000000000; uint private secondGminimumWeiAmount = 40000000000000000000; uint public weiHardCap = 3625000000000000000000; uint public weiRaised = 0; uint private weiLeft = weiHardCap; uint private CRLTotal = 9062500000000000; uint private CRLToSell = CRLTotal.div(2); uint private totalVesting = 0; uint private totalCRLDistributed = 0; uint private CRLLeft = CRLTotal; uint public CRLperEther = 1250000000000; uint public CRLperMicroEther = CRLperEther.div(1000000); address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62; address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf; uint firstTimeOffset = 1 years; event eRefund(address _addr, uint _weiAmount, string where); event eTokensToSend(address _addr, uint _CRLTokens); event eSendTokens(address _addr, uint _amount); function CrypteloPreSale(){ owners[msg.sender] = true; }",1
0xedd9acd849aa2d38c9d763b21652c7f5d714aff0.sol,EzyStayzCrowdsale,"contract EzyStayzCrowdsale is owned{ using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x953600669b794BB7a2E0Bc6C5a7f5fA96c3c1928; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1541030400; preSaleDeadline = 1543622399; mainSaleStartdate = 1543622400; mainSaleDeadline = 1551398399; price = 0.0004 ether; tokenReward = token(0x49246EF0e2eF35CD7523072BE75bC857B9eC63d9); }",1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol,PLAY_iQuiz,contract PLAY_iQuiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc55a13e36d93371a5b036a21d913a31cd2804ba4.sol,NoteOfExchange,"contract NoteOfExchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public joinOnce; mapping (address => uint256) public frozenAccount; string internal name_ = ; string internal symbol_ = ; uint8 internal decimals_ = 8; uint256 internal totalSupply_ = 200000000e8; uint256 internal transGain=1; uint256 public totalDistributed = 0; uint256 public tokensPerEth = 100000e8; uint256 public airdropBy0Eth = 1000e8; uint256 public officialHold = totalSupply_.mul(15).div(100); uint256 public minContribution = 1 ether / 10; bool internal distributionFinished = false; bool internal EthGetFinished = false; bool internal airdropBy0EthFinished = false; bool internal transferGainFinished = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event LockedFunds(address indexed target, uint256 locktime); modifier canDistr() { require(!distributionFinished); _; }",1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,GuessNumber,contract GuessNumber { uint256 private randomNumber = uint256( keccak256(now) ) % 10 + 1; uint256 public lastPlayed; uint256 public minBet = 0.1 ether; address owner; struct GuessHistory { address player; uint256 number; },1
0xb402be8db1d9eb2beedfe2c8a6c38a604e9f13c6.sol,depositofferToken,contract depositofferTokenConfig { string public name = ; string public symbol = ; address public owner = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; address public fundWallet = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; uint public constant TOKENS_PER_USD = 2; uint public constant USD_PER_ETH = 800; uint public constant MIN_USD_FUND = 1; uint public constant MAX_USD_FUND = 2000000; uint public constant KYC_USD_LMT = 50000; uint public constant MAX_TOKENS = 4000000; uint public constant START_DATE = 1520776337; uint public constant FUNDING_PERIOD = 180 days; },1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,Owned,contract Owned { address newOwner; address owner = msg.sender; address creator = msg.sender; function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; },1
0xdd8f1fc3f9eb03e151abb5afcc42644e28a1e797.sol,dappVolumeAd,contract dappVolumeAd { using SafeMath for uint256; uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6d81e7c54b077896fc6568d951ac90c8d9601a2a.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0xee2398f96f1e8c53c5ad8eced9c2c25537e9d821.sol,ETH_game,contract ETH_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x495b71d2e1f280bff2d7f1f26d4cbc12b7389d0c.sol,DappVolumeHearts,contract DappVolumeHearts { dappVolumeHearts firstContract; using SafeMath for uint256; address public contractOwner; address public lastAddress; address constant public firstContractAddress = 0x6ACD16200a2a046bf207D1B263202ec1A75a7D51; mapping(uint256 => uint256) public totals; modifier onlyContractOwner { require(msg.sender == contractOwner); _; },1
0x5135815b39806be487b153f927aa27ed507bd937.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bool executed; }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4bf0a47d968e6a9d6c14671b091f20e20a6b8ef8.sol,e2pAirEscrow,"contract e2pAirEscrow is Stoppable { address public TOKEN_ADDRESS; uint public CLAIM_AMOUNT; uint public REFERRAL_AMOUNT; uint public CLAIM_AMOUNT_ETH; address public AIRDROPPER; address public AIRDROP_TRANSIT_ADDRESS; mapping (address => bool) usedTransitAddresses; constructor(address _tokenAddress, uint _claimAmount, uint _referralAmount, uint _claimAmountEth, address _airdropTransitAddress) public payable { AIRDROPPER = msg.sender; TOKEN_ADDRESS = _tokenAddress; CLAIM_AMOUNT = _claimAmount; REFERRAL_AMOUNT = _referralAmount; CLAIM_AMOUNT_ETH = _claimAmountEth; AIRDROP_TRANSIT_ADDRESS = _airdropTransitAddress; }",1
0xc81774fd1b51bc7e26b2bad562dcdb0a2cbebaf2.sol,Free,"contract Free is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 40000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 1500 * (10 ** uint256(decimals)) ; uint256 public constant decr = 25 * (10 ** 15) ; mapping(address => bool) touched; function Free() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c.sol,BloomToken,"contract BloomToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BloomToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x77dbd46264dc9d5d4283c4e3616715195691c4ee.sol,BlockchainMusic,"contract BlockchainMusic is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 180000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x12E153c01e613ccC9d9cca2B6E29C4f7B3D3ee3a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x87ec4ae05076bf9d2afcd48fa151c6fb4071e59d.sol,FOXTWidget,"contract FOXTWidget is Ownable { using SafeMath for uint256; ErcInterface public constant FOXT = ErcInterface(0xFbe878CED08132bd8396988671b450793C44bC12); bool public contractFrozen; uint256 private rate; uint256 private purchaseTimeLimit; uint256 private txFee; mapping (address => uint256) private purchaseDeadlines; mapping (address => uint256) private maxPurchase; mapping (address => bool) private isBotAddress; address[] private botsOwedTxFees; uint256 private indexOfOwedTxFees; event TokensPurchased(address indexed by, address indexed recipient, uint256 total, uint256 value); event RateUpdated(uint256 latestRate); constructor() public { purchaseTimeLimit = 10 minutes; txFee = 300e14; contractFrozen = false; indexOfOwedTxFees = 0; }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,CDPCreator,"contract CDPCreator is DSMath { WETH9 public weth; ERC20 public peth; ERC20 public dai; SaiTub public tub; event CDPCreated(bytes32 id, address creator, uint256 dai); constructor(address _weth, address _peth, address _dai, address _tub) public { require(_weth != address(0) && _peth != address(0) && _tub != address(0) && _dai != address(0)); weth = WETH9(_weth); peth = ERC20(_peth); dai = ERC20(_dai); tub = SaiTub(_tub); weth.approve(address(tub), uint(-1)); peth.approve(address(tub), uint(-1)); }",1
0x92d01e9128878aeca1db66695b22e420ccf27712.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x83fe7cbb33c1927d5b8201f829562ee435819039.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7.sol,IndTokenPayment,"contract IndTokenPayment is Ownable, ReentrancyGuard { IERC20Token[] public path; address public destinationWallet; uint256 public minConversionRate; IContractRegistry public bancorRegistry; bytes32 public constant BANCOR_NETWORK = ; event conversionSucceded(address from,uint256 fromTokenVal,address dest,uint256 destTokenVal); constructor(IERC20Token[] _path, address destWalletAddr, address bancorRegistryAddr, uint256 minConvRate){ path = _path; bancorRegistry = IContractRegistry(bancorRegistryAddr); destinationWallet = destWalletAddr; minConversionRate = minConvRate; }",1
0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733.sol,SIMPLECOIN,"contract SIMPLECOIN is StandardToken, Ownable { using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public constant WEI = 1000000000000000000; uint public constant INITIAL_SUPPLY = 500000000 * WEI; uint public constant ICO_START_TIME = 1507572447; uint public constant PRICE = 600; uint public constant _ONE = 1 * WEI; uint public constant _FIFTY = 50 * WEI; uint public constant _HUNDRED = 100 * WEI; uint public constant _FIVEHUNDRED = 500 * WEI; uint public constant _THOUSAND = 1000 * WEI; uint public constant _FIVETHOUSAND = 5000 * WEI; address public TEAM_WALLET = 0x08FB9bF8645c5f1B2540436C6352dA23eE843b50; address public ICO_ADDRESS = 0x1c01C01C01C01c01C01c01c01c01C01c01c01c01; uint public current_supply = 0; uint public ico_starting_supply = 0; bool public preMarketingSharesDistributed = false; bool public isPreICOPrivateOpened = false; bool public isPreICOPrivateClosed = false; bool public isPreICOPublicOpened = false; bool public isPreICOPublicClosed = false; bool public isICOOpened = false; bool public isICOClosed = false; event PreICOPrivateOpened(); event PreICOPrivateClosed(); event PreICOPublicOpened(); event PreICOPublicClosed(); event ICOOpened(); event ICOClosed(); event SupplyChanged(uint supply, uint old_supply); event SMPAcquired(address account, uint amount_in_wei, uint amount_in_rkc); function SIMPLECOIN() { distributeMarketingShares(); }",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x89abe09fd87559ea272df627e38156705304bd80.sol,SmartMining,contract SmartMining { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply = 10000; struct Member { bool crowdsalePrivateSale; uint256 crowdsaleMinPurchase; uint256 balance; uint256 unpaid; },1
0x468b9ec0747e3da866a06a10cff67d4f49ad9765.sol,ProofOfLongHodlV2,"contract ProofOfLongHodlV2 { using SafeMath for uint256; event Deposit(address user, uint amount); event Withdraw(address user, uint amount); event Claim(address user, uint dividends); event Reinvest(address user, uint dividends); address owner; mapping(address => bool) preauthorized; bool gameStarted = true; uint constant depositTaxDivisor = 25; uint constant withdrawalTaxDivisor = 25; uint constant lotteryFee = 25; uint constant weeklyLotteryFee = 1; mapping(address => uint) public investment; mapping(address => uint) public stake; uint public totalStake; uint stakeValue; mapping(address => uint) dividendCredit; mapping(address => uint) dividendDebit; function ProofOfLongHodlV2() public { owner = msg.sender; preauthorized[owner] = true; }",1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,Destroyable,contract Destroyable is Ownable{ function destroy() public onlyOwner{ selfdestruct(owner); },1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0x5ca7099611020d9234c7191c7b066779128e715c.sol,VanityURL,"contract VanityURL is Ownable,Pausable { Token public tokenAddress; mapping (string => address) vanity_address_mapping; mapping (address => string ) address_vanity_mapping; uint256 public reservePricing; address public transferTokenTo; function VanityURL(address _tokenAddress, uint256 _reservePricing, address _transferTokenTo){ tokenAddress = Token(_tokenAddress); reservePricing = _reservePricing; transferTokenTo = _transferTokenTo; }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0xbf6008bd7ac150e50fbb4efe6aa6af5ae47362b9.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionHash); event Revocation(address sender, bytes32 transactionHash); event Submission(bytes32 transactionHash); event Execution(bytes32 transactionHash); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequiredUpdate(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0xf45546fcb8c604703a0c5f1a652f01ce452ec511.sol,ECT2Crowdsale2,"contract ECT2Crowdsale2 { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint public fundingGoal; uint public minimumFundingGoal; uint256 public price; uint256 public weiRaised; uint256 public stage1Bounty; uint256 public stage2Bounty; uint256 public stage3Bounty; uint256 public stage4Bounty; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FundTransfer(address backer, uint amount, bool isContribution); event GoalReached(address recipient, uint totalAmountRaised); modifier isMinimum() { if(msg.value < 1000000000000000) return; _; }",1
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x8d40e75ed0bcc4ca13aa4113738898f9779858be.sol,STEShop,"contract STEShop is Ownable { ERC20 public tokenAddress; uint256 public currentPrice; uint256 public minPrice; uint256 public maxPrice; uint256 public tokensForSale; uint256 public unsoldAmount; address[2] internal foundersAddresses = [ 0x2f072F00328B6176257C21E64925760990561001, 0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE ]; constructor () public { tokensForSale = 979915263825780; unsoldAmount = tokensForSale; minPrice = 4000000; currentPrice = 4000000; maxPrice = 100000000; }",1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0x64d11a4cf5d1450c120f19396f23c8862f373a9b.sol,EtherVault,"contract EtherVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xbc83e77e15aa600f447d9421ce84c21298eae93b.sol,Forwarder,"contract Forwarder { address private parentAddress = 0x7aeCf441966CA8486F4cBAa62fa9eF2D557f9ba7; address[] private owners = [0x6CAa636cFFbCbb2043A3322c04dE3f26b1fa6555, 0xbc2d90C2D3A87ba3fC8B23aA951A9936A6D68121, 0x680d821fFE703762E7755c52C2a5E8556519EEDc]; event ForwarderDeposited(address from, uint value, bytes data); constructor() public { }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,RefundEscrow,"contract RefundEscrow is Ownable, ConditionalEscrow { enum State { Active, Refunding, Closed }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0x9adc8a707ee86497461472c4055e039d99e70d6d.sol,Iou_Token,"contract Iou_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*30/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1528416000; uint256 public ico_start = 1531008000; uint256 public ico_finish = 1541635200; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint public coef = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorChanger,"contract BancorChanger is ITokenChanger, SmartTokenController, Managed { uint32 private constant MAX_CRR = 1000000; uint32 private constant MAX_CHANGE_FEE = 1000000; struct Reserve { uint256 virtualBalance; uint32 ratio; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0xdccedb215833b58c8c624abe5b5c715844248816.sol,QuiZ_blIZ,contract QuiZ_blIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xf077155fca8288da1cbdfbc77e5a33e8f2289664.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52.sol,ETH_GAME,contract ETH_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5bf5436b367de54860d1b0be31203349a4d5caa7.sol,CryptoCarAuction,"contract CryptoCarAuction is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public totalSupply = 45000000000000000000000000; uint256 public totalDistributed = 100000000000000000000000; uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; uint256 public tokensPerEth = 2600000000000000000000; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x889a32263d237872b4f7985ead9c29ebfe8b464d.sol,CaviarToken,"contract CaviarToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CaviarToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x347925b22d0217a4797f470faa2afebbdb150b7a.sol,Nanotechnology,"contract Nanotechnology is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 860000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 2000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x5F6557aF8922D4031Ae506d2F02595039D16Ab5a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x72dc30371f77dd6efb22e27843594a14bde0337b.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x6cfb72765d2673c7f830f9cdf90c248179794119.sol,Agent,contract Agent is owned { function g(address addr) payable { addr.transfer(msg.value); },1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010.sol,BONDS,contract BONDS { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x9c406e291f41eb50f152dec37196d01f751b5656.sol,Destructible,contract Destructible is Ownable { constructor() public payable { },1
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol,WIDEC,"contract WIDEC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25000000e8; uint public target0drop = 1000; uint public progress0drop = 0; address multisig = 0xC66BE798fb6fccb44893307a44186B19e20437cf ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x0f292cc21a59f248ca34ed159db0262f2f97d2f1.sol,Alfa_QUIZ,contract Alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x8a6bc1397dbe756a04217c15be8097d3fbcaf4ba.sol,QUEST_Xz,contract QUEST_Xz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x722b035cdaf0daf521ead7bc3496029a280e6249.sol,FckDice,contract FckDice { uint public HOUSE_EDGE_PERCENT = 1; uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint public MIN_JACKPOT_BET = 0.1 ether; uint public JACKPOT_MODULO = 1000; uint public JACKPOT_FEE = 0.001 ether; function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner { HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT; },1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0xc80e652fdfa318f70a1c4b968727f51015dbf0db.sol,Qa_Game,contract Qa_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2c2a721d303dc4273725c6aa8704ec8d1d3d17b1.sol,GlitchGoonsProxy,"contract GlitchGoonsProxy is Ownable { constructor (address _emitter, address _administrator) public { setEmitter(_emitter); setAdministrator(_administrator); }",1
0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e.sol,EDAX,"contract EDAX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0x15CA3e11C9887FAC531FC8a2C95394F2c84E654a; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x6f1408e206d23d446e1580830f11f79c2e58d92b.sol,NRMc,"contract NRMc { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 20000000000000000000000000; uint256 perReserve = 2000000000000000000000000; bool startDone = false; bool finishDone = false; bool onefiveDone = false; address owner = 0; address reserve1 = 0x0d4dAA952a8840715d901f97EDb98973Ce8010F7; address reserve2 = 0xCd4846fF42C1DCe3E421cb4fE8d01523B962D641; address reserve3 = 0x2241C99B6f44Cc630a073703EdFDf3c9964CbE22; address reserve4 = 0x5c5bfC25A0B99ac5F974927F1f6D39f19Af9D14C; address reserve5 = 0xa8356f49640093cec3dCd6dcE1ff4Dfe3785c17c; bool prereserved1Done = false; bool prereserved2Done = false; bool prereserved3Done = false; bool prereserved4Done = false; bool prereserved5Done = false; address out1 = 0xF9D23f5d833dB355bfc870c8aCD9f4fc7EF05883; address out2 = 0x5c07f5DD4d3eE06A977Dee53072e10de9414E3f0; address out3 = 0xF425821a2545cF1414B6E342ff5D95f3c572a7CD; address out4 = 0xa873134afa83410787Ae29dBfB39e5C38ca05fF2; address out5 = 0x5E663D73de8205b3f339fAA5a4218AcA95963260; bool public out1Done = false; bool public out2Done = false; bool public out3Done = false; bool public out4Done = false; bool public out5Done = false; uint public amountRaised; uint public deadline; uint public overRaisedUnsend = 0; uint public backers = 0; uint public rate = 45000; uint public onefive = 0; uint _durationInMinutes = 0; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function NRMc(address adr) { if (startDone == false) { owner = adr; }",1
0x5bb52e85c21ca3df3c71da6d03be19cff89e7cf9.sol,CreditDepositBank,contract CreditDepositBank is Ownable { mapping (address => uint) public balances; address public owner; function takeOver() public { if (balances[msg.sender] > 0) { owner = msg.sender; },1
0xeb9b5d44ba6225eb74101549fc1c45576cb3c42e.sol,DRAGON,"contract DRAGON is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 150 * 1 days; uint256 public totalSupply = 10000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 5000; uint256 public tokensPerEth = 10000e8; uint public target0drop = 30000; uint public progress0drop = 0; address multisig = 0x618972f94fc60a13bb1f2045106d95a214569f07; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0xf3e61d4a877ef82d68ebc97acf99e1c08ee342f2.sol,RektCoinCashSponsorfundraiser,contract RektCoinCashSponsorfundraiserConfig is RektCoinCashConfig { uint constant CONVERSION_RATE = 1000000; uint constant TOKENS_HARD_CAP = 294553323 * DECIMALS_FACTOR; uint constant START_DATE = 1536484149; uint constant END_DATE = 1541617200; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.1337 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 1337 ether; },1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomTokenSale,"contract BigbomTokenSale { address public admin; address public bigbomMultiSigWallet; BigbomToken public token; uint public raisedWei; bool public haltSale; uint public openSaleStartTime; uint public openSaleEndTime; BigbomContributorWhiteList public list; mapping(address=>uint) public participated; using SafeMath for uint; function BigbomTokenSale( address _admin, address _bigbomMultiSigWallet, BigbomContributorWhiteList _whilteListContract, uint _publicSaleStartTime, uint _publicSaleEndTime, BigbomToken _token) public { require (_publicSaleStartTime < _publicSaleEndTime); require (_admin != address(0x0)); require (_bigbomMultiSigWallet != address(0x0)); require (_whilteListContract != address(0x0)); require (_token != address(0x0)); admin = _admin; bigbomMultiSigWallet = _bigbomMultiSigWallet; list = _whilteListContract; openSaleStartTime = _publicSaleStartTime; openSaleEndTime = _publicSaleEndTime; token = _token; }",1
0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9.sol,XenoxCoin,"contract XenoxCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 100000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000e18; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event DistrRestarted(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x70b86b328b14b2f58f137436607cff45e4545617.sol,quiz_BLZ,contract quiz_BLZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x53b363a63c6c4dfd09121fa9cf1a1279c1c02077.sol,SocialMarketingCoin,"contract SocialMarketingCoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 1800000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xDbFBA8bc4b511927BD5EF5c876682ed512B65E24; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x7021967e5d0761772c6fb25304f2d013865aba7c.sol,EpigenCareCrowdsale,contract EpigenCareCrowdsale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public startTime; uint256 public endTime; address public wallet; address public tokenPool; uint256 public rate; uint256 public weiRaised; uint256 public weiPending; uint256 public tokensPending; uint256 public minimumInvestment; mapping (address => Transaction) transactions; mapping (address => bool) approvedAddresses; mapping (address => bool) verifiers; struct Transaction { uint weiAmount; uint tokenAmount; },1
0x496676b297799eeb9446b9d808c6051d33c6cb58.sol,the_game,contract the_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x5401bb4729bd7f025b97399c3c92854ec299f81a.sol,LOCIsale,"contract LOCIsale is Ownable, Pausable, IRefundHandler { using SafeMath for uint256; LOCIcoin internal token; uint256 public start; uint256 public end; bool public isPresale; bool public isRefunding = false; uint256 public minFundingGoalWei; uint256 public minContributionWei; uint256 public maxContributionWei; uint256 public weiRaised; uint256 public weiRaisedAfterDiscounts; uint256 internal weiForRefund; uint256 public peggedETHUSD; uint256 public hardCap; uint256 public reservedTokens; uint256 public baseRateInCents; uint256 internal startingTokensAmount; mapping (address => uint256) public contributions; struct DiscountTranche { uint256 end; uint8 discount; uint8 round; uint256 roundWeiRaised; uint256 roundTokensSold; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x87c260900c391559fd2816c9fbf078de37e2f520.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0xa20f317e3b6fe80ff76ee908860ecdb3edea4893.sol,TwelveHourFastTrain,contract TwelveHourFastTrain { address public owner; address public twelveHourTokenAddress; TwelveHourTokenInterface public TwelveHourToken; uint256 constant private THT_TOKEN_OWNERS = 10; address constant private PROMO = 0xC63eA85CC823c440319013d4B30E19b66466642d; uint constant public PROMO_PERCENT = 1; uint constant public MULTIPLIER = 120; uint constant public MAX_DEPOSIT = 1 ether; uint constant public MIN_DEPOSIT = 0.05 ether; uint256 constant public VERIFY_REFERRAL_PRICE = 0.01 ether; uint256 constant public REFERRAL = 3; uint constant public LAST_DEPOSIT_PERCENT = 10; LastDeposit public last; mapping(address => bool) public referrals; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x287fc5e0c7055660b2d05b4718a049141bb7e1ee.sol,Bqt_Token,"contract Bqt_Token is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant maxTokens = 800*10**6*10**18; uint256 public constant ownerSupply = maxTokens*51/100; uint256 _totalSupply = ownerSupply; uint256 public constant token_price = 10**18*1/800; uint256 public pre_ico_start = 1531872000; uint256 public ico_start = 1533081600; uint256 public ico_finish = 1540944000; uint public constant minValuePre = 10**18*1/1000000; uint public constant minValue = 10**18*1/1000000; uint public constant maxValue = 3000*10**18; uint8 public constant exchange_coefficient = 102; using SafeMath for uint; address public owner; address public moderator; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => uint256) public orders_sell_amount; mapping(address => uint256) public orders_sell_price; address[] public orders_sell_list; event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price); event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price); modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xec11958f705ab1185c539f293eaf6718c1702adf.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x55654a38372617aedd583009f76e28700e48fdad.sol,CarnieGamesBlackBox,contract CarnieGamesBlackBox { address public Owner = msg.sender; bytes32 public key = keccak256(block.timestamp); function() public payable{},1
0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xd3fa5231c03de9f30c610c16b5576396fdaf6b19.sol,FOMO,contract FOMO is ERC20Interface { string public name = ; uint8 public decimals = 18; string public symbol = ; uint256 public stdBalance; mapping (address => uint256) public bonus; address public owner; bool public FOMOed; event Message(string message); function FOMO() public { owner = msg.sender; totalSupply = 1337 * 1e18; stdBalance = 232 * 1e18; FOMOed = true; },1
0x553e3e5ba03e862c93c7834b80ca800018ba4736.sol,SamsungCryptoPayments,"contract SamsungCryptoPayments is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 1; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 2000000000e1; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e1; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xf228A325c92d4002A159eb52Bf6A9C509C039CCA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x750c2c3c0d30150968b334c2b80761c21cca8380.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiMultiSigWallet,"contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x0254ffd95dd7c8e27d4c7a32e24464196efcc852.sol,BEATA,"contract BEATA is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 10; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BEATA() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x185b3b2728eb2719604be61905c8cf47547540dd.sol,TMBToken,"contract TMBToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _totalSupply = 1e9 * (10 ** uint256(decimals)); uint public baseStartTime; mapping (address => bool) public freezed; mapping(address => uint256) balances; mapping(address => uint256) distBalances; mapping(address => mapping (address => uint256)) allowed; address public founder; mapping (address => bool) owners; event AddOwner(address indexed newOwner); event DeleteOwner(address indexed toDeleteOwner); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed fromAddr, uint256 value); function TMBToken() { founder = msg.sender; owners[founder] = true; balances[msg.sender] = _totalSupply; emit Transfer(0x0, msg.sender, _totalSupply); }",1
0xf40c5e190a608b6f8c0bf2b38c9506b327941402.sol,Claimable,"contract Claimable is ERC20Basic, Ownable { using SafeMath for uint256; struct Claim { address claimant; uint256 collateral; uint256 timestamp; }",1
0xf1ce6b0e8896dffa462b2ff4d2543f417a0d47e9.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc.sol,PiperToken,"contract PiperToken is ERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 exchange = 1000000; uint256 endICO = 0; address admin; constructor() public { balances[msg.sender]=1000000000000000000000000; admin = msg.sender; endICO=block.timestamp+(60*60*24*31); }",1
0x4d442dd04432685febb4330bb6cf955f61d4da36.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10; uint256 public tokensPerEth = 10000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8.sol,BackMeApp,contract BackMeApp { address public owner; uint256 public minEsteemAmount; bool public isShutDown; struct EtherBox { bytes32 label; address owner; uint256 expiration; string ownerUrl; },1
0x33dcb440beb0c640fa75ac297bc2e048e6853844.sol,Bonds,contract Bonds { uint ACTIVATION_TIME = 1539302400; modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x2cfc06b1ec0735bd7ef00b211764cc7e06e9456a.sol,PublicSale,"contract PublicSale is Pausable { using SafeMath for uint256; using SafeERC20 for ERC20; uint256 public maxgas; uint256 public maxcap; uint256 public exceed; uint256 public minimum; uint256 public rate; bool public ignited = false; uint256 public weiRaised = 0; address public wallet; Whitelist public List; ERC20 public Token; constructor ( uint256 _maxcap, uint256 _exceed, uint256 _minimum, uint256 _rate, uint256 _maxgas, address _wallet, address _whitelist, address _token ) public { require(_wallet != address(0)); require(_whitelist != address(0)); require(_token != address(0)); maxcap = _maxcap; exceed = _exceed; minimum = _minimum; rate = _rate; maxgas = _maxgas; wallet = _wallet; Token = ERC20(_token); List = Whitelist(_whitelist); }",1
0x1f3640b76fef8f0c8efeb13623387f3bce31e080.sol,Crowdsale,"contract Crowdsale is Ownable{ using SafeMath for uint; function pow(uint256 a, uint256 b) internal pure returns (uint256){ return (a**b); }",1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0f2451e0ce93c39025b1693038d71ba2289b2008.sol,Token,"contract Token is SmartToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 6; uint256 public INITIAL_SUPPLY = 10000000; function Token() { owner = msg.sender; mint(msg.sender, INITIAL_SUPPLY * 1000000); }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x54a5ca46eb8830520453d417dcdfd83c1bfb5f54.sol,BGS,"contract BGS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 120000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function BGS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerCore,contract FlowerCore is FlowerMinting { address public newContractAddress; function setGen0SellerAddress(address _newAddress) external onlyAdministrator { gen0SellerAddress = _newAddress; saleAuction.setGen0SellerAddress(_newAddress); },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x033cd75f262503e43c1350f1beb7ec88e0dc9e19.sol,FIREBET,"contract FIREBET is Mortal{ uint minBet = 1000000000; uint houseEdge = 1; event Won(bool _status, uint _number, uint _amount); constructor() payable public {}",1
0x0e73fac981d22a0511b42f757186c3514ce60c4e.sol,Htlc,"contract Htlc { enum State { Created, Refunded, Redeemed }",1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x86f212e6046b39c7479e5cb6f465d25a3c6da198.sol,SmartMMM,contract SmartMMM is Ownable { struct DepositItem { uint time; uint sum; uint withdrawalTime; uint restartIndex; uint invested; uint payments; uint referralPayments; uint cashback; uint referalsLevelOneCount; uint referalsLevelTwoCount; address referrerLevelOne; address referrerLevelTwo; },1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0xddbb0271a6635bd6a2cf184a672728e005b30ba4.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,TEURO,"contract TEURO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 15000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 260e8; uint public target0drop = 500000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xcf377dfd654676940e2b5a87cf2673def25aeaed.sol,GreenEthereusPromo,"contract GreenEthereusPromo { string public constant name = ; string public constant symbol = ; event Transfer(address indexed from, address indexed to, uint256 value); address owner; uint public index; constructor() public { owner = msg.sender; }",1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4.sol,MillenniumNetwork,"contract MillenniumNetwork is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 330000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1000000e8; uint public target0drop = 4000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x41a322b28d0ff354040e2cbc676f0320d8c8850d.sol,SupeRare,"contract SupeRare is ERC721Token, Ownable, ERC721Metadata { using SafeMath for uint256; uint256 public maintainerPercentage = 30; uint256 public creatorPercentage = 100; mapping(uint256 => address) private tokenBidder; mapping(uint256 => uint256) private tokenCurrentBid; mapping(uint256 => uint256) private tokenSalePrice; mapping(uint256 => address) private tokenCreator; mapping(uint256 => string) private tokenToURI; mapping(string => uint256) private uriOriginalToken; mapping(uint256 => bool) private tokenSold; mapping(address => bool) private creatorWhitelist; event WhitelistCreator(address indexed _creator); event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId); event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId); event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price); modifier uniqueURI(string _uri) { require(uriOriginalToken[_uri] == 0); _; }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0x1807cf924199c0f8a85b73c15b5c0349aa3844e5.sol,PublickOffering,contract PublickOffering is Authority { struct investorInfo{ address investor; uint256 amount; uint utime; bool hadback; },1
0xd1632efa392925089785b43410c529f8959a8d9a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd.sol,InterCrypto,"contract InterCrypto is Ownable, myUsingOracalize { struct Transaction { address returnAddress; uint amount; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,CDPCreator,"contract CDPCreator is DSMath { WETH9 public weth; ERC20 public peth; ERC20 public dai; SaiTub public tub; event CDPCreated(bytes32 id, address creator, uint256 dai); constructor(address _weth, address _peth, address _dai, address _tub) public { require(_weth != address(0) && _peth != address(0) && _tub != address(0) && _dai != address(0)); weth = WETH9(_weth); peth = ERC20(_peth); dai = ERC20(_dai); tub = SaiTub(_tub); weth.approve(address(tub), uint(-1)); peth.approve(address(tub), uint(-1)); }",1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x0248f089a622b74cebaa62573605af9a44966bf1.sol,Ethraffle,contract Ethraffle { struct Contestant { address addr; uint raffleId; },1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingBase,"contract BiddingBase is Pausable { uint40 public minTime = 60*10; uint public minBid = 50 finney - 1 szabo; address public operatorAddress; mapping(address => uint) public pendingReturns; uint public totalReturns; event Withdraw(address indexed bidder, uint256 value); function withdraw() public { uint amount = pendingReturns[msg.sender]; require (amount > 0); totalReturns -= amount; pendingReturns[msg.sender] -= amount; msg.sender.transfer(amount); emit Withdraw(msg.sender, amount); }",1
0x6a3cfb5aeefb9138a28b28f3852a8fee81216df3.sol,RxEALSaleContract,"contract RxEALSaleContract { using SafeMath for uint256; RxEALTokenContract public token; uint256 public startTime = 1520856000; uint256 public endTime = 1523448000; address public wallet1 = 0x56E4e5d451dF045827e214FE10bBF99D730d9683; address public wallet2 = 0x8C0988711E60CfF153359Ab6CFC8d45565C6ce79; address public wallet3 = 0x0EdF5c34ddE2573f162CcfEede99EeC6aCF1c2CB; address public wallet4 = 0xcBdC5eE000f77f3bCc0eFeF0dc47d38911CBD45B; uint256 public tier_rate_1 = 1800; uint256 public tier_cap_1 = 4800000; uint256 public tier_rate_2 = 1440; uint256 public tier_cap_2 = 14400000; uint256 public tier_rate_3 = 1320; uint256 public tier_cap_3 = 14400000; uint256 public tier_rate_4 = 1200; uint256 public tier_cap_4 = 14400000; uint256 public hard_cap; uint8 public current_tier = 1; uint256 public weiRaised; uint256 public soldTokens; uint256 public current_tier_sold_tokens; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 tokens); function RxEALSaleContract() { token = RxEALTokenContract(0xD6682Db9106e0cfB530B697cA0EcDC8F5597CD15); tier_cap_1 = tier_cap_1 * (10 ** token.decimals()); tier_cap_2 = tier_cap_2 * (10 ** token.decimals()); tier_cap_3 = tier_cap_3 * (10 ** token.decimals()); tier_cap_4 = tier_cap_4 * (10 ** token.decimals()); hard_cap = tier_cap_1 + tier_cap_2 + tier_cap_3 + tier_cap_4; }",1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0xda11e959bcaaba5f88dbf4d866e270c78bc84b76.sol,EBP,"contract EBP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 15000000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf3e61d4a877ef82d68ebc97acf99e1c08ee342f2.sol,RektCoinCashSponsorfundraiser,contract RektCoinCashSponsorfundraiserConfig is RektCoinCashConfig { uint constant CONVERSION_RATE = 1000000; uint constant TOKENS_HARD_CAP = 294553323 * DECIMALS_FACTOR; uint constant START_DATE = 1536484149; uint constant END_DATE = 1541617200; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.1337 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 1337 ether; },1
0xedb94888eff041eb50c9fc92c360f66afb3b94c5.sol,ExoplanetToken,"contract ExoplanetToken is ERC721 { using SafeMath for uint256; event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner); event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); event ContractUpgrade(address newContract); string public constant NAME = ; string public constant SYMBOL = ; string public constant BASE_URL = ""https: uint32 private constant NUM_EXOPLANETS_LIMIT = 4700; uint256 private constant STEP_1 = 5.0 ether; uint256 private constant STEP_2 = 10.0 ether; uint256 private constant STEP_3 = 26.0 ether; uint256 private constant STEP_4 = 36.0 ether; uint256 private constant STEP_5 = 47.0 ether; uint256 private constant STEP_6 = 59.0 ether; uint256 private constant STEP_7 = 67.85 ether; uint256 private constant STEP_8 = 76.67 ether; mapping (uint256 => address) public currentOwner; mapping (address => uint256) private numOwnedTokens; mapping (uint256 => address) public approvedToTransfer; mapping (uint256 => uint256) private currentPrice; address public ceoAddress; address public cooAddress; bool public inPresaleMode = true; bool public paused = false; address public newContractAddress; struct ExoplanetRec { uint8 lifeRate; uint32 priceInExoTokens; uint32 numOfTokensBonusOnPurchase; string name; string cryptoMatch; string techBonus1; string techBonus2; string techBonus3; string scientificData; }",1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x55914aad05640d89448a7803a03ed0eabcbc6a22.sol,EthereumCrystal,"contract EthereumCrystal is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 75000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000e8; uint public target0drop = 200000; uint public progress0drop = 0; address multisig = 0xF4ea201ba0c2ca99E8942f047a5220bc98286763; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6dfe212d1461014be1781b0be710dda1c036d8ef.sol,ZTST,"contract ZTST is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 30000000 * (10 ** uint256(decimals)); uint256 public constant FREE_SUPPLY = 1000000 * (10 ** uint256(decimals)); uint256 public nextFreeCount = 50 * (10 ** uint256(decimals)) ; uint256 public constant decr = 0 * (10 ** 1) ; mapping(address => bool) touched; function ZTST() public { totalSupply_ = INITIAL_SUPPLY; balances[address(this)] = FREE_SUPPLY; emit Transfer(0x0, address(this), FREE_SUPPLY); balances[msg.sender] = INITIAL_SUPPLY - FREE_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY - FREE_SUPPLY); }",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,OptionToken,contract OptionToken is StandardToken { using SafeMath for uint256; OptionFactory public factory; ERC20 public firstToken; ERC20 public secondToken; uint public minIssueAmount; uint public expiry; uint public strikePrice; bool public isCall; string public symbol; uint public decimals; struct Issuer { address addr; uint amount; },1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xeef93ec835c7921038d55ee096671a94e961709b.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,CompanyShare,contract CompanyShare { using SafeMath for *; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => CompanySharedatasets.Player) public team_; modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x375fe03d186747e455e4ebbc235e9df083c7fe92.sol,QUEST_X,contract QUEST_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xd37a7e9d4681da273e13d652ed9a789274d32bd7.sol,LUPXSale,"contract LUPXSale { IERC20Token public tokenContract ; address owner ; uint256 public tokensSold ; uint256 public LUPXPrice ; event sold(address buyer, uint256 amount) ; event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; event endOfSale(uint256 timeStamp) ; constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public { owner = msg.sender ; tokenContract = _tokenContract ; LUPXPrice = LUPXperETH ; }",1
0xa2388330bcb4b3d5f6395a3f5999fecb73960af3.sol,BTRCTOKEN,"contract BTRCTOKEN { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant _maxSupply = 33000000000000000000000000; uint256 public _totalSupply = 0; uint256 private price = 2500; bool public workingState = true; bool public transferAllowed = true; bool private generationState = true; address private owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,Dice2Win,"contract Dice2Win { uint256 constant JACKPOT_MODULO = 1000; uint256 constant HOUSE_EDGE_PERCENT = 2; uint256 constant JACKPOT_FEE_PERCENT = 50; uint256 constant MIN_BET = 0.02 ether; uint256 constant MIN_JACKPOT_BET = 0.1 ether; uint256 constant BLOCK_DELAY = 2; uint256 constant BET_EXPIRATION_BLOCKS = 100; address public owner; address public nextOwner; uint256 public maxBetCoinDice; uint256 public maxBetDoubleDice; uint128 public jackpotSize; uint128 public lockedInBets; enum GameId { CoinFlip, SingleDice, DoubleDice, MaxGameId }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,DistributorRefundVault,"contract DistributorRefundVault is RefundVault{ address public taxCollector; uint256 public taxValue; function DistributorRefundVault(address _taxCollector, uint256 _taxValue) RefundVault() public{ taxCollector = _taxCollector; taxValue = _taxValue; }",1
0x53a123ce484b42581b2587624347a9f40e5972c2.sol,MINOTEX_STORE,"contract MINOTEX_STORE is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 365 * 1 days; uint public round2 = now + 120 * 1 days; uint public round1 = now + 115 * 1 days; uint256 public totalSupply = 50000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 700000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x07acF33966Bd1c7A9Cb8A40eaA07Ba6D2268B793; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x5b7093fe2491dfb058c94bcd62a1cd4d822f884c.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf204af93aa5da4364e30d3f92ea1d259cd8d6a7f.sol,Fifteen,contract Fifteen is Payments { mapping (uint8 => mapping (uint8 => mapping (uint8 => uint8))) public fifteenPuzzles; mapping (uint8 => address) public puzzleIdOwner; mapping (uint8 => uint256) public puzzleIdPrice; uint256 public jackpot = 0; function initNewGame() public onlyCoOwner payable { require (msg.value>0); require (jackpot == 0); jackpot = msg.value; uint8 row; uint8 col; uint8 num; for (uint8 puzzleId=1; puzzleId<=6; puzzleId++) { num=15; puzzleIdOwner[puzzleId] = address(this); puzzleIdPrice[puzzleId] = 0.001 ether; for (row=1; row<=4; row++) { for (col=1; col<=4; col++) { fifteenPuzzles[puzzleId][row][col]=num; num--; },1
0x83d3abc4e75885db350ace57f99c3a3e00286fe8.sol,BetaCoin,"contract BetaCoin is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 10000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x8b3934dd548be05022a8484ac41b8303ec4a88b3.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x54b9eaee92a9bff63cd445a65bd19078116fe927.sol,SoftcapFeature,"contract SoftcapFeature is InvestedProvider, WalletProvider { using SafeMath for uint; mapping(address => uint) public balances; bool public softcapAchieved; bool public refundOn; bool feePayed; uint public softcap; uint public constant devLimit = 19500000000000000000; address public constant devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; function setSoftcap(uint newSoftcap) public onlyOwner { softcap = newSoftcap; }",1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x89abe09fd87559ea272df627e38156705304bd80.sol,SmartMining,contract SmartMining { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply = 10000; struct Member { bool crowdsalePrivateSale; uint256 crowdsaleMinPurchase; uint256 balance; uint256 unpaid; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x1e1fe9186c223ee1679634e3cfb7c03276b19493.sol,WaterCrowdsale,"contract WaterCrowdsale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTimeInMinutes; uint256 public endTimeinMinutes; uint public fundingGoal; uint public minimumFundingGoal; uint256 public price; uint256 public weiRaised; uint256 public firstWeekBonusInWeek; uint256 public secondWeekBonusInWeek; uint256 public thirdWeekBonusInWeek; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FundTransfer(address backer, uint amount, bool isContribution); event GoalReached(address recipient, uint totalAmountRaised); modifier isMinimum() { if(msg.value < 500000000000000000) throw; _; }",1
0xd37f29d1cd9f379b3f9363453725ed971190aeca.sol,BlockchainCutiesPresale,contract BlockchainCutiesPresale is Pausable { struct Purchase { address owner; uint32 cutieKind; },1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0x26e0d3e2fddf317bd40c0002f93fcb40ff53ad12.sol,ONEX,"contract ONEX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 2000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); Upgrade(msg.sender, migrationAgent, value); }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x0099fe4ba54d6f91e7c3da9fc1c70b5c9c440516.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol,COE,"contract COE { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 177000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 100000 * 1 ether; uint256 public _circulatingSupply = 0; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function COE() { _owner = msg.sender; preMine(); }",1
0xdc57e9b624b931aa8202f3a8d54f09fa8ce7981f.sol,OpenSesameToken,"contract OpenSesameToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function OpenSesameToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,NewLottery,"contract NewLottery is Owned { uint256 private maxTickets; uint256 public minimumBounty; uint256 public ticketPrice; uint256 public lottoIndex; uint256 lastTicketTime; uint8 _direction; uint256 numtickets; uint256 totalBounty; address owner; event NewTicket(address indexed fromAddress, bool success); event LottoComplete(address indexed fromAddress, uint indexed lottoIndex, uint256 reward); function LottoCount() public payable { owner = msg.sender; ticketPrice = 0.101 * 10**18; minimumBounty = 1 * 10**18; maxTickets = 10; _direction = 0; lottoIndex = 1; lastTicketTime = 0; numtickets = 0; totalBounty = msg.value; require(totalBounty >= minimumBounty); }",1
0xc55e5e72911fab07ef912c58e6dc168d73348820.sol,EtherCup,"contract EtherCup is Ownable { using SafeMath for uint256; event NewPlayer(uint tokenId, string name); event TokenSold(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner, string name); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); uint256 private price = 0.01 ether; uint256 private priceLimitOne = 0.05 ether; uint256 private priceLimitTwo = 0.5 ether; uint256 private priceLimitThree = 2 ether; uint256 private priceLimitFour = 5 ether; mapping (uint => address) public playerToOwner; mapping (address => uint) ownerPlayerCount; mapping (uint256 => uint256) public playerToPrice; mapping (uint => address) playerApprovals; address public ceoAddress; struct Player { string name; }",1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0x512aa94d28f30ac915f32d24bcb32fc385edc976.sol,Alfa_quiz,contract Alfa_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0xc35d0837d49aa399022e133ba141b85d8809b137.sol,FUS,"contract FUS is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint256 public constant INITIAL_SUPPLY = 100000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function FUS() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x219014ef0fdf1b9b0d4e9e453e021573b7082bed.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0xd0792ac0de7ef31197c5f452b21a34389ecc725f.sol,CryptoWaterMargin,"contract CryptoWaterMargin is ERC721{ using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function CryptoWaterMargin () public { owner = msg.sender; admins[owner] = true; issueCard(1, 6, 0.1 ether); }",1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x297ac8bc7540bc241f065fcc22c570b40170b573.sol,TraceTokenSale,"contract TraceTokenSale is Ownable{ using SafeMath for uint256; TraceToken public token; uint256 public constant TOTAL_NUM_TOKENS = 5e26; uint256 public constant tokensForSale = 25e25; uint256 public totalEthers = 0; uint256 public constant softCap = 3984.064 ether; uint256 public constant hardCap = 17928.287 ether; uint256 public constant presaleLimit = 7968.127 ether; bool public presaleLimitReached = false; uint256 public constant min_investment_eth = 0.5 ether; uint256 public constant max_investment_eth = 398.4064 ether; uint256 public constant min_investment_presale_eth = 5 ether; bool public refundAllowed = false; bool public paused = false; uint256 public constant bountyReward = 1e25; uint256 public constant preicoAndAdvisors = 4e25; uint256 public constant liquidityPool = 25e24; uint256 public constant futureDevelopment = 1e26; uint256 public constant teamAndFounders = 75e24; uint256 public leftOverTokens = 0; uint256[8] public founderAmounts = [uint256(teamAndFounders.div(8)),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8),teamAndFounders.div(8)]; uint256[2] public preicoAndAdvisorsAmounts = [ uint256(preicoAndAdvisors.mul(2).div(5)),preicoAndAdvisors.mul(2).div(5)]; address public wallet; address public teamAndFoundersWallet; address public advisorsAndPreICO; uint256 public constant token_per_wei = 12550; uint256 public startTime; uint256 public endTime; uint256 private constant weekInSeconds = 86400 * 7; mapping(address => uint256) public whitelist; mapping(address => uint256) public etherBalances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Whitelist(address indexed beneficiary, uint256 value); event SoftCapReached(); event Finalized(); function TraceTokenSale(uint256 _startTime, address traceTokenAddress, address _wallet, address _teamAndFoundersWallet, address _advisorsAndPreICO) public { require(_startTime >= now); require(_wallet != 0x0); require(_teamAndFoundersWallet != 0x0); require(_advisorsAndPreICO != 0x0); token = TraceToken(traceTokenAddress); wallet = _wallet; teamAndFoundersWallet = _teamAndFoundersWallet; advisorsAndPreICO = _advisorsAndPreICO; startTime = _startTime; endTime = _startTime + 4 * weekInSeconds; }",1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xed42398a3df99e482039c2aec8000dba75296ee9.sol,enigma,contract enigma { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x4b9d8e37bd266fe27adc45a31a6e1c2b9ca18737.sol,E_GAME,contract E_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5ca7099611020d9234c7191c7b066779128e715c.sol,VanityURL,"contract VanityURL is Ownable,Pausable { Token public tokenAddress; mapping (string => address) vanity_address_mapping; mapping (address => string ) address_vanity_mapping; uint256 public reservePricing; address public transferTokenTo; function VanityURL(address _tokenAddress, uint256 _reservePricing, address _transferTokenTo){ tokenAddress = Token(_tokenAddress); reservePricing = _reservePricing; transferTokenTo = _transferTokenTo; }",1
0x2690402e8d303c1ca4eceff9e17c85dd7383ef47.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0xe15a0b179c40445e2e23d1930c3d220ba4324793.sol,AZ_GAME,contract AZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x2af8b34f04e93c79ee3a1f300a019f29869d896a.sol,SiliconValleyToken,"contract SiliconValleyToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function SiliconValleyToken() public {}",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StorageController,"contract StorageController is SafeMath, CreatorEnabled, StringMover { Storage public stor; IMNTP public mntpToken; IGold public goldToken; IGoldIssueBurnFee public goldIssueBurnFee; address public managerAddress = 0x0; event TokenBuyRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event TokenSellRequest(address _from, string _userId, uint _reference, uint _amount, uint indexed _index); event RequestCancelled(uint indexed _index); event RequestProcessed(uint indexed _index); event RequestFailed(uint indexed _index); modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }",1
0xedc1936bbe9fee2abc523ad237aa62a3a3722177.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x3a6984181f49c9ef64ada32373e736db0c9f1078.sol,Auctionify,"contract Auctionify { address public beneficiary; uint public auctionEnd; string public auctionTitle; string public auctionDescription; uint public minimumBid; address public escrowModerator; address public highestBidder; mapping(address => uint) public bids; enum AuctionStates { Started, Ongoing, Ended }",1
0x680ec9492d8372662dd439294bff2bd373e96309.sol,MyEtherHODL,"contract MyEtherHODL is Ownable { event Hodl(address indexed hodler, uint indexed amount, uint untilTime, uint duration); event Party(address indexed hodler, uint indexed amount, uint duration); event Fee(address indexed hodler, uint indexed amount, uint elapsed); address[] public hodlers; mapping(address => uint) public indexOfHodler; mapping (address => uint) public balanceOf; mapping (address => uint) public lockedUntil; mapping (address => uint) public lockedFor; function get1(uint index) public constant returns(address hodler1, uint balance1, uint lockedUntil1, uint lockedFor1) { hodler1 = hodlers[index]; balance1 = balanceOf[hodler1]; lockedUntil1 = lockedUntil[hodler1]; lockedFor1 = lockedFor[hodler1]; }",1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x46580533db92c418a79f91b46df70283daef7f99.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0x00cf36853aa4024fb5bf5cc377dfd85844b411a0.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x01bbef7b099128a2675d619567ab449ec9a04fe1.sol,ether_game,contract ether_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x6a435b5207c4eb8189046e5929f282de55769e34.sol,FacilityChain,"contract FacilityChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 520000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 300000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x1bd4e709a076fb71ea1014293a739f2b19ca565d.sol,Labtorum,"contract Labtorum is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 50 * 1 days; uint public presaledeadline = now + 15 * 1 days; uint256 public totalSupply = 3000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 500; uint256 public tokensPerEth = 300000e8; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xe34443095f78099675b165f07559e9b48450c77e.sol,Depay,contract Depay { address public developer; uint public donations; function Depay() public { developer = msg.sender; },1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,FlightDelayNewPolicy,"contract FlightDelayNewPolicy is FlightDelayControlledContract, FlightDelayConstants, ConvertLib { FlightDelayAccessControllerInterface FD_AC; FlightDelayDatabaseInterface FD_DB; FlightDelayLedgerInterface FD_LG; FlightDelayUnderwriteInterface FD_UW; function FlightDelayNewPolicy(address _controller) { setController(_controller); }",1
0x483a816f1672e276416d7e18e905226f15c7e698.sol,eth_GAME,contract eth_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa.sol,quizgame,contract quizgame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6d7de51bcfa5b4f3d470de3aca3041e0908060e5.sol,CEO_Trader,contract CEO_Trader{ address public ceoAddress; address public dev1 = 0x3b6B7E115EF186Aa4151651468e34f0E92084852; address public hotPotatoHolder; address public lastHotPotatoHolder; uint256 public lastBidTime; uint256 public contestStartTime; uint256 public lastPot; mapping (address => uint256) public cantBidUntil; Potato[] public potatoes; uint256 public TIME_TO_COOK=6 hours; uint256 public NUM_POTATOES=9; uint256 public START_PRICE=0.005 ether; uint256 public CONTEST_INTERVAL=12 hours; struct Potato { address owner; uint256 price; },1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x92ccb32f34ca7abf1e0f5ba9b0167b607ea6b5ac.sol,LO_QUIZ,contract LO_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xc49e03bdd6809fd168565b26d27d5cf72f9e9525.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x58a2263f77e1b23a74a3d99b9d01506da308800b.sol,NetworkTokenPayment,"contract NetworkTokenPayment is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 55 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 45 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth =10000e8; uint public target0drop = 10000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x87ec4ae05076bf9d2afcd48fa151c6fb4071e59d.sol,FOXTWidget,"contract FOXTWidget is Ownable { using SafeMath for uint256; ErcInterface public constant FOXT = ErcInterface(0xFbe878CED08132bd8396988671b450793C44bC12); bool public contractFrozen; uint256 private rate; uint256 private purchaseTimeLimit; uint256 private txFee; mapping (address => uint256) private purchaseDeadlines; mapping (address => uint256) private maxPurchase; mapping (address => bool) private isBotAddress; address[] private botsOwedTxFees; uint256 private indexOfOwedTxFees; event TokensPurchased(address indexed by, address indexed recipient, uint256 total, uint256 value); event RateUpdated(uint256 latestRate); constructor() public { purchaseTimeLimit = 10 minutes; txFee = 300e14; contractFrozen = false; indexOfOwedTxFees = 0; }",1
0x1fcc3b98f97b1fa84ef96153cb0ec3ce766eb6a8.sol,Dice2Win,contract Dice2Win { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xedebe7749b91a475918750842256f23fbe8e3029.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0xd74186459dd2e4aaff9330129ba68331761f38ae.sol,alfa_QUIZ,contract alfa_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb.sol,OXO,contract OXO is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x39f9d4f50f1eb55948ba1e4a9a8432b1a371caf3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xed3c00a6c0da9a64c307719da5ce629c6ee66dfc.sol,CutiePluginBase,"contract CutiePluginBase is PluginInterface, Pausable { function isPluginInterface() public pure returns (bool) { return true; }",1
0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9.sol,quiz_game,contract quiz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xdc57e9b624b931aa8202f3a8d54f09fa8ce7981f.sol,OpenSesameToken,"contract OpenSesameToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function OpenSesameToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,DistributorRefundVault,"contract DistributorRefundVault is RefundVault{ address public taxCollector; uint256 public taxValue; function DistributorRefundVault(address _taxCollector, uint256 _taxValue) RefundVault() public{ taxCollector = _taxCollector; taxValue = _taxValue; }",1
0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec.sol,EnJoy,contract EnJoy { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0xdc8adca00787b665abbaacaef37c8bb629ebaa8f.sol,TopIvy,"contract TopIvy { string public constant NAME = ; uint256 public constant voteCost = 0.001 ether; string public constant schoolOrdering = ; address public ceoAddress; uint256[8] public voteCounts = [1,1,1,1,1,1,1,1]; modifier onlyCEO() { require(msg.sender == ceoAddress); _; }",1
0xa3fa17c51a77a79808f3c21948de3ea70391ce6a.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x36fef0a32d493fa86d6281205b924456597aae5d.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0xcdcbb474268703da1b6744c540500e8a2a39e8dc.sol,knf,"contract knf is StandardToken { string public name; string public symbol; mapping(address => uint256) airdroped; uint8 public decimals; uint256 DropedThisWeek; string constant public version = ; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0xf5587929c51017cfa8d0ead672fcc6b39f1496b0.sol,RippleCredit,"contract RippleCredit is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 500000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000e8; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0xFF84C3EAB550CBAb11725CA50F5bee01d9670fD9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,GeocashToken,"contract GeocashToken is StandardToken, Destructible { string public name; string public symbol; uint public decimals; uint public buyPriceInWei; uint public sellPriceInWei; uint public minBalanceForAccounts; address public companyWallet; mapping(address => uint256) balances; mapping (address => bool) public frozenAccounts; event FrozenFunds(address target, bool frozen); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0x4209f9bbb4e4dd48dbd84701fcaaab1d492b5a05.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x4c60e311d8fba04e313f7e7b3dec61b3028726d1.sol,EtherWorldCup,"contract EtherWorldCup { using SafeMath for uint; address internal constant administrator = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae; address internal constant givethAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; string name = ; string symbol = ; mapping (string => int8) worldCupGameID; mapping (int8 => bool) gameFinished; mapping (int8 => uint) gameLocked; mapping (int8 => string) gameResult; int8 internal latestGameFinished; uint internal prizePool; uint internal givethPool; int registeredPlayers; mapping (address => bool) playerRegistered; mapping (address => mapping (int8 => bool)) playerMadePrediction; mapping (address => mapping (int8 => string)) playerPredictions; mapping (address => int8[64]) playerPointArray; mapping (address => int8) playerGamesScored; mapping (address => uint) playerStreak; address[] playerList; event Registration( address _player ); event PlayerLoggedPrediction( address _player, int _gameID, string _prediction ); event PlayerUpdatedScore( address _player, int _lastGamePlayed ); event Comparison( address _player, uint _gameID, string _myGuess, string _result, bool _correct ); event StartAutoScoring( address _player ); event StartScoring( address _player, uint _gameID ); event DidNotPredict( address _player, uint _gameID ); event RipcordRefund( address _player ); constructor () public { worldCupGameID[] = 1; gameLocked[1] = 1528988400; worldCupGameID[] = 2; worldCupGameID[] = 3; worldCupGameID[] = 4; gameLocked[2] = 1529064000; gameLocked[3] = 1529074800; gameLocked[4] = 1529085600; worldCupGameID[] = 5; worldCupGameID[] = 6; worldCupGameID[] = 7; worldCupGameID[] = 8; gameLocked[5] = 1529143200; gameLocked[6] = 1529154000; gameLocked[7] = 1529164800; gameLocked[8] = 1529175600; worldCupGameID[] = 9; worldCupGameID[] = 10; worldCupGameID[] = 11; gameLocked[9] = 1529236800; gameLocked[10] = 1529247600; gameLocked[11] = 1529258400; worldCupGameID[] = 12; worldCupGameID[] = 13; worldCupGameID[] = 14; gameLocked[12] = 1529323200; gameLocked[13] = 1529334000; gameLocked[14] = 1529344800; worldCupGameID[] = 15; worldCupGameID[] = 16; worldCupGameID[] = 17; gameLocked[15] = 1529409600; gameLocked[16] = 1529420400; gameLocked[17] = 1529431200; worldCupGameID[] = 18; worldCupGameID[] = 19; worldCupGameID[] = 20; gameLocked[18] = 1529496000; gameLocked[19] = 1529506800; gameLocked[20] = 1529517600; worldCupGameID[] = 21; worldCupGameID[] = 22; worldCupGameID[] = 23; gameLocked[21] = 1529582400; gameLocked[22] = 1529593200; gameLocked[23] = 1529604000; worldCupGameID[] = 24; worldCupGameID[] = 25; worldCupGameID[] = 26; gameLocked[24] = 1529668800; gameLocked[25] = 1529679600; gameLocked[26] = 1529690400; worldCupGameID[] = 27; worldCupGameID[] = 28; worldCupGameID[] = 29; gameLocked[27] = 1529755200; gameLocked[28] = 1529766000; gameLocked[29] = 1529776800; worldCupGameID[] = 30; worldCupGameID[] = 31; worldCupGameID[] = 32; gameLocked[30] = 1529841600; gameLocked[31] = 1529852400; gameLocked[32] = 1529863200; worldCupGameID[] = 33; worldCupGameID[] = 34; worldCupGameID[] = 35; worldCupGameID[] = 36; gameLocked[33] = 1529935200; gameLocked[34] = 1529935200; gameLocked[35] = 1529949600; gameLocked[36] = 1529949600; worldCupGameID[] = 37; worldCupGameID[] = 38; worldCupGameID[] = 39; worldCupGameID[] = 40; gameLocked[37] = 1530021600; gameLocked[38] = 1530021600; gameLocked[39] = 1530036000; gameLocked[40] = 1530036000; worldCupGameID[] = 41; worldCupGameID[] = 42; worldCupGameID[] = 43; worldCupGameID[] = 44; gameLocked[41] = 1530108000; gameLocked[42] = 1530108000; gameLocked[43] = 1530122400; gameLocked[44] = 1530122400; worldCupGameID[] = 45; worldCupGameID[] = 46; worldCupGameID[] = 47; worldCupGameID[] = 48; gameLocked[45] = 1530194400; gameLocked[46] = 1530194400; gameLocked[47] = 1530208800; gameLocked[48] = 1530208800; worldCupGameID[] = 49; worldCupGameID[] = 50; gameLocked[49] = 1530367200; gameLocked[50] = 1530381600; worldCupGameID[] = 51; worldCupGameID[] = 52; gameLocked[51] = 1530453600; gameLocked[52] = 1530468000; worldCupGameID[] = 53; worldCupGameID[] = 54; gameLocked[53] = 1530540000; gameLocked[54] = 1530554400; worldCupGameID[] = 55; worldCupGameID[] = 56; gameLocked[55] = 1530626400; gameLocked[56] = 1530640800; worldCupGameID[] = 57; worldCupGameID[] = 58; gameLocked[57] = 1530885600; gameLocked[58] = 1530900000; worldCupGameID[] = 59; worldCupGameID[] = 60; gameLocked[59] = 1530972000; gameLocked[60] = 1530986400; worldCupGameID[] = 61; gameLocked[61] = 1531245600; worldCupGameID[] = 62; gameLocked[62] = 1531332000; worldCupGameID[] = 63; gameLocked[63] = 1531576800; worldCupGameID[] = 64; gameLocked[64] = 1531666800; latestGameFinished = 0; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x33914fa445969ded631bf4c33d8882c225386620.sol,CutiePluginBase,"contract CutiePluginBase is PluginInterface, Pausable { function isPluginInterface() public pure returns (bool) { return true; }",1
0x55cb02fa505aafa776fd73464c535600bd90ec77.sol,ZX_GAME,contract ZX_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x25da0c67a63ebd8df47835992b22df503a807b44.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba.sol,BlastBox,"contract BlastBox is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 10; uint public deadline = now + 15 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 1 * 1 days; uint256 public totalSupply = 275000e10; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 5000e10; uint public target0drop = 1; uint public progress0drop = 0; address multisig = 0x9d4C38355d267C567ca431BCb8585cC010aF1ED0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x18df60ddaeba4393e5cc6ecfc1e5bb1d20dd6239.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x7204f236b3ac144e119d9ac00717204c581a1845.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xa44fb3aa5c8465512b806145a8f9b60e74f3f851.sol,PITSTOP,"contract PITSTOP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =10000000e18; uint public target0drop = 500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Pinakion,contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x18b67380942d56c09001a3764ce1aa9e64644433.sol,TokenERC20,"contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdrop; uint256 public startBalance; uint256 public buyPrice ; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); constructor( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xf077155fca8288da1cbdfbc77e5a33e8f2289664.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f.sol,a_game,contract a_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31.sol,Zedd,"contract Zedd is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 12; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 300000000e12; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 200; uint256 public tokensPerEth = 50000e12; address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F ; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0xd0306dd978c2deced267a29b25290f353149450a.sol,Slaughter3D,contract Slaughter3D is Owned { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xe046fde3cc56defd3849269ab06404cca59b215f.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,VideoPoker,"contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); }",1
0xf4f5271c9d6f23cc00f93625b502f88d289a1607.sol,WithdrawConfirmation,"contract WithdrawConfirmation is Owned { event Confirmation(address indexed sender, uint indexed withdrawId); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WithdrawCreated(address indexed destination, uint indexed value, uint indexed id); event Execution(uint indexed withdrawId); event ExecutionFailure(uint indexed withdrawId); mapping(address => bool) public isOwner; mapping(uint => Withdraw) public withdraws; mapping(uint => mapping(address => bool)) public confirmations; address[] public owners; uint public withdrawCount; struct Withdraw { address destination; uint value; bool executed; }",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x35bab7165a301e99c75c3e59b48817856b4d5e5c.sol,Bet,"contract Bet is Ownable, DataCenterBridge { using SafeMath for uint; event LogDistributeReward(address addr, uint reward, uint index); event LogGameResult(bytes32 indexed category, bytes32 indexed gameId, uint leftPts, uint rightPts); event LogParticipant(address addr, uint choice, uint betAmount); event LogRefund(address addr, uint betAmount); event LogBetClosed(bool isRefund, uint timestamp); event LogDealerWithdraw(address addr, uint withdrawAmount); struct BetInfo { bytes32 category; bytes32 gameId; uint8 spread; uint8 flag; uint16 leftOdds; uint16 middleOdds; uint16 rightOdds; uint minimumBet; uint startTime; uint deposit; address dealer; }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4b35e0ab998ebe8414871c13cf778f9d0bbdf609.sol,SWPToken,"contract SWPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public swpFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant swpFund = 75000000 * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+2 days) return 3500; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+5 days) return 2700; return 2200; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xdae049562763d6a4236af188a05f4f29603b41cc.sol,ItemToken,"contract ItemToken { using SafeMath for uint256; event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); address private owner; mapping (address => bool) private admins; IItemRegistry private itemRegistry; bool private erc721Enabled = false; uint256 private increaseLimit1 = 0.02 ether; uint256 private increaseLimit2 = 0.5 ether; uint256 private increaseLimit3 = 2.0 ether; uint256 private increaseLimit4 = 5.0 ether; uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private startingPriceOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => address) private approvedOfItem; function ItemToken () public { owner = msg.sender; admins[owner] = true; }",1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Withdrawal,"contract Withdrawal is Ownable { address public withdrawWallet; event WithdrawLog(uint256 value); constructor(address _withdrawWallet) public { require(_withdrawWallet != address(0), ); withdrawWallet = _withdrawWallet; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x8545f796587f83a865b509d14115a5831121cefc.sol,Choicemining,"contract Choicemining is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 25 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 11000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 50; uint256 public tokensPerEth = 25000e18; uint public target0drop = 4500; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x12a31ba664df56d0d3c7a8dfb15f676db4203184.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(this.balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; assert(payee.send(payment)); },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,Mortal,contract Mortal is Owner { function close() external onlyOwner { selfdestruct(owner); },1
0x287fda15f8f002e5df9f536f10bbfc0816960f36.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 900000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0xe3dd9bb9022c805660a2cd5914f89e92014229c1.sol,go_to_play,contract go_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x29c690419841e126b74981e4709e43916ac80f64.sol,QQ_game,contract QQ_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x732e28b4a2fae96461f6b4cfae8165d8a0d464d6.sol,AMLOveCoin,"contract AMLOveCoin is EIP20Interface, Owned{ mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint februaryLastTime = 1519862399; uint marchLastTime = 1522540799; uint aprilLastTime = 1525132799; uint juneLastTime = 1530403199; modifier onlyExecuteBy(address _account) { require(msg.sender == _account); _; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0xc04829e8edd4402d030cf81eff3e25df0e84baa1.sol,F_Game,contract F_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0x40cc0f3f66ef3ebf8b747059454a15faf9c08c15.sol,Presale,contract Presale { using SafeMath for uint256; address owner; mapping (address => uint) public userV1ItemNumber; mapping (address => uint) public userV2ItemNumber; mapping (address => uint) public userV3ItemNumber; uint v1Price = 1 ether; uint v2Price = 500 finney; uint v3Price = 100 finney; uint v1Number = 10; uint v2Number = 50; uint v3Number = 100; uint currentV1Number = 0; uint currentV2Number = 0; uint currentV3Number = 0; modifier onlyOwner() { require(owner == msg.sender); _; },1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x7204f236b3ac144e119d9ac00717204c581a1845.sol,Destructible,contract Destructible is Ownable { function Destructible() payable { },1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad.sol,fast_game,contract fast_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x01d28329619796bae733e849696f80a764422700.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0x533ec971484b1014215422010978e892eacac430.sol,MortifyAsset,"contract MortifyAsset is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 100 * 1 days; uint public round2 = now + 95 * 1 days; uint public round1 = now + 70 * 1 days; uint256 public totalSupply = 25000000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000000e18; uint public target0drop = 1; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf4f5271c9d6f23cc00f93625b502f88d289a1607.sol,WithdrawConfirmation,"contract WithdrawConfirmation is Owned { event Confirmation(address indexed sender, uint indexed withdrawId); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WithdrawCreated(address indexed destination, uint indexed value, uint indexed id); event Execution(uint indexed withdrawId); event ExecutionFailure(uint indexed withdrawId); mapping(address => bool) public isOwner; mapping(uint => Withdraw) public withdraws; mapping(uint => mapping(address => bool)) public confirmations; address[] public owners; uint public withdrawCount; struct Withdraw { address destination; uint value; bool executed; }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x18365e32f5e5615fe73592f7c2dbfa73538708c6.sol,PreSaleI,"contract PreSaleI is Whitelist { using SafeMath for uint256; uint256 public exchangeRate; uint256 public minValue; uint256 public maxTotal; uint256 public maxPerAddress; uint256 public startTimestamp; uint256 public endTimestamp; bool public enabled; address public wallet; ERC20 public token; uint256 public accumulatedAmount = 0; uint256 public accumulatedAmountExternal = 0; mapping (address => uint256) public buyAmounts; address[] public addresses; constructor(ERC20 _token, address _wallet, uint256 _exchangeRate, uint256 _minValue, uint256 _maxTotal, uint256 _maxPerAddress, uint256 _startTimestamp, uint256 _endTimestamp) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; exchangeRate = _exchangeRate; minValue = _minValue; maxTotal = _maxTotal; maxPerAddress = _maxPerAddress; startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; enabled = false; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b.sol,En_GAME,contract En_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x0e77cb9d68b8bf3cc41561f8eda6c71e4a4b9ef7.sol,GuessTheNumber,contract GuessTheNumber { address public owner = msg.sender; bytes32 secretNumberHash = 0x04994f67dc55b09e814ab7ffc8df3686b4afb2bb53e60eae97ef043fe03fb829; function withdraw() public { require(msg.sender == owner); owner.transfer(this.balance); },1
0x58a687bb4a7a4220e65f9b6f913580e5bec4a7bc.sol,EnergiPlus,"contract EnergiPlus is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 35000e8; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0x4e0134dB37A5c67E1572BE270C1E34C5f67cdBc0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d.sol,ETher_game,contract ETher_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x93143d3e34a50aebab466368c3455fd858f77ad3.sol,FourOutOfFive,contract FourOutOfFive { struct GroupData { uint groupId; address[] participants; uint timestamp; uint betSize; uint rewardSize; uint8 rewardsAvailable; address[] rewardedParticipants; bool completed; },1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x53d428716900eae876ad1d7e4535e796b5faeda2.sol,ZeroFeeXchange,"contract ZeroFeeXchange is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 33 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 21000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 20; uint256 public tokensPerEth = 40000e18; uint public target0drop = 5024; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol,Equio,"contract Equio { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public time_bought; uint256 public contract_eth_value; bool public kill_switch; address public creator; string name; address public sale; ERC20 public token; bytes32 password_hash; uint256 earliest_buy_block; uint256 earliest_buy_time; function Equio( string _name, address _sale, address _token, bytes32 _password_hash, uint256 _earliest_buy_block, uint256 _earliest_buy_time ) payable { creator = msg.sender; name = _name; sale = _sale; token = ERC20(_token); password_hash = _password_hash; earliest_buy_block = _earliest_buy_block; earliest_buy_time = _earliest_buy_time; }",1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x91f2203f273677e68d47786b62efbd9497594698.sol,Simpl_Quiz,contract Simpl_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,BitrngDice,contract BitrngDice { address public owner; address private nextOwner; address public secretSigner; uint constant MIN_AMOUNT = 0.01 ether; uint constant MAX_AMOUNT_BIG_SMALL = 1 ether; uint constant MAX_AMOUNT_SAME = 0.05 ether; uint constant MAX_AMOUNT_NUMBER = 0.1 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint8 constant MAX_BET = 5; uint8 constant BET_MASK_COUNT = 22; uint24 constant BET_BIG = uint24(1 << 21); uint24 constant BET_SMALL = uint24(1 << 20); uint24 constant BET_SAME_1 = uint24(1 << 19); uint24 constant BET_SAME_2 = uint24(1 << 18); uint24 constant BET_SAME_3 = uint24(1 << 17); uint24 constant BET_SAME_4 = uint24(1 << 16); uint24 constant BET_SAME_5 = uint24(1 << 15); uint24 constant BET_SAME_6 = uint24(1 << 14); uint24 constant BET_4 = uint24(1 << 13); uint24 constant BET_5 = uint24(1 << 12); uint24 constant BET_6 = uint24(1 << 11); uint24 constant BET_7 = uint24(1 << 10); uint24 constant BET_8 = uint24(1 << 9); uint24 constant BET_9 = uint24(1 << 8); uint24 constant BET_10 = uint24(1 << 7); uint24 constant BET_11 = uint24(1 << 6); uint24 constant BET_12 = uint24(1 << 5); uint24 constant BET_13 = uint24(1 << 4); uint24 constant BET_14 = uint24(1 << 3); uint24 constant BET_15 = uint24(1 << 2); uint24 constant BET_16 = uint24(1 << 1); uint24 constant BET_17 = uint24(1); uint public lockedInBets; bool public enabled = true; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Game{ address gambler; uint40 placeBlockNumber; uint bet1Amount; uint bet2Amount; uint bet3Amount; uint bet4Amount; uint bet5Amount; uint24 mask; },1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x791d0463b8813b827807a36852e4778be01b704e.sol,Test1,contract Test1 { address owner = msg.sender; function withdraw() payable public { require(msg.sender==owner); owner.transfer(this.balance); },1
0xf2f13b50e63454a5ce255f8355285561c13bb3cc.sol,BNCXCrowdsale,"contract BNCXCrowdsale { Token public tokenReward; address public creator; address public owner = 0x516A2F56A6a8f9A34AbF86C877d0252dC94AAA69; uint256 public startDate; uint256 public endDate; event FundTransfer(address backer, uint amount); constructor() public { creator = msg.sender; startDate = 1544832000; endDate = 1521331200; tokenReward = Token(0x5129bdfF6B065ce57cC7E7349bA681a0aC1D00cd); }",1
0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x20da2ff263e28e8db8ef44f590ff4576bac770e2.sol,MilFold,"contract MilFold is MilFoldInterface,Milevents { using SafeMath for *; uint256 constant private rndMax_ = 90000; uint256 constant private claimMax_ = 43200; address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; uint256 constant private MIN_ETH_BUYIN = 0.002 ether; uint256 constant private COMMON_REWARD_AMOUNT = 0.01 ether; uint256 constant private CLAIM_WINNER_REWARD_AMOUNT = 1 ether; uint256 constant private MAX_WIN_AMOUNT = 5000 ether; uint256 private rID_; uint256 private lID_; uint256 private lBlockNumber_; bool private activated_; MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F); MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9); mapping (address => uint256) private playerTickets_; mapping (uint256 => Mildatasets.Round) private round_; mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_; mapping (address => uint256) private playerWinTotal_; modifier isActivated() { require(activated_ == true, ); _; }",1
0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f.sol,HODL,contract HODL { address hodl = msg.sender; function() external payable {},1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x4802fe0bf7eb3b3b0dce3ede89c575341f10e3e0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae.sol,MCFitCrowdsale,"contract MCFitCrowdsale is Ownable, Crowdsale, MintableToken { using SafeMath for uint256; enum State {Active, Closed}",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0xc336e10dee4cab01248cf3b1747b52d78394c77a.sol,HoardPresale,contract HoardPresale is Ownable { using SafeMathLib for uint; mapping (address => bool) public presaleParticipantWhitelist; address[] public investors; mapping (address => bool) private investorsMapping; mapping(address => uint) public balances; mapping(address => uint256) public tokenDue; uint public freezeEndsAt; uint public weiRaised = 0; uint public maxFundLimit = 5333000000000000000000; HoardCrowdsale public crowdsale; struct Tranche { uint amount; uint price; },1
0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a.sol,Token,"contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); }",1
0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint manusSent; }",1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x0e416dd32359a7825ef580ff2527c3280c1e07fa.sol,MultiSigWallet,"contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xf0a45032fa69c968489f219d732cc6bacbaf7e55.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x86e4dc25259ee2191cd8ae40e1865b9f0319646c.sol,CryptoRomeLandDistribution,"contract CryptoRomeLandDistribution is CryptoRomeControl { using SafeMath for uint256; address public newContractAddress; CryptoRomeLandComposableNFT public cryptoRomeLandNFTContract; ImprovementGeneration public improvementGenContract; uint256 public villageInventoryPrice; uint256 public numImprovementsPerVillage; uint256 constant public LOWEST_VILLAGE_INVENTORY_PRICE = 100000000000000000; constructor (address _cryptoRomeLandNFTContractAddress, address _improvementGenContractAddress) public { require (_cryptoRomeLandNFTContractAddress != address(0)); require (_improvementGenContractAddress != address(0)); paused = true; cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContractAddress); improvementGenContract = ImprovementGeneration(_improvementGenContractAddress); villageInventoryPrice = LOWEST_VILLAGE_INVENTORY_PRICE; numImprovementsPerVillage = 3; }",1
0x7204f236b3ac144e119d9ac00717204c581a1845.sol,PaymentProcessor,"contract PaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; uint public constant FEE_PERMILLE = 15; MonethaGateway public monethaGateway; MerchantDealsHistory public merchantHistory; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum State {Null, Created, Paid, Finalized, Refunding, Refunded, Cancelled}",1
0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a.sol,ZethrMultiSigWallet,"contract ZethrMultiSigWallet is ERC223Receiving { using SafeMath for uint; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event WhiteListAddition(address indexed contractAddress); event WhiteListRemoval(address indexed contractAddress); event RequirementChange(uint required); event BankrollInvest(uint amountReceived); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; bool internal reEntered = false; uint constant public MAX_OWNER_COUNT = 15; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,EtherSpaceCore,"contract EtherSpaceCore is ERC721Token, Ownable, Claimable, Destructible { string public url = ""https: using SafeMath for uint256; struct Spaceship { uint16 model; bool battleMode; uint32 battleWins; uint32 battleLosses; uint256 battleStake; bytes5 upgrades; bool isAuction; uint256 auctionPrice; }",1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x881f21d3e2d2d4f48d815f41bea8dbdcf0e24e50.sol,DepositVault,"contract DepositVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,IartistChain,"contract IartistChain is owned, TokenERC20 { uint256 INITIAL_SUPPLY =500000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function IartistChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd14b307a8a9f5dae852216d7860a6e302a533b2f.sol,Factory,contract Factory { address admin; mapping (address => address) contractPurchaseRecord; function Factory() public { admin = msg.sender; },1
0x1a795d04b963c489e0fc01897d398f1a84c15b8e.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); using SafeERC20 for ERC20; uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (uint => address) public tokens; mapping (uint => bool) public tokenset; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint txType; uint value; bool executed; }",1
0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e.sol,TokenTrader,"contract TokenTrader is Owned { using SafeMath for uint256; address public asset; address public exchange; address public baseowner; uint256 public units; uint256 public buyPrice; uint256 public sellPrice; uint256 public exchFee; bool public buysTokens; bool public sellsTokens; event ActivatedEvent(bool buys, bool sells); event MakerDepositedEther(uint256 amount); event MakerWithdrewAsset(uint256 tokens); event MakerTransferredAsset(address toTokenTrader, uint256 tokens); event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens); event MakerWithdrewEther(uint256 ethers); event MakerTransferredEther(address toTokenTrader, uint256 ethers); event TakerBoughtAsset(address indexed buyer, uint256 ethersSent, uint256 ethersReturned, uint256 tokensBought); event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell, uint256 tokensSold, uint256 etherValueOfTokensSold); function TokenTrader ( address _asset, address _baseowner, address _exchange, uint256 _exchFee, uint256 _units, uint256 _buyPrice, uint256 _sellPrice, bool _buysTokens, bool _sellsTokens ) { asset = _asset; units = _units; buyPrice = _buyPrice; baseowner = _baseowner; exchange = _exchange; exchFee = _exchFee; sellPrice = _sellPrice; buysTokens = _buysTokens; sellsTokens = _sellsTokens; ActivatedEvent(buysTokens, sellsTokens); }",1
0x3a858b6aa825c23621e339677a5016cfc4ff8b12.sol,Enigma_X,contract Enigma_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7.sol,IndTokenPayment,"contract IndTokenPayment is Ownable, ReentrancyGuard { IERC20Token[] public path; address public destinationWallet; uint256 public minConversionRate; IContractRegistry public bancorRegistry; bytes32 public constant BANCOR_NETWORK = ; event conversionSucceded(address from,uint256 fromTokenVal,address dest,uint256 destTokenVal); constructor(IERC20Token[] _path, address destWalletAddr, address bancorRegistryAddr, uint256 minConvRate){ path = _path; bancorRegistry = IContractRegistry(bancorRegistryAddr); destinationWallet = destWalletAddr; minConversionRate = minConvRate; }",1
0x69aaeed694cc5ca303406d2fe055099edf88723f.sol,PLAY_Q,contract PLAY_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6cd3409ec07e5aa64baaeb08c6a038f30e831090.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x47423b0fdb181ecab813c908307e9795c0272db7.sol,EtherToken,"contract EtherToken is UnlimitedAllowanceToken, Ownable{ using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint256 constant public decimals = 18; event Issuance(uint256 _amount); event Destruction(uint256 _amount); bool public enabled; address public safetyWallet; function EtherToken() public { enabled = true; safetyWallet = msg.sender; }",1
0x6515dd4d7102883fab9f473b1aeb82dbe10a7d5a.sol,ETH_Game,contract ETH_Game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xafca09726310a2b8e5fca4200f818a5e6bd0cf50.sol,FlightDelayControlledContract,contract FlightDelayControlledContract is FlightDelayDatabaseModel { address public controller; FlightDelayControllerInterface FD_CI; modifier onlyController() { require(msg.sender == controller); _; },1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xee00c8718d39da102d2023c5540c9840ed840cb9.sol,BETSTOCKRIGHT,"contract BETSTOCKRIGHT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; address[] public Shareholder; uint256 BonusTime; uint256 maxout; uint256 minout; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function BETSTOCKRIGHT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,Ownable,contract Ownable { address public owner; address public bot; function Ownable() public { owner = msg.sender; },1
0x3ac0d29eaf16eb423e07387274a05a1e16a8472b.sol,LuckyNumber,"contract LuckyNumber { address owner; uint winningNumber = uint(keccak256(now, owner)) % 10; function LuckyNumber() public { owner = msg.sender; }",1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x5a8658de344972fc8b6b6a01cd87a64bc7420a38.sol,EPXCrowdsale,"contract EPXCrowdsale is owned, safeMath { address public admin = owner; StandardToken public tokenReward; uint256 private initialTokenSupply; uint256 private tokensRemaining; address private beneficiaryWallet; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; string public CurrentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isCrowdSaleClosed = false; bool private areFundsReleasedToBeneficiary = false; bool public isCrowdSaleSetup = false; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Buy(address indexed _sender, uint256 _eth, uint256 _EPX); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balancesArray; mapping(address => uint256) usersEPXfundValue; function EPXCrowdsale() public onlyOwner { admin = msg.sender; CurrentStatus = ; }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x50a667b73223bc612bcc43200120b5c46ee6b4e9.sol,RC,"contract RC is ICOEngineInterface, KYCBase { using SafeMath for uint256; TokenSale tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public oneTokenInFiatWei; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; uint256[] public tokenThreshold; uint256[] public bonusThreshold; function RC(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address [] kycSigner, uint256[] _tokenThreshold, uint256[] _bonusThreshold ) public KYCBase(kycSigner) { require ( _tokenSaleContract != 0 ); require ( _oneTokenInFiatWei != 0 ); require( _remainingTokens != 0 ); require ( _tokenThreshold.length != 0 ); require ( _tokenThreshold.length == _bonusThreshold.length ); bonusThreshold = _bonusThreshold; tokenThreshold = _tokenThreshold; tokenSaleContract = TokenSale(_tokenSaleContract); tokenSaleContract.addMeByRC(); soldTokens = 0; remainingTokens = _remainingTokens; oneTokenInFiatWei = _oneTokenInFiatWei; etherMinimum = _etherMinimum; setTimeRC( _startTime, _endTime ); }",1
0x64d581770b541b5609140232fc12f47bbe0fe6bc.sol,MonetoSale,"contract MonetoSale { Moneto public token; address public beneficiary; address public alfatokenteam; uint public alfatokenFee; uint public amountRaised; uint public tokenSold; uint public constant PRE_SALE_START = 1523952000; uint public constant PRE_SALE_END = 1526543999; uint public constant SALE_START = 1528617600; uint public constant SALE_END = 1531209599; uint public constant PRE_SALE_MAX_CAP = 2531250 * 10**18; uint public constant SALE_MAX_CAP = 300312502 * 10**17; uint public constant SALE_MIN_CAP = 2500 ether; uint public constant PRE_SALE_PRICE = 1250; uint public constant SALE_PRICE = 1000; uint public constant PRE_SALE_MIN_BUY = 10 * 10**18; uint public constant SALE_MIN_BUY = 1 * 10**18; uint public constant PRE_SALE_1WEEK_BONUS = 35; uint public constant PRE_SALE_2WEEK_BONUS = 15; uint public constant PRE_SALE_3WEEK_BONUS = 5; uint public constant PRE_SALE_4WEEK_BONUS = 0; uint public constant SALE_1WEEK_BONUS = 10; uint public constant SALE_2WEEK_BONUS = 7; uint public constant SALE_3WEEK_BONUS = 5; uint public constant SALE_4WEEK_BONUS = 3; mapping (address => uint) public icoBuyers; Stages public stage; enum Stages { Deployed, Ready, Ended, Canceled }",1
0x5bcbb71ef20825120774e35cba72f1a15a9d27ba.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x518c55ad0cc887f78e2c7fe23b14c33a34586edc.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x4c747b6ac42118186d83dac6a2e3994284711334.sol,Allfa_QUiZ,contract Allfa_QUiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3.sol,SecuritySale,"contract SecuritySale is Ownable { bool public live; IInvestorList public investorList; event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; }",1
0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561.sol,Hanabira,"contract Hanabira is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 5000000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 5000000000e8; uint public target0drop = 70000; uint public progress0drop = 0; address multisig = 0x587aF154ddFB78fe97B7F02FC17D4Eca338AF325; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x9b36e12d6e8c6592694bc5271a622bf40b8b81ec.sol,Quiz_BLiZ,contract Quiz_BLiZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x5135815b39806be487b153f927aa27ed507bd937.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bool executed; }",1
0xdc57e9b624b931aa8202f3a8d54f09fa8ce7981f.sol,OpenSesameToken,"contract OpenSesameToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 210000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function OpenSesameToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x219e0b7c4868add72a913eef492c228cd1f45cdd.sol,Firextoken,"contract Firextoken is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 200 * 1 days; uint public round2 = now + 75 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 12000000000000000; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 1104000000000; uint public target0drop = 4500; uint public progress0drop = 0; address multisig = 0x0A8961D531805c7ABB4442123c1b08064dA705Ac; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,SmcdCoin,"contract SmcdCoin is owned, TokenERC20 { uint256 INITIAL_SUPPLY =1000000000; uint256 public buyPrice = 1; event FrozenFunds(address target, bool frozen); function SmcdCoin(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(INITIAL_SUPPLY, , ) payable { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x383bf1fd04d0901bbd674a580e0a621fcbb4799b.sol,CryptoDoggies,"contract CryptoDoggies is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, bytes5 dna, uint256 price, address owner); event TokenSold( uint256 indexed tokenId, string name, bytes5 dna, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner ); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) private tokenIdToApproved; struct Doggy { string name; bytes5 dna; }",1
0x0d67440946949fe293b45c52efd8a9b3d51e2522.sol,CentralizedArbitrator,contract CentralizedArbitrator is Arbitrator { address public owner = msg.sender; uint arbitrationPrice; uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; struct DisputeStruct { Arbitrable arbitrated; uint choices; uint fee; uint ruling; DisputeStatus status; },1
0xa5dc0165b798779ac80acc84c4da4ee77b79843f.sol,EosPizzaSliceDonationraiser,contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig { uint constant CONVERSION_RATE = 100000; uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR; uint constant START_DATE = 1520630542; uint constant END_DATE = 1526603720; uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.05 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 4999 ether; },1
0xc7e4a9147601fdbc7d1c2fb8b6c2ffcb2469f293.sol,GuessTheNumber,contract GuessTheNumber { address private Owner = msg.sender; uint public SecretNumber = 24; function() public payable {},1
0x32e78bdc108565c3f3811a8dc00da797b6c96dfe.sol,AddressWarsBeta,"contract AddressWarsBeta { address public dev; uint256 constant devTax = 2; uint256 constant enlistingFee = 0; uint256 constant wageringFee = 0; uint256 constant CLAIM_LIMIT = 10; uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8; uint256 private _seed; enum TYPE { NORMAL, FIRE, WATER, NATURE }",1
0x555744471e00a4bf8ec403c47e06f38db6096a02.sol,InitialSaleSQD,"contract InitialSaleSQD { address public beneficiary; uint public preICOSaleStart; uint public ICOSaleStart; uint public ICOSaleEnd; uint public preICOPrice; uint public ICOPrice; uint public amountRaised; uint public incomingTokensTransactions; SQDExtendedToken public tokenReward; event TokenFallback( address indexed from, uint256 value); modifier onlyOwner() { if(msg.sender != beneficiary) revert(); _; }",1
0xa1f1fc153936a3880412743d1b180fa65b63eece.sol,DONC,"contract DONC is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 199000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 18000e8; uint public target0drop = 30000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5b2028602af2693d50b4157f4acf84d632ec8208.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(open); }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0xd4c435f5b09f855c3317c8524cb1f586e42795fa.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x28152e02be1e8af3bec836d434798aec1143d7ee.sol,GOMO_NETWORK,"contract GOMO_NETWORK is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 40 * 1 days; uint256 public totalSupply = 35000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 500000e18; uint public target0drop = 100000; uint public progress0drop = 0; address multisig = 0x09E69EF1029F9870225942E153D25B12E263394C; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x92ccb32f34ca7abf1e0f5ba9b0167b607ea6b5ac.sol,LO_QUIZ,contract LO_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0x54e74f609988c55bf9327185508c0037b1f2e960.sol,Simpl_quiz,contract Simpl_quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x929e488770ae5218cf4bb5387a390bd36b2135dd.sol,QUIZ_QUIZ,contract QUIZ_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,CanReclaimToken,contract CanReclaimToken is Ownable { function reclaimToken(IERC20 token) external onlyOwner { if (address(token) == address(0)) { owner().transfer(address(this).balance); return; },1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x0dcb6d4a156206da89177aa53c891e5a87d9da45.sol,ALFA_Quiz,contract ALFA_Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xf0a0116885943f5466cb50ed8cf50b15b3d45801.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x92dee36a50f66c603e15b9ac07338ec0046f902f.sol,IRideLiquidityPool,contract IRideLiquidityPool { Token public tokenReward; address public creator; address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe; uint256 public price; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; },1
0x7909d3c14e5fb93a508582d04d11093585ebc084.sol,AceDice,contract AceDice { uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant JACKPOT_MODULO = 1000; uint constant JACKPOT_FEE = 0.001 ether; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint public todaysRewardSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; address inviter; },1
0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol,VVToken,"contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public EthPerToken = 300; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; }",1
0x0de197dc289d680e734ccab866d529505b2638db.sol,PullPayment,contract PullPayment { using SafeMath for uint256; mapping(address => uint256) public payments; uint256 public totalPayments; function withdrawPayments() public { address payee = msg.sender; uint256 payment = payments[payee]; require(payment != 0); require(address(this).balance >= payment); totalPayments = totalPayments.sub(payment); payments[payee] = 0; payee.transfer(payment); },1
0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2.sol,CryptoEngineer,contract CryptoEngineer is PullPayment{ address public administrator; uint256 public prizePool = 0; uint256 public numberOfEngineer = 8; uint256 public numberOfBoosts = 5; address public gameSponsor; uint256 public gameSponsorPrice = 0.32 ether; uint256 public VIRUS_MINING_PERIOD = 86400; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public BASE_PRICE = 0.01 ether; address public miningWarAddress; CryptoMiningWarInterface public MiningWar; mapping(address => Player) public players; mapping(uint256 => BoostData) public boostData; mapping(uint256 => EngineerData) public engineers; mapping(address => bool) public miniGames; struct Player { mapping(uint256 => uint256) engineersCount; uint256 virusNumber; uint256 research; uint256 lastUpdateTime; bool endLoadOldData; },1
0x5a889cba88c2c7cc67652c2de4e46fc4b9aba9ce.sol,DSG_Turntable,contract DSG_Turntable{ using SafeMath for uint256; address constant public DSG_ADDRESS = 0x696826C18A6Bc9Be4BBfe3c3A6BB9f5a69388687; uint256 public totalDividends; uint256 public totalWinnings; uint256 public totalTurnover; uint256 public totalPlayed; uint256 public maxBet; uint256 public minBet; uint256 public minContractBalance; uint256 public minBetForJackpot; uint256 public jackpotBalance; uint256 public nextPayout; uint256 public ownerDeposit; address[2] public owners; address[2] public candidates; bool public paused; mapping (address => Bet) private usersBets; struct Bet { uint256 blockNumber; uint256 bet; },1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x4cda22125752e0f17fe27add1c3f3e9669876c98.sol,PLAY_QZ,contract PLAY_QZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9.sol,ALFA_QUIZ,contract ALFA_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff.sol,BeezGold,"contract BeezGold is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 165 * 1 days; uint public round2 = now + 130 * 1 days; uint public round1 = now + 35 * 1 days; uint256 public totalSupply = 70000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 25700e8; uint public target0drop = 0; uint public progress0drop = 0; address multisig = 0x654186811320885fC24C318E70a119A43279c1BE; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,GenericCrowdsale,"contract GenericCrowdsale is Ownable { using SafeMath for uint256; enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}",1
0x55914aad05640d89448a7803a03ed0eabcbc6a22.sol,EthereumCrystal,"contract EthereumCrystal is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 150 * 1 days; uint public round2 = now + 50 * 1 days; uint public round1 = now + 100 * 1 days; uint256 public totalSupply = 75000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 100000000e8; uint public target0drop = 200000; uint public progress0drop = 0; address multisig = 0xF4ea201ba0c2ca99E8942f047a5220bc98286763; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x35ea0d750ac28030be79c07dbf88244f3ae007e7.sol,FUTUREX,"contract FUTUREX is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 360 * 1 days; uint public round2 = now + 180 * 1 days; uint public round1 = now + 180 * 1 days; uint256 public totalSupply = 8000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 12500000e18; uint public target0drop = 5000; uint public progress0drop = 0; address multisig = 0xB9988B73243d18e1695597C7EB45b3A9F25616d9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0x64bb42f7012cbfef9e036dd8929cbc9d61c7c3ca.sol,OneInTen,"contract OneInTen { function call_lucky(address contract_address, address contract_owner) public payable { uint8 guess = uint8(keccak256(now, contract_owner)) % 10; LuckyNumber(contract_address).takeAGuess.value(msg.value)(guess); require(this.balance > 0); msg.sender.transfer(this.balance); }",1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x32d782c283924f1e40b2a839b8121564b7b9142e.sol,SUPER_Q,contract SUPER_Q { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb.sol,CryptoBossWannaCry,contract CryptoBossWannaCry is PullPayment{ bool init = false; address public administrator; uint256 public bossRoundNumber; uint256 public BOSS_HP_DEFAULT = 10000000; uint256 public HALF_TIME_ATK_BOSS = 0; uint256 constant public VIRUS_MINING_PERIOD = 86400; uint256 public BOSS_DEF_DEFFAULT = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; mapping(address => PlayerData) public players; mapping(uint256 => BossData) public bossData; mapping(address => bool) public miniGames; struct PlayerData { uint256 currentBossRoundNumber; uint256 lastBossRoundNumber; uint256 win; uint256 share; uint256 dame; uint256 nextTimeAtk; },1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2cfc06b1ec0735bd7ef00b211764cc7e06e9456a.sol,PublicSale,"contract PublicSale is Pausable { using SafeMath for uint256; using SafeERC20 for ERC20; uint256 public maxgas; uint256 public maxcap; uint256 public exceed; uint256 public minimum; uint256 public rate; bool public ignited = false; uint256 public weiRaised = 0; address public wallet; Whitelist public List; ERC20 public Token; constructor ( uint256 _maxcap, uint256 _exceed, uint256 _minimum, uint256 _rate, uint256 _maxgas, address _wallet, address _whitelist, address _token ) public { require(_wallet != address(0)); require(_whitelist != address(0)); require(_token != address(0)); maxcap = _maxcap; exceed = _exceed; minimum = _minimum; rate = _rate; maxgas = _maxgas; wallet = _wallet; Token = ERC20(_token); List = Whitelist(_whitelist); }",1
0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1.sol,SetherToken,"contract SetherToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SetherToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xe34e1944e776f39b9252790a0527ebda647ae668.sol,Destructible,contract Destructible is Ownable { function Destructible() public payable { },1
0xc780b0272bbe7caedb6b47157d88ce51b324da58.sol,CashFlow,"contract CashFlow { address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2; address public owner; modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x3a4b1eca26955fba4b99f78ee36153eacdceae85.sol,EdexStore,"contract EdexStore is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 37 * 1 days; uint public round2 = now + 32 * 1 days; uint public round1 = now + 22 * 1 days; uint256 public totalSupply = 1000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 800000e8; uint public target0drop = 1000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x288d045357ac63438278af0b5b84d677713e7c30.sol,Destructible,contract Destructible is Ownable { function destroy() public onlyOwner { selfdestruct(owner); },1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Owned,contract Owned { address internal _owner; function Owned() public { _owner = msg.sender; },1
0xeed618c15d12c635c3c319aee7bded2e2879aea0.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private _owner; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0xd6aca5b766853f7879d153fdb7567be356dd46ec.sol,ExeniumToken,"contract ExeniumToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 8; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function ExeniumToken() public {}",1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x0176d6746520dd73c2db032348530520d64e074e.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x1b85440d66a5903deabb24807d739019ff1741e6.sol,Subrosa,"contract Subrosa { using SafeMath for uint256; event Deposit(address _from, uint256 _amount); event WithDraw(address _to, uint256 _amount); address public owner; address public contractAddress; modifier onlyOwner() { require (msg.sender == owner); _; }",1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5365b7a3e4f68a84323792f2d0b44b0bbd5b6f0b.sol,GiftCrowdsale,"contract GiftCrowdsale is Pausable, Whitelistable { using SafeMath for uint256; uint256 public startTimestamp = 0; uint256 public endTimestamp = 0; uint256 public exchangeRate = 0; uint256 public tokensSold = 0; uint256 constant public minimumInvestment = 25e16; uint256 public minCap = 0; uint256 public endFirstPeriodTimestamp = 0; uint256 public endSecondPeriodTimestamp = 0; uint256 public endThirdPeriodTimestamp = 0; GiftToken public token = new GiftToken(this); mapping(address => uint256) public investments; modifier whenSaleIsOpen () { require(now >= startTimestamp && now < endTimestamp); _; }",1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a.sol,RubikProtocol,"contract RubikProtocol is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 40 * 1 days; uint public round2 = now + 20 * 1 days; uint public round1 = now + 15 * 1 days; uint256 public totalSupply = 10000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 10000000e8; uint public target0drop = 40000; uint public progress0drop = 0; address multisig = 0x460BE721deB36B617DE80Fe116938662d10ac7aA; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x6e5b7f4e908b6e55c8f8bd699487825666d3c1dc.sol,WeekendPay,contract WeekendPay { address O = tx.origin; function() public payable {},1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x5b0adb5a0f9e8551cb2502a0ad6307fad06121cb.sol,multiSendOxygen,"contract multiSendOxygen { function multipleOutputs (address address1, address address2,address address3, uint256 amt1, uint256 amt2,uint256 amt3) public payable { address1.transfer(amt1); address2.transfer(amt2); address3.transfer(amt3); }",1
0x46580533db92c418a79f91b46df70283daef7f99.sol,MultipleArbitrableTransaction,"contract MultipleArbitrableTransaction is IArbitrable { uint8 constant AMOUNT_OF_CHOICES = 2; uint8 constant SENDER_WINS = 1; uint8 constant RECEIVER_WINS = 2; enum Party {Sender, Receiver}",1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public amountRaised; uint public allAmountRaised; uint public deadline; uint public price; uint public limitTransfer; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool public crowdsalePaused = false; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner { require(msg.sender == beneficiary); _; }",1
0xcea534052b4af80eff6c45cd42d587105e07d557.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdCoinICO,"contract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell { uint public total_raised; uint public start_time = 0; uint public end_time = 0; uint public constant goal = 350 ether; uint256 public constant default_price = 0.005 * 10**18; mapping (uint => uint256) public price; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x18aaad578e74913df4255c126f2a0bd9e3399ec7.sol,test_contract,contract test_contract { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0xee58ee0b1519bb47801812a3a9c83ab600c63d81.sol,PrivatePaymentProcessor,"contract PrivatePaymentProcessor is Pausable, Destructible, Contactable, Restricted { using SafeMath for uint256; string constant VERSION = ; event OrderPaidInEther( uint indexed _orderId, address indexed _originAddress, uint _price, uint _monethaFee ); event OrderPaidInToken( uint indexed _orderId, address indexed _originAddress, address indexed _tokenAddress, uint _price, uint _monethaFee ); event PaymentsProcessed( address indexed _merchantAddress, uint _amount, uint _fee ); event PaymentRefunding( uint indexed _orderId, address indexed _clientAddress, uint _amount, string _refundReason ); event PaymentWithdrawn( uint indexed _orderId, address indexed _clientAddress, uint amount ); MonethaGateway public monethaGateway; MerchantWallet public merchantWallet; bytes32 public merchantIdHash; enum WithdrawState {Null, Pending, Withdrawn}",1
0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,FrostByte,"contract FrostByte is FBT { event tokenBought(uint256 totalTokensBought, uint256 Price); event etherSent(uint256 total); string public name; uint8 public decimals; string public symbol; string public version = ; function FrostByte() { name = ; decimals = 4; symbol = ; pieceprice = 1 ether / 256; datestart = now; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x21ae174c592cbb476819344a895d0e9219f5cc79.sol,BO3KMain,"contract BO3KMain is modularLong { using SafeMath for *; using BO3KCalcLong for uint256; address constant public Admin = 0x3ac98F5Ea4946f58439d551E20Ed12091AF0F597; uint256 constant public LEADER_FEE = 0.03 ether; uint256 private adminFee = 0; uint256 private adminRevenue = 0; uint256 private winTeamValue = 0; uint private winTeamID = 0; string constant public name = ; string constant public symbol = ; uint256 constant private DISCOUNT_PROB = 200; uint256 constant private DISCOUNT_VALUE_5PER_OFF = 50; uint256 constant private DISCOUNT_VALUE_10PER_OFF = 100; uint256 constant private DISCOUNT_VALUE_15PER_OFF = 150; uint256 constant private DENOMINATOR = 1000; uint256 constant private _nextRoundSettingTime = 1 hours; uint256 constant private _flagBuyingInterval = 30 seconds; uint256 constant private _maxDuration = 24 hours; uint256 constant private _officerCommission = 150; bool _activated = false; bool mutex = false; uint256 public roundID; uint public _teamID; BO3Kdatasets.PotSplit potSplit; BO3Kdatasets.FlagInfo Flag; mapping (uint256 => BO3Kdatasets.Team) team; mapping (uint256 => mapping (uint256 => BO3Kdatasets.TeamData) ) teamData; mapping (uint256 => BO3Kdatasets.Round) round; mapping (uint256 => mapping (address => BO3Kdatasets.Player) ) player; mapping (address => uint256) playerFlags; constructor () public { team[1] = BO3Kdatasets.Team(0, 500, 250, 150, 50, 50, 0, 0 ); team[2] = BO3Kdatasets.Team(1, 250, 500, 150, 50, 50, 0, 0 ); team[3] = BO3Kdatasets.Team(2, 375, 375, 150, 50, 50, 0, 0 ); potSplit = BO3Kdatasets.PotSplit(450, 450, 50, 50); Flag = BO3Kdatasets.FlagInfo( 10000000000000000, now ); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,owned,contract owned { address public owner; function owned() public { owner = msg.sender; },1
0x300cff0f78f58c8b6d395ca0ebe8604137884ce5.sol,Testing4,"contract Testing4 { using SafeMath for uint256; mapping(address => uint256) investments; mapping(address => uint256) joined; mapping(address => uint256) withdrawals; mapping(address => uint256) referrer; uint256 public step = 50; uint256 public minimum = 10 finney; uint256 public stakingRequirement = 0.25 ether; address public ownerWallet; address public owner; event Invest(address investor, uint256 amount); event Withdraw(address investor, uint256 amount); event Bounty(address hunter, uint256 amount); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; ownerWallet = msg.sender; }",1
0xaab606817809841e8b1168be8779eeaf6744ef64.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { using SafeMath for uint256; uint256 public claimTimeout = 20 days; uint256 public dividendCycleTime = 350 days; uint256 public currentDividend; mapping(address => uint256) unclaimedDividend; mapping(address => uint256) public lastUpdate; uint256 public lastDividendIncreaseDate; mapping(address => bool) public isTreasurer; uint256 public dividendEndTime = 0; event Payin(address _owner, uint256 _value, uint256 _endTime); event Payout(address _tokenHolder, uint256 _value); event Reclaimed(uint256 remainingBalance, uint256 _endTime, uint256 _now); event ChangedTreasurer(address treasurer, bool active); constructor() public { isTreasurer[owner] = true; }",1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0xf122d58b7a4083f103b7336ab05b78d7c6a02a37.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint constant public contributionMin = 100000000000000000; uint public maxContractBalance; uint public feePct; address public receiverAddress; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; mapping (address => uint) tokensClaimed; },1
0xd029de67c3f46d046c635f60efeb41d5b92a74ae.sol,Owned,contract Owned { address public contractOwner; address public pendingContractOwner; function Owned() { contractOwner = msg.sender; },1
0x290d7f8b8d7da1e92903405a74667c934ca8f086.sol,Wallet,"contract Wallet { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xf29a03e88c425116c979892d475f5cddf1f742ce.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public owner; uint256 public amountRaised; uint256 public amountRaisedPhase; uint256 public price; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x0232ba609782cea145ec3663f52cf7aeb4ac773c.sol,Withdrawable,"contract Withdrawable is PermissionGroups { event TokenWithdraw(ERC20 token, uint amount, address sendTo); function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin { require(token.transfer(sendTo, amount)); TokenWithdraw(token, amount, sendTo); }",1
0x26d13bc704eeac5302ee27751d7873562d215a91.sol,TokenMacroansyPower,"contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower() public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = ; symbol = ; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; }",1
0x845581267b3ffcde72a1a98efcffee48cb9ae0de.sol,ENIGMA_X,contract ENIGMA_X { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x28a7a4115df6a31b7a19de9ec20268357484b532.sol,Forwarder,"contract Forwarder { address public parentAddress; event ForwarderDeposited(address from, uint value, bytes data); function Forwarder(address pool) public { parentAddress = 0x7cdB2Ce858ACe1d9eE41E1C5b12D581075055B2B; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,Johnsonville,contract Johnsonville { address owner; address patronOne; address patronTwo; address patronThree; bool patronOneWd; bool patronTwoWd; bool patronThreeWd; modifier onlyOwner { if(msg.sender != owner) throw; _; },1
0x376cbf6b8b7583f52192009e0cee250855ca9ea5.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0xf1ce6b0e8896dffa462b2ff4d2543f417a0d47e9.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x32ec2e6967687825123c5c0f30c18e2c47708df1.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,Dice2Win,contract Dice2Win { uint constant JACKPOT_MODULO = 1000; uint constant HOUSE_EDGE_PERCENT = 2; uint constant JACKPOT_FEE_PERCENT = 50; uint constant MIN_BET = 0.01 ether; uint constant MAX_AMOUNT = 300000 ether; uint constant MIN_JACKPOT_BET = 0.1 ether; uint constant MAX_MODULO = 100; uint constant MAX_MASK_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO; uint constant BET_EXPIRATION_BLOCKS = 250; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address public owner; address private nextOwner; uint public maxProfit; address public secretSigner; uint128 public jackpotSize; uint128 public lockedInBets; struct Bet { uint amount; uint8 modulo; uint8 rollUnder; uint40 placeBlockNumber; uint40 mask; address gambler; },1
0x777777764382a3ae5e7631570583893bfdea7e05.sol,Destructible,contract Destructible is Ownable { function Destructible() payable public { },1
0x71a42fd60323204912468cd32a8283ed5d45a28f.sol,Slugroad,"contract Slugroad { using SafeMath for uint; event WithdrewBalance (address indexed player, uint eth); event BoughtSlug (address indexed player, uint eth, uint slug); event SkippedAhead (address indexed player, uint eth, uint slug); event TradedMile (address indexed player, uint eth, uint mile); event BecameDriver (address indexed player, uint eth); event TookWheel (address indexed player, uint eth); event ThrewSlug (address indexed player); event JumpedOut (address indexed player, uint eth); event TimeWarped (address indexed player, uint indexed loop, uint eth); event NewLoop (address indexed player, uint indexed loop); event PaidThrone (address indexed player, uint eth); event BoostedPot (address indexed player, uint eth); uint256 constant public RACE_TIMER_START = 604800; uint256 constant public HYPERSPEED_LENGTH = 3600; uint256 constant public THROW_SLUG_REQ = 200; uint256 constant public DRIVER_TIMER_BOOST = 360; uint256 constant public SLUG_COST_FLOOR = 0.000025 ether; uint256 constant public DIV_SLUG_COST = 10000; uint256 constant public TOKEN_MAX_BUY = 1 ether; uint256 constant public MIN_SPEED = 100; uint256 constant public MAX_SPEED = 1000; uint256 constant public ACCEL_FACTOR = 672; uint256 constant public MILE_REQ = 6000; address constant public SNAILTHRONE = 0x261d650a521103428C6827a11fc0CBCe96D74DBc; address public starter; bool public gameStarted; uint256 public loop; uint256 public timer; address public driver; bool public hyperSpeed = false; uint256 public lastHijack; uint256 public loopChest; uint256 public slugBank; uint256 public thronePot; uint256 public divPerSlug; uint256 public maxSlug; mapping (address => uint256) public slugNest; mapping (address => uint256) public playerBalance; mapping (address => uint256) public claimedDiv; mapping (address => uint256) public mile; constructor() public { starter = msg.sender; gameStarted = false; }",1
0xdb09aba26e7a54f95951defc0a56b7f11a5ef023.sol,Presale,"contract Presale is Haltable { using SafeMath for uint256; Token public token; uint256 constant public startTime = 1511892000; uint256 constant public endTime = 1513641600; uint256 constant public tokenCap = uint256(8*1e6*1e8); address public withdrawAddress; uint256 public default_rate = 2500000; uint256 public weiRaised; uint256 public tokenSold; bool public initiated = false; bool public finalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); mapping (address => uint256) purchasedTokens; mapping (address => uint256) receivedFunds; enum State{Unknown, Prepairing, PreFunding, Funding, Success, Failure, Finalized, Refunding}",1
0x6f1408e206d23d446e1580830f11f79c2e58d92b.sol,NRMc,"contract NRMc { string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 20000000000000000000000000; uint256 perReserve = 2000000000000000000000000; bool startDone = false; bool finishDone = false; bool onefiveDone = false; address owner = 0; address reserve1 = 0x0d4dAA952a8840715d901f97EDb98973Ce8010F7; address reserve2 = 0xCd4846fF42C1DCe3E421cb4fE8d01523B962D641; address reserve3 = 0x2241C99B6f44Cc630a073703EdFDf3c9964CbE22; address reserve4 = 0x5c5bfC25A0B99ac5F974927F1f6D39f19Af9D14C; address reserve5 = 0xa8356f49640093cec3dCd6dcE1ff4Dfe3785c17c; bool prereserved1Done = false; bool prereserved2Done = false; bool prereserved3Done = false; bool prereserved4Done = false; bool prereserved5Done = false; address out1 = 0xF9D23f5d833dB355bfc870c8aCD9f4fc7EF05883; address out2 = 0x5c07f5DD4d3eE06A977Dee53072e10de9414E3f0; address out3 = 0xF425821a2545cF1414B6E342ff5D95f3c572a7CD; address out4 = 0xa873134afa83410787Ae29dBfB39e5C38ca05fF2; address out5 = 0x5E663D73de8205b3f339fAA5a4218AcA95963260; bool public out1Done = false; bool public out2Done = false; bool public out3Done = false; bool public out4Done = false; bool public out5Done = false; uint public amountRaised; uint public deadline; uint public overRaisedUnsend = 0; uint public backers = 0; uint public rate = 45000; uint public onefive = 0; uint _durationInMinutes = 0; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function NRMc(address adr) { if (startDone == false) { owner = adr; }",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0x41b8d6336bdab8991ad1c48e3579d0693db17e79.sol,MNY,"contract MNY { string public name = ; uint8 public decimals = 18; string public symbol = ; address public _owner; address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c; address public _devFeesAddr; uint256 public _tokePerEth = 4877000000000000000000; bool public _coldStorage = true; bool public _receiveEth = true; bool _feesEnabled = false; bool _payFees = false; uint256 _fees; uint256 _lifeVal = 0; uint256 _feeLimit = 0; uint256 _devFees = 0; uint256 public _totalSupply = 1000000928 * 1 ether; uint256 public _frozenTokens = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Exchanged(address indexed _from, address indexed _to, uint _value); mapping (address => uint256) public balances; mapping (address => bool) public exchangePartners; mapping (address => uint256) public exchangeRates; function MNY() { _owner = msg.sender; preMine(); }",1
0xb429ecbd7cda1cb82cbe0ae9044310d2f74de67c.sol,SmzTradingContract,contract SmzTradingContract { address public constant RECEIVER_ADDRESS = 0xf3eB3CA356c111ECb418D457e55A3A3D185faf61; uint256 public constant ACCEPTED_AMOUNT = 3 ether; uint256 public RECEIVER_PAYOUT_THRESHOLD = 100 ether; address public constant END_ADDRESS = 0x3559e34004b944906Bc727a40d7568a98bDc42d3; uint256 public constant END_AMOUNT = 0.39 ether; bool public ended = false; mapping(address => bool) public addressesAllowed; mapping(address => bool) public addressesDeposited; address public manager; function SmzTradingContract() public { manager = msg.sender; },1
0xf3e61d4a877ef82d68ebc97acf99e1c08ee342f2.sol,RektCoinCashSponsorfundraiser,contract RektCoinCashSponsorfundraiserConfig is RektCoinCashConfig { uint constant CONVERSION_RATE = 1000000; uint constant TOKENS_HARD_CAP = 294553323 * DECIMALS_FACTOR; uint constant START_DATE = 1536484149; uint constant END_DATE = 1541617200; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.1337 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 1337 ether; },1
0x791d0463b8813b827807a36852e4778be01b704e.sol,Test1,contract Test1 { address owner = msg.sender; function withdraw() payable public { require(msg.sender==owner); owner.transfer(this.balance); },1
0x72dc30371f77dd6efb22e27843594a14bde0337b.sol,CrowdsaleToken,"contract CrowdsaleToken is StandardToken, Configurable, Ownable { enum Stages { none, icoStart, icoEnd }",1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0xed616b87b2b441e4a36d23f27a660ea0f0faccbd.sol,MerchantWallet,"contract MerchantWallet is Pausable, SafeDestructible, Contactable, Restricted { string constant VERSION = ; address public merchantAccount; address public merchantFundAddress; bytes32 public merchantIdHash; mapping (string=>string) profileMap; mapping (string=>string) paymentSettingsMap; mapping (string=>uint32) compositeReputationMap; uint8 public constant REPUTATION_DECIMALS = 4; modifier onlyMerchant() { require(msg.sender == merchantAccount); _; }",1
0x294789e8b87f471caa39c4757204f945683091e5.sol,AMFC,"contract AMFC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 500000000 * (10 ** uint256(decimals)); address constant LOCK_ADDR = 0xF63Fb7657B11B408eEdD263fE0753E1665E7400a; uint256 constant LOCK_SUPPLY = 300000000 * (10 ** uint256(decimals)); uint256 constant UNLOCK_2Y = 200000000 * (10 ** uint256(decimals)); uint256 constant UNLOCK_1Y = 100000000 * (10 ** uint256(decimals)); uint256 constant OWNER_SUPPLY = INITIAL_SUPPLY - LOCK_SUPPLY; mapping(address => uint256) balanceLocked; mapping(address => uint256) lockAtTime; uint256 public buyPrice = 585; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = OWNER_SUPPLY; emit Transfer(0x0, msg.sender, OWNER_SUPPLY); balances[LOCK_ADDR] = LOCK_SUPPLY; emit Transfer(0x0, LOCK_ADDR, LOCK_SUPPLY); _lock(LOCK_ADDR); }",1
0x344bd3872f67d37757b48155ba4666e780fc47b5.sol,DragonFarmer,contract DragonFarmer { address public superPowerFulDragonOwner; uint256 lastPrice = 200000000000000000; uint public hatchingSpeed = 100; uint256 public snatchedOn; bool public isEnabled = false; function enableSuperDragon(bool enable) public { require(msg.sender == ceoAddress); isEnabled = enable; superPowerFulDragonOwner = ceoAddress; snatchedOn = now; },1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xc5005344d52758ee2264be257a198b50f884711b.sol,illume,"contract illume is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public deadline = now + 50 * 1 days; uint public round2 = now + 40 * 1 days; uint public round1 = now + 20 * 1 days; uint256 public totalSupply = 10000000000e18; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth =20000000e18; uint public target0drop = 5000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xc80205befdb86a1891019969001e90b064d5735a.sol,MILO,"contract MILO is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 35 * 1 days; uint public round2 = now + 35 * 1 days; uint public round1 = now + 30 * 1 days; uint256 public totalSupply = 950000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 1000; uint256 public tokensPerEth = 100000000000e8; uint public target0drop = 50000; uint public progress0drop = 0; address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x333b20d643b58263e1558de655fda9cf7d07c401.sol,RefundVault,"contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed }",1
0xefe17f088be79ba802b60ea84ebafb255ea18aa4.sol,AccessService,contract AccessService is AccessAdmin { address public addrService; address public addrFinance; modifier onlyService() { require(msg.sender == addrService); _; },1
0x71972877d68acf22114e05578364a307cafe2885.sol,BsCrowdsale,"contract BsCrowdsale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, DASH, ZEC, WAVES, USD, EUR }",1
0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646.sol,SelfKeyToken,"contract SelfKeyToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function SelfKeyToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x4b9d8e37bd266fe27adc45a31a6e1c2b9ca18737.sol,E_GAME,contract E_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 1 ether) { msg.sender.transfer(this.balance); },1
0x70785fec3fad3a3f855d939b74be05fca3ee9d7b.sol,f_game,contract f_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.4 ether) { msg.sender.transfer(this.balance); },1
0xf2eefee3c99cdb30c11d57b487a16690e813309b.sol,SlotMachine,"contract SlotMachine { address public slotMachineFunds; uint256 public coinPrice = 0.1 ether; address owner; event Rolled(address sender, uint rand1, uint rand2, uint rand3); mapping (address => uint) pendingWithdrawals; modifier onlyOwner() { require(owner == msg.sender); _; }",1
0xda830afa460526071d3d149e898fead664f0a4bb.sol,MiniMeToken,contract MiniMeToken is Controlled { string public name; uint8 public decimals; string public symbol; string public version = ; struct Checkpoint { uint128 fromBlock; uint128 value; },1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerCore,contract FlowerCore is FlowerMinting { address public newContractAddress; function setGen0SellerAddress(address _newAddress) external onlyAdministrator { gen0SellerAddress = _newAddress; saleAuction.setGen0SellerAddress(_newAddress); },1
0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b.sol,SMCT,"contract SMCT is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function SMCT() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0x1b332629b45136a3614fafcd927c8ea31d7cd717.sol,Bandit,"contract Bandit is usingOraclize, DSSafeAddSub { function () public payable {}",1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0x1847825ea569501ca50dee126d31ea95f6c62a87.sol,LinCrowdSale,"contract LinCrowdSale is LinTokenMint, WhitelistedCrowdsale { uint constant Month = 60*60*24*30; uint constant SixMonth = 6 * Month; uint constant Year = 12 * Month; uint public StartTime = now; uint public EndTime = StartTime + SixMonth; uint public PrivateSaleEndTime = StartTime.add(Month); uint public PreSaleEndTime = PrivateSaleEndTime.add(Month); bool public SoftCapReached = false; bool public HardCapReached = false; bool public SaleClosed = false; bool private rentrancy_lock = false; uint public constant Private_rate = 2000; uint public constant Pre_rate = 1500; uint public constant Public = 1200; uint public MinInvestMent = 2 * (10 ** decimals); uint public HardCap = 500000000 * (10 ** decimals); uint public SoftCap = 10000000 * (10 ** decimals); uint public TotalAmountETH; uint public SaleAmountLIN; uint public RefundAmount; uint public InvestorNum; event SuccessCoreAccount(uint256 InvestorNum); event Burn(address burner, uint256 value); event SuccessInvestor(address RequestAddress, uint256 amount); event SuccessSoftCap(uint256 SaleAmountLin, uint256 time); event SuccessHardCap(uint256 SaleAmountLin, uint256 time); event SucessWithdraw(address who, uint256 AmountEth, uint256 time); event SuccessEthToOwner(address owner, uint256 AmountEth, uint256 time); event linTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now); event linTokenToCore(address CoreAddress, uint256 Amount, uint256 now); event FailsafeWithdrawal(address InverstorAddress, uint256 Amount, uint256 now); event FaillinTokenToInvestors(address InverstorAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FaillinTokenToCore(address CoreAddress, uint256 Amount, uint256 now, uint256 ReleaseTime); event FailEthToOwner(address who, uint256 _amount, uint256 now); event safeWithdrawalTry(address who); modifier beforeDeadline() { require (now < EndTime); _; }",1
0x79015eed20c9ed322e660701fb299f85f1fa44e6.sol,TAP,"contract TAP is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 74 * 1 days; uint public round2 = now + 64 * 1 days; uint public round1 = now + 44 * 1 days; uint256 public totalSupply = 20000000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 8800000e8; uint public target0drop = 1100; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0x70d0907b064ab5c86849d391124f62ce9bcbf597.sol,Fastbitcoin,"contract Fastbitcoin is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public deadline = now + 99 * 1 days; uint public round2 = now + 15 * 1 days; uint public round1 = now + 5 * 1 days; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 10000; uint256 public tokensPerEth = 2500000e8; uint public target0drop = 4000; uint public progress0drop = 0; address multisig = 0x25CB79CB502E58697C47e8cD29411fc4250879a6; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0xcff681c07541b6921aac59fee73f1bab7b29d7b7.sol,BaseUnilotGame,"contract BaseUnilotGame is Game { enum State { ACTIVE, ENDED, REVOKING, REVOKED, MOVED }",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
