file,contract,code,label
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0x0cfae4866c11cf6194d787cf76d479e28a7cc577.sol,FundariaToken,"contract FundariaToken { string public constant name = ; string public constant symbol = ; uint public totalSupply; uint public supplyLimit; uint public course; mapping(address=>uint256) public balanceOf; mapping(address=>mapping(address=>uint256)) public allowance; mapping(address=>bool) public allowedAddresses; address public fundariaPoolAddress; address creator; event SuppliedTo(address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event SupplyLimitChanged(uint newLimit, uint oldLimit); event AllowedAddressAdded(address _address); event CourseChanged(uint newCourse, uint oldCourse); function FundariaToken() { allowedAddresses[msg.sender] = true; creator = msg.sender; }",1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x0de1beed64aa3ca5f563a1ba585861748c352231.sol,BioCoin,"contract BioCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BioCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 10000000; balances[0x66125E7980a3A79413485e61Cd8161Fa6C467227] = _totalSupply; Transfer(address(0), 0x66125E7980a3A79413485e61Cd8161Fa6C467227, _totalSupply); }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherBase,"contract AetherBase is AetherAccessControl { event Construct ( address indexed owner, uint256 propertyId, PropertyClass class, uint8 x, uint8 y, uint8 z, uint8 dx, uint8 dz, string data ); event Transfer( address indexed from, address indexed to, uint256 indexed tokenId ); enum PropertyClass { DISTRICT, BUILDING, UNIT }",1
0xce4d3ebe1cae5561186f98edd205718475318ff0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x37e3efe76ee6cec50559bc07565eaf36ddc05467.sol,ControlledToken,"contract ControlledToken is ERC20, Controlled { uint256 constant MAX_UINT256 = 2**256 - 1; event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public totalSupply; function ControlledToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,Timed,contract Timed { uint256 public startTime; uint256 public endTime; uint256 public avarageBlockTime; function isInTime() constant returns (bool inTime) { return block.timestamp >= (startTime - avarageBlockTime) && !isTimeExpired(); },1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0x03200f18368a33906491df56b74cc97986fbdbce.sol,XueBiToken,"contract XueBiToken { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function XueBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd294fb1b8b1169dc634017f60d9ca36a5701bd7d.sol,TokenBCCO,"contract TokenBCCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenBCCO( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x528b165220a26565e00709cbaef7b88fc8600f81.sol,SafeMath,None,1
0x39e743fee400a5d9b36f1167b70c10e8f06440e5.sol,TNCGroupToken,"contract TNCGroupToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xecfbc0c5bc5cf4a266c1a90db0a4fe79c82bcd93.sol,HYIPToken,"contract HYIPToken is BurnableToken, UpgradeableToken { string public name; string public symbol; uint public decimals; address public owner; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); function mint(address receiver, uint amount) onlyMintAgent public { totalSupply = totalSupply + amount; balances[receiver] = balances[receiver] + amount; Transfer(0, receiver, amount); }",1
0xf3cfb35afdbffea20892488ba7f1574adda81b9d.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x38ceafcff00dc2f88656a4ff3235e2124819eef6.sol,CryptojoyTokenSeller,"contract CryptojoyTokenSeller is Ownable { using SafeMath for uint; uint8 public constant decimals = 18; uint public miningSupply; uint constant MAGNITUDE = 10**6; uint constant LOG1DOT5 = 405465; uint constant THREE_SECOND= 15 * MAGNITUDE / 10; uint public a; uint public b; uint public c; uint public blockInterval; uint public startBlockNumber; address public platform; uint public lowerBoundaryETH; uint public upperBoundaryETH; uint public supplyPerInterval; uint public miningInterval; uint public tokenMint = 0; EIP20Interface public token; modifier isWithinLimits(uint _eth) { require(_eth >= lowerBoundaryETH, ); require(_eth <= upperBoundaryETH, ); _; }",1
0x1ba20a713f82b2483aa393de0c5da67d146f4bd7.sol,EMJAC,"contract EMJAC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EMJAC() public { symbol = ; name = ; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x1bf3ff664d0bd9eea47628af7296ce0c51795680.sol,WistiToken,"contract WistiToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WistiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x54053ea92b9366182dbbf3e4583c8a5496bb2903.sol,CCD_KOHLE_3_20190411,"contract CCD_KOHLE_3_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2e98a6804e4b6c832ed0ca876a943abd3400b224.sol,Bela,"contract Bela is MintableToken, HasNoEther { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public ownerTimeLastMinted; uint public ownerMintRate; uint private globalMintRate; uint public totalBelaStaked; struct TokenStakeData { uint initialStakeBalance; uint initialStakeTime; uint initialStakePercentage; address stakeSplitAddress; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x532a68a4f2cf7f381dbe151bc64771396eca9398.sol,HUBTToken,"contract HUBTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HUBTToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000; balances[0x18f46174B90DB82300073c0319B86F7b1E3DDCb3] = _totalSupply; Transfer(address(0), 0x18f46174B90DB82300073c0319B86F7b1E3DDCb3, _totalSupply); }",1
0x466c44812835f57b736ef9f63582b8a6693a14d0.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrGame,"contract ZethrGame { using SafeMath for uint; using SafeMath for uint56; event Result (address player, uint amountWagered, int amountOffset); event Wager (address player, uint amount, bytes data); address[] pendingBetsQueue; uint queueHead = 0; uint queueTail = 0; mapping(address => BetBase) bets; struct BetBase { uint56 tokenValue; uint48 blockNumber; uint8 tier; }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,ItemList,None,1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0xa575aea29bcf52afa55113b3b1b9e3813143d10d.sol,TokenLingERC20,"contract TokenLingERC20 { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20 ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0xf45c4e30e9a4d8107d7dbd0556065baedf03838d.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x78a06472d78bfef33270654319b6373d51cf0575.sol,EasyMineToken,"contract EasyMineToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function EasyMineToken(address _icoAddress, address _preIcoAddress, address _easyMineWalletAddress, address _bountyWalletAddress) { require(_icoAddress != 0x0); require(_preIcoAddress != 0x0); require(_easyMineWalletAddress != 0x0); require(_bountyWalletAddress != 0x0); totalSupply = 33000000 * 10**18; uint256 icoTokens = 27000000 * 10**18; uint256 preIcoTokens = 2000000 * 10**18; uint256 easyMineTokens = 3000000 * 10**18; uint256 bountyTokens = 1000000 * 10**18; assert(icoTokens + preIcoTokens + easyMineTokens + bountyTokens == totalSupply); balances[_icoAddress] = icoTokens; Transfer(0, _icoAddress, icoTokens); balances[_preIcoAddress] = preIcoTokens; Transfer(0, _preIcoAddress, preIcoTokens); balances[_easyMineWalletAddress] = easyMineTokens; Transfer(0, _easyMineWalletAddress, easyMineTokens); balances[_bountyWalletAddress] = bountyTokens; Transfer(0, _bountyWalletAddress, bountyTokens); }",1
0x1f313e1015d362a50a16a479f857637bbb36a353.sol,LineOfTransfers,"contract LineOfTransfers { address[] public accounts; uint[] public values; uint public transferPointer = 0; address public owner; event Transfer(address to, uint amount); modifier hasBalance(uint index) { require(this.balance >= values[index]); _; }",1
0xc378bb8f3e155e5e561eb4caa337c4a35c34c2ba.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xeea8cd2150b0438555b515f0bdd1ded0d84eab8c.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x04247b9b59091b349eb60e429fe7dbc99fdad34b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 initialSupply=130000000; string tokenName=; string tokenSymbol=; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbfb3b6972a814e2f6ed6d6fb9f9e47cd0b13720a.sol,SafeDivs,"contract SafeDivs { using SafeMath for *; address public devAddr_ = address(0xe6CE2a354a0BF26B5b383015B7E61701F6adb39C); address public affiAddr_ = address(0x08F521636a2B117B554d04dc9E54fa4061161859); address public partnerAddr_ = address(0x08962cDCe053e2cE92daE22F3dE7538F40dAEFC2); bool public activated_ = false; modifier isActivated() { require(activated_ == true, ); _; }",1
0xe9c7bf5da52566cc9e5a3157c3d29bcc809d072b.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf2e827c8c4e02b6daf1a4e28dc506f3c4522386a5efe225e8b0ff24ffe7dc049; constructor() public { owner = msg.sender; },1
0x2676d51e7a2e532f8e944e6ea5ca1cd07048ab08.sol,AHS,contract AHS { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x1ba4780b57d6efe3a1170edfa66091e7c769db7d.sol,Clen,"contract Clen is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Clen( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xf50d193eb6761fb3189be46b9165d4aec20e05f0.sol,FLEBToken,contract FLEBToken{ address public owner; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 0; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; constructor() public{ owner = msg.sender; },1
0x28b3381c0bf4658a2fa66fbcf6f31dcda1a7b596.sol,SHERE_PFI_I_883,"contract SHERE_PFI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 760409854824080000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe3d474f3686a831bf380498d1dbd57fdf972ca30.sol,MaticNetwork,"contract MaticNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MaticNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply = 10000000000000000000000000000; balances[0xdC954B7BC91F60504ccC6fAb9dCD6C8259575f51] = _totalSupply; }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3a8a6d2bc23fb68a245250ad34019a65cf057418.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x554ffc77f4251a9fb3c0e3590a6a205f8d4e067d.sol,ZmineToken,"contract ZmineToken is StandardToken, Ownable { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 1000000000 ether; function ZmineToken() public { balances[owner] = totalSupply; }",1
0xf272fb519aed5e92a06a90426336f378423718e5.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol) public { totalSupply = _initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _tokenName; symbol = _tokenSymbol; }",1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0x01b90ee8249afdf628f738af4a2a8ffd7b8434ed.sol,DMC,"contract DMC { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0xd2d0f85b690604c245f61513bf4679b24ed64c35.sol,BFDToken,"contract BFDToken is EIP20Interface, SafeMath { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string constant public name = ; uint8 constant public decimals = 18; string constant public symbol = ; mapping (address => uint256) public addressType; mapping (address => uint256[3]) public releaseForSeed; mapping (address => uint256[5]) public releaseForTeamAndAdvisor; event AllocateToken(address indexed _to, uint256 _value, uint256 _type); address public owner; uint256 public finaliseTime; function BFDToken() public { totalSupply = 20*10**26; balances[msg.sender] = totalSupply; owner = msg.sender; }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x721da477f68c71788a262d58853fe6977d86535e.sol,EtheremonPayment,"contract EtheremonPayment is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public STAT_COUNT = 6; uint8 constant public STAT_MAX = 32; uint8 constant public GEN0_NO = 24; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0x2d784562eb7538cc5e5dd5de880d2a1cc241c1bd.sol,DobrocoinContract,"contract DobrocoinContract is owned, Token { uint256 public sellPrice; uint256 public buyPrice; uint256 public AutoBuy = 1; uint256 public AutoSell = 1; address[] public ReservedAddress; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol, string tokenAuthor ) Token(initialSupply, tokenName, tokenSymbol, tokenAuthor) public {}",1
0x5b36ca95ed4145a608b9f474f81f3c345dc6599f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,SmartHomeCoin,"contract SmartHomeCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartHomeCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xbd91b8e4d0afb1b7fc19bca93a74a1c531bd125c.sol,IscmToken,contract IscmToken is StandardToken { function () { throw; },1
0x40489719e489782959486a04b765e1e93e5b221a.sol,SGEToken,"contract SGEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SGEToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa6281838f4a9c5736b2aa1cba9260d3f879623ca.sol,DecentralizeCurrencyAssets,"contract DecentralizeCurrencyAssets is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 7980000000000000000000000000; balances[0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9] = _totalSupply; emit Transfer(address(0), 0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9, _totalSupply); }",1
0xf40b7341cb564b506af7cd3788331b55621aabab.sol,TokenIAET,"contract TokenIAET { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c62da804298d5972a323c80b539b8e7517a0dde.sol,VENJOCOIN,"contract VENJOCOIN is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 2000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0xcfd2047eb61412e9b8de511dc2087e07003829ee.sol,FifteenPlus,contract FifteenPlus { address owner; address ths = this; mapping (address => uint256) balance; mapping (address => uint256) overallPayment; mapping (address => uint256) timestamp; mapping (address => uint256) prtime; mapping (address => uint16) rate; constructor() public { owner = msg.sender;},1
0x4c246f6e5fb1302c4f244ca3acabc2c09cfd46ad.sol,LCT,"contract LCT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LCT () public { symbol = ; name = ; decimals = 6; _totalSupply = 1000000000000000; balances[0x0A022c3844A055dB6458ef5103A764a71B526222] = _totalSupply; Transfer(address(0), 0x0A022c3844A055dB6458ef5103A764a71B526222, _totalSupply); }",1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0x0e9eccf7ced35da0702c9e2d943654da80fc72dd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0x33555a3130fc40082a566005714eeec369e62fc8.sol,Dividends,contract Dividends { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 10000000* (10 ** uint256(decimals)); uint256 SellFee = 1250; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x1d1cf6cd3fe91fe4d1533ba3e0b7758dfb59aa1f.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; address public burner; bool public burnerSet; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 50000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x26c0e6f69b18125f68ac55f439b1e10c2a2e5c03.sol,Owners,contract Owners { mapping (address => bool) public owners; uint public ownersCount; uint public minOwnersRequired = 2; event OwnerAdded(address indexed owner); event OwnerRemoved(address indexed owner); constructor(bool withDeployer) public { if (withDeployer) { ownersCount++; owners[msg.sender] = true; },1
0xc4ff0412050fafbd9e697b1931a23ea41f4cb26f.sol,token1234,contract token1234 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token1234() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x6d105976d1a93e1ce23b825b562519144a56d7a4.sol,StringDump,contract StringDump { event Event(string value); function emitEvent(string value) public { Event(value); },1
0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5.sol,DYLC_ERC20Token,"contract DYLC_ERC20Token { address public owner; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 5000000000 * (10**18); uint256 public currentSupply = 0; uint256 public angelTime = 1522395000; uint256 public privateTime = 1523777400; uint256 public firstTime = 1525073400; uint256 public secondTime = 1526369400; uint256 public thirdTime = 1527665400; uint256 public endTime = 1529047800; uint256 public constant earlyExchangeRate = 83054; uint256 public constant baseExchangeRate = 55369; uint8 public constant rewardAngel = 20; uint8 public constant rewardPrivate = 20; uint8 public constant rewardOne = 15; uint8 public constant rewardTwo = 10; uint8 public constant rewardThree = 5; uint256 public constant CROWD_SUPPLY = 550000000 * (10**18); uint256 public constant DEVELOPER_RESERVED = 4450000000 * (10**18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x278ae6f52ce72b0df6cba451534b87846acc9d65.sol,BPER,"contract BPER is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BPER() public { symbol = ; name = ; decimals = 10; _totalSupply = 16000000000000000000; balances[0x8fB784413918e0917E50cC42282334C08a21730f] = _totalSupply; Transfer(address(0), 0x8fB784413918e0917E50cC42282334C08a21730f, _totalSupply); }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0xd8f2f712040d1a0d90622c767420d354c645ba4a.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x1bb28e79f2482df6bf60efc7a33365703bcf1536.sol,hodlEthereum,"contract hodlEthereum { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1596067200; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,FollowCoin,"contract FollowCoin is Ownable, ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping (address => uint256) public balances; mapping (address => bool) public allowedAccount; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public isHolder; address [] public holders; event Burn(address indexed from, uint256 value); bool public contributorsLockdown = true; function disableLockDown() onlyOwner { contributorsLockdown = false; }",1
0x2836ad31220bb62d0df9f1b6354c75118dcbf247.sol,TLIFE,"contract TLIFE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x61585C21E0C0c5875EaB1bc707476BD0a28f157b; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0x261d650a521103428c6827a11fc0cbce96d74dbc.sol,SnailThrone,"contract SnailThrone { using SafeMath for uint; event WithdrewEarnings (address indexed player, uint ethreward); event ClaimedDivs (address indexed player, uint ethreward); event BoughtSnail (address indexed player, uint ethspent, uint snail); event SoldSnail (address indexed player, uint ethreward, uint snail); event HatchedSnail (address indexed player, uint ethspent, uint snail); event FedFrogking (address indexed player, uint ethreward, uint egg); event Ascended (address indexed player, uint ethreward, uint indexed round); event BecamePharaoh (address indexed player, uint indexed round); event NewDivs (uint ethreward); uint256 public GOD_TIMER_START = 86400; uint256 public PHARAOH_REQ_START = 40; uint256 public GOD_TIMER_INTERVAL = 12; uint256 public GOD_TIMER_BOOST = 480; uint256 public TIME_TO_HATCH_1SNAIL = 1080000; uint256 public TOKEN_PRICE_FLOOR = 0.00002 ether; uint256 public TOKEN_PRICE_MULT = 0.00000000001 ether; uint256 public TOKEN_MAX_BUY = 4 ether; uint256 public SNAIL_REQ_REF = 300; bool public gameStarted = false; address public gameOwner; uint256 public godRound = 0; uint256 public godPot = 0; uint256 public godTimer = 0; address public pharaoh; uint256 public lastClaim; uint256 public pharaohReq = PHARAOH_REQ_START; uint256 public maxSnail = 0; uint256 public frogPot = 0; uint256 public snailPot = 0; uint256 public divsPerSnail = 0; mapping (address => uint256) public hatcherySnail; mapping (address => uint256) public lastHatch; mapping (address => uint256) public playerEarnings; mapping (address => uint256) public claimedDivs; constructor() public { gameOwner = msg.sender; }",1
0xcfca01488643501cab56d1855921c897d5ee4b1b.sol,BitcoinInw,"contract BitcoinInw is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c] = _totalSupply; emit Transfer(address(0), 0xbcceFb33F12FbBfE0eD87b11187B5C78Dcd13b6c, _totalSupply); }",1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimStorage,"contract MonethaUsersClaimStorage is Contactable { string constant VERSION = ; mapping (address => uint256) public claimedTokens; event UpdatedClaim(address indexed _userAddress, uint256 _claimedTokens, bool _isDeleted); event DeletedClaim(address indexed _userAddress, uint256 _unclaimedTokens, bool _isDeleted); function updateUserClaim(address _userAddress, uint256 _tokens) external onlyOwner returns (bool) { claimedTokens[_userAddress] = claimedTokens[_userAddress] + _tokens; emit UpdatedClaim(_userAddress, _tokens, false); return true; }",1
0xb42f5366792ed7c08995451c1a93780b7554762b.sol,MyAdvancedToken,"contract MyAdvancedToken is developed, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x296556605b5a0d78b7252393a22e89bd24af7bc0.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x5ba983231b4bb509f0f25e97fa22e20d71c5d44c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed678608de045609da5a7a459c5416fe25bc5532.sol,BLPZ,"contract BLPZ is NFTokenMetadata, NFTokenEnumerable { function mint(address _to, uint256 _tokenId)external { super._mint(_to, _tokenId); }",1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x0249a616e4559f560aa30fa0e79d634603161b3a.sol,medcarednaio,"contract medcarednaio is ERC20Interface, Ownable{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x6cf1b38cefe57377fd4bbc7df7c38dfe013ff91a.sol,GYLCoin,"contract GYLCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GYLCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b3b99e956588b54f5841f2fb7c63721e6c7c392.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c.sol,FairWin,contract FairWin { uint ethWei = 1 ether; uint allCount = 0; uint oneDayCount = 0; uint totalMoney = 0; uint totalCount = 0; uint private beginTime = 1; uint lineCountTimes = 1; uint private currentIndex = 0; address private owner; uint private actStu = 0; constructor () public { owner = msg.sender; },1
0x3fd8d623695b3adedc1fa57a84f93fd78326ba27.sol,SafeMath,contract SafeMath { function SafeMath() { },1
0xf3eb8b0600739111e41c14be93fcff15f104e6e6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,FrogSeekers,"contract FrogSeekers is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5.sol,LexitToken,"contract LexitToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LexitToken() TokenERC20() public { }",1
0xa3d48af5b7541658e7b663905f11433f1b4074f5.sol,OysterPearl,"contract OysterPearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public funds = 0; address public owner; bool public saleClosed = false; bool public ownerLock = false; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed payout, address indexed fee); function OysterPearl() public { owner = msg.sender; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); }",1
0xbd91b8e4d0afb1b7fc19bca93a74a1c531bd125c.sol,IscmToken,contract IscmToken is StandardToken { function () { throw; },1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function totalSupply() public constant returns (uint256 supply) { return totalSupply; }",1
0x5bedf488d29407bc08e77cd9ee292c2041a61c8c.sol,UnKoin,contract UnKoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe3dbf587330d9b8f127a3f38dabf9aa3c90d3187.sol,VCcoin,"contract VCcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VCcoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0x903862f79f24d564aef487b7b28306e71df2ab03] = _totalSupply; Transfer(address(0), 0x903862f79f24d564aef487b7b28306e71df2ab03, _totalSupply); }",1
0x2cf1093158d4197e84d842122fc4fa34ccd46220.sol,ShareToken,contract ShareToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public corporationContract; mapping (address => bool) public identityApproved; mapping (address => bool) public voteLock; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public transferCount = 0; struct pasttransfer { address from; address to; uint256 beforesender; uint256 beforereceiver; uint256 value; uint256 time; },1
0xc7df14a8289efe7a2d3399387302fdf86e7adc4e.sol,IXToken,contract IXToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x369d0db2c7d56b095d758379b75f64085953528a.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply ; balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6bba754d3558fc95318e61e4796e71f0ef322444.sol,testmonedafinal,"contract testmonedafinal { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function testmonedafinal( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) public { owner = msg.sender; balanceOf[owner] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x74a67602b4e28efc2d012e4f29faad18e0f13cfb.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x540cf76f7efaffdeef8eec75b07807353667cef7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x413bdaae8e7218aea3a7ca544762d4f9f128a562.sol,NFC,"contract NFC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NFC() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGame,contract TheEthGame { using SafeMath for uint256; struct Player { uint256 score; uint256 lastCellBoughtOnBlockNumber; uint256 numberOfCellsOwned; uint256 numberOfCellsBought; uint256 earnings; uint256 partialHarmonicSum; uint256 partialScoreSum; address referreal; bytes32 name; },1
0x27945afcdea13201263bfe8c71d2e8fdffd35ff7.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 public trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping (address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,SampleStorage,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x6c827d03d3e46301746fe722be69442908b79fe7.sol,AthleticPass,"contract AthleticPass { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x568a693e1094b1e51e8053b2fc642da7161603f5.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,Proxy,contract Proxy { address public Owner = msg.sender; address public Proxy = 0x0; bytes data; modifier onlyOwner { if (msg.sender == Owner) _; },1
0xd96205b1ef12bc471195fe92a896c461528181ab.sol,CandyToken,"contract CandyToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x65140d4358bf4eabdaf7175dfc0eaae0d005c075.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns(uint256) { return totalSupply_; },1
0x189cfa1e719ec7728d04e861a6cea077b5fad634.sol,SafeMath,contract SafeMath { constructor() internal { },1
0x5548003c0610a9be74eecd469db94e947601209a.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; admins[contractCreator] = true; },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0xf412af62269a0b3b10ea727df81231cdc5bb6364.sol,dCHF,"contract dCHF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function dCHF() public { symbol = ; name = ; decimals = 2; _totalSupply = 1500000; balances[0x0000F70bC78af03f14132c68b59153E4788bAb20] = _totalSupply; Transfer(address(0),0x0000F70bC78af03f14132c68b59153E4788bAb20 , _totalSupply); }",1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0xa211db1867e4fa5dc0dd4d8f51f177a51d054d94.sol,ZTKGamers,"contract ZTKGamers is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 5000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 962; uint256 public totalZTKCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; event ZTKCheckIssue(string chequeIndex); struct ZTKCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x074661068c2cbca51dde811871554d2fa5bae312.sol,BountyHunterToken,"contract BountyHunterToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BountyHunterToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x5c6a2ece543d3038f98cea1a2a5f0759fbceb8b1.sol,BatchTokensTransfer,contract BatchTokensTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0x711a1836b306d2eac12129c0b97da8931ee80fe2.sol,Burner,"contract Burner { uint256 public totalBurned; function Purge() public { msg.sender.transfer(this.balance / 1000); assembly { mstore(0, 0x30ff) create(balance(address), 30, 2) pop }",1
0x466c44812835f57b736ef9f63582b8a6693a14d0.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xc4c06df5c799bec6ee6e4652beec86e5cfc94778.sol,BTF,"contract BTF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTF() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x2f253924924525632B82a2CEB99F7325fB036866] = _totalSupply; Transfer(address(0), 0x2f253924924525632B82a2CEB99F7325fB036866, _totalSupply); }",1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0xc67e520f6ff27552411c458cf3cf6a920dbd0832.sol,MessaggioInBottiglia,contract MessaggioInBottiglia { address public owner; string public message; string public ownerName; mapping(address => string[]) public comments; modifier onlyOwner() { require(owner == msg.sender); _; },1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0x654dddc32f6734a33b9cea0901c47f9a00336c1e.sol,VisperNetwork,contract VisperNetwork is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**18; function name() public constant returns (string) { return ; },1
0x283144fc0ff045d5aebf509ad6914459d77f04ea.sol,VOCC_I053_20181211,"contract VOCC_I053_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,Contactable,contract Contactable is Ownable{ string public contactInformation; function setContactInformation(string info) onlyOwner public { contactInformation = info; },1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0x34644911eeefd50877cca86562e673b94885048b.sol,RUSS_PFVI_III_883,"contract RUSS_PFVI_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1055519864651380000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x29946bc47b8e8a64562816bd6c62e9aa023dfb92.sol,GHANIANCIDIDIGITALTETHER,"contract GHANIANCIDIDIGITALTETHER { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x85429f986a5cc38f90de7b4ffa44d570eef04066.sol,KinguinVault,"contract KinguinVault is Ownable, ERC223Receiver { mapping(uint=>address) public microWalletPayments; mapping(uint=>address) public microWalletsAddrs; mapping(address=>uint) public microWalletsIDs; mapping(uint=>uint) public microWalletPaymentBlockNr; KinguinKrowns public token; uint public uncleSafeNr = 5; address public withdrawAddress; modifier onlyWithdraw() { require(withdrawAddress == msg.sender); _; }",1
0xd95294fecb64478541ca7b0e5c0a278f4f9d7ee5.sol,Distribution,contract Distribution is Ownable { function Distribution() public {},1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x78a06472d78bfef33270654319b6373d51cf0575.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x209132061047ff4d2ad395691005d3266e48b673.sol,ERC20,contract ERC20 { function totalSupply() constant returns (uint256 supply) {},1
0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f.sol,TopCoinFXToken,contract TopCoinFXToken { string public name = ; string public symbol = ; uint256 public constant decimals = 18; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 1000000000; uint public constant powNumber = 10; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x4c8c4659f734294d9561c8b0efc210028ed12052.sol,company_acc,contract company_acc { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc209a261dae1dc7caa5b02a54874c85a69de5c9ddc0b0bebdbfa9a394fb24caf; constructor() public { owner = msg.sender; },1
0x3fd8f39a962efda04956981c31ab89fab5fb8bc8.sol,Rotharium,"contract Rotharium is owned{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function Rotharium( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0xec270e8f52b492dd0c2dcd43fc6f868e78f49f18.sol,multiowned,contract multiowned { struct MultiOwnedOperationPendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x748c6ed3f78f5f06ceb76834f195d3a05b7d628a.sol,POWH33,contract POWH33 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TFcoin,"contract TFcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TFcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0xf1379777de65845ed323a08be31c086d0131ce23.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x39127b81f7c63dcc2477079bd17f08256584f623.sol,VOCC_I055_20181211,"contract VOCC_I055_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1e8dfb1d2a82903807e94e5977dc75d85c7659a0.sol,BeBitcoin,"contract BeBitcoin is ERC20Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BeBitcoin ( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4556a66dcb18a31256450d11cd0baf7051441656.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71972877d68acf22114e05578364a307cafe2885.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) internal constant returns (uint256 ) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x4d6fca01cf1eda9c66a77c43c1326e3fe350996d.sol,VOCC_I051_20181211,"contract VOCC_I051_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xaa746780d844379ae5ef9f9f7daceb59ba6fde57.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x40ae4acd08e65714b093bf2495fd7941aedfa231.sol,multiowned,contract multiowned { struct MultiOwnedOperationPendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x45e4390e6387b896268661ed4e2066df40a95a29.sol,VOCC_I032_20181211,"contract VOCC_I032_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function totalSupply() public constant returns (uint256 supply) { return totalSupply; }",1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,EOMarketToken,"contract EOMarketToken is AccessService { uint8 public decimals = 0; uint256 public totalSupply = 100; uint256 public totalSold = 0; string public name = ; string public symbol = ; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; address[] shareholders; mapping (address => uint256) addressToIndex; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EOMarketToken() public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; balances[this] = totalSupply; }",1
0x1ba20a713f82b2483aa393de0c5da67d146f4bd7.sol,EMJAC,"contract EMJAC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EMJAC() public { symbol = ; name = ; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); }",1
0x03e5279e6a8acf5e81d70aaaf7791f497ff5aad9.sol,VUULRToken,contract VUULRTokenConfig { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS); uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR; },1
0xa19fdf84f56c91e7e805c3a5a47613132b112b91.sol,OhNoToken,"contract OhNoToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OhNoToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d] = _totalSupply; Transfer(address(0), 0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d, _totalSupply); }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd.sol,Maths,None,1
0xaa4ec8484e89bed69570825688789589d38eea5e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x36eafcf412718774440ed934a81f3e6f90cdd54c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x32d55157bd2ae652f4b6be48ee4a7a1686d28a3f.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xe31ced3343f21e5cad5d31163bba5899ee01d813.sol,ERC20_CRYPTOMILLION_CPMN,"contract ERC20_CRYPTOMILLION_CPMN { string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function CreateTokenERC20(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd3676a37a23ad8f4238064c1edc704debf335f26.sol,CariNetPrivilege,"contract CariNetPrivilege { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CariNetPrivilege ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8cc0ef2b26ff52f86de029cb38ed53b7ed98a57.sol,PumpAndDump,contract PumpAndDump { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x715ea4b194e90e2c6861192be7883fe481bf8be4.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x1fd159fa190ab588f60699ef6def984602dd8c5b.sol,HAPYToken,"contract HAPYToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HAPYToken() public { totalSupply = 2999999999 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) { uint len = (a.length <= b.length) ? a.length : b.length; for (uint i = 0; i < len; i++) { if (a[i] != b[i]) { return i; }",1
0xe9c7bf5da52566cc9e5a3157c3d29bcc809d072b.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf2e827c8c4e02b6daf1a4e28dc506f3c4522386a5efe225e8b0ff24ffe7dc049; constructor() public { owner = msg.sender; },1
0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09.sol,EMC,"contract EMC is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xda6733cc3800c9a74caf0ba8858df1bc264434d7.sol,CSN,"contract CSN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc48b1ac1417db27c4e2c2ed3dae5a3d2fbb07dc5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { balanceOf[msg.sender] = 2100000000000000; totalSupply = 2100000000000000; name = ; symbol = ; decimals = 8; }",1
0x018a5118019cc0cd453e49217374250177be5970.sol,FreeInvestment5,contract FreeInvestment5 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 5/100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x5409fcd56836e0e0459c12ab45e7ef23c6094bed.sol,RedExchange,contract RedExchange { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xee6be3671b9d6a129573d89fc72deb074e61d0ec.sol,GenesisToken,"contract GenesisToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GenesisToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 6 weeks; endDate = now + 24 weeks; }",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3a3629390cef79b01fc4090abb26818d1759aefc.sol,Datastore,contract Datastore is HasNoEther { string public fromVersion = ; uint public appId; string public appNickname; uint public identities; address public manager; address public newManager; UidCheckerInterface public checker; struct Uid { string lastUid; uint lastUpdate; },1
0x6b3b198577e9a1e96ef681ee60e551845dd4ea79.sol,Detonator,contract Detonator is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0x40f5d52331674b60bc532f553c97feac5d60ab34.sol,CryptoMinerTokenPlat,contract CryptoMinerTokenPlat{ modifier onlyBagholders { require(myTokens() > 0); _; },1
0x730688f6396c8d109f1e19e9bfaa9ff50b69246c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6576963107077cce5ec879978c03ec6bb300cc89.sol,SafeMath,None,1
0x3388d5ce5388d72f5fb5858bd6de7a28ab1a08c5.sol,DESP,contract DESP is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public constant wallet = 0x51559EfC1AcC15bcAfc7E0C2fB440848C136A46B; uint public ethCollected; bool public hasFinished; function price(uint _v) public constant returns (uint) { return _v < 7 ether ? _v < 3 ether ? _v < 1 ether ? 1000 : _v < 2 ether ? 1005 : 1010 : _v < 4 ether ? 1015 : _v < 5 ether ? 1020 : 1030 : _v < 14 ether ? _v < 10 ether ? _v < 9 ether ? 1040 : 1050 : 1080 : _v < 100 ether ? _v < 20 ether ? 1110 : 1150 : 1200; },1
0xaf7188dbaa4e9a25864827cc9b9a72f663017834.sol,HammBones,"contract HammBones is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HammBones() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xcE599E08b3cAd353960143c01F6012cbf90C9DA8] = _totalSupply; Transfer(address(0), 0xcE599E08b3cAd353960143c01F6012cbf90C9DA8, _totalSupply); }",1
0x7476c85d6dfc144c6b196d8956b4cc2bbfb860f2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0dd1326b7b80107f002ba16dad7fe2dd22f00491.sol,LetsBreakThings,contract LetsBreakThings { address public creator; address public creatorproxy; function deposit() public payable { },1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xed51040da497901107870ece117f9ed8df4f4e52.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; bool public isEnableBuySell; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public { }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0x6eb1eee8dcb041e2d3b2130ce124c3005dc3d6a7.sol,PopeCoin,"contract PopeCoin is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PopeCoin( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0x00) { owner = centralMinter; }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BasicToken,contract BasicToken is ERC20Basic { mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0xdb5f7df433ffba706d39dc9dd7b2d68459fc2c22.sol,TradeIO,contract TradeIO { address owner; mapping(bytes8 => string) dateToHash; modifier onlyOwner () { require(owner == msg.sender); _; },1
0xaf860eb1d70ffc3842c6a1004ce89a7ade043f25.sol,BurgerKapija,"contract BurgerKapija is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BurgerKapija() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x6c50ad33f6b4414b7be304cc69725d212ebf138a] = _totalSupply; Transfer(address(0), 0x6c50ad33f6b4414b7be304cc69725d212ebf138a, _totalSupply); }",1
0x6b87999be87358065bbde41e8a0fe0b7b1cd2514.sol,TeslaWatt,"contract TeslaWatt is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x5c531ca3f21acc08ff6151e2d99d84acb632dfcd.sol,ConnectCapacity,contract ConnectCapacity { address private controllerSystem; struct AdaptionOrder { address vglNb; int256 cot; int256 pct; int256 tct; int256 ict; },1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,SafeMath,None,1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x34734d66dadc3fe1c35b6555341f07e8d8524c29.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d9bbc5035f2b0f74fc3e0a8a023aa98f5749fa.sol,mango,"contract mango is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function mango() public { symbol = ; name = ; decimals = 18; emit Transfer(address(0),0xAc2682F1Bd5316875805058f4Ec6157ccdE04859, 100000); bonusEnds = now + 12 weeks; endDate = now + 20 weeks; }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0xa1c15f52d51b436a4aec29e5dc6e9ccfdc50c229.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8.sol,DragonLifeChain,"contract DragonLifeChain is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc55cef4d21c3b879b7a6e7ba3e0f848fc111e2a4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0xd0bd12a8d5ebca1e2fa46da59f1993ec51c3d75c.sol,BKToken,"contract BKToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BKToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x1d5854e7f4dd81d9d4c09097d3cc736c7771f234.sol,vualt,contract vualt { bytes32 keyHash; address owner; bytes32 wallet_id = 0x162fb6d4a567c777d990e7b7517f9068408a67c8cca7089c7649eeeb349ee523; constructor() public { owner = msg.sender; },1
0x53ec8bca4d14737f7ea33415bfe392f32e331b35.sol,SOLUSToken,"contract SOLUSToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SOLUSToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 32 weeks; }",1
0xf19eac69f9566f0b40660bd0cc16234330f38456.sol,SafeMath,None,1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0ed74a3ecc90270d18a3b3a8eb0042a7cdd03b19.sol,MINEX,"contract MINEX { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MINEX() { balanceOf[msg.sender] = 2999029096950000; totalSupply = 2999029096950000; name = ; symbol = ; decimals = 8; }",1
0xf47cd932ee150f60cd611c3cfdba51bd33b27ad1.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0xed98b38f4fc2fcc633465b699f6d983d96e1fe8c.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Airdrop(address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x4b8b7f902456204f5a8cdd36cfe0ce0233822e2e.sol,ERC20COIN,"contract ERC20COIN { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdaf6fc57f9f415401f55632afb50c47f60a404fc.sol,BANK_III_PFII_883,"contract BANK_III_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 429287043125237000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3324d52c43952d53cf28b421c813efdc9c85af55.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x539bff788404c395117dd2dfdcc3d5e00a72d3b7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70528e8cc624f437fd01ab5a5215d8bb092b73ff.sol,ERC20,"contract ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x6e81a9ee3a1d4c2522de6e15e30ab551b3bdcbb6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01cd3d9df5869ca7954745663bd6201c571e05cf.sol,LULUToken,contract LULUToken is StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; string public releaseArr = ; uint public decimals = 18; function LULUToken() { totalSupply = 100000000000 * 1000000000000000000; balances[msg.sender] = totalSupply / 5; },1
0x4032a725b81cfd0cdb519933cc6084d9b22175c0.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0xE2FB6529EF566a080e6d23dE0bd351311087D567); function SimpleDistributor() public { owner = msg.sender; },1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa24f50fa560d2ec57956955f929273e899994bca.sol,XZEN,"contract XZEN is StandardToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant tokenCreationCapPreICO = 55000000*10**decimals; address public multiSigWallet = 0x51cf183cbe4e4c80297c49ff5017770fdd95c06d; address public teamWallet = 0x2BeB722Dc6E80D0C61e63240ca44B8a6D538e3Ae; uint public oneTokenInWei = 31847133757962; uint startDate = 1510592400; function XZEN() { owner = teamWallet; balances[teamWallet] = 55000000*10**decimals; totalSupply = totalSupply.add(balances[teamWallet]); Transfer(0x0, teamWallet, balances[teamWallet]); }",1
0x0868ce9bb32f4abedc83190ba5960a2863dc8646.sol,TEHRAN_Portfolio_Ib_883,"contract TEHRAN_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 2140354551050680000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineTokenWallet,contract EasyMineTokenWallet { uint256 constant public VESTING_PERIOD = 180 days; uint256 constant public DAILY_FUNDS_RELEASE = 15000 * 10**18; address public owner; address public withdrawalAddress; Token public easyMineToken; uint256 public startTime; uint256 public totalWithdrawn; modifier isOwner() { require(msg.sender == owner); _; },1
0x0d3264ab9ee29bec9534f0f210ca8db3ac4794a8.sol,LeifengMedals,"contract LeifengMedals { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LeifengMedals( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cbb5b731a6b0e03551e24b8a02e101d293e418e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f.sol,TopCoinFXToken,contract TopCoinFXToken { string public name = ; string public symbol = ; uint256 public constant decimals = 18; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 1000000000; uint public constant powNumber = 10; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x5bf79762869f3af9dd1c9385e59d35be5b32cc8d.sol,AdmissionToken,"contract AdmissionToken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AdmissionToken( ) public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000; name = ; symbol = ; }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,MilestoneCrowdsale,contract MilestoneCrowdsale is TimedCrowdsale { using SafeMath for uint256; uint256 public constant MAX_MILESTONE = 10; struct Milestone { uint256 index; uint256 startTime; uint256 tokensSold; uint256 cap; uint256 rate; },1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x3f90421fd22b7e3251c8600430acc82922d2a434.sol,Lima,"contract Lima is StandardToken, Ownable{ string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; uint256 public _totalSupply = 7000000000e18; uint256 public _initialSupply = 7000000000e18; uint256 public _totalTokenSold = 0; bool private reserve_activated = false; function Lima() { balances[owner] = _initialSupply; totalSupply = _totalSupply; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 200000000; fundsWallet = owner; }",1
0x1b9dcdcddd2d6ca699cad9505faa363e81145c6b.sol,BrinkToken,"contract BrinkToken is EIP20Interface { address owner = msg.sender; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint price; function BrinkToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6b3f9f54e2a684ea28365af5f3dd6d714df4328b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x28577a6d31559bd265ce3adb62d0458550f7b8a7.sol,CCCToken,"contract CCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CCCToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0xd44dbf7e6aa11b3a9e16890f57eb6a6dc74ee94d.sol,token,"contract token { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[this] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55f363057098fb092ba85daf92ee6eeb4074e660.sol,VOCC_I105_20181211,"contract VOCC_I105_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b5ae67ee604f10e6429d74533ac15a57fa14572.sol,LUCK,contract LUCK is Ownable{ address[] public bebdsds; tokenTransfer public bebTokenTransfer; function LUCK(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x6ec2e2e2bd43d4deaa883533f80ea61682236073.sol,HACHIKO,"contract HACHIKO is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe30980cb82afe59f38935fdd6d3b60e688877677.sol,CRTRC,"contract CRTRC is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CRTRC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x55883c45ca6d60ae69e084acc1daece002dd11c7.sol,CorexToken,"contract CorexToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Mint(address indexed to, uint256 amount); event CanMint(bool _canMint); function CorexToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0e7d77bf4c468b6b626b07be5aa1c8222eb08324.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xc4c06df5c799bec6ee6e4652beec86e5cfc94778.sol,BTF,"contract BTF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTF() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x2f253924924525632B82a2CEB99F7325fB036866] = _totalSupply; Transfer(address(0), 0x2f253924924525632B82a2CEB99F7325fB036866, _totalSupply); }",1
0xaac4bd00745b72f49fd1d32862cfdac8a1bb80eb.sol,PingToken,"contract PingToken { event Pong(uint256 pong); event Transfer(address indexed from, address indexed to, uint256 value); uint256 public pings; uint256 public totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public genCode = 0; mapping(address => uint256) balances; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Impl,contract ERC20ImplUpgradeable is CustodianUpgradeable { struct ImplChangeRequest { address proposedNew; },1
0x55100b6e3e1cc3018881a4a68edf229a80bac944.sol,MintingERC20,"contract MintingERC20 is ERC20 { mapping (address => bool) public minters; uint256 public maxSupply; function MintingERC20( uint256 _initialSupply, uint256 _maxSupply, string _tokenName, uint8 _decimals, string _symbol, bool _transferAllSupplyToOwner, bool _locked ) ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked) { standard = ; minters[msg.sender] = true; maxSupply = _maxSupply; }",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,PresaleToken,"contract PresaleToken is PausableToken, MintableToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 9; event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens); function PresaleToken() public { pause(); }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x5ba983231b4bb509f0f25e97fa22e20d71c5d44c.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken() TokenERC20(0, , ) public { sellPrice = (uint256(10) ** decimals) / 110000000; buyPrice = (uint256(10) ** decimals) / 110000; }",1
0x92eb85cf258cf4f28af209ec102e29841a501134.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e1de8374d4d0717b8cb9cb180621c021492162e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,PPNToken,contract PPNTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function PPNTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0x6b6130ed3d3e50db4e550638ab887c53287d41b7.sol,CSNTToken,"contract CSNTToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 1000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x17aeb3c181365bc4a386d8dc6ecbe2a96a379088.sol,CipherPlayToken,contract CipherPlayToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 24000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xf2a95300326adf582a43b63218742e4528f82b01.sol,MultiSend,contract MultiSend { TokenERC20 public _ERC20Contract; address public _multiSendOwner; function MultiSend () { address c = 0xc3761eb917cd790b30dad99f6cc5b4ff93c4f9ea; _ERC20Contract = TokenERC20(c); _multiSendOwner = msg.sender; },1
0xa4dd9ad3da2d074f63b3993e7d5d7fc4ab37721a.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x85982b3b3b55100dc92752546bfb2fe5ea676a08.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x28b213902cd539e09992f4cbea374952cba5eeed.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { tokenName = ; tokenSymbol = ; initialSupply = 1000000000 * 10 ** uint256(decimals); totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6eb1eee8dcb041e2d3b2130ce124c3005dc3d6a7.sol,PopeCoin,"contract PopeCoin is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PopeCoin( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0x00) { owner = centralMinter; }",1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5573cb8589a2ed0ca4029202739bfc251932201f.sol,STRATCO,"contract STRATCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b29a6277c996b477d6632e60eef41268311ce1c.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 500000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; }",1
0x06373e227fc3855b0f646db3ed4eebe0f58797f7.sol,EasyTravel,"contract EasyTravel { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EasyTravel( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,FansChainToken,"contract FansChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FansChainToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x54f61b89a0bac15c88c6bddf41573ddc1ba5bf6d.sol,LEF,"contract LEF is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function LEF() public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x286ae9778a87dc8d4eb4ac3d57b5b928d41abbff.sol,VOCC_I027_20181211,"contract VOCC_I027_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28380d4942470c315c2974b934b2080751d35a77.sol,TurdCoin,"contract TurdCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TurdCoin() TokenERC20(1000000, , ) public {}",1
0x3293cc907fde439b39aedaf1b982785adaff186b.sol,ERC20Token,"contract ERC20Token is ReentryProtected, ERC20Interface { using SafeMath for uint256; uint256 totSupply; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; function ERC20Token() { totSupply = 0; balance[msg.sender] = totSupply; }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0xdbb6b23520472c5070078cd3e7097b36b001fb57.sol,TheBigBangOnline,contract TheBigBangOnline is Ownable { using SafeMath for uint256; bool contractProtection = true; modifier notFromContract() { if ( (msg.sender != tx.origin) && (contractProtection == true)){ revert(); },1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa3d48af5b7541658e7b663905f11433f1b4074f5.sol,OysterPearl,"contract OysterPearl { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public funds = 0; address public owner; bool public saleClosed = false; bool public ownerLock = false; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Bury(address indexed target, uint256 value); event Claim(address indexed payout, address indexed fee); function OysterPearl() public { owner = msg.sender; totalSupply = 0; totalSupply += 25000000 * 10 ** uint256(decimals); totalSupply += 75000000 * 10 ** uint256(decimals); totalSupply += 1000000 * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; claimAmount = 5 * 10 ** (uint256(decimals) - 1); payAmount = 4 * 10 ** (uint256(decimals) - 1); feeAmount = 1 * 10 ** (uint256(decimals) - 1); }",1
0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500.sol,ZchargeToken,"contract ZchargeToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZchargeToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x6a670d25dfb62f5d24c33de9092c38e4123c3dcd.sol,LuckToken,"contract LuckToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LuckToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4c49d776c1c314d16b82ecac7ed8f70433db757d.sol,caspianToken,"contract caspianToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function caspianToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply=10000000000000000000000000000; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,HajjERC20,"contract HajjERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c493a221ae9b49c3e45f2df8a3b34223855c1f4.sol,ERC827Caller,"contract ERC827Caller { function makeCall(address _target, bytes _data) external payable returns (bool) { return _target.call.value(msg.value)(_data); }",1
0xf06274d668f923f472abdb67ac3dd38ac1f0bde4.sol,BOARDMYTRIP,"contract BOARDMYTRIP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 21000000000000000; balances[0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB] = _totalSupply; emit Transfer(address(0), 0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed3ce5919656b9988ab33c04a0e684ec94043f5b.sol,UltraVioletToken,"contract UltraVioletToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function UltraVioletToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x36b53bf543eebf9ad42c5f161efd1247f38d034d.sol,REOC,"contract REOC { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function REOC() public { totalSupply = 2000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc41585205b83b7c643a37b87887c97cf31cb8867.sol,QINTAR,"contract QINTAR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 5; _totalSupply = 100000000000; balances[0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b] = _totalSupply; emit Transfer(address(0), 0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b, _totalSupply); }",1
0x6ce17d826a1c50e97678810954943c83ebd10066.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x748c6ed3f78f5f06ceb76834f195d3a05b7d628a.sol,POWH33,contract POWH33 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x564a47b92be4d4070f3488112c6dd4ed757ad4c7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value)public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x1e2bbf1578d1ecd107c95ab550f8c9559a0acca6.sol,Tbyc,"contract Tbyc { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tbyc() { owner = 0x0a09B58084554786215Dabe7Ab645cB17b1e490E; name = ; symbol = ; decimals = 18; totalSupply = 1314000000000000000000000000; balanceOf[owner] = 1314000000000000000000000000; }",1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0xeb86dfc14848b56955051cfd9d696bafde1d6027.sol,StoreGift,contract StoreGift is BasicAuth { struct Gift { string m_Key; uint m_Expire; uint32[] m_ItemIdxList; uint[] m_ItemNumlist; },1
0x732c6f4f1cf13d850d71e9dad229997db0818a52.sol,ERC20,contract ERC20 { using SafeMath for uint256; address public owner; address public admin; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant initSupply = 60000000 * 10**decimals; uint256 public constant supplyReserveVal = 37500000 * 10**decimals; uint256 public totalSupply; uint256 public icoSalesSupply = 0; uint256 public icoReserveSupply = 0; uint256 public softCap = 5000000 * 10**decimals; uint256 public hardCap = 21500000 * 10**decimals; uint256 public icoDeadLine = 1533513600; bool public isIcoPaused = false; bool public isStoppingIcoOnHardCap = true; modifier duringIcoOnlyTheOwner() { require( now>icoDeadLine || msg.sender==owner ); _; },1
0xee1b90c203b6e0d11b090dd5b588602e44efd7b1.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x27058b0fe23a4cdd08aced7ffd646647019cdab9.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x067d488a1fc741cf3c928b17aa6f23a939e96c4c.sol,SOUTH_KOREA_WINS,"contract SOUTH_KOREA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 6988045660440500000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c.sol,DefensorWallet,"contract DefensorWallet is ERC20, Owner { string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; struct FrozenToken { bool isFrozenAll; uint256 amount; uint256 unfrozenDate; }",1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,SafeOpt,None,1
0x52ab2ef83426ad1fa5d3e402947e38dce2894903.sol,Vegan,"contract Vegan is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Vegan() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000000000000000000000; startDate = now; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xc608f567bcf51b0d84edef669b9d7d47440b7bb7.sol,EthronTokenPonzi,"contract EthronTokenPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthronTokenPonzi() public { }",1
0x5861e9618ec3fe9c8e1d4befb8dc5466a6a9fde1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,FrogSeekers,"contract FrogSeekers is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,HajjERC20,"contract HajjERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x26cd1f0943d5877f7de475571172f957c337d4e4.sol,GoldenBit,"contract GoldenBit is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 960000000000000000000000000; balances[0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB] = _totalSupply; emit Transfer(address(0), 0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB, _totalSupply); }",1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0xf3e3f649771651368d89dd6fefc57c77dceb6f78.sol,BitMaxProToken,"contract BitMaxProToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 2500000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xc03b0dbd201ee426d907e367f996706cf53b8028.sol,HODLerParadise,contract HODLerParadise{ struct User{ address hodler; bytes32 passcode; uint hodling_since; },1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8.sol,COSHATokenHKD,"contract COSHATokenHKD { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 1 * 10 ** (10 + uint256(decimals)); initialSupply = totalSupply; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; tokenName = name; tokenSymbol = symbol; }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x785585878feb8cf7cd1e3b9eca0635464c2dd0cb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4cee97ddd88f0bec86dd4b4163ca499a9790c3df.sol,Raven,"contract Raven is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Raven() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0xdb5c3c46e28b53a39c255aa39a411dd64e5fed9c.sol,NeosCredits,"contract NeosCredits is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NeosCredits() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xE581eFBa0B2a360Dc66443289a50660e9F44aC81] = _totalSupply; Transfer(address(0), 0xE581eFBa0B2a360Dc66443289a50660e9F44aC81, _totalSupply); }",1
0xb47670e40bdf1fbd34753f9ac360e613af9001f4.sol,VOCC_I029_20181211,"contract VOCC_I029_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x32b2dc789ca341119b03c86c0a3c0b613e4835b6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x1caecd601911d84941fddc74f94a871e15d24299.sol,JAPAN_WINS,"contract JAPAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd628af3abb55fc8a5e6095fbcf95e508b7bc6724.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x3617081dd9294a785780a4fcde3dcb8f0a2c69e8.sol,MofasAirdrop,"contract MofasAirdrop is Ownable { function multisend(address[] to, uint256[] value) onlyOwner returns (uint256) { address tokenAddr = 0x1d18f44256A27862d886E27191d55AB4029172C1; uint256 i = 0; while (i < to.length) { ERC20(tokenAddr).transfer(to[i], value[i] * ( 10 ** 18 )); i++; }",1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,BodyRabbit,"contract BodyRabbit is BaseRabbit, ERC721 { uint public totalBunny = 0; string public constant name = ; string public constant symbol = ; PrivateRabbitInterface privateContract; AdmixtureInterface AdmixtureContract; function setPriv(address _privAddress) public returns(bool) { privAddress = _privAddress; privateContract = PrivateRabbitInterface(_privAddress); }",1
0xc541e02e7d66cb5cbd7d33d1874dcc3f028ad75c.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc48b1ac1417db27c4e2c2ed3dae5a3d2fbb07dc5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { balanceOf[msg.sender] = 2100000000000000; totalSupply = 2100000000000000; name = ; symbol = ; decimals = 8; }",1
0x294ee9f35988af1ce361409cee4251a293d21f5c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ebd04228ae2900ccad55193233492ddc3b09de9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25dab234f1a0368656846412fa0c33a978315c07.sol,CryptoGoldStandardCoin,"contract CryptoGoldStandardCoin is MintableToken, BurnableToken { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 9; uint public INITIAL_SUPPLY = 100000000000; uint public sellPrice = 0; uint public buyPrice = 2**256-1; uint public priceExpirationBlockNumber = 0; function setPrices(uint newSellPrice, uint newBuyPrice, uint newPriceExpirationBlockNumber) onlyOwner public{ require(newPriceExpirationBlockNumber > block.number); require(newSellPrice < newBuyPrice); sellPrice = newSellPrice; buyPrice = newBuyPrice; priceExpirationBlockNumber = newPriceExpirationBlockNumber; }",1
0x3a03afa73623b99eedaa6180a869dd5bde17a601.sol,CheapLambos,contract CheapLambos { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x72acaab5b211b9a69bf71f4a6bb1f56546451509.sol,GlobalCapitalGroup,"contract GlobalCapitalGroup { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0x5b0462bb50a0c4b051e26a01689f45f6ed0ffaab.sol,ERC20BatchTransfer,"contract ERC20BatchTransfer { function batchTransfer(address _tokenAddress, address[] _beneficiaries, uint256 _amount) public { require(_amount > 0); ERC20 tokenContract = ERC20(_tokenAddress); for (uint b = 0; b < _beneficiaries.length; b++) { require(tokenContract.transferFrom(msg.sender, _beneficiaries[b], _amount)); }",1
0x2c7a0708aed7126d4b58b07f9bb58ba40b996418.sol,SJGC_ERC20,"contract SJGC_ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public TokenPerKRWBuy = 100; mapping(bytes32 => bool) transactionHashes; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x54f61b89a0bac15c88c6bddf41573ddc1ba5bf6d.sol,LEF,"contract LEF is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function LEF() public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XCPlugin,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x31243ce202f30d4aa4ed723b927fa8731cb951e9.sol,Numisma,"contract Numisma is owned, TokenERC20 { string public comment; uint256 initialSupply = 1000000; string tokenName = ; string tokenSymbol = ; string version = ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Numisma() TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Control,contract Control { mapping(address => uint8) public agents; modifier onlyADM() { require(agents[msg.sender] == 1); _; },1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x47078e95d238108b5ee30d4806025b5aab6dac83.sol,BraggerContract,contract BraggerContract { address public richest; string public displayString; uint public highestBalance; address owner; function BraggerContract() public payable { owner = msg.sender; highestBalance = 0; },1
0x383bf1fd04d0901bbd674a580e0a621fcbb4799b.sol,CryptoDoggies,"contract CryptoDoggies is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, bytes5 dna, uint256 price, address owner); event TokenSold( uint256 indexed tokenId, string name, bytes5 dna, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner ); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) private tokenIdToApproved; struct Doggy { string name; bytes5 dna; }",1
0x035070be3ae4be1f69245214a4343a723c30232b.sol,Ethereum,"contract Ethereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ethereum() public { symbol = ; name = ; decimals = 8; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x1bdf56c9593590122fd8750555d8148da2b80be8.sol,ShareTokenSale,contract ShareTokenSale is Ownable { using SafeMath for uint256; ERC20 public token; address public receiverAddr; uint256 public totalSaleAmount; uint256 public totalWannaBuyAmount; uint256 public startTime; uint256 public endTime; uint256 public userWithdrawalStartTime; uint256 public clearStartTime; uint256 public withdrawn; uint256 public proportion = 1 ether; mapping(uint256 => uint256) public globalAmounts; struct Stage { uint256 rate; uint256 duration; uint256 startTime; },1
0x035c8119a68a8f762fe2731fa190a5afcba653a3.sol,RVLS,"contract RVLS { string public name; string public symbol; uint8 public decimals = 5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RVLS( ) public { totalSupply = 1000000000000000; balanceOf[msg.sender] = 1000000000000000; name = ; symbol = ; }",1
0xeccab39acb2caf9adba72c1cb92fdc106b993e0b.sol,AzbitToken,"contract AzbitToken is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public releaseDate = 1546300800; uint256 public constant MIN_RELEASE_DATE = 1546300800; uint256 public constant MAX_RELEASE_DATE = 1559260800; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public whiteList; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x002036ed3d00736787a31a19b1e28f7a86c72672.sol,DLP,"contract DLP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DLP() public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xdfbfd64726b1b178ef8204ae4992f641f31c8248.sol,EloPlayToken,"contract EloPlayToken is ERC20Token, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; address public TARGET_ADDRESS; address public TARGET_TOKENS_ADDRESS; uint256 public START_TS; uint256 public END_TS; uint256 public CAP; uint256 public USDETHRATE; bool public halted; uint256 public totalEthers; event TokensBought(address indexed buyer, uint256 ethers, uint256 new_ether_balance, uint256 tokens, uint256 target_address_tokens, uint256 new_total_supply, uint256 buy_price); event FundTransfer(address backer, uint amount, bool isContribution); function EloPlayToken(uint256 _start_ts, uint256 _end_ts, uint256 _cap, address _target_address, address _target_tokens_address, uint256 _usdethrate) { START_TS = _start_ts; END_TS = _end_ts; CAP = _cap; USDETHRATE = _usdethrate; TARGET_ADDRESS = _target_address; TARGET_TOKENS_ADDRESS = _target_tokens_address; }",1
0x339150b0851bc5b3c0323789a58cc4e4afb38b37.sol,EasyInvest10,contract EasyInvest10 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); invested[totalETH] += msg.value; },1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x418ce003a8ad9925239bd20ea52abc1d950aeea1.sol,KidChain,contract KidChain is StandardToken { function () public { revert(); },1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,SimpleMarket,"contract SimpleMarket is owned, WithdrawalContract { uint public startPrice; uint public fixPrice = 0.1 ether; uint internal decimals = 0; bytes32 public productId = 0x0; struct UserStruct { uint userListPointer; bytes32[] productKeys; bytes32 userEmail; bytes32 userName; mapping(bytes32 => uint) productKeyPointers; }",1
0xee284b58871645ce2656e309e238c5e2eace771a.sol,PornTokenV2,"contract PornTokenV2 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PornTokenV2( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0x561f26b8522d1b43559f3171ccebabd6d317af4e.sol,IGEChainERC20,"contract IGEChainERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IGEChainERC20() public { totalSupply =31415926500000000; balanceOf[msg.sender] = 31415926500000000; name = ; symbol = ; }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0.sol,TokenERC20,"contract TokenERC20 is SafeMath { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) private addressBalance; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function balanceOf (address _owner) constant returns (uint256 balance) { return addressBalance[_owner]; }",1
0xedd4941d09bb0fafd230100c86ffbbd7907b6fed.sol,SafeMath,None,1
0xda6245b3355e15cb38f65701700876de75ef4bef.sol,HOT,"contract HOT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function HOT() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,BitBonus,"contract BitBonus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x633A5cD23D95c26f750B802A03A82490C00Da802] = _totalSupply; emit Transfer(address(0), 0x633A5cD23D95c26f750B802A03A82490C00Da802, _totalSupply); }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x9299ccef011d2d8faf76b214c8549c14bc918035.sol,ITGCToken,contract ITGCToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 8; uint public totalSupply = (20 * 10 ** 8 + 50) * 10 ** 8; constructor() public { balances[msg.sender] = totalSupply; },1
0x2cf1093158d4197e84d842122fc4fa34ccd46220.sol,ShareToken,contract ShareToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public corporationContract; mapping (address => bool) public identityApproved; mapping (address => bool) public voteLock; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public transferCount = 0; struct pasttransfer { address from; address to; uint256 beforesender; uint256 beforereceiver; uint256 value; uint256 time; },1
0xa5818774ffb1405d7684c92892c990ba6939828b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x281f5b914b0d589f8193cd5e711c6920874e00c8.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 640000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,InsuranceFund,contract InsuranceFund { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 withdrawals; bool insured; },1
0x84d5c939ddfdc3ea033f03e18213a6906f94e0c3.sol,CryptoSagaDungeonProgress,"contract CryptoSagaDungeonProgress is Claimable, AccessDeploy { mapping(address => uint32[25]) public addressToProgress; function getProgressOfAddressAndId(address _address, uint32 _id) external view returns (uint32) { var _progressList = addressToProgress[_address]; return _progressList[_id]; }",1
0x693f915802b6f2bf47e97bf28ac118042278c9fa.sol,DynamicToken,"contract DynamicToken is TokenInterface { bool public isClosed; bool public isMaxSupplyLocked; bool public isLockedOpen; bool public isContractOwnerLocked; uint256 public maxSupply; address public upgradedContract; address public contractOwner; address[] public accounts; string[] public proofIds; mapping (address => bool) public accountExists; mapping (string => bool) proofIdExists; event TransferFrom(address indexed _from, address indexed _to, address indexed _spender, uint256 _amount); event Issue(address indexed _from, address indexed _to, uint256 _amount, string _proofId); event Burn(address indexed _burnFrom, uint256 _amount); event Close(address indexed _closedBy); event Upgrade(address indexed _upgradedContract); event LockOpen(address indexed _by); event LockContractOwner(address indexed _by); event TransferContractOwnership(address indexed _by, address indexed _to); event MaxSupply(address indexed _by, uint256 _newMaxSupply, bool _isMaxSupplyLocked); function DynamicToken() { contractOwner = msg.sender; maxSupply = 10**7; totalSupply = 0; isClosed = false; isMaxSupplyLocked = false; isLockedOpen = false; isContractOwnerLocked = false; }",1
0xc0ffeee61948d8993864a73a099c0e38d887d3f4.sol,MultiSigTokenWallet,contract MultiSigTokenWallet { address[] public owners; address[] public tokens; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; uint public transactionCount; mapping (address => uint) public tokenBalances; mapping (address => bool) public isOwner; mapping (address => address[]) public userList; uint public required; uint public nonce; struct Transaction { address destination; uint value; bytes data; bool executed; },1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,Crowdsale,"contract Crowdsale is Pausable, TokenVesting { using SafeMath for uint; address public multisigETH; address public commissionAddress; uint public tokensForTeam; uint public ethReceivedPresale; uint public ethReceivedMain; uint public totalTokensSent; uint public tokensSentMain; uint public tokensSentPresale; uint public tokensSentDev; uint public startBlock; uint public endBlock; uint public maxCap; uint public minCap; uint public minContributionMainSale; uint public minContributionPresale; uint public maxContribution; bool public crowdsaleClosed; uint public tokenPriceWei; uint public refundCount; uint public totalRefunded; uint public campaignDurationDays; uint public firstPeriod; uint public secondPeriod; uint public thirdPeriod; uint public firstBonus; uint public secondBonus; uint public thirdBonus; uint public multiplier; uint public status; Step public currentStep; address[] public holdersIndex; address[] public devIndex; enum Step { FundingPreSale, FundingMainSale, Refunding }",1
0x1774e30a3daab7bbace3ce4c64ddc6a4f29a975a.sol,XHHM,"contract XHHM is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XHHM() public { symbol = ; name = ; decimals = 18; _totalSupply = 900000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xf2940f868fcd1fbe8d1e1c02d2eaf68d8d7db338.sol,PlayerBook,contract PlayerBook { using SafeMath for uint256; address private admin = msg.sender; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => Player) public plyr_; mapping (uint256 => uint256) public refIDxpID_; struct Player { address addr; },1
0xc83355ef25a104938275b46cffd94bf9917d0691.sol,FUTR,"contract FUTR { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 MAX_SUBMITTED = 500067157619455000000000; uint256 _totalSupply = 0; uint256[] levels = [ 8771929824561400000000, 19895525330179400000000, 37350070784724800000000, 64114776667077800000000, 98400490952792100000000, 148400490952792000000000, 218400490952792000000000, 308400490952792000000000, 415067157619459000000000, 500067157619455000000000 ]; uint256[] ratios = [ 114, 89, 55, 34, 21, 13, 8, 5, 3, 2 ]; uint256 _submitted = 0; uint256 public tier = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event Mined(address indexed _miner, uint _value); event WaitStarted(uint256 endTime); event SwapStarted(uint256 endTime); event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time); event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time); string public name = ; uint8 public decimals = 18; string public symbol = ; bool public swap = false; bool public wait = false; bool public extended = false; uint256 public endTime; uint256 swapTime; uint256 swapEndTime; uint256 endTimeExtended; uint256 swapTimeExtended; uint256 swapEndTimeExtended; uint256 public payRate = 0; uint256 submittedFeesPaid = 0; uint256 penalty = 0; uint256 reservedFees = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () external payable { require(msg.sender != address(0) && tier != 10 && swap == false && wait == false); uint256 issued = mint(msg.sender, msg.value); Mined(msg.sender, issued); Transfer(this, msg.sender, issued); }",1
0x1bdf56c9593590122fd8750555d8148da2b80be8.sol,ShareTokenSale,contract ShareTokenSale is Ownable { using SafeMath for uint256; ERC20 public token; address public receiverAddr; uint256 public totalSaleAmount; uint256 public totalWannaBuyAmount; uint256 public startTime; uint256 public endTime; uint256 public userWithdrawalStartTime; uint256 public clearStartTime; uint256 public withdrawn; uint256 public proportion = 1 ether; mapping(uint256 => uint256) public globalAmounts; struct Stage { uint256 rate; uint256 duration; uint256 startTime; },1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x0d8f67a5792c156d0244f380a66655b9f4255586.sol,Carrot,"contract Carrot { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Carrot( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa2f000b776a64770e1a3e1e43e63296f5f029451.sol,chuxinlianContract,"contract chuxinlianContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public CXLExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintCXLToken(msg.sender, (msg.value * CXLExchangeRate * 10**decimals) / etherChange); }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x342f4057110be50957d0f156f4939a929944c69e.sol,MultiWhitelist,contract MultiWhitelist { address public owner; function MultiWhitelist(address _owner) public { owner = _owner; },1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,VestingAllocation,"contract VestingAllocation is Ownable { address[] public allocationAddressList; uint256 public periods; uint256 public minutesInPeriod; uint256 public remainingTokensPerPeriod; uint256 public totalSupply; uint256 public initTimestamp; mapping (address => Types.StructVestingAllocation) public allocationOf; function VestingAllocation(uint256 _tokensPerPeriod, uint256 _periods, uint256 _minutesInPeriod, uint256 _initalTimestamp) Ownable() public { totalSupply = _tokensPerPeriod * _periods; periods = _periods; minutesInPeriod = _minutesInPeriod; remainingTokensPerPeriod = _tokensPerPeriod; initTimestamp = _initalTimestamp; }",1
0xc541e02e7d66cb5cbd7d33d1874dcc3f028ad75c.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x00b9034425e357bf61b4abeb22299ec4a62c725b.sol,Essence,"contract Essence is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Essence( ) TokenERC20() public {}",1
0xda6245b3355e15cb38f65701700876de75ef4bef.sol,HOT,"contract HOT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function HOT() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xead527531f9e31c989c6be6e9cf4abfc7531c999.sol,Bourneereum,"contract Bourneereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bourneereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40a835f8573c4b75e962e435591ea2200b74a714.sol,MyEtherTeller,contract MyEtherTeller { address public owner; struct EscrowStruct { address buyer; address seller; address escrow_agent; uint escrow_fee; uint amount; bool escrow_intervention; bool release_approval; bool refund_approval; bytes32 notes; },1
0x5554e04e76533e1d14c52f05beef6c9d329e1e30.sol,Token,"contract Token { mapping (address => uint256) public balanceOf; mapping (uint256 => address) public addresses; mapping (address => bool) public addressExists; mapping (address => uint256) public addressIndex; mapping(address => mapping (address => uint256)) allowed; uint256 public numberOfAddress = 0; string public physicalString; string public cryptoString; bool public isSecured; string public name; string public symbol; uint256 public totalSupply; bool public canMintBurn; uint256 public txnTax; uint256 public holdingTax; uint256 public holdingTaxInterval; uint256 public lastHoldingTax; uint256 public holdingTaxDecimals = 2; bool public isPrivate; address public owner; function Token(string n, string a, uint256 totalSupplyToUse, bool isSecured, bool cMB, string physical, string crypto, uint256 txnTaxToUse, uint256 holdingTaxToUse, uint256 holdingTaxIntervalToUse, bool isPrivateToUse) { name = n; symbol = a; totalSupply = totalSupplyToUse; balanceOf[msg.sender] = totalSupplyToUse; isSecured = isSecured; physicalString = physical; cryptoString = crypto; canMintBurn = cMB; owner = msg.sender; txnTax = txnTaxToUse; holdingTax = holdingTaxToUse; holdingTaxInterval = holdingTaxIntervalToUse; if(holdingTaxInterval!=0) { lastHoldingTax = now; while(getHour(lastHoldingTax)!=21) { lastHoldingTax -= 1 hours; }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,InsuranceFund,contract InsuranceFund { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 withdrawals; bool insured; },1
0xd35be56e4ed6818d09e6f95b9c744c4607fda453.sol,ProofOfBitConnect,contract ProofOfBitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6f9064180354a6773db5af7226a40614c8dbce39.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; for (i = 0; i < dests.length; i++) { ERC20(_tokenAddr).transfer(dests[i], values[i]); }",1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32e2150b69072fc331f7e4dff202d5bc4cb7156f.sol,CCD_BDX_BOO_20190329_1,"contract CCD_BDX_BOO_20190329_1 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x46b9ad944d1059450da1163511069c718f699d31.sol,CREDITS,"contract CREDITS is Ownable{ string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; uint public TotalHoldersAmount; bool public Frozen=true; bool public CanChange=true; address public Admin; address public AddressForReturn; address[] Accounts; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address => bool) public AccountIsFrozen; mapping(address => bool) public AccountIsNotFrozen; mapping(address => bool) public AccountIsNotFrozenForReturn; mapping(address => uint) public AccountIsFrozenByDate; mapping (address => bool) public isHolder; mapping (address => bool) public isArrAccountIsFrozen; mapping (address => bool) public isArrAccountIsNotFrozen; mapping (address => bool) public isArrAccountIsNotFrozenForReturn; mapping (address => bool) public isArrAccountIsFrozenByDate; address [] public Arrholders; address [] public ArrAccountIsFrozen; address [] public ArrAccountIsNotFrozen; address [] public ArrAccountIsNotFrozenForReturn; address [] public ArrAccountIsFrozenByDate; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint256 value); modifier IsNotFrozen{ require(((!Frozen&&AccountIsFrozen[msg.sender]!=true)||((Frozen)&&AccountIsNotFrozen[msg.sender]==true))&&now>AccountIsFrozenByDate[msg.sender]); _; }",1
0xc165c159d3b19c36ca1a84f6841a801af47c9c03.sol,EBANKTOKEN,"contract EBANKTOKEN is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EBANKTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0x6f4f8b6f233eb5dbad46163010f35fed843125b7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1ad1f2d6f5dcb3beca60ebff0bfab6d04a095299cdb316f6975f52b3c8abb569; constructor() public { owner = msg.sender; },1
0x52a4b11b23587467b54a49ec0ccb47436526f714.sol,DoacaoEvento,"contract DoacaoEvento { address public responsavel; enum StatusDoacao{ABERTO, FECHADO, SACADO}",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x3452519f4711703e13ea0863487eb8401bd6ae57.sol,BulkSender,"contract BulkSender is Ownable { using SafeERC20 for ERC20Basic; function bulkTransfer(ERC20Basic token, address[] toAddresses, uint256[] values) public onlyOwner returns (bool) { require((toAddresses.length > 0) && (toAddresses.length == values.length)); for (uint i = 0; i < toAddresses.length; i++) { token.safeTransfer(toAddresses[i], values[i]); }",1
0x8a113a57e74aef531bee8de7e16e604916f053ac.sol,ClipperCoin,"contract ClipperCoin is Owned{ using SafeMath for uint; string public name = ; string public symbol = ; uint public decimals = 18; uint public totalSupply = 200000000 ether; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClipperCoin( uint256 initialSupply, string tokenName, uint8 tokenDecimals, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; }",1
0x582e09ee0a6ae313f9e8e4e84491808dec0e7eda.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x324d65aa829a9b976fe661b03a7d4cd0d66ff843.sol,BCE,"contract BCE { using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public supplyLeftAtOrigin = 21000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public constant RATE = 500; function BCE( address sendTo, uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = sendTo; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6bc4375083d3ad563de91cad8438f629841448a5.sol,CryptogeneidToken,"contract CryptogeneidToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptogeneidToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xc6EE88b4746850cD70bDb5b2C299966862fc880F] = _totalSupply; Transfer(address(0), 0xc6EE88b4746850cD70bDb5b2C299966862fc880F, _totalSupply); }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0xd38f3c46d20aa7021e486290a24e25eba1491909.sol,IVNTToken,"contract IVNTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xD0899570c15DCfFE5952D32D68A9464725d6BF78; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0xd1f95941d9a69e875f7f51f04e5f214f8114e730.sol,Exzie,"contract Exzie is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Exzie() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000; balances[0xd81fe1115652d04d6b7c48f5e2ed5a615297852d] = _totalSupply; Transfer(address(0), 0xd81fe1115652d04d6b7c48f5e2ed5a615297852d, _totalSupply); }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc7109afb8a3cc28f2429bf4a35f959a567a2610.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,WhiteListManager,contract WhiteListManager is Ownable { mapping (address => bool) public list; function unset(address addr) public onlyOwner { list[addr] = false; },1
0x7078b01170768c6db7bd9f515305682e52664cd3.sol,TariInvestment,"contract TariInvestment is Ownable { address public investmentAddress = 0x33eFC5120D99a63bdF990013ECaBbd6c900803CE; address public majorPartnerAddress = 0x8f0592bDCeE38774d93bC1fd2c97ee6540385356; address public minorPartnerAddress = 0xC787C3f6F75D7195361b64318CE019f90507f806; mapping(address => uint) public balances; uint totalInvestment; uint availableRefunds; uint refundingDeadline; enum State{Open, Closed, Refunding}",1
0x0dabaea13982b659ffa03c02307ce1e5a04dc657.sol,ERC20TOKEN,"contract ERC20TOKEN is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xc3758ba9d0851dae0abfeb65ab439138deb3d3e3.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 6; uint256 public totalSupply=76000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function HotelloadTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcfd2047eb61412e9b8de511dc2087e07003829ee.sol,FifteenPlus,contract FifteenPlus { address owner; address ths = this; mapping (address => uint256) balance; mapping (address => uint256) overallPayment; mapping (address => uint256) timestamp; mapping (address => uint256) prtime; mapping (address => uint16) rate; constructor() public { owner = msg.sender;},1
0xaf8ce1b205be2bfdede58d8f923f610463658148.sol,iCASH,"contract iCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function iCASH() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x5D33021e1333CE72b9051aF68718a3576C92AAc8] = _totalSupply; Transfer(address(0), 0x5D33021e1333CE72b9051aF68718a3576C92AAc8, _totalSupply); }",1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0xf026ba160c18f5342031e25f6e93e2ba264ed64f.sol,CIRCLECOIN,"contract CIRCLECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CIRCLECOIN() public { symbol = ; name = ; decimals = 16; _totalSupply = 1000000000000000000000000; balances[0x63D8a091d446949ce806f5B9a45Cf8b254896ee5] = _totalSupply; Transfer(address(0), 0x63D8a091d446949ce806f5B9a45Cf8b254896ee5, _totalSupply); }",1
0x074661068c2cbca51dde811871554d2fa5bae312.sol,BountyHunterToken,"contract BountyHunterToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BountyHunterToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x41c1bc7738ef9c259f100a5fd655185496fb5a47.sol,Kcoin,"contract Kcoin is IERC20{ using SafeMath for uint256; uint public initialSupply = 150000000000e18; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint public totalSupply = 1500000000000e18; uint256 public constant Rate1 = 5000; uint256 public constant Rate2 = 5000; uint256 public constant Rate3 = 4500; uint256 public constant Rate4 = 4000; uint256 public constant Rate5 = 3500; uint256 public constant Rate6 = 3000; uint256 public constant Rate7 = 2500; uint256 public constant Rate8 = 2000; uint256 public constant Rate9 = 1500; uint256 public constant Rate10= 1000; uint256 public constant Start1 = 1519862400; uint256 public constant Start2 = 1522540800; uint256 public constant Start3 = 1525132800; uint256 public constant Start4 = 1527811200; uint256 public constant Start5 = 1530403200; uint256 public constant Start6 = 1533081600; uint256 public constant Start7 = 1535760000; uint256 public constant Start8 = 1538352000; uint256 public constant Start9 = 1541030400; uint256 public constant Start10= 1543622400; uint256 public constant End1 = 1522540799; uint256 public constant End2 = 1525132799; uint256 public constant End3 = 1527811199; uint256 public constant End4 = 1530403199; uint256 public constant End5 = 1533081599; uint256 public constant End6 = 1535759999; uint256 public constant End7 = 1538351940; uint256 public constant End8 = 1540943940; uint256 public constant End9 = 1543622340; uint256 public constant End10= 1546300740; address public owner; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; event Burn(address indexed from, uint256 value); function() public payable { buyTokens(); }",1
0x184001d794a8c91def72b8a488b67cc907d4e5be.sol,Ore,"contract Ore { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 25529833 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function Ore() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xebb060f9d0029082a04f78d84b9fb9d3d26f9a93.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf4d9f469297d7c6a8c3962aa04ab37d6cfa66ee7.sol,AdviserCasperToken,"contract AdviserCasperToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AdviserCasperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 440000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xd4191d6bcefb28cb2e6fc5d0ea48aab7860da523.sol,FCMCOIN,"contract FCMCOIN is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FCMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0xda0267fae25b4bfd53a1191ee1e864ecbdff92bb.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x55bec5649fbb5f5be831ee5b0f7a8a8f02b25144.sol,PuzzleGift,contract PuzzleGift { address prop = msg.sender; function()payable{},1
0x1b33bb74de3d15295fcd8ca3a777951f6a8f8fac.sol,WandaBroker,"contract WandaBroker is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WandaBroker() public { symbol = ; name = ; decimals = 18; _totalSupply = 888888888000000000000000000; balances[0x7127Eb5bB39807a4872b18eA694883634B39cd79] = _totalSupply; Transfer(address(0), 0x7127Eb5bB39807a4872b18eA694883634B39cd79, _totalSupply); }",1
0x1c5599ea81f4946a2ff80dc7438a8e139ee8c746.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function transfer(address _to, uint256 _value) public returns (bool) { if (balances[msg.sender] < _value) { throw; }",1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x017a5d8d82afaa22bc29d75013d6ff3656e90851.sol,ScamStampToken,contract ScamStampToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x6b775965ff81583429ee39f4f6a5fb6889ab61eb.sol,ZTKDIGITALTOKEN,"contract ZTKDIGITALTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZTKDIGITALTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xb6d8f913834B34BC5c997C63C597956E42dA405a] = _totalSupply; Transfer(address(0), 0xb6d8f913834B34BC5c997C63C597956E42dA405a, _totalSupply); }",1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x27eb46f50f1850be1fffa943822e00bb0377974a.sol,KittyClub99,contract KittyClub99 { string public name = ; string public symbol = ; uint256 public decimals = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 99; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonstersBase,"contract MonstersBase is MonsterAccessControl, MonstersData { event Transfer(address from, address to, uint256 tokenId); bool lockedMonsterCreator = false; MonsterAuction public monsterAuction; MonsterCreatorInterface public monsterCreator; function setMonsterCreatorAddress(address _address) external onlyAdmin { require(!lockedMonsterCreator); MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address); monsterCreator = candidateContract; lockedMonsterCreator = true; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x4d6993c02e6bbcbf6d6183c9b599b1d8c18c32d8.sol,MultiSend,"contract MultiSend { function multisend(address _tokenAddr, address[] dests, uint256[] values) returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,TokenRHT,"contract TokenRHT is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = true; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRHT() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x3fdd90ccdb7a430dac92580170a47f278322a9a0.sol,MDIVToken,"contract MDIVToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MDIVToken() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0xa149a7230cACE190905E9B50954471825C261021] = _totalSupply; emit Transfer(address(0), 0xa149a7230cACE190905E9B50954471825C261021, _totalSupply); }",1
0xf438e3a0c1bb9dc0ef6da672c97a282236d3f233.sol,HyperToken,"contract HyperToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HyperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x106B0Ab1922d0a8a44454d743A68EF936cc2F563] = _totalSupply; Transfer(address(0), 0x106B0Ab1922d0a8a44454d743A68EF936cc2F563, _totalSupply); }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0x48de9c6454d9da324d7908a6472ca4fb77a3e4fd.sol,LC,"contract LC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39fad5cdc35e46bb64598519e00c9419ce121c9d.sol,Bulletin,contract Bulletin { string public message = ; address public owner; function Bulletin(){ owner = msg.sender; },1
0x0ce6d5a093d4166237c7a9ff8e0553b0293214a1.sol,InfoBurnableToken,"contract InfoBurnableToken is BurnableToken, StandardToken { string message = ; address public manager; event NoFunds(address _who, string _message); modifier onlyManager() { require(msg.sender == manager); _; }",1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,WilliamJones,"contract WilliamJones is owned, PiToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WilliamJones( uint256 initialSupply, string tokenName, string tokenSymbol ) PiToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x4b3b99e956588b54f5841f2fb7c63721e6c7c392.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0xbf3f792573e6bee4aea45a8e3d6c8543c39c78b7.sol,CoinX,"contract CoinX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41f8d4d01ba8505111794e3fa3deb3ed8cbaa8ee.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 10; address public addressA = 0x82914CFc37c46fbbb830150cF2330B80DAADa2D5; function founder() private { owner = msg.sender; },1
0x28b213902cd539e09992f4cbea374952cba5eeed.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { tokenName = ; tokenSymbol = ; initialSupply = 1000000000 * 10 ** uint256(decimals); totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0dee19332fb83fb343a9fbb722b5395b8e7c9d8d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5bedf488d29407bc08e77cd9ee292c2041a61c8c.sol,UnKoin,contract UnKoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; bool public send_allowed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2dfb39072368a67b419e873d39848707b5234935.sol,SEEDWhitelist,contract SEEDWhitelist is Whitelist { mapping (address => bool) public admin; modifier onlyAdmin() { require(admin[msg.sender]); _; },1
0xbf74cc2839b4b639062e37b6ea53f3ed7964132c.sol,Announcement,contract Announcement { struct Message { string ipfsHash; uint256 timestamp; },1
0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00.sol,MSCE,"contract MSCE is Ownable, StandardToken, BurnableToken{ using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; uint256 unitCount = 100; uint256 unitTime = 1 days; uint256 lockTime = unitCount * unitTime; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; mapping (address => uint256) public lockAmount; mapping (address => uint256) public lockStartTime; mapping (address => uint256) public lockReleaseTime; event LockAmount(address _from, address _to, uint256 amount, uint256 releaseTime); event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0xda908dcf358351d79e5051a7118c9318f67fcfc9.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; string public version = ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,MilestoneCrowdsale,contract MilestoneCrowdsale is TimedCrowdsale { using SafeMath for uint256; uint256 public constant MAX_MILESTONE = 10; struct Milestone { uint256 index; uint256 startTime; uint256 tokensSold; uint256 cap; uint256 rate; },1
0x06fba879216e50fbc51e5b99cc264026a0152374.sol,LUCKen,contract LUCKen is Ownable{ address[] public bebdsds; uint256 _min; uint256 _max; tokenTransfer public bebTokenTransfer; function LUCKen(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0xf265534f967d29190c995314190aa2275f710af5.sol,MHT,"contract MHT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function MHT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x51fdc3827865af9bde006a2ad6d593d4aca5e591.sol,SafeMath,None,1
0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0x088674acdb4f6ac52fa46f8334955e34b00b0b36.sol,CCD_KOHLE_10_20190411,"contract CCD_KOHLE_10_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x17459fd5727e458829db77443531333b1fb93d6b.sol,BANK_IV_PFI_883,"contract BANK_IV_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 417212953933922000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1bd49ed82e56061a3cc72feeec729eb65cceb9d3.sol,HIROTOKEN,"contract HIROTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HIROTOKEN() public { symbol = ; name = ; decimals = 0; _totalSupply = 22222222222; balances[0x196D80D725d3F90246d7a44086bb2B883D8b0c84] = _totalSupply; Transfer(address(0), 0x196D80D725d3F90246d7a44086bb2B883D8b0c84, _totalSupply); }",1
0x2717ea295168058e783484dc0f3e35e25d6590df.sol,elenctraToken,"contract elenctraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function elenctraToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 15 weeks; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721Interface { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner); event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner); event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner); event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner); event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId); event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId); event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId); event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0xc59cb23295e2deeb66bd090acb6b02be8d30a11f.sol,Utils,contract Utils { function Utils() { },1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0eb29d27265d818dbbb395b7c9423f77aea70fa7.sol,COLOMBIA_WINS,"contract COLOMBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 476721916935210000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6ec2e2e2bd43d4deaa883533f80ea61682236073.sol,HACHIKO,"contract HACHIKO is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5b755b2130dab47636222ea33695c62bb54dc85d.sol,GoblinChainToken,"contract GoblinChainToken is ERC20Interface{ using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GoblinChainToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7000000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x4cd161743a3378aa4169cb5844ea422985342c05.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xd41d48be0a81690a785bf1df336163f7b78eadca.sol,Crypland,contract Crypland { struct Element {uint worth; uint level; uint cooldown;},1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x658fcbed32979cfbe6cd99da69dff23884cc0455.sol,CompanyToken,"contract CompanyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; uint256 public rate; bool public allow_buy; mapping(address => uint256) balances; event Transfer(address indexed from, address indexed to, uint256 value); event Mint(address indexed owner, uint256 value); event SetOwner(address indexed owner); event SetAllowBuy(bool allow_buy); event SetRate(uint256 rate); event CreateToken(address indexed sender, uint256 value); constructor() public { totalSupply = 2500000; name = ; symbol = ; decimals = 2; rate = 190; balances[msg.sender] = totalSupply; owner = msg.sender; allow_buy = false; }",1
0x205daf7cb272e436652115ecfb7df465631d80d0.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) public returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x03a2f2eb836fdd6ef462edc65bccd358ba1f2375.sol,BasicToken,"contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; struct WalletData { uint256 tokensAmount; uint256 freezedAmount; bool canFreezeTokens; }",1
0x6fff29dc8fbea3a6f202f993231030946571dbd4.sol,DAAC,contract DAAC is ERC20Interface { uint256 public constant decimals = 18; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 1000000000*(10 ** 18); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x6f9064180354a6773db5af7226a40614c8dbce39.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; for (i = 0; i < dests.length; i++) { ERC20(_tokenAddr).transfer(dests[i], values[i]); }",1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0xebafa3504fa15e481b45ab1ca8b75923d7570f5c.sol,ARGENTINA_WINS,"contract ARGENTINA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 127901002104568000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6c1a692ea7c92ae76cbfdda122830698c950f0ff.sol,CursedToken,contract CursedToken is ERC20 { string public symbol = ; string public name = ; uint8 public decimals = 0; uint public totalSupply = 0; address public owner = 0x55516b579E56C1287f0700eddDa352C2d2c5b3b6; address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CursedToken() public { },1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0xb3b476df77086b227d480c99b69b08a77631f2cf.sol,ICOSyndicate,"contract ICOSyndicate { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; uint256 public eth_cap = 30000 ether; address public developer = 0x91d97da49d3cD71B475F46d719241BD8bb6Af18f; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) public { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0x0f6029ebde2ecd9ab4d60dd5d0a297e9e59bf77a.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
0x2997ab37017123cbda1529adcdc591ed81d58255.sol,GIFTtoken,"contract GIFTtoken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 11; uint256 public initialSupply; function GIFTtoken () { totalSupply = 100000000 * 10 ** decimals; balances[0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, 0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF, totalSupply); }",1
0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x5acd19b9c91e596b1f062f18e3d02da7ed8d1e50.sol,BTClite,"contract BTClite is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant SUPPLY_CAP = 21000000 * (10 ** uint256(decimals)); address NULL_ADDRESS = address(0); event NoteChanged(string newNote); string public note = ; function setNote(string note_) public onlyOwner { note = note_; NoteChanged(note); }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x8ce188196892455fb131dea104bc3ba4e8516654.sol,VOCC_I026_20181211,"contract VOCC_I026_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,BlockHashRNG,contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; },1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0xec0dc71b3e5fc3f8ddfc655e800ae6d9b55f993f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0xf217d60e1f7ab5db57329032e07ce14a9d77a4ac.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2b6cb3e260fedcaa522f5b6d3c02b8716345d26d.sol,tokenDemo,"contract tokenDemo is owned{ string public name; string public symbol; uint8 public decimals=18; uint public totalSupply; uint public sellPrice=0.01 ether; uint public buyPrice=0.01 ether; mapping(address => uint) public balanceOf; mapping(address => bool) public frozenAccount; function tokenDemo( uint initialSupply, string _name, string _symbol, address centralMinter ) payable { if(centralMinter !=0){ owner=centralMinter; }",1
0x537c23b71d847eef947f150ac7e33b1854138d5c.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 50000 * 10 ** uint256(decimals); string public contract_link = ""https: mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { owner = 0xCD6011A9D3995A693F9964608D08EDbb48220225; balanceOf[owner] = totalSupply; }",1
0x6a0d52e162fa1994f25fef0cdc0a3c52efad3e6d.sol,CROWDWISDOM,"contract CROWDWISDOM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x84BF93D0ffadeaa3B3eb2400d5251c889eeA6326] = _totalSupply; emit Transfer(address(0), 0x84BF93D0ffadeaa3B3eb2400d5251c889eeA6326, _totalSupply); }",1
0x57db1c0f1c4c71919426c23e65be611fa9076b20.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x656610729fc13e8283d96aa69cdf56c112222951.sol,JeopardyJack,contract JeopardyJack { bytes32 private answerHash; uint private isActive; Guess[] public Guesses; string public Riddle; string public Answer; struct Guess { address player; string guess; },1
0x36cc5160e243f91157d8c14222f2ed5c52cf3d05.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xecd5214f25083fe68cb51d3fd693c09f7fde00d4.sol,CAC_2400_20180920,"contract CAC_2400_20180920 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 12597120000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4b44f450bc3bfb60dc1a0690cba028e1193cae4f.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xd0823c151d23678c6efe2b73b70aedf25be469fa.sol,AIOToken,"contract AIOToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIOToken() public { symbol = ; name = ; decimals = 18; totalSupply = 870000 * 10**uint(decimals); balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); bonusEnds = now + 3 weeks; endDate = now + 8 weeks; }",1
0xb3aac808b10eb65b74b59deb4f1998b52327bd1a.sol,InsightsNetwork1,contract InsightsNetwork1 { address public owner; address public successor; mapping (address => uint) public balances; mapping (address => uint) public unlockTimes; bool public active; uint256 _totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; function InsightsNetwork1() { owner = msg.sender; active = true; },1
0x7078b01170768c6db7bd9f515305682e52664cd3.sol,TariInvestment,"contract TariInvestment is Ownable { address public investmentAddress = 0x33eFC5120D99a63bdF990013ECaBbd6c900803CE; address public majorPartnerAddress = 0x8f0592bDCeE38774d93bC1fd2c97ee6540385356; address public minorPartnerAddress = 0xC787C3f6F75D7195361b64318CE019f90507f806; mapping(address => uint) public balances; uint totalInvestment; uint availableRefunds; uint refundingDeadline; enum State{Open, Closed, Refunding}",1
0x8c3cd81e8987e44b8d8702ed6d5791b346d0e1e5.sol,CryptoMemes,"contract CryptoMemes is ERC721 { event Transfer(address from, address to, uint256 tokenId); event Created(address owner, uint256 tokenId, string url, uint256 hash, uint256 createdAt); event UrlUpdated(address owner, uint256 tokenId, string url); modifier onlyOwnerOf(uint256 tokenId) { require(memeIndexToOwner[tokenId] == msg.sender); _; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x2612bb62eaa42991d12be0892c27040d4143e037.sol,ToknTalkToken,"contract ToknTalkToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; address public mintSigner = msg.sender; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public totalSupply = 0; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public mintedBy; function transfer(address to, uint amount) external returns (bool) { require(to != address(this)); require(to != 0); uint balanceOfMsgSender = balanceOf[msg.sender]; require(balanceOfMsgSender >= amount); balanceOf[msg.sender] = balanceOfMsgSender - amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; }",1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x41dc0d29ea75f603ad725b6b26fba39a477ac796.sol,AXNETToken,"contract AXNETToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AXNETToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0xdb2a6352362e9c23a563f4118b899ef8b6ab66f1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2ea313b7e47b79e82bd9a6e00364cd1bdf2355f5.sol,HamsterWarsToken,contract HamsterWarsToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6be9ad54d8ad5510d61690a7bd3823d0790c71b6.sol,IRAN_WINS,"contract IRAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5206357752953970000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x587be3718e68f144f6dade2e50f28af95dd4be7e.sol,Fast20,contract Fast20 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 20 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x1b05e6557768650c0df0c9377c32c621ac1ccf17.sol,NFTHouseGame,contract NFTHouseGame { struct Listing { uint startPrice; uint endPrice; uint startedAt; uint endsAt; bool isAvailable; },1
0xa524828a504da3486b70c7b07eb0a7d3a157ae56.sol,WineSpiritCoin,"contract WineSpiritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WineSpiritCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x0A4Eeec02eFAAF3964E0655DFF97b4f809240f9c] = _totalSupply; Transfer(address(0), 0x0A4Eeec02eFAAF3964E0655DFF97b4f809240f9c, _totalSupply); }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0x33c1aa1014e4ffd61c312671a42ecff8aef6201f.sol,IndividualLockableToken,"contract IndividualLockableToken is ERC20Pausable, Ownable{ using SafeMath for uint256; event LockTimeSetted(address indexed holder, uint256 old_release_time, uint256 new_release_time); event Locked(address indexed holder, uint256 locked_balance_change, uint256 total_locked_balance, uint256 release_time); struct lockState { uint256 locked_balance; uint256 release_time; }",1
0x2eac4037a8df73f7ddde34b8153c16ded607ff8b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x3633c61be0dd1b1fd20a97e05c5ed880a204de33.sol,EtherTeam,"contract EtherTeam is Ownable,PyramidEvents{ using SafeMath for uint; address private wallet1; address private wallet2; uint public startAtBlockNumber; uint public curBubbleNumber= 1000; bool public gameOpened=false; uint public totalPlayers=0; mapping(address=>uint) playerRefCode; mapping(uint=>address) playerRefxAddr; mapping(uint=>uint) parentRefCode; mapping(uint=>uint) numOfBubblesL1; mapping(uint=>uint) numOfBubblesL2; mapping(uint=>uint) numOfBubblesL3; mapping(address=>uint) playerRewards; mapping(uint=>uint) referees; uint gameRound=1; mapping(uint=>address) roundxAddr; mapping(uint=>uint) roundxRefCode; constructor(address _addr1,address _addr2)public { wallet1=_addr1; wallet2=_addr2; startAtBlockNumber = block.number+633; }",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xde522a2778e4554707e6a8df36a4871ce9967bb5.sol,FML,"contract FML { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FML() public { totalSupply = 2100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0e6664cdb81ddf20d776b3bcb001797cee4030bc.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x0022ee765799c1f836a36612b8c62be098fd0bbb.sol,SOCGEN_301201,"contract SOCGEN_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10780817168445100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0da76de0916ef2da3c58a97e4d09d501c56a9f15.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xbc5e7120e1e917c6ba34e94b3a29016f64bbd2c1.sol,RocketCash,contract RocketCash { uint constant public start = 1541678400; address constant public administrationFund = 0x97a121027a529B96f1a71135457Ab8e353060811; mapping (address => uint) public invested; mapping (address => uint) private lastInvestmentTime; mapping (address => uint) private collected; mapping (address => Refer[]) public referrers; mapping (address => Refer[]) public referrals; uint public investedTotal; uint public investorsCount; struct Refer { address investor; uint time; uint amount; uint percent; },1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x72acaab5b211b9a69bf71f4a6bb1f56546451509.sol,GlobalCapitalGroup,"contract GlobalCapitalGroup { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xaa4ec8484e89bed69570825688789589d38eea5e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1eeeaffe28d463dcf2c1898d19cf3871e9a17d7c.sol,MultiTransfer,"contract MultiTransfer is MultiOwnable { function MultiTransaction(address _tokenAddress, address[] _addresses, uint256[] _values) public onlyOwner { SNOVToken token = SNOVToken(_tokenAddress); for (uint256 i = 0; i < _addresses.length; i++) { token.transfer(_addresses[i], _values[i]); }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0x283144fc0ff045d5aebf509ad6914459d77f04ea.sol,VOCC_I053_20181211,"contract VOCC_I053_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28daa51dc3d80a951af9c451d174f0c7156c6876.sol,EtherShareReward,contract EtherShareReward { EtherShare ES = EtherShare(0xc86bdf9661c62646194ef29b1b8f5fe226e8c97e); struct oneReward { address from; uint value; },1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x0cfae4866c11cf6194d787cf76d479e28a7cc577.sol,FundariaToken,"contract FundariaToken { string public constant name = ; string public constant symbol = ; uint public totalSupply; uint public supplyLimit; uint public course; mapping(address=>uint256) public balanceOf; mapping(address=>mapping(address=>uint256)) public allowance; mapping(address=>bool) public allowedAddresses; address public fundariaPoolAddress; address creator; event SuppliedTo(address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event SupplyLimitChanged(uint newLimit, uint oldLimit); event AllowedAddressAdded(address _address); event CourseChanged(uint newCourse, uint oldCourse); function FundariaToken() { allowedAddresses[msg.sender] = true; creator = msg.sender; }",1
0xdbe46c0e6526e9068da1626acfddff2386635045.sol,PumpToken,contract PumpToken { address owner = msg.sender; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() pure returns (string) { return ; },1
0xcf5229653f1badd37ccedd1f96f6171715f28673.sol,TMCToken,"contract TMCToken is Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TMCToken (uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44a1b86ffa821bcadb636a4493aa50d5ab0ddf4a.sol,GoodDayToken,"contract GoodDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GoodDayToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 12 weeks; }",1
0xaa746780d844379ae5ef9f9f7daceb59ba6fde57.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x19055b944806fba2717dc694cf0173a1eb2d1604.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x57c09a8de0b0f471f8567609777addffb5c46a08.sol,BitexGlobalXBXCoin,"contract BitexGlobalXBXCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public lockAmount; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event eventForAllTxn(address indexed from, address indexed to, uint256 value, string eventName, string platformTxId); constructor ( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, string plaformTxId ) public { totalSupply = initialSupply; balanceOf[msg.sender] = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; emit eventForAllTxn(msg.sender, msg.sender, totalSupply,, plaformTxId); }",1
0xdaf6fc57f9f415401f55632afb50c47f60a404fc.sol,BANK_III_PFII_883,"contract BANK_III_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 429287043125237000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x77140fd91053d4613407d5253d3151e717d211fc.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x332124f226e80c3afdbb59271f550881b20604a1.sol,PlazaToken,"contract PlazaToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PlazaToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x263c618480dbe35c300d8d5ecda19bbb986acaed.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TOURISTOKEN { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol )MyAdvancedToken(initialSupply, tokenName, tokenSymbol) public {}",1
0xeecdfead2d05f0708450db0ddd65cd513a9b1eea.sol,DiscoverToken,"contract DiscoverToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000; balances[0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817] = _totalSupply; emit Transfer(address(0), 0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817, _totalSupply); }",1
0xf265b27c698f9687ed04876e2f99d8be45ecdc57.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x48910bceb950d7b3a3f0a7e963c752a15d4c80fc.sol,token,"contract token is owned{ string public name; string public symbol; uint8 public decimals = 10; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01aec44dd1be1bf86f4fe4f768fc8fd46008b166.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf40b7341cb564b506af7cd3788331b55621aabab.sol,TokenIAET,"contract TokenIAET { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf45a3bbe486779250961c9f2da73651deb90406a.sol,Distribute,"contract Distribute is Owned { mapping (address => uint) public tokensOwed; ERC20Basic token; event AmountSet(address contributor, uint amount); event AmountSent(address contributor, uint amount); function Distribute(address _token) public { token = ERC20Basic(_token); }",1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x9283df9554419641f2cab66af4876f9de8526e4c.sol,KikkeliToken,contract KikkeliToken is MintableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; bool public transfersEnabled = false; event TransfersEnabled(); modifier whenTransfersEnabled() { require(transfersEnabled); _; },1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x1fd159fa190ab588f60699ef6def984602dd8c5b.sol,HAPYToken,"contract HAPYToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HAPYToken() public { totalSupply = 2999999999 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf528d0e1e11edee40ca3724bd9fd923bb0235cc3.sol,TGCToken,"contract TGCToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 10, 0 ]; uint public constant NUM_OF_PHASE = 3; uint16 public constant BLOCKS_PER_PHASE = 29000; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 3000 ether; uint256 public constant HARD_CAP = 4500 ether; uint256 public constant BASE_RATE = 10000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x6c44134ab77bd7b90907d2b9745c628caae077d6.sol,BTC,"contract BTC is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BTC( ) TokenERC20() public {}",1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4488ed050cd13ccfe0b0fcf3d168216830142775.sol,NetkillerAdvancedTokenAirDrop,"contract NetkillerAdvancedTokenAirDrop { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false; bool public airdropStatus = false; uint256 public airdropTotalSupply; uint256 public airdropCurrentTotal; uint256 public airdropAmount; mapping(address => bool) public touched; event AirDrop(address indexed target, uint256 value); function NetkillerAdvancedTokenAirDrop( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; airdropAmount = 1 * 10 ** uint256(decimals); }",1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x1789cca7430aacbdb7c89f9b5695a9c06e4764eb.sol,Custodian,contract Custodian { struct Request { bytes32 lockId; bytes4 callbackSelector; address callbackAddress; uint256 idx; uint256 timestamp; bool extended; },1
0x55e539fb53394851e8c541411d31c942b14b998e.sol,URUGUAY_WINS,"contract URUGUAY_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 325566187175265000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x9251efccb139465204e3d6e3269a73b212f24a5f.sol,Pob,contract Pob{ using SafeMath for *; struct BetItem{ uint256 id; uint256 betCount; },1
0x0313f9c5fa5338bc00e416ceae577038e5fa3e28.sol,FilmFinsCoin,"contract FilmFinsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 132300000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa322e495e36c18cc888e445fc09fba88e5ce164e.sol,NEBC,"contract NEBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NEBC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x7880ddfa13218bae0a42ea56902de21ff29a82ce.sol,BlockGame,"contract BlockGame is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BlockGame() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB] = _totalSupply; Transfer(address(0), 0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB, _totalSupply); }",1
0x30169203b76ff6a1879983efe66a65c31fa7758e.sol,EternalMultiplier,contract EternalMultiplier { struct Deposit { address depositor; uint deposit; uint payout; },1
0x316ee6b10479576e908e5272458c789c3f4d2a47.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x3796a3e6fcf1b3a74d00b9e8fb31f07ed04a7937.sol,SPAIN_WINS,"contract SPAIN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 78484705836894400000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x292e8030f21039cdbbfb797d547f57e0a031075a.sol,TmrChainERC20,"contract TmrChainERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TmrChainERC20() public { totalSupply =1000000000000000; balanceOf[msg.sender] = 1000000000000000; name = ; symbol = ; }",1
0x20a35ada16321d18ba2e72bd5fe81bc23515dbd9.sol,ProofOfVerifiedContract,contract ProofOfVerifiedContract { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x8470c0012ebd1201641620df2ac8600a402725b1.sol,MerialCoin,"contract MerialCoin { using SafeMath for uint256; string public symbol; string public name; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAddress; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenAddress(address indexed target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor () public { name = ; symbol = ; decimals = 18; totalSupply = 1000000000 * 10 ** uint256(decimals); owner = msg.sender; balanceOf[msg.sender] = totalSupply; }",1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0xde6c1dd8404827149f6edc09e50476aa0cd7b4ab.sol,SRX,"contract SRX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRX( ) public { totalSupply = 100000000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000000; name = ; symbol = ; }",1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0x377dfa7bab23a798ca1fa0923bcd4d4ef2184d85.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0xc7b62900c4860bc20f8561ee53d9a888b2ee411b.sol,BinanceGold,"contract BinanceGold { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 766575559732 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x059accb493f5a47dc97cc0443aeec8a3fd2591c1.sol,TRXT,"contract TRXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRXT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x175814180bd4999b1b9339f8a8820675bb55fb86.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa212156581b12d6b4f953da0f898af9fb62db72f.sol,MSERToken,"contract MSERToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0xf2e449491975e376342586dd1229da20c969a39d.sol,CrisCoin,"contract CrisCoin { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; address public owner; uint256 public constant RATE = 1000; uint256 initialSupply = 100000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CrisCoin() public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf35470b6182cbd9a0f0c01d8f491b18445707c7d.sol,ERC827Caller,"contract ERC827Caller { function makeCall(address _target, bytes _data) external payable returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x508f36baac673fe9e213e69f0f75cbcfeb015917.sol,MKT,"contract MKT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MKT ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0x47df2f172d2f387a602a85adff876a8ef535cf62.sol,TicketsCoin,"contract TicketsCoin { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 7665755597320 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x25c08bb7aa204d221288d9739899f4edf96f5fba.sol,PornTokenV2Crowdsale,"contract PornTokenV2Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint private currentBalance; uint public deadline; uint public price; uint public initialTokenAmount; uint public currentTokenAmount; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); function PornTokenV2Crowdsale( address sendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward ) { beneficiary = sendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = 13370000000000; initialTokenAmount = 747943160; currentTokenAmount = 747943160; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0xc4ff0412050fafbd9e697b1931a23ea41f4cb26f.sol,token1234,contract token1234 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token1234() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0xde3ad37d806309761210c18704dc1a3faada4aa9.sol,DUBAI_Portfolio_Ib_883,"contract DUBAI_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 728002043355369000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2e0ed230795f1bd24996f82c76b7bd0d86120e34.sol,AssetNotary,"contract AssetNotary is TimestampNotary, LinkedToken { using SafeMath for uint256; bytes8[] private _assetList; mapping (bytes8 => uint8) private _assetDecimals; mapping (bytes8 => uint256) private _assetBalances; event AssetBalanceUpdate( bytes8 indexed assetId, uint256 balance ); function registerAsset(bytes8 assetId, uint8 decimals) public onlyOperator returns (bool) { require(decimals > 0); require(decimals <= 32); _assetDecimals[assetId] = decimals; _assetList.push(assetId); return true; }",1
0x1b2ced22e089d752d2c27e90d95599a7a9699774.sol,DappsGallery,contract DappsGallery is ERC721Token { string[] public dns; mapping (string=>Redirect) redirects; struct Redirect { string uri; bool registered; },1
0x64d5e7be2e92d4436ba9c4a630491cb268764103.sol,funds,contract funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9a1488a97840653a0be4a4aed50ecf6137507b7c798a86604f31e3199852668c; constructor() public { owner = msg.sender; },1
0xd0ffe3496101fd676b646ade429653d7df12edd2.sol,ContractEFT,contract ContractEFT is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = formatDecimals(500000000000); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; },1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x5ba983231b4bb509f0f25e97fa22e20d71c5d44c.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken() TokenERC20(0, , ) public { sellPrice = (uint256(10) ** decimals) / 110000000; buyPrice = (uint256(10) ** decimals) / 110000; }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2a062a343b53bb8fcee929d50f14ce4b418f455b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x2a062a343b53bb8fcee929d50f14ce4b418f455b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x7123027d76a5135e66b3a365efaba2b55de18a62.sol,CrypteloERC20,"contract CrypteloERC20 { string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; uint256 public totalSupplyICO; uint256 public totalSupplyPrivateSale; uint256 public totalSupplyTeamTokens; uint256 public totalSupplyExpansionTokens; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Supply(uint256 supply); function CrypteloERC20() public { name = ; symbol = ; decimals = 8; totalSupply = 500000000; totalSupplyICO = 150000000; totalSupplyPrivateSale = 100000000; totalSupplyTeamTokens = 125000000; totalSupplyExpansionTokens = 125000000; address privateW = 0xb3d9c613a4B680A5Ffd28E08258dBd7BA77102A2; address ICOW = 0xF2b3Fc7196D5Ec9bD9111AF5B6D79c9FE26d729F; address companyW = 0xeC23f509E328100C08646389a3b6C45e9290AA42; address expansionW = 0xf799aa9cA15D6137eDAEb204016378112064ECa3; balanceOf[ICOW] = totalSupplyICO * ( 10 ** decimals); balanceOf[privateW] = totalSupplyPrivateSale * ( 10 ** decimals); balanceOf[companyW] = totalSupplyTeamTokens * ( 10 ** decimals); balanceOf[expansionW] = totalSupplyExpansionTokens * ( 10 ** decimals); Supply(totalSupplyICO * ( 10 ** decimals)); }",1
0x5cc0076a6bbf43344a7923c5cca40f5bdff2970e.sol,LiteToken,"contract LiteToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LiteToken() public { symbol = ; name = ; decimals = 4; _totalSupply = 84000000000000; balances[0x186d32c30f1DeFfF1eeDb34Ee661426918243545] = _totalSupply; emit Transfer(address(0), 0x186d32c30f1DeFfF1eeDb34Ee661426918243545, _totalSupply); }",1
0x1be2770c2cfc85834c8c0fa55c0705c4a22b3cf9.sol,GMBAirdrop,"contract GMBAirdrop is Ownable { function multisend(address[] to, uint256[] value) onlyOwner returns (uint256) { address tokenAddr = 0x1B148b90442826375e864B71165A18B4D9256097; uint256 i = 0; while (i < to.length) { ERC20(tokenAddr).transfer(to[i], value[i] * ( 10 ** 18 )); i++; }",1
0x57cff17810be242bc4760c03cd5bcc6ec0879470.sol,POWMlite,contract POWMlite { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6c49802f7a55e22c2cd689c97b9ee6341d73d153.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x86b300ef935284a99fa5d148a9a6ccc5103b21a8.sol,CryptoDashtoken,"contract CryptoDashtoken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000000; balances[0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761] = _totalSupply; emit Transfer(address(0), 0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761, _totalSupply); }",1
0xc8035ea3580d5dd63b7535c26687fe18f8284e2f.sol,Rapide,"contract Rapide { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Rapide( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xda908dcf358351d79e5051a7118c9318f67fcfc9.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; string public version = ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d8f2ffb3a314d8f353779873b13f0a23c11496c.sol,FDFToken,"contract FDFToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3 * 1000 * 1000 * 1000 * 10 ** decimals; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FDFToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x4efd3bf84f40eda370e52df162eccc394cfc8834.sol,Zhoan,"contract Zhoan { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; address private admin_add; uint private present_money=0; event Transfer(address indexed from, address indexed to, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowances; constructor(uint256 limit,string token_name,string token_symbol,uint8 token_decimals) public { admin_add=msg.sender; name=token_name; symbol=token_symbol; totalSupply=limit * 10 ** uint256(decimals); decimals=token_decimals; balanceOf[admin_add]=totalSupply; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Registry,contract Registry is Ownable { bool opened; string[] identifiers; mapping(string => address) registrantOfIdentifier; mapping(string => uint[]) versionsOfIdentifier; mapping(string => mapping(uint => Template)) templateOfVersionOfIdentifier; constructor(bool _opened) Ownable() public { opened = _opened; },1
0x8495332b80411cf5114b6c3ecc81deeb65b3951d.sol,SUPERBANK,contract SUPERBANK{ mapping (address => uint256) invested; mapping (address => uint256) dateInvest; uint constant public FEE = 1; uint constant public ADMIN_FEE = 8; uint constant public REFERRER_FEE = 11; address private adminAddr; constructor() public{ adminAddr = msg.sender; },1
0x5aa8d6de8cbf23dac734e6f904b93bd056b15b81.sol,SenbitTokenVision,"contract SenbitTokenVision{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function SenbitTokenVision() public{ balanceOf[msg.sender] = 300000000 * (10**18); totalSupply = 300000000 * (10**18); name = ; symbol = ; decimals = 18; }",1
0x9c49b65ddef30ad4a32c0ff6bf103144cd7733fc.sol,Sports3D,contract Sports3D { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,SimpleMarket,"contract SimpleMarket is owned, WithdrawalContract { uint public startPrice; uint public fixPrice = 0.1 ether; uint internal decimals = 0; bytes32 public productId = 0x0; struct UserStruct { uint userListPointer; bytes32[] productKeys; bytes32 userEmail; bytes32 userName; mapping(bytes32 => uint) productKeyPointers; }",1
0xf4e3a095e2cad145793ec0f9fb5500e260514065.sol,FRANCE_WINS,"contract FRANCE_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 92352243954837600000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x36efee477f68c136139abeb219be6c2254711d0a.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0xee278a3543afbe4c1639b430774537995c6bd995.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=36300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x01b90ee8249afdf628f738af4a2a8ffd7b8434ed.sol,DMC,"contract DMC { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xd82f9939aa0ba1bf5d5bbade54b5f2f61d2cfdbe.sol,NEWT,"contract NEWT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NEWT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x405003a880bffd30d2df5ce590f94517578dbfc3.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0x083802265C0585A788df3C890fbb17D5362502b2); constructor() public { owner = msg.sender; },1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0x6cdccb2b249298419ab3dea261a92fbacf2223ab.sol,BountyEscrow,"contract BountyEscrow { address public admin; mapping(address => bool) public authorizations; event Bounty( address indexed sender, uint256 indexed amount ); event Payout( uint256 indexed id, bool indexed success ); function BountyEscrow() public { admin = msg.sender; }",1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x36f0deb0af8ab453b6b4fcc8b0b7fe2f1b44e55f.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x5b63b8d11ce8e45894b66f876dca321b8a735da2.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) public pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x281f5b914b0d589f8193cd5e711c6920874e00c8.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 640000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x73f46f17b1a9712262dc3410b37eae4233f36ff9.sol,NeutralToken,contract NeutralToken { function isSenderOwner(address sender) private view returns (bool) { return sender == owner_; },1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x7045c5c158aecd68eed18671cc8775fc7f7d6e70.sol,DHCToken,contract DHCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 40000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0xd9d42c6d1ebf9083d9514e5ae5f53cd627708c12.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x47b56408263cf1f9bdb93b930bf01c6c5935ebb4.sol,ERC20,"contract ERC20Interface { string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x39f968b4b8b367ce20f5aefc852591f7eada4b3e.sol,Administration,"contract Administration is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Administration() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000000000000000000000; balances[0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c] = _totalSupply; Transfer(address(0), 0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c, _totalSupply); }",1
0x86b300ef935284a99fa5d148a9a6ccc5103b21a8.sol,CryptoDashtoken,"contract CryptoDashtoken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000000; balances[0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761] = _totalSupply; emit Transfer(address(0), 0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761, _totalSupply); }",1
0x54dd71cac082ac6fcfeb727c5bbb0a07be1c5de9.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; winnerAddress = 0xFb2D26b0caa4C331bd0e101460ec9dbE0A4783A4; admins[contractCreator] = true; },1
0x841b42c7ee6a15904d1926bf15ffdb6d30a77723.sol,GDC,"contract GDC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GDC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd1b4fdf2fdeb790df015bf0b74bf43253b9ac2da.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xed462f6d5a89cc5cab505c0549c2a4e7bbd2522b.sol,EVOLUTION2,contract EVOLUTION2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRT,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x02f2d4a04e6e01ace88bd2cd632875543b2ef577.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x28cb4e001f87dacd8e97250e1312008668bd78a8.sol,multi_user_wallet,contract multi_user_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xcdbb6bf672a7088809e37cb8ce69daed19bf9761445769788e2a2668c46ff036; constructor() public { owner = msg.sender; },1
0x711256406c2e9072fbaee5b67d5a893f66a3e707.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); address public ELIX_ADDRESS; uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x20d2f8fdd0951f2f5249c86b3cdc2be7656f2c01.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public _balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { _totalSupply = 0 * 10 ** uint256(decimals); _balanceOf[msg.sender] = _totalSupply; name = ; symbol = ; }",1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3066d8ce545ddf5dc758d261470f9575365999a.sol,TBC,"contract TBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() { totalSupply = 500000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc5e1510dfb5942f0af172af9c3ef3eef46e945c2.sol,TMRToken,"contract TMRToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TMRToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 600000000000000000000000000; balances[0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01] = _totalSupply; Transfer(address(0), 0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01, _totalSupply); }",1
0x77fa1d1ded3f4bed737e9ae870a6f3605445df9c.sol,CryptoPokemon,contract CryptoPokemon { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address devFeeAddress; address tournamentPrizeAddress; function CryptoPokemon () public { contractCreator = msg.sender; devFeeAddress = 0xFb2D26b0caa4C331bd0e101460ec9dbE0A4783A4; tournamentPrizeAddress = 0xC6784e712229087fC91E0c77fcCb6b2F1fDE2Dc2; admins[contractCreator] = true; },1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRTokenERC20,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0xf13297aebfe157c4412e59363351779e60ec6b86.sol,GRAM,"contract GRAM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 12000000000000000; balances[0xEdf54a2ED7337410B8e367B4023C76134b3e801a] = _totalSupply; emit Transfer(address(0), 0xEdf54a2ED7337410B8e367B4023C76134b3e801a, _totalSupply); }",1
0x51036b0029e95ecbce4784df0a87987d1092ec7d.sol,StandardToken,contract StandardToken is Token { modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; },1
0x6f60914be8e1aa413c981926e9edf3e5603d3f46.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5aa24fb102c6b7b13ba353922746223348a4a8b3.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x32e730afe4332bf98902ea59c3d003e81b5c7c69.sol,TokenERC20AC,"contract TokenERC20AC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20AC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27945afcdea13201263bfe8c71d2e8fdffd35ff7.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 public trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping (address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0xeb86dfc14848b56955051cfd9d696bafde1d6027.sol,StoreGift,contract StoreGift is BasicAuth { struct Gift { string m_Key; uint m_Expire; uint32[] m_ItemIdxList; uint[] m_ItemNumlist; },1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x417ecbab65f29e462a58b6f0516c8e8d5254016b.sol,Airdrop,"contract Airdrop is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x4bb12d68c795462c12ec30ad82421218d9c32a7d.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; uint public percent; mapping(address => uint256) public percentOf; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); event RewardToken(address backer, uint amount, uint percent); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint weiCostOfEachToken, address addressOfTokenUsedAsReward, uint initPercent ) { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = weiCostOfEachToken * 1 wei; tokenReward = token(addressOfTokenUsedAsReward); percent = initPercent; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x4bb71389943242be7e08b61c00175a8f0e8cabb4.sol,TwoAfrica,"contract TwoAfrica is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TwoAfrica( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x00762964227f2db1b8c811db1672c97b0ed47946.sol,PORTUGAL_WINS,"contract PORTUGAL_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 290684095692201000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint256 value; bytes data; bytes4 sig; },1
0x8ae546782bd5c25715afaffb028ce9ee2cbe7bec.sol,NSCDistributionContract,"contract NSCDistributionContract is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _initialDistribution; uint private _totalSupply; uint256 public unitsOneEthCanBuy; uint256 private totalEthInWei; address private fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NSCDistributionContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); _initialDistribution = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 692; fundsWallet = msg.sender; }",1
0x579fa0a1872459138aad423644c9c5038fa31807.sol,EOMarketToken,"contract EOMarketToken is AccessService { uint8 public decimals = 0; uint256 public totalSupply = 100; uint256 public totalSold = 0; string public name = ; string public symbol = ; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; address[] shareholders; mapping (address => uint256) addressToIndex; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EOMarketToken() public { addrAdmin = msg.sender; addrService = msg.sender; addrFinance = msg.sender; balances[this] = totalSupply; }",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x81b4d08645da11374a03749ab170836e4e539767.sol,NewToken,contract NewToken { function NewToken() { totalSupply = 1000000000000000000; name = ; decimals = 9; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xb39b66a7273b83bca1f2f618672302485b391f92.sol,ANHUI_ANNUITY_DAO_33_c,"contract ANHUI_ANNUITY_DAO_33_c { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd6310735586f09cf1cb6485f234b3534579706af.sol,BitMaxProToken,"contract BitMaxProToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0x37aa63c4cbd06a57f1ea35bceee4e46f0a7ce924.sol,SafeMath,None,1
0x0dee19332fb83fb343a9fbb722b5395b8e7c9d8d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6c00afe8618feb85095b2c4c3c27441b22db2d12.sol,CNKTToken,"contract CNKTToken is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function CNKTToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33201831496217a779bf6169038dd9232771f179.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x501c17b26029f3a129fd9adeb4b642bd35a35248.sol,SolClub,"contract SolClub is Ownable, DetailedERC20(, , 0) { using SafeMath for uint256; using SafeMath64 for uint64; struct Member { bytes20 username; uint64 karma; uint16 canWithdrawPeriod; uint16 birthPeriod; }",1
0xc040d0af51f34221b5f96b65d916ff176361fae1.sol,Token,"contract Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Token() public { symbol = ; name = ; decimals = 4; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0x6fa8b7532cae4e8feedadfb4a757a43ae5243165.sol,BING,"contract BING is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BING( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x57c09a8de0b0f471f8567609777addffb5c46a08.sol,BitexGlobalXBXCoin,"contract BitexGlobalXBXCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public lockAmount; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event eventForAllTxn(address indexed from, address indexed to, uint256 value, string eventName, string platformTxId); constructor ( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, string plaformTxId ) public { totalSupply = initialSupply; balanceOf[msg.sender] = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; emit eventForAllTxn(msg.sender, msg.sender, totalSupply,, plaformTxId); }",1
0x657ccd6a9816a49da1bce76ff5245de29ce73807.sol,Lambo,contract Lambo { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0x21929a10fb3d093bbd1042626be5bf34d401babc.sol,EFTToken,"contract EFTToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EFTToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x707bd951c676c5f7a957df363d6ce1b2af4b636d.sol,ANOToken,"contract ANOToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 21000000000 * 10**18; uint256 public tokensAllocatedToCrowdFund; uint256 public totalAllocatedTokens; address public crowdFundAddress; address public founderMultiSigAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier onlyCrowdFundAddress() { require(msg.sender == crowdFundAddress); _; }",1
0xc48e4349d482296c32bb7ca430466f324c694d34.sol,RozowkaCoin,"contract RozowkaCoin { string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RozowkaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000000; name = ; symbol = ; }",1
0xd5670cdb0d6e6d9eedfdbaceb97d5774466f0b23.sol,Owned,contract Owned { address public ceoAddress; address public cooAddress; address private newCeoAddress; address private newCooAddress; function Owned() public { ceoAddress = msg.sender; cooAddress = msg.sender; },1
0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0xbd677963d9bc990ee8fb7de06e1a63bf6850c2d1.sol,castrol,"contract castrol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function castrol() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0xa5763bf433f2f154b798b924fb2f6c54137b3522.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x262e1acb79822bfd711f04aa80d08b629ecdb299.sol,StopLoss,"contract StopLoss is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StopLoss() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x0667F1b5000fca448C3E3FdebA796616797c4DC9] = _totalSupply; Transfer(address(0), 0x0667F1b5000fca448C3E3FdebA796616797c4DC9, _totalSupply); }",1
0xa2310206fd3fff0b66e03407eb03ed1ada4acecc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); _balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cb1c2b61e24ad08bf5fff4d2b13ea987d211a88.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf003e8c65a28a445e0318e83416567336fb1c667.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x5b0462bb50a0c4b051e26a01689f45f6ed0ffaab.sol,ERC20BatchTransfer,"contract ERC20BatchTransfer { function batchTransfer(address _tokenAddress, address[] _beneficiaries, uint256 _amount) public { require(_amount > 0); ERC20 tokenContract = ERC20(_tokenAddress); for (uint b = 0; b < _beneficiaries.length; b++) { require(tokenContract.transferFrom(msg.sender, _beneficiaries[b], _amount)); }",1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0x0217495d71d7246205bc1b1039dad814d0c0c192.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc.sol,UbiatarPlay,contract UbiatarPlay is ERC20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x6cbb5b731a6b0e03551e24b8a02e101d293e418e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xdc7109afb8a3cc28f2429bf4a35f959a567a2610.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x3ff283f4b333f0c046dea47938a413a2bae56bf5.sol,FantasySportsCoin,"contract FantasySportsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantasySportsCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0] = _totalSupply; Transfer(address(0), 0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0, _totalSupply); }",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x74b0e3d730f82fc410986c1f18480ede1e256e6e.sol,GlobaleCash,"contract GlobaleCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GlobaleCash() public { symbol = ; name = ; decimals = 0; _totalSupply = 60000000; balances[0x7C86D15F158ad52FBC7B0206995731a309E3CCE0] = _totalSupply; Transfer(address(0), 0x7C86D15F158ad52FBC7B0206995731a309E3CCE0, _totalSupply); }",1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0xf297a0806f24dbc96794af54c8c3691874c430f4.sol,ForestEcosphere,"contract ForestEcosphere { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5b8ad60798ec10ad36e52625ff881801240c491a.sol,P4,contract P4 is Ownable { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf3e6264475f63d771ca562a5176fb9a9b79acd67.sol,Celer,"contract Celer is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Celer() public { symbol = ; name = ; decimals = 8; _totalSupply = 90000000000000000; balances[0x19532C1A9588ec51fc0EB54467E08233636b1a91] = _totalSupply; emit Transfer(address(0), 0x19532C1A9588ec51fc0EB54467E08233636b1a91, _totalSupply); }",1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0x6c00afe8618feb85095b2c4c3c27441b22db2d12.sol,CNKTToken,"contract CNKTToken is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function CNKTToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,PPNToken,contract PPNTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function PPNTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xceedf087d386109ff18dd38b0684efb0355a13e8.sol,EthereumMobile,"contract EthereumMobile { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x20bcae16a8ba95d8e8363e265de4ecfc36ec5cd9.sol,HEYBITCOIN,"contract HEYBITCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HEYBITCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 2311000000000000000000000000; balances[0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384] = _totalSupply; Transfer(address(0), 0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384, _totalSupply); }",1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,Freedom,contract Freedom is ERC20Contract { using SafeMath for uint256; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; string public constant tokenName = ; string public constant tokenSymbol = ; uint256 public totalSupply = 1000000000e8; uint8 public decimals = 8; constructor () public { balanceOf[msg.sender] = totalSupply; totalSupply = totalSupply; decimals = decimals; },1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0xeb0c680b2e42685bc836922d416dfd836704ab09.sol,ARWToken,"contract ARWToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ARWToken() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x37f0137cb24c315d4f725473697e558d6ccaffaa.sol,CROATIA_WINS,"contract CROATIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 360448278658330000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa5d1eb8bbb42b7f2ebbebf174b3966510243f30c.sol,TokenCreation,"contract TokenCreation is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public freezeOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor( string tokenSymbol, string tokenName, uint256 tokenSupply ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = 18; totalSupply = tokenSupply * (10 ** 18); balanceOf[0x94eE12284824C91dB533d4745cD02098d7284460] = SafeMath.safeDiv(totalSupply, 10); balanceOf[0xfaDB28B22b1b5579f877c78098948529175F81Eb] = SafeMath.safeSub(totalSupply, SafeMath.safeDiv(totalSupply, 10)); }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x51d9e05775bde1b3c12d781d2f847b1ab93e3c3d.sol,EthAnte,contract EthAnte { uint public timeOut; uint public feeRate; address public TechnicalRise = 0x7c0Bf55bAb08B4C1eBac3FC115C394a739c62538; address public lastBidder; function EthAnte() public payable { lastBidder = msg.sender; timeOut = now + 1 hours; feeRate = 10; },1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x78477a3683980a31f86fa09e176f90b80fffda00.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa2651bfa1d613fea0f7a3138e442e4ee865b5ec7.sol,AdsVenture,contract AdsVenture is Owned{ struct User{ string username; uint balance; },1
0x1b528346f0631dc465813a757eaf38035b44b9e4.sol,KCBToken,"contract KCBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KCBToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0x1899924f87138cd0607e27c516a84bc839faa1a4.sol,TokenCreator,"contract TokenCreator { event TokenCreated(address indexed owner, address token); function createToken (string _name, string _symbol, uint8 _decimals) public { emit TokenCreated(msg.sender, new MyToken(_name, _symbol, _decimals, msg.sender)); }",1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x5870a119fccc91a46426ed1d4f12f8384f372e93.sol,TEG,"contract TEG{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TEG() public { balances[msg.sender] = 1600000000000; totalSupply = 1600000000000; name = ; decimals =4; symbol = ; }",1
0x70965361f143d268342c84b4d6f7c41b438cd5d7.sol,LuckcoinContract,"contract LuckcoinContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public LKCExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintLKCToken(msg.sender, (msg.value * LKCExchangeRate * 10**decimals) / etherChange); }",1
0xdcac1e6732cb951282e1cfc18b26adb5d1f995e2.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1fd1f34a7476fa7d7b2187c8bd255e39e78271e6.sol,PAXPAGO,"contract PAXPAGO is TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xd2be917afd50b81b585a5a96866658f9f90d811b.sol,SimpleEthBank,"contract SimpleEthBank { address public director; mapping (address => uint) accountBalances; mapping (address => bool) accountExists; event Deposit(address from, uint amount); event Withdrawal(address from, uint amount); event Transfer(address from, address to, uint amount); function SimpleEthBank() { director = msg.sender; }",1
0x749aba9e082ccb185d1ef88fa514339e3c3368d3.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0x76c6a8d8bd3ffc0bc0a3198cee1f59fc75bf7d67.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 initialSupply=1000000000; string tokenName=; string tokenSymbol=; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x294ee9f35988af1ce361409cee4251a293d21f5c.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) payable public {}",1
0x5ac8359a7d38afedf7ed0d4abb283cd2654d126a.sol,MyToken,contract MyToken is StandardToken { string public name; uint8 public decimals; string public symbol; function(){ revert(); },1
0x6c70879f56427b8c511e196c44ff05333a533987.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileICO,contract AgileICO { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x00ec953a3a3dad27da4f70d7e5be12dc08ef2835.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x848d015af507fb3840fee1078ad3a352e0aba055.sol,PUNCToken,"contract PUNCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PUNCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43] = _totalSupply; Transfer(address(0), 0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43, _totalSupply); }",1
0xafaeb51b058999a84354f5e45b44a1649519bcff.sol,MMCoin,"contract MMCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MMCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xa6239853ff98b88367f6fcb003790654395d322d.sol,ETH10,contract ETH10 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10/100 * (block.number - atBlock[msg.sender]) / 6000; address sender = msg.sender; sender.send(amount); },1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,NDUXB,"contract NDUXBase is BasicToken, Ownable { string public constant name = ; string public constant symbol = ; uint constant maxTotalSupply = 75000000; function NDUXBase() public { mint(this, maxTotalSupply); }",1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0xeec58a6a1584145106693c24115b7efebf9de896.sol,BlockchainTechnologyFundingToken,"contract BlockchainTechnologyFundingToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x2a89115A6160987088CDA53b72f9751005A91EfE] = _totalSupply; emit Transfer(address(0), 0x2a89115A6160987088CDA53b72f9751005A91EfE, _totalSupply); }",1
0x1848df8d1728a8ce654c7faf833b2d7296744fe4.sol,WorldToken,contract WorldToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 420000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,CRYPTOSSTOKEN,"contract CRYPTOSSTOKEN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5279ef99353dd74fdfda8d70e9a2f6cb8a1ae2fe.sol,CHEMCHINA_PFV_III_883,"contract CHEMCHINA_PFV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1049417559213730000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x08b4c866ae9d1be56a06e0c302054b4ffe067b43.sol,BitCar,contract BitCar is ERC20TokenInterface { function () public { revert(); },1
0x58c37105311985775c43e8b27efabf441859dfc4.sol,DBXTTest,"contract DBXTTest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; endDate = now + 12 weeks; }",1
0x34734d66dadc3fe1c35b6555341f07e8d8524c29.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2803ade692943fff909a20ee3109efb78282cab1.sol,HTHP,"contract HTHP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HTHP() public { symbol = ; name = ; decimals = 8; _totalSupply = 12000000000000000; balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply; Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply); }",1
0x2a0937dedadf8fe3f16a779c56524739ef77f149.sol,TEL_AVIV_Portfolio_I_883,"contract TEL_AVIV_Portfolio_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 742949791335499000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2906f2b553dcfda6891cba64b0ac9e5780b5c1a6.sol,CoinCopyTrade,"contract CoinCopyTrade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply =2000000000000000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0x64b09d1a4b01db659fc36b72de0361f2c6c521b1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x64bfbfa5aedd9622f627e3ddeadb634eb96a6fed.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x268f39ebb4868a09fa654d4ffe1ab024bc937db2.sol,DNACoin,"contract DNACoin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant UNIT = 10 ** decimals; address public companyWallet; address public backendWallet; uint256 public maxSupply = 1000000 * UNIT; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyBackend() { require(msg.sender == backendWallet); _; }",1
0x2029fdb81d226e0e45a620c47314b3ab1f78bf46.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0xc5e1510dfb5942f0af172af9c3ef3eef46e945c2.sol,TMRToken,"contract TMRToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TMRToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 600000000000000000000000000; balances[0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01] = _totalSupply; Transfer(address(0), 0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01, _totalSupply); }",1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf19903d8e5b7d604b62d2a210b39ba9e1e1f93ef.sol,STASHToken,"contract STASHToken is STASHInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function STASHToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 36000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 600000; fundsWallet = msg.sender; }",1
0xc040d0af51f34221b5f96b65d916ff176361fae1.sol,Token,"contract Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Token() public { symbol = ; name = ; decimals = 4; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6b8cc8bf77711aa7e2de795b883b7639587a02c2.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x18911e747108241e4afe4feeecc742e90c5177bd.sol,VistaToken,"contract VistaToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VistaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0xa5d1eb8bbb42b7f2ebbebf174b3966510243f30c.sol,TokenCreation,"contract TokenCreation is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public freezeOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor( string tokenSymbol, string tokenName, uint256 tokenSupply ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = 18; totalSupply = tokenSupply * (10 ** 18); balanceOf[0x94eE12284824C91dB533d4745cD02098d7284460] = SafeMath.safeDiv(totalSupply, 10); balanceOf[0xfaDB28B22b1b5579f877c78098948529175F81Eb] = SafeMath.safeSub(totalSupply, SafeMath.safeDiv(totalSupply, 10)); }",1
0x32e996a5a0b6d93c457bfa70917b08622ccdb3f4.sol,Digitelcoin,"contract Digitelcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Digitelcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 30000000000000000; balances[ 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894] = _totalSupply; Transfer(address(0), 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894, _totalSupply); }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x36f0deb0af8ab453b6b4fcc8b0b7fe2f1b44e55f.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x1e834560e79def1479555bf5d9a35e8bc3dbe70a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf13297aebfe157c4412e59363351779e60ec6b86.sol,GRAM,"contract GRAM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 12000000000000000; balances[0xEdf54a2ED7337410B8e367B4023C76134b3e801a] = _totalSupply; emit Transfer(address(0), 0xEdf54a2ED7337410B8e367B4023C76134b3e801a, _totalSupply); }",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,Whitelist,"contract Whitelist is Ownable, RBAC { string public constant ROLE_WHITELISTED = ; modifier onlyIfWhitelisted(address _operator) { checkRole(_operator, ROLE_WHITELISTED); _; }",1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xf3a4d8e3f5bfbab3b2d42e46d23c461eb866d16e.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address _target, bytes _data) external payable onlyOwner returns (bool) { return _target.call.value(msg.value)(_data); }",1
0xda0267fae25b4bfd53a1191ee1e864ecbdff92bb.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xf2855df7f963531f689a8a3d2eb7bf4e0f532c01.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5409fcd56836e0e0459c12ab45e7ef23c6094bed.sol,RedExchange,contract RedExchange { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf026ba160c18f5342031e25f6e93e2ba264ed64f.sol,CIRCLECOIN,"contract CIRCLECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CIRCLECOIN() public { symbol = ; name = ; decimals = 16; _totalSupply = 1000000000000000000000000; balances[0x63D8a091d446949ce806f5B9a45Cf8b254896ee5] = _totalSupply; Transfer(address(0), 0x63D8a091d446949ce806f5B9a45Cf8b254896ee5, _totalSupply); }",1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0x412c003380e08921be3ee7ee5830d3a00dd7e589.sol,AeternumLibertarianFoundationToken,"contract AeternumLibertarianFoundationToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AeternumLibertarianFoundationToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0x5c0e4f2a54f1e0716ea64de7cfe83b0cf1ad417b.sol,PowrLedgerToken,"contract PowrLedgerToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PowrLedgerToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 21 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6edea3515749cef9986d05f08104ffd976217bb7.sol,BestMultiplierV3,contract BestMultiplierV3 { struct Deposit { address depositor; uint deposit; uint payout; },1
0x7677b0d1fa1b71e3dc17aae1c9fcf22b13a59a34.sol,WhoWins,contract WhoWins { mapping (address => uint256) public balance; mapping (address => uint256) public atBlock; address public house; constructor() public { house = msg.sender; },1
0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x041fe8df8b4aaa868941eb877952f17babe57da5.sol,SafeMath,None,1
0xbde3e294e28709399b81d20689e351c7b1008773.sol,fcomToken,"contract fcomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function fcomToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x07e76a4c93ea197cb578fef37d046972890df61b.sol,BigToken,"contract BigToken is ERC20, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public mintPerBlock = 333333333333333; struct BigTransaction { uint blockNumber; uint256 amount; }",1
0x56190ef084441dfde78fe6cb9a0c5b03b108ef48.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0x2bae8bf1d52cf870381c6c02f0256f1b68d7aa2e.sol,OBOK,contract OBOK { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0x2011266a6c9e48b3ed2e397637df03abe1d3e832.sol,ETGOLDToken,"contract ETGOLDToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETGOLDToken() public { totalSupply = 24000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc.sol,PEPEso,"contract PEPEso is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PEPEso() public { symbol = ; name = ; decimals = 0; _totalSupply = 246675000000000000000000; balances[0xC18Fe0a2B3E0eFE79CF16ba411e26116D812d7d3] = _totalSupply; Transfer(address(0), 0xC18Fe0a2B3E0eFE79CF16ba411e26116D812d7d3, _totalSupply); }",1
0x5b6696ed1e4e74c2a73a3f27186ab315f4fa55d8.sol,TkoWhitelist,"contract TkoWhitelist is Ownable{ using SafeMath for uint256; address public admin; mapping(address => uint256) internal totalIndividualWeiAmount; mapping(address => bool) internal whitelist; event AdminChanged(address indexed previousAdmin, address indexed newAdmin); function TkoWhitelist (address _admin) public { require(_admin != address(0)); admin = _admin; }",1
0x2d935e1e98f3485518b918478dc1dbbdc2c9d9fc.sol,PEPEso,"contract PEPEso is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PEPEso() public { symbol = ; name = ; decimals = 0; _totalSupply = 246675000000000000000000; balances[0xC18Fe0a2B3E0eFE79CF16ba411e26116D812d7d3] = _totalSupply; Transfer(address(0), 0xC18Fe0a2B3E0eFE79CF16ba411e26116D812d7d3, _totalSupply); }",1
0x4702d2c2a715e1c3a738b923236d12fe834b61d1.sol,TaiwanCoin,"contract TaiwanCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 23000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x2b1a25c869017b8cac04c91763bee039d5353ec0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Impl,contract ERC20ImplUpgradeable is CustodianUpgradeable { struct ImplChangeRequest { address proposedNew; },1
0x4c9b31eeca8da5a63237097176691bef68e8b8c5.sol,PunkLombard,contract PunkLombard { address public CryptoPunksContract; uint256 public loanAmount; uint256 public punkIndex; uint256 public annualInterestRate; uint256 public loanTenor; uint256 public loanPeriod; address public lender; address public borrower; uint256 public loanStart; uint256 public loanEnd; uint256 public interest; address public contractOwner; modifier onlyOwner { if (msg.sender != contractOwner) revert(); _; },1
0xdb18bf96d5b00fe57dbfcd42b48e280624670f90.sol,WillTestament,"contract WillTestament is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WillTestament() public { symbol = ; name = ; decimals = 18; _totalSupply = 7795482309000000000000000000; balances[0x9Ffc7727A6895d6beEc409249486a422a1648416] = _totalSupply; Transfer(address(0), 0x9Ffc7727A6895d6beEc409249486a422a1648416, _totalSupply); }",1
0x569708221bc339b4391bab9127422603250fc294.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x02eebe04031cb7dd33ca76c8947059c8f8549ff1.sol,VOCC_I108_20181211,"contract VOCC_I108_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x5870a119fccc91a46426ed1d4f12f8384f372e93.sol,TEG,"contract TEG{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TEG() public { balances[msg.sender] = 1600000000000; totalSupply = 1600000000000; name = ; decimals =4; symbol = ; }",1
0xa2f5fa2c90fe3f959aafd2a42ea9c4ada668b682.sol,FastChat,contract FastChat { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 10000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xdd850d1d845a444a13e9516317a0a57075d9cf8e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f664dccaef62d345d78b62a8095acc828e67e4c.sol,FriendsFingersToken,"contract FriendsFingersToken is DetailedERC20, MintableToken, BurnableToken, SafeContract { address public builder; modifier canTransfer() { require(mintingFinished); _; }",1
0xafbdd9d46f5ce898204e75484008a442b594b409.sol,DAIMLER_AG,"contract DAIMLER_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10379707031250000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0x02eebe04031cb7dd33ca76c8947059c8f8549ff1.sol,VOCC_I108_20181211,"contract VOCC_I108_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbf92c30ecebae64ae5ab0361f9010d7317be3c50.sol,GSEPTO,"contract GSEPTO { string public name = ; string public symbol = ; address private owner; uint256 public fundingGoal; uint256 public amountRaised; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _amount); event FundTransfer(address indexed _backer, uint256 _amount); event IncreaseFunding(uint256 indexed _increase, uint256 indexed _curFundingGoal); bool public crowdsaleOpened = true; function GSEPTO(uint256 _fundingGoal) public { owner = msg.sender; fundingGoal = _fundingGoal; balanceOf[owner] = fundingGoal; Transfer(0x0, owner, fundingGoal); }",1
0xc4fd6c87218a2c0f2f7cfed260e1778d62020688.sol,TestingCoin,contract TestingCoin { string constant public name = ; string constant public symbol = ; uint256 constant scaleFactor = 0x10000000000000000; uint8 constant limitedFirstBuyers = 4; uint256 constant firstBuyerLimit = 0.5 ether; uint8 constant public decimals = 18; mapping(address => uint256) public stakeBalance; mapping(address => int256) public payouts; uint256 public totalSupply; uint256 public contractBalance; int256 totalPayouts; uint256 earningsPerStake; uint8 initialFunds; address creator; uint256 numStakes = 0; uint256 balance = 0; modifier isAdmin() { require(msg.sender == creator ); _; },1
0x1dd7c1a2be393644bf56420aa64d53058a3c430a.sol,SodaCoin,"contract SodaCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76] = _totalSupply; emit Transfer(address(0), 0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76, _totalSupply); }",1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0x25073d89644d3b033f422949e70064c60fa05c3c.sol,ToyOwnership,contract ToyOwnership { struct ToyToken { address owner; uint uid; uint timestamp; uint exp; bytes toyData; },1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x07e76a4c93ea197cb578fef37d046972890df61b.sol,BigToken,"contract BigToken is ERC20, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public mintPerBlock = 333333333333333; struct BigTransaction { uint blockNumber; uint256 amount; }",1
0x18dfd8c468ed83397c0e1cadae01e1e65e86d275.sol,PacioToken,"contract PacioToken is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 12; uint public tokensIssued; uint public tokensAvailable; uint public contributors; uint public founderTokensAllocated; uint public founderTokensVested; uint public foundationTokensAllocated; uint public foundationTokensVested; bool public icoCompleteB; address private pFounderToksA; address private pFoundationToksA; event LogIssue(address indexed Dst, uint Picos); event LogSaleCapReached(uint TokensIssued); event LogIcoCompleted(); event LogBurn(address Src, uint Picos); event LogDestroy(uint Picos); function Initialise(address vNewOwnerA) { require(totalSupply == 0); super.ChangeOwner(vNewOwnerA); founderTokensAllocated = 10**20; foundationTokensAllocated = 10**20; totalSupply = 10**21; iTokensOwnedM[ownerA] = 10**21; tokensAvailable = 8*(10**20); Transfer(0x0, ownerA, 10**21); }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x1d9e20e581a5468644fe74ccb6a46278ef377f9e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x038d5044c7a8e7146763524f84f8850e2805673b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; event Burn(address indexed from, uint256 value); function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x54e3cd83c6b8f9ba0bab9397e9b7c8a882bcaa1d.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbf3f792573e6bee4aea45a8e3d6c8543c39c78b7.sol,CoinX,"contract CoinX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TFcoin,"contract TFcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TFcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44a6bae1dba4d2b91ff7b0b54506fd0e1f9c44de.sol,TunTokenERC20,"contract TunTokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=1000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TunTokenERC20() public { balanceOf[msg.sender] = totalSupply; }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0x6cabf1b590ee8daa30a1c76ff5dd21284d8681d8.sol,HCHToken,"contract HCHToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HCHToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x6c24a2934a0255c4dce7ae619ed2b285f06477a0.sol,BighubToken,"contract BighubToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BighubToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1400000000000000000000000000; balances[0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A] = _totalSupply; emit Transfer(address(0), 0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A, _totalSupply); }",1
0x58054e51c19fa796443043418be91032b99992a3.sol,iGniter,contract iGniter is SafeMath { struct serPayment { uint unlockedTime; uint256 unlockedBlockNumber; },1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc.sol,COTY,"contract COTY{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0xbe2a1d562817b6064e0568a4dc9e2c80f7478dfe.sol,TSCoin,"contract TSCoin { uint256 totalSupply_; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply = 200000000*(10**uint256(decimals)); uint256 public buyPrice; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function totalSupply() public view returns (uint256){ return totalSupply_; }",1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2.sol,WannabeSmartInvestor,contract WannabeSmartInvestor { address private owner; mapping(address => uint) public incomeFrom; constructor() public { owner = msg.sender; },1
0xc518086f77b45498fabdaa93bdbea24393c7fed6.sol,SFCCToken,"contract SFCCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000 ether; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0xe9e3f9cfc1a64dfca53614a0182cfad56c10624f.sol,SuNFT,"contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, SupportsInterface { mapping (uint256 => address) internal tokenApprovals; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { address owner = _tokenOwnerWithSubstitutions[_tokenId]; require(msg.sender == owner); _; }",1
0x361f5a02be315ed1241d8c2997d1fc35aaa27596.sol,DinarETHCrypto,"contract DinarETHCrypto is ERC20Interface, DinarETHInterface { using SafeMath for uint256; string public symbol = ; string public name = ; string public goldCertVerifier = ""https: uint8 public constant decimals = 8; uint256 public constant DNARtoGoldXchgRate = 10000000; uint256 public constant _totalSupply = 9900000000000000; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x287fda15f8f002e5df9f536f10bbfc0816960f36.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0x18486c451fdc6eac512d468967f75729d11b89ea.sol,LiteCoinW,contract LiteCoinW is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,DepositProxy,"contract DepositProxy is Proxy { address public Owner; mapping (address => uint) public Deposits; event Deposited(address who, uint amount); event Withdrawn(address who, uint amount); function Deposit() payable { if (msg.sender == tx.origin) { Owner = msg.sender; deposit(); }",1
0x5258e585f8efe5d7ecca0a9232fc26fd8ca02436.sol,KCOIN,"contract KCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c3be406174349cfa4501654313d97e6a31072e1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2154f9d7da8bf221e102197195531c82cee1677e.sol,AIUToken,"contract AIUToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e0646940d1ec4494fe80ca13643e3abb76f5810.sol,GameSicBo,"contract GameSicBo is Base { uint public lastBlockNumber = 0; uint public gameID = 0; uint public gameBeginTime; uint public gameEndTime; uint public gameTime; uint256 public gameMaxBetAmount; uint256 public gameMinBetAmount; bool public gameOver = true; bytes32 public gameEncryptedText; uint public gameResult; string public gameRandon1; string public constant gameRandon2 = ; bool public betInfoIsLocked = false; uint public playNo = 1; uint public gameBeginPlayNo; uint public gameEndPlayNo; uint public nextRewardPlayNo; uint public currentRewardNum = 100; function GameSicBo(string _gameName,uint _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,address _DonQuixoteToken) public { require(_gameTime > 0); require(_gameMinBetAmount >= 0); require(_gameMaxBetAmount > 0); require(_gameMaxBetAmount >= _gameMinBetAmount); gameMinBetAmount = _gameMinBetAmount; gameMaxBetAmount = _gameMaxBetAmount; gameTime = _gameTime; require(_DonQuixoteToken != 0x0); DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken); owner = msg.sender; gameName = _gameName; }",1
0x2edd739976bf60e2b5a7a9fdb4a96e0dad4ca21e.sol,BethElCoin,"contract BethElCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xF417694bfAcd465b98681aa5cB2723FA6cd53ef1] = _totalSupply; emit Transfer(address(0),0xF417694bfAcd465b98681aa5cB2723FA6cd53ef1, _totalSupply); }",1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0x701e28058b24563b9f718b720f7c48cb6690226e.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500.sol,ZchargeToken,"contract ZchargeToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZchargeToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff.sol,BTYCEC,contract BTYCEC is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sysusermoney; uint public sysoutmoney; uint public sellPrice; uint public buyPrice; uint public btycbuyPrice; uint public btycsellPrice; uint public sysPer; uint public sysPrice1; uint public sysPer1; uint public systime1; uint public sysPrice2; uint public sysPer2; uint public systime2; uint public transper; bool public actived; uint public onceAddTime; uint public upper1; uint public upper2; uint public teamper1; uint public teamper2; uint public outper1; uint public outper2; uint public sellper; uint public sysday; uint public sysminteth; uint public hasoutmony; uint public hasbuymoney; uint public hassellmoney; uint public hasbuyeth; uint public hasselleth; uint public hasbtycbuymoney; uint public hasbtycsellmoney; mapping(address => uint) balances; mapping(address => uint) myeth; mapping(address => uint) froeth; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => address) public fromaddr; mapping(address => uint) public crontime; mapping(address => uint) public mintnum; uint[] public permans; mapping(address => uint) public teamget; struct sunsdata{ uint n1; uint n2; uint getmoney; },1
0xd4111b29cfc55c147b4fe759c8d99012df597065.sol,WHDCToken,"contract WHDCToken is Pausable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0xead527531f9e31c989c6be6e9cf4abfc7531c999.sol,Bourneereum,"contract Bourneereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bourneereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2ad62fb35bad00b30e3af1d920de48d29613993.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd216c12e89ac892e944edf6c947c860681ef18da.sol,Knightium,"contract Knightium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Knightium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x501c17b26029f3a129fd9adeb4b642bd35a35248.sol,SolClub,"contract SolClub is Ownable, DetailedERC20(, , 0) { using SafeMath for uint256; using SafeMath64 for uint64; struct Member { bytes20 username; uint64 karma; uint16 canWithdrawPeriod; uint16 birthPeriod; }",1
0x0ec03c088cbfffdd0c2ba8c1cfa35f655a9ce078.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x749f35ff65932e68267dd82f6cd85eea735d700e.sol,CCLToken,"contract CCLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 4000000000000000000000000000; balances[0xf835bF0285c99102eaedd684b4401272eF36aF65] = _totalSupply; Transfer(address(0), 0xf835bF0285c99102eaedd684b4401272eF36aF65, _totalSupply); }",1
0x4bf3e4d2378a1256cbe1cd1c2a8bc9857b811282.sol,Databits,"contract Databits is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 5000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Databits(){ balanceOf[msg.sender] = totalSupply; }",1
0x6a00a6cd60733c483070aa5e7d835fa81fe5b10a.sol,BJUIO,"contract BJUIO { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x201e7cd92e03ea87c51d3e22974243ed7a26a1cb.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 7; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x86f91249a10f9872acc96cc352f9a914531a38e5.sol,CrowdsaleRC,"contract CrowdsaleRC { uint public createdTimestamp; uint public start; uint public deadline; address public owner; address public beneficiary; uint public amountRaised; uint public maxAmount; mapping(address => uint256) public balanceOf; mapping (address => bool) public whitelist; event FundTransfer(address backer, uint amount, bool isContribution); function CrowdsaleRC () public { createdTimestamp = block.timestamp; start = 1529316000; deadline = 1532080800; amountRaised = 0; beneficiary = 0xD27eAD21C9564f122c8f84cD98a505efDf547665; owner = msg.sender; maxAmount = 2000 ether; }",1
0x261bb5e1c53248860f4bc405abaae3e0bfc12874.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdd6eef0507f10d21f716e36d8b1aae76a4fa3f62.sol,CashexGlobalCoin,contract CashexGlobalCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 1000000000000000000; function name() public constant returns (string) { return ; },1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol,VirtualGift,contract VirtualGift is ERC721 { ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); struct Gift { uint256 price; string description; },1
0x0223fc70574214f65813fe336d870ac47e147fae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply; }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TOURISTOKEN { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol )MyAdvancedToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x50fb2403b415c4ce2c94c7bf7cbfa36145fc5cbf.sol,SCCC,"contract SCCC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b2988f2d77c38b46a753ea09a4f6bf726e07e34.sol,LILE,"contract LILE1Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x414e58fbd9264565d611c5eb2a392a70529dad41.sol,CoinEGGToken,contract CoinEGGToken is Token { string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 10000000000*(10**18); balances[msg.sender] = totalSupply; name = ; decimals = 18; symbol = ; },1
0x201fbe9e789d10d893b43ed5aaa5f1b7149f6de8.sol,BEC,"contract BEC is ERC20Interface, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BEC() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x3f8d54a081b67E135063A08c826B900930ef5B4E] = _totalSupply; Transfer(address(0), 0x3f8d54a081b67E135063A08c826B900930ef5B4E, _totalSupply); }",1
0x64d5e7be2e92d4436ba9c4a630491cb268764103.sol,funds,contract funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9a1488a97840653a0be4a4aed50ecf6137507b7c798a86604f31e3199852668c; constructor() public { owner = msg.sender; },1
0xde522a2778e4554707e6a8df36a4871ce9967bb5.sol,FML,"contract FML { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FML() public { totalSupply = 2100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0da1c6228c8e4b666b0ddf4c391bf24e70b7e19e.sol,SafeMath,"contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; }",1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,UltimateCoin,"contract UltimateCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UltimateCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x066771118888b07539988963e29ffe99d6e62fd1.sol,TokenERC20,"contract TokenERC20 is Owner{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0xcf5a08af322e52bee93861341f7bd90eb3d65aa3.sol,HeavyLitecoin,"contract HeavyLitecoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HeavyLitecoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8] = _totalSupply; Transfer(address(0), 0xaCaD93Eaf7509161Fe61C2173ce143fD469e5Cf8, _totalSupply); }",1
0xf3c96e0153cdab274834a9ef9d4f6a330677d66d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x28863b9534af2a4c3d912e9a3b76b0b7b4fe2046.sol,ViberateBuyer,"contract ViberateBuyer { mapping (address => uint256) public balances; uint256 public buy_bounty; uint256 public withdraw_bounty; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4; uint256 public earliest_buy_time = 1504612800; uint256 public eth_cap = 10000 ether; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x71d00a5e4a541caafd106509eff28a7798443c26.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0xdb7ad50a39346a78f272ac286e78430061949b2a.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x1ea976a4abbdbcc67d9b4fd6d5dba23618fb52fd.sol,SafeMath,None,1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0e50e6d6bb434938d8fe670a2d7a14cd128eb50f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x30d62b3392520580ffc74d7326bb29a4bf541a4d.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,TokenRK50Z,"contract TokenRK50Z is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = false; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRK50Z() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4.sol,FccToken,"contract FccToken is Owned, StandardToken { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 8; function FccToken() { balances[msg.sender] = 200000000* 10**8; totalSupply = 200000000* 10**8; locked = false; }",1
0x1d07f0704dbb88298c69e351c92a82272f0daf75.sol,AdvSoundTribeToken,"contract AdvSoundTribeToken is owned, SoundTribeToken { function AdvSoundTribeToken( uint256 initialSupply ) SoundTribeToken(initialSupply) public {}",1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3939627b9775c3b76c05138d281c7f92e251aab.sol,LespNetWork,"contract LespNetWork { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xa427451a26d3419d75cb79f835c4b2e898a93ba4.sol,LSYP,"contract LSYP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LSYP() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b] = _totalSupply; Transfer(address(0), 0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b, _totalSupply); }",1
0x0eb29d27265d818dbbb395b7c9423f77aea70fa7.sol,COLOMBIA_WINS,"contract COLOMBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 476721916935210000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x78fadca7874afa0fdee1cafd9a80d6ace86325fe.sol,SafeMath,None,1
0x011a94df7ccf7eb28409cefc9d825f24c75b3c74.sol,SalaryInfo,contract SalaryInfo { struct User { string name; },1
0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3606bac9d236835210beb1a332431dd9fd5484da.sol,CTNCToken,contract CTNCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 3016000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2.sol,Poge,"contract Poge { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Poge( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,ActionAuction,"contract ActionAuction is AccessNoWithdraw { using SafeMath for uint256; event AuctionCreate(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionSold(uint256 indexed index, address indexed seller, address indexed buyer, uint256 tokenId, uint256 price); event AuctionCancel(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionPriceChange(uint256 indexed index, address indexed seller, uint256 tokenId, uint64 newGwei); struct Auction { address seller; uint64 tokenId; uint64 price; uint64 tmStart; uint64 tmSell; }",1
0x33201831496217a779bf6169038dd9232771f179.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xc35924a3661bbadabbba4f1823fa74fcafcb08ef.sol,RxPharma,"contract RxPharma{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RxPharma() public { totalSupply = 50000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x32b2dc789ca341119b03c86c0a3c0b613e4835b6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x44a1b86ffa821bcadb636a4493aa50d5ab0ddf4a.sol,GoodDayToken,"contract GoodDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GoodDayToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 12 weeks; }",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x696be206174bea69e7a00b4deb1c6fddfa4786c9.sol,RAZEN,"contract RAZEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RAZEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce] = _totalSupply; Transfer(address(0), 0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce, _totalSupply); }",1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc.sol,COTY,"contract COTY{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x545123c9b719cc37d098168742ca21748adc0060.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0d4661d04c9a2ea0db5319ea9380ec0118215d7.sol,CCG,"contract CCG is Token { string public name; uint8 public decimals; string public symbol; function CCG (uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100000000 * (10 ** decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x52f7018bc6ba4d24abfbaefccae4617bfb0a0b52.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x5c0e4f2a54f1e0716ea64de7cfe83b0cf1ad417b.sol,PowrLedgerToken,"contract PowrLedgerToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PowrLedgerToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 21 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0xd2be917afd50b81b585a5a96866658f9f90d811b.sol,SimpleEthBank,"contract SimpleEthBank { address public director; mapping (address => uint) accountBalances; mapping (address => bool) accountExists; event Deposit(address from, uint amount); event Withdrawal(address from, uint amount); event Transfer(address from, address to, uint amount); function SimpleEthBank() { director = msg.sender; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x4b43d8a35257f42a2d0d4d774409208efc31b406.sol,Project512Foundation,"contract Project512Foundation { string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 public initialSupply = 125000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Project512Foundation () public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5b60414447a58a9ac5e28fd695f1e23874103ef0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DDBBCOIN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = 8; balanceOf[msg.sender] = 2160000000000000; name = ; symbol = ; }",1
0x341199e2387bcf1c356881f4bb5dedbe33ab26b1.sol,SHERE_PFIII_I_883,"contract SHERE_PFIII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 744212612048926000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xbfb7eee5dbc373433a97431fd5a3010b53e16378.sol,DDAContract,contract DDAContract is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 10**26; mapping (address => uint) public balances; mapping (address => mapping (address => uint256)) public allowed; address dedeAddress; function totalSupply() constant returns (uint totalSupply){ return _totalSupply; },1
0x70b8028610e60c1962522e0559c9a658663cfcce.sol,Olympus,"contract Olympus { using SafeMath for uint; address private constant supportAddress = 0x0bD47808d4A09aD155b00C39dBb101Fb71e1C0f0; uint private constant supportPercent = 1; mapping(address => uint) private shares; uint private totalShares; uint private totalPersons; function getBalance(address _account) public constant returns (uint) { if (totalShares == 0) return 0; uint contractBalance = address(this).balance; uint profitPercent = calculateProfitPercent(contractBalance, totalPersons); return contractBalance.mul(shares[_account]).mul(profitPercent).div(totalShares).div(100); }",1
0xd5e1f90d918fd871fa0aba9aea54bb07e6382299.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0xd903286ce14d55ce3eee7a39bcf683c21ed5356e.sol,TheGTokenTest,"contract TheGTokenTest is Token { string public name; uint8 public decimals; string public symbol; function TheGTokenTest(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0xa19fdf84f56c91e7e805c3a5a47613132b112b91.sol,OhNoToken,"contract OhNoToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OhNoToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d] = _totalSupply; Transfer(address(0), 0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d, _totalSupply); }",1
0x1e4e36b3f011d862fd70006804da8fcefe89d3d8.sol,VenusToken,"contract VenusToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 54053687735; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VenusToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaa88e4e83055f144a9f265a217d5727c8b0df57a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53844515fcd00fe3864167a648309dd11c5055fc.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = INITIAL_SUPPLY.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { totalSupply_ = INITIAL_SUPPLY; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x73390087000b126be1ced616a9df4daff59d03c6.sol,CHEMCHINA_PFV_I_883,"contract CHEMCHINA_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 582396634707317000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0x33bb55835499b4013686e39de293ee4d832bbca4.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD, GroupE, GroupF, GroupG, GroupH, GroupI, GroupJ}",1
0x1e2bbf1578d1ecd107c95ab550f8c9559a0acca6.sol,Tbyc,"contract Tbyc { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tbyc() { owner = 0x0a09B58084554786215Dabe7Ab645cB17b1e490E; name = ; symbol = ; decimals = 18; totalSupply = 1314000000000000000000000000; balanceOf[owner] = 1314000000000000000000000000; }",1
0x6f97b5c035939424037f00102068e610380ee25a.sol,NDD_KHC_I_883,"contract NDD_KHC_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1407435608253240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x536ad2443ba256577876dbb4b89db10966513475.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 400000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1adbdb4df70c537e5052fc83099495f2ca19002f.sol,VOCC_I044_20181211,"contract VOCC_I044_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4c9b31eeca8da5a63237097176691bef68e8b8c5.sol,PunkLombard,contract PunkLombard { address public CryptoPunksContract; uint256 public loanAmount; uint256 public punkIndex; uint256 public annualInterestRate; uint256 public loanTenor; uint256 public loanPeriod; address public lender; address public borrower; uint256 public loanStart; uint256 public loanEnd; uint256 public interest; address public contractOwner; modifier onlyOwner { if (msg.sender != contractOwner) revert(); _; },1
0xe1291032766b81488dc565479503a103489f78d7.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x71fbecb11e291f824fd5dc9e760f56a5239e4702.sol,HodlDAO,contract HodlDAO { string public version = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => withdrawalRequest) public withdrawalRequests; struct withdrawalRequest { uint sinceTime; uint256 amount; },1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0xd6ed0e5d7f854b64b5e467a240a6c155c17cc6a2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0xa2b5ca48fc2f8517c5e6077046a17e57d346dab5.sol,CHEMCHINA_PFI_I_883,"contract CHEMCHINA_PFI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 561734866207499000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0x6a7b0eb4684a85ae792dcd90f743e0813bb80977.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4b43d8a35257f42a2d0d4d774409208efc31b406.sol,Project512Foundation,"contract Project512Foundation { string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 public initialSupply = 125000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Project512Foundation () public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x01d5d0108589f3c52fcce6e65503bb6515e66698.sol,DcorpProxy,"contract DcorpProxy is TokenObserver, TransferableOwnership, TokenRetriever { enum Stages { Deploying, Deployed, Executed }",1
0x569708221bc339b4391bab9127422603250fc294.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0xed023b117953fcfaa92150d3ebe3e987d19563ce.sol,ERC721DutchAuction,"contract ERC721DutchAuction is Ownable, Pausable { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x35ae44bc4e3186ca732efa09a459cf93fa491a47.sol,XMLYToken,"contract XMLYToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) freezed; mapping(address => uint) freezeAmount; mapping(address => uint) unlockTime; function XMLYToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5B807E379170d42f3B099C01A5399a2e1e58963B] = _totalSupply; Transfer(address(0), 0x5B807E379170d42f3B099C01A5399a2e1e58963B, _totalSupply); }",1
0xeaaa3585ffdcc973a22929d09179dc06d517b84d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol) internal { totalSupply = _initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _tokenName; symbol = _tokenSymbol; }",1
0x1dd7c1a2be393644bf56420aa64d53058a3c430a.sol,SodaCoin,"contract SodaCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76] = _totalSupply; emit Transfer(address(0), 0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76, _totalSupply); }",1
0xd532375971258953263218994966e2a0a3d5c18a.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721 { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x78fadca7874afa0fdee1cafd9a80d6ace86325fe.sol,SafeMath,None,1
0xe30a7eb71dd59538e2d4f03a4e63ea9a155857d1.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc.sol,Multiplexer,"contract Multiplexer { function sendEth(address[] _to, uint256[] _value) payable returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 255); uint256 beforeValue = msg.value; uint256 afterValue = 0; for (uint8 i = 0; i < _to.length; i++) { afterValue = afterValue + _value[i]; assert(_to[i].send(_value[i])); }",1
0xed787fc6835408bfc3ea8e24dfea1f4ea54be982.sol,Molecule,"contract Molecule { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Molecule( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cf1b38cefe57377fd4bbc7df7c38dfe013ff91a.sol,GYLCoin,"contract GYLCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GYLCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,VestingAllocation,"contract VestingAllocation is Ownable { address[] public allocationAddressList; uint256 public periods; uint256 public minutesInPeriod; uint256 public remainingTokensPerPeriod; uint256 public totalSupply; uint256 public initTimestamp; mapping (address => Types.StructVestingAllocation) public allocationOf; function VestingAllocation(uint256 _tokensPerPeriod, uint256 _periods, uint256 _minutesInPeriod, uint256 _initalTimestamp) Ownable() public { totalSupply = _tokensPerPeriod * _periods; periods = _periods; minutesInPeriod = _minutesInPeriod; remainingTokensPerPeriod = _tokensPerPeriod; initTimestamp = _initalTimestamp; }",1
0x54c548703c6f423cf7ed22806b608d332fcebb3b.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0x41f8d4d01ba8505111794e3fa3deb3ed8cbaa8ee.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 10; address public addressA = 0x82914CFc37c46fbbb830150cF2330B80DAADa2D5; function founder() private { owner = msg.sender; },1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,Milestones,"contract Milestones is Ownable { enum State { PreIco, IcoOpen, IcoClosed, IcoSuccessful, IcoFailed, BankLicenseSuccessful, BankLicenseFailed }",1
0x47b56408263cf1f9bdb93b930bf01c6c5935ebb4.sol,ERC20,"contract ERC20Interface { string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,ERC20Token,"contract ERC20Token is StandardToken, Ownable { using SafeMath for uint256; string public name; string public symbol; string public version = ; uint256 public totalCoin; uint8 public decimals; uint256 public min; uint256 public exchangeRate; mapping (address => bool) public frozenAccount; event TokenNameChanged(string indexed previousName, string indexed newName); event TokenSymbolChanged(string indexed previousSymbol, string indexed newSymbol); event ExhangeRateChanged(uint256 indexed previousRate, uint8 indexed newRate); event FrozenFunds(address target, bool frozen); function ERC20Token() public { decimals = 18; totalCoin = 20000000000; totalSupply = totalCoin * 10**uint(decimals); balances[owner] = totalSupply; exchangeRate = 12500000; min = 10000000000000000; symbol = ; name = ; }",1
0x0022ee765799c1f836a36612b8c62be098fd0bbb.sol,SOCGEN_301201,"contract SOCGEN_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10780817168445100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0xdbb6b23520472c5070078cd3e7097b36b001fb57.sol,TheBigBangOnline,contract TheBigBangOnline is Ownable { using SafeMath for uint256; bool contractProtection = true; modifier notFromContract() { if ( (msg.sender != tx.origin) && (contractProtection == true)){ revert(); },1
0xf19eac69f9566f0b40660bd0cc16234330f38456.sol,SafeMath,None,1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,ProperProposal,"contract ProperProposal is ProposalInterface, TokenRescue { struct Argument { address source; uint8 position; uint256 count; }",1
0x6bc2adef424c32cf1e15789f010ea16a753587ac.sol,LEBRON,"contract LEBRON is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LEBRON() public { symbol = ; name = ; decimals = 18; _totalSupply = 230000000000000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x3f8fd16e55cfee539b81cc47bb9682090988ebd4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x33fcaf980028cd42f9ca3675645d42db8aa4065b.sol,Jerome,"contract Jerome is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 42069; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x2d784562eb7538cc5e5dd5de880d2a1cc241c1bd.sol,DobrocoinContract,"contract DobrocoinContract is owned, Token { uint256 public sellPrice; uint256 public buyPrice; uint256 public AutoBuy = 1; uint256 public AutoSell = 1; address[] public ReservedAddress; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol, string tokenAuthor ) Token(initialSupply, tokenName, tokenSymbol, tokenAuthor) public {}",1
0x92891fb5abe9049e181ca49ce04a9872c0c1ca44.sol,SimplyBank,contract SimplyBank { mapping (address => uint256) dates; mapping (address => uint256) invests; address constant private TECH_SUPPORT = 0x85889bBece41bf106675A9ae3b70Ee78D86C1649; function() external payable { if (msg.value == 0.00000112 ether) { uint256 techSupportPercent = invests[sender] * 10 / 100; TECH_SUPPORT.transfer(techSupportPercent); uint256 withdrawalAmount = invests[sender] - techSupportPercent; sender.transfer(withdrawalAmount); dates[sender] = 0; invests[sender] = 0; },1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,Freedom,contract Freedom is ERC20Contract { using SafeMath for uint256; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; string public constant tokenName = ; string public constant tokenSymbol = ; uint256 public totalSupply = 1000000000e8; uint8 public decimals = 8; constructor () public { balanceOf[msg.sender] = totalSupply; totalSupply = totalSupply; decimals = decimals; },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xdc0c33a4c10dfdca03e583107eb5520555c86f9e.sol,CryptoProfit,contract CryptoProfit { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xf2e449491975e376342586dd1229da20c969a39d.sol,CrisCoin,"contract CrisCoin { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; address public owner; uint256 public constant RATE = 1000; uint256 initialSupply = 100000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CrisCoin() public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0x017a5d8d82afaa22bc29d75013d6ff3656e90851.sol,ScamStampToken,contract ScamStampToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x3293cc907fde439b39aedaf1b982785adaff186b.sol,ERC20Token,"contract ERC20Token is ReentryProtected, ERC20Interface { using SafeMath for uint256; uint256 totSupply; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; function ERC20Token() { totSupply = 0; balance[msg.sender] = totSupply; }",1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0xf50d193eb6761fb3189be46b9165d4aec20e05f0.sol,FLEBToken,contract FLEBToken{ address public owner; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 0; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; constructor() public{ owner = msg.sender; },1
0x0d514c490640d6276b5bb5adc52d1453cf11c5a0.sol,Token,contract Token is StandardToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; address public mintableAddress; function Token(address sale_address) { balances[msg.sender] = 0; totalSupply = 0; name = name; decimals = decimals; symbol = symbol; mintableAddress = sale_address; allowTransfer = true; createTokens(); },1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xce242dfca2b3499af28de3074083c3acdcd2d0f6.sol,VOCC_I084_20181211,"contract VOCC_I084_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf442c2f7f9f91bd482fac07ed599ece40ffcc283.sol,HeelToken,"contract HeelToken { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=23000000000*10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HeelToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x774853153c3cc175a3606c58d6f27f6b57e72fd3.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x17b4ae55a5b0b6c10b0f4bae2d75a4e83de41709.sol,Util,None,1
0x8564e222115248d10593cf4a6719fa6d82194e62.sol,ITube,"contract ITube is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ITube() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 5 weeks; endDate = now + 15 weeks; }",1
0xdde19c145c1ee51b48f7a28e8df125da0cc440be.sol,EmbiggenToken,contract EmbiggenToken is ERC20 { using SafeMath for uint256; uint constant MAX_UINT = 2**256 - 1; string public name; string public symbol; uint8 public decimals; uint initialSupply; uint initializedTime; uint hourRate; struct UserBalance { uint latestBalance; uint lastCalculated; },1
0xdfb9e87ff81cb089484ef8150a21be80f6cdd401.sol,CRYPTOPOKER,"contract CRYPTOPOKER { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000* (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,ZToken,"contract ZToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xcd856a8d411f43392c21d89271dd0bf565128080.sol,Fundraising,contract Fundraising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9285ec36936b38aaf7f00c9d18ea89687d857f5d728b4df9a8b995b1e7b60d85; constructor() public { owner = msg.sender; },1
0x72519fa6cd095c99d5d67e31ddc117409bc5c047.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 0; },1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate) { require(_endTime >= _startTime); require(_rate > 0); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; }",1
0x32e730afe4332bf98902ea59c3d003e81b5c7c69.sol,TokenERC20AC,"contract TokenERC20AC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20AC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb41654a43aae0d7d17701c612567b4243aa9cd6c.sol,PlayWinCollectProtocol,"contract PlayWinCollectProtocol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PlayWinCollectProtocol() public { symbol = ; name = ; decimals = 18; _totalSupply = 37100000000000000000000000; balances[0x5506310E6265Fc678ac11a423cceb5d048CAa2d3] = _totalSupply; Transfer(address(0), 0x5506310E6265Fc678ac11a423cceb5d048CAa2d3, _totalSupply); }",1
0x05e886072ec32a5d4273ce451483a7693cb812e4.sol,BTN,"contract BTN is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTN() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf013e0ea26cb386b3021783a3201bf2652778f93.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x83ba853b8196bb51c148dd762a827c703b156450.sol,FeeWallet,"contract FeeWallet is IFeeWallet, Ownable, Members { address public serviceAccount; uint public servicePercentage; uint public affiliatePercentage; mapping (address => uint) public pendingWithdrawals; function FeeWallet( address _serviceAccount, uint _servicePercentage, uint _affiliatePercentage) public { serviceAccount = _serviceAccount; servicePercentage = _servicePercentage; affiliatePercentage = _affiliatePercentage; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x00762964227f2db1b8c811db1672c97b0ed47946.sol,PORTUGAL_WINS,"contract PORTUGAL_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 290684095692201000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0xf07d979303c50a8632848cb154c6b30980218c07.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x54794cfdbac9b9e58eb737643d9f0269ab5c8248.sol,SimpleERC20Token,"contract SimpleERC20Token { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x6d500e4b6565c3c25a6edd51839d52269e3d293f.sol,KiddyToys,"contract KiddyToys is ERC721, Ownable { event ToyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public toyIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public toyIdToApproved; mapping (uint256 => uint256) private toyIdToPrice; struct Toy { string name; }",1
0x54053ea92b9366182dbbf3e4583c8a5496bb2903.sol,CCD_KOHLE_3_20190411,"contract CCD_KOHLE_3_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0xeea8cd2150b0438555b515f0bdd1ded0d84eab8c.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0xc7b17e5ea5a3e4f3147167e7c165167f1a670ff7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0x330ac902cc4cb12e02249358dcfe3f60785e3439.sol,Easy30,contract Easy30 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 30 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614.sol,SAN,"contract SAN is Owned, ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 15; address CROWDSALE_MINTER = 0xDa2Cf810c5718135247628689D84F94c61B41d6A; address public SUBSCRIPTION_MODULE = 0x00000000; address public beneficiary; uint public PLATFORM_FEE_PER_10000 = 1; uint public totalOnDeposit; uint public totalInCirculation; function SAN() { beneficiary = owner = msg.sender; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x8476957a872ac0bc253333cc063b6a37f6a6faa3.sol,CINDICATORFund,"contract CINDICATORFund { mapping (address => uint256) public balances; mapping (address => bool) public voters; uint256 public votes = 0; bytes32 hash_pwd = 0x9f280e9af8b2203790b80a28449e312091a38cd80f67c9a7ad5a5ce1a8317f49; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 35 ether; address public sale = 0x0; function perform_withdraw(address tokenAddress) { require(bought_tokens); ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; require(token.transfer(msg.sender, tokens_to_withdraw)); }",1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x881f21d3e2d2d4f48d815f41bea8dbdcf0e24e50.sol,DepositVault,"contract DepositVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0x0f2d4c5c9dc5d1f7f9260e3d57ed2bbad742eba1.sol,DIR,"contract DIR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DIR() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa.sol,LIFECOIN,"contract LIFECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LIFECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000000; balances[0xD133cc957d41C0cd62ed6175155B2E54F951eA79] = _totalSupply; Transfer(address(0), 0xD133cc957d41C0cd62ed6175155B2E54F951eA79, _totalSupply); }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0x6feb3a071a2732378521c53d024b67ad068ec921.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2da35901659e6bc37045d4ea0a7eba88cb3d6b0a.sol,BLINK_Token,"contract BLINK_Token is IERC20, Ownable, SafeMath { string public symbol; string public name; uint public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(string _symbol,string _name,uint _decimals,uint totalSupply) public { symbol = _symbol; name = _name; decimals = _decimals; _totalSupply = totalSupply * 10 ** decimals; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9299ccef011d2d8faf76b214c8549c14bc918035.sol,ITGCToken,contract ITGCToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 8; uint public totalSupply = (20 * 10 ** 8 + 50) * 10 ** 8; constructor() public { balances[msg.sender] = totalSupply; },1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x541cdaae3d240aee1a79a7469c2f10b6dd98e4d7.sol,DAILYC,"contract DAILYC is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 200 * 10000 * 10000 * 10 ** 8; uint constant valueSale = 0; uint constant valueTeam = valueTotal / 100 * 100; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x0dee19332fb83fb343a9fbb722b5395b8e7c9d8d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0x6bef7336e8176ce577d32a4ffc8c7e87b726d4a3.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 4; _totalSupply = 5000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xa032e135d6509c7e13c43f07b567edf4071f5636.sol,CryptoExchangeCoin,"contract CryptoExchangeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 125000000000; balances[0x5A3022F4b72c720E616b1085296b2d133eb2f3F3] = _totalSupply; emit Transfer(address(0), 0x5A3022F4b72c720E616b1085296b2d133eb2f3F3, _totalSupply); }",1
0x849919acec8627dde44da59e1a9737985d022b9d.sol,ChatBitToken,"contract ChatBitToken is owned, TokenERC20 { uint256 public sellPrice = 20180418134311; uint256 public buyPrice = 1000000000000000000; uint256 public limitAMT = 0; bool public isPreSales = false; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ChatBitToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6d358ad6eca1461f092659797e8dceb2d5150fa6.sol,EthereumPrivate,"contract EthereumPrivate { string public name=; string public symbol=; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumPrivate() public { totalSupply = 960000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0xd0059e9d822c471f394ae5974d783e86b2aa0853.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd868be9b1d2391dfd635bea0fbb7f42a473e9af9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb3f48d38ace4b44c710ba32cb5aea66c0f533571.sol,AUTOCOIN,"contract AUTOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4] = _totalSupply; emit Transfer(address(0), 0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4, _totalSupply); }",1
0x54139aa6fd3a986b83b684d1a928fc79e3f35850.sol,BubbleCoin,"contract BubbleCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function BubbleCoin() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0xdb5f7df433ffba706d39dc9dd7b2d68459fc2c22.sol,TradeIO,contract TradeIO { address owner; mapping(bytes8 => string) dateToHash; modifier onlyOwner () { require(owner == msg.sender); _; },1
0x5270a37951f8c3ff2a99c6fb386cbc2aa63aa709.sol,WTI_301201,"contract WTI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11134262607820500000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b87999be87358065bbde41e8a0fe0b7b1cd2514.sol,TeslaWatt,"contract TeslaWatt is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x367125be15fc3a0d78321dafa75be6c8e0941921.sol,LanxangCash,"contract LanxangCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LanxangCash() public { symbol = ; name = ; decimals = 18; _totalSupply = 12000000000000000000000000; balances[0x5C4A7ca79a967E5d251195Bdb334983D066aA2A2] = _totalSupply; Transfer(address(0), 0x5C4A7ca79a967E5d251195Bdb334983D066aA2A2, _totalSupply); }",1
0x5a086708501251d2c948d767a88379f0b8d8c300.sol,WeduToken,contract WeduToken is ERC20Interface { string private TOKEN_NAME; string private TOKEN_SYMBOL; uint8 private DECIMAL; uint private WEDU_UNIT; address owner; mapping(address => bool) internal blackList; uint private totalSupplyValue; struct BalanceType { uint locked; uint unlocked; },1
0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7.sol,Bgc,"contract Bgc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bgc( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2eac4037a8df73f7ddde34b8153c16ded607ff8b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xec841073efd8e68ddffbd6cf440f2548684345ea.sol,GemCoin,"contract GemCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GemCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x1df6fC0743712B1Ee73e9C7A1A3eA82f07757721] = _totalSupply; Transfer(address(0), 0x1df6fC0743712B1Ee73e9C7A1A3eA82f07757721, _totalSupply); }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9.sol,Jiggs,contract Jiggs { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x35ced9349943292f8a3b2e0a96fec76d7877ac4e.sol,BancorKillerContract,"contract BancorKillerContract { using SafeMath for uint256; address public admin; address public base_token; address public traded_token; uint256 public base_token_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; bool public base_token_is_seeded; bool public traded_token_is_seeded; mapping (address => uint256) public token_balance; constructor(address _base_token, address _traded_token,uint256 _base_token_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = tx.origin; base_token = _base_token; traded_token = _traded_token; base_token_seed_amount = _base_token_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; }",1
0x340085ed7d6c18dcf4c8b661fba6bd95916c8644.sol,BoostPax,"contract BoostPax { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x33d514e149ca8405ad9644d5fd2384b645abd668.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,Contactable,contract Contactable is Ownable{ string public contactInformation; function setContactInformation(string info) onlyOwner public { contactInformation = info; },1
0x30dc851be3c09af90c0c8a9dfdd7db85b9d8b304.sol,Fpgcchain,"contract Fpgcchain{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Fpgcchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x01cd3d9df5869ca7954745663bd6201c571e05cf.sol,LULUToken,contract LULUToken is StandardToken { using SafeMath for uint256; string public name = ; string public symbol = ; string public releaseArr = ; uint public decimals = 18; function LULUToken() { totalSupply = 100000000000 * 1000000000000000000; balances[msg.sender] = totalSupply / 5; },1
0x70965361f143d268342c84b4d6f7c41b438cd5d7.sol,LuckcoinContract,"contract LuckcoinContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public LKCExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintLKCToken(msg.sender, (msg.value * LKCExchangeRate * 10**decimals) / etherChange); }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x5affe8b1f00df6c8120f7e6bc39713fce11f24ac.sol,VOCC_I049_20181211,"contract VOCC_I049_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7996f859a313aab6458558c648e2f1f4acbf5f93.sol,HealthAidToken,contract HealthAidToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 25000000000 * 100000000; function name() public constant returns (string) { return ; },1
0xf2bea87df174bee8a862e1395fc97084ac6e6e56.sol,Treasure,"contract Treasure is PlayerBook { uint private seed = 18; uint[3] public gameRound = [1, 1, 1]; uint[3] public maxKeys = [1200, 12000, 60000]; uint[3] public keyLimits = [100, 1000, 5000]; uint public keyPrice = 10 finney; uint public devFee = 10; uint public laffFee1 = 10; uint public laffFee2 = 1; address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5; mapping(uint => mapping(uint => RoundInfo)) public gameInfo; mapping(uint => mapping(uint => mapping(uint => uint))) public userAff; struct RoundInfo { uint module; uint rd; uint count; uint keys; uint maxKeys; uint keyLimits; uint award; address winner; bool isEnd; mapping(uint => uint) userKeys; mapping(uint => uint) userId; }",1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe3d474f3686a831bf380498d1dbd57fdf972ca30.sol,MaticNetwork,"contract MaticNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MaticNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply = 10000000000000000000000000000; balances[0xdC954B7BC91F60504ccC6fAb9dCD6C8259575f51] = _totalSupply; }",1
0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xecbed48098c4f25a16195c45ddf5fd736e28b14b.sol,UserfeedsClaimWithConfigurableTokenMultiTransfer,"contract UserfeedsClaimWithConfigurableTokenMultiTransfer is Destructible, WithClaim { function post(string data, address[] recipients, ERC20 token, uint[] values) public { emit Claim(data); transfer(recipients, token, values); }",1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x841b42c7ee6a15904d1926bf15ffdb6d30a77723.sol,GDC,"contract GDC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GDC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6dd2c2a82234d280e2b397db17b923fab49695e6.sol,DHSCToken,contract DHSCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 1000000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0x32e816ea26806edc713058068aef312a99cfd96c.sol,DMCHAIN,"contract DMCHAIN { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x87af260d1f637661dcecb6e4efcb4f74963c9539.sol,VINCI_301201,"contract VINCI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11063890721038700000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0xc165c159d3b19c36ca1a84f6841a801af47c9c03.sol,EBANKTOKEN,"contract EBANKTOKEN is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EBANKTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x6aeb95f06cda84ca345c2de0f3b7f96923a44f4c.sol,SafeMath,None,1
0x0d7b2ea059bbfdc99ee6ae6289939d84397e5b78.sol,NortontokenERC20,"contract NortontokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NortontokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x461d558429cb87a5faf967a4333d671b7a97c04f.sol,BOBOToken,"contract BOBOToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 295000000000000000000000000; balances[0xEDFfEaB5E58abAF81C62762DF71DC755fd787F6f] = _totalSupply; emit Transfer(address(0), 0xEDFfEaB5E58abAF81C62762DF71DC755fd787F6f, _totalSupply); }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonstersBase,"contract MonstersBase is MonsterAccessControl, MonstersData { event Transfer(address from, address to, uint256 tokenId); bool lockedMonsterCreator = false; MonsterAuction public monsterAuction; MonsterCreatorInterface public monsterCreator; function setMonsterCreatorAddress(address _address) external onlyAdmin { require(!lockedMonsterCreator); MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address); monsterCreator = candidateContract; lockedMonsterCreator = true; }",1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0xd8d94cfa0dc8898d13e6f9a1618c490f68c160dd.sol,MichaelCoin,"contract MichaelCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MichaelCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100; balances[0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25] = _totalSupply; Transfer(address(0), 0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25, _totalSupply); }",1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0x3513a1e5f29af91b3acaba9ab877026402b317e6.sol,verifier,contract verifier is owned{ struct action { uint timestamp; uint256 value; address from; },1
0x0e496fe351e9a2eabcc76d57b1248e10394d60be.sol,yiDaoGame,"contract yiDaoGame { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaoGame( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c591aaa5b18d6411b01c9e6862b155f0433a6c2.sol,PiaoPiaoToken,contract PiaoPiaoToken is LoveToken { mapping (address => uint256) balances; string public name; uint8 public decimals; string public symbol; string public loveUrl; function PiaoPiaoToken() { balances[msg.sender] = 5201314; totalSupply = 5201314; name = ; decimals = 0; symbol = ; },1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,StandarTokentokenGAT,"contract StandarTokentokenGAT is tokenGAT{ mapping (address => uint256) balances; mapping (address => uint256 ) weirecives; mapping (address => mapping (address => uint256)) allowed; function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; }",1
0xf4c1d8863820b5e66fee5ea5d247f597f73f91f6.sol,SBToken,contract SBToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xee284b58871645ce2656e309e238c5e2eace771a.sol,PornTokenV2,"contract PornTokenV2 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PornTokenV2( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 200; uint256 public blocksBeforeTargetShoot = 800; event death(address indexed player); event semiShot(address indexed player); event targetShot(address indexed player); constructor() public { },1
0x2e0b77cd408989a8f09e22d2c832be793f167aae.sol,FrameworkInvest,"contract FrameworkInvest is MintedCrowdsale,CappedCrowdsale, Ownable { mapping(address => bool) public owners; uint8 decimals = 18; enum CrowdsaleStage { PS_R1, PS_R2, PS_R3, PS_R4, PS_R5, PS_R6, PS_R7, ICO }",1
0x712742829b3181b45facca605c699d4479855c30.sol,StrongHands,"contract StrongHands is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StrongHands() public { symbol = ; name = ; decimals = 18; _totalSupply = 18984246847200000000000000000000; balances[0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9] = _totalSupply; Transfer(address(0), 0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9, _totalSupply); }",1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x05dab93a76f33fdb225e0a05cafbdd41612b88b6.sol,TeikhosBounty,contract TeikhosBounty { address public bipedaljoe = 0x4c5D24A7Ca972aeA90Cc040DA6770A13Fc7D4d9A; SHA3_512 public sha3_512 = SHA3_512(0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222); struct Commit { uint timestamp; bytes signature; },1
0xa34af5196a9dd30e85dd39e1632eb579e3427230.sol,Xerium,"contract Xerium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xerium() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0x5A86f0cafD4ef3ba4f0344C138afcC84bd1ED222] = _totalSupply; Transfer(address(0), 0x5A86f0cafD4ef3ba4f0344C138afcC84bd1ED222, _totalSupply); }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,Robincoin,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x205969440ffcf5493df62a974ad8a30ec96527ea.sol,NDD_DBX_I_883,"contract NDD_DBX_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 505773630192928000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5.sol,DYLC_ERC20Token,"contract DYLC_ERC20Token { address public owner; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 5000000000 * (10**18); uint256 public currentSupply = 0; uint256 public angelTime = 1522395000; uint256 public privateTime = 1523777400; uint256 public firstTime = 1525073400; uint256 public secondTime = 1526369400; uint256 public thirdTime = 1527665400; uint256 public endTime = 1529047800; uint256 public constant earlyExchangeRate = 83054; uint256 public constant baseExchangeRate = 55369; uint8 public constant rewardAngel = 20; uint8 public constant rewardPrivate = 20; uint8 public constant rewardOne = 15; uint8 public constant rewardTwo = 10; uint8 public constant rewardThree = 5; uint256 public constant CROWD_SUPPLY = 550000000 * (10**18); uint256 public constant DEVELOPER_RESERVED = 4450000000 * (10**18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x53f671aef0a803085f6e3a6c215dd88454394f3e.sol,WorldCupWinner,"contract WorldCupWinner { using SafeMath for uint256; event BuyWinner(address indexed buyer, uint256 indexed traddingTime, uint256 first, uint256 second, uint256 three, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerList(uint256 indexed first, uint256 indexed second, uint256 indexed third,address buyer, uint256 traddingTime, uint256 gameid, uint256 buyType, uint buyTotal,uint256 buyPrice); event BuyWinnerTwo(address indexed buyer, uint256 indexed first, uint256 indexed gameid,uint256 traddingTime, uint256 buyType,uint256 buyPrice,uint buyTotal); event ShareBonus(address indexed buyer, uint256 indexed traddingTime, uint256 indexed buyerType, uint256 gameID, uint256 remainingAmount); address public owner; uint[] _teamIDs; struct Game{ uint256 _bouns; uint[] _teams; uint256[] _teamPrice; uint _playType; bool _stop; uint256 _beginTime; }",1
0x1d8ed4b0a3147ed17ea09582b46e0c9635396720.sol,IamRich,"contract IamRich is owned, TokenERC20 { uint256 public buyPrice = 10 * 1 ether; uint public boughtNum = 0; function IamRich() TokenERC20() public {}",1
0xf3620846825ba198be14cdbc5f2b41bbff788d67.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x421a0ee46dbfee7f65076c7e0c32fa86918bf62d.sol,BBX,"contract BBX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BBX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x322909bb3aa921f101d829c0edf57493468d9bd4.sol,Guestbook,contract Guestbook { struct Entry{ address owner; string alias; uint timestamp; uint donation; string message; },1
0x5acd07353106306a6530ac4d49233271ec372963.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x72907f5d1417404d9e4963d53107ddd4237aa10d.sol,ecothereum,"contract ecothereum is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ecothereum ( ) public { totalSupply = 41000000 * 10e17; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7.sol,Bgc,"contract Bgc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bgc( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4083c75ab1f20ac0a1787a591c98bacd43ae777a.sol,Brainmab,"contract Brainmab { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public { balances[msg.sender] = 14000000000000000000000000000; totalSupply = 14000000000000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xf29e2bcde0ed59252df2f4b4f3867599dd06b687.sol,SenbitTokenSBIT,"contract SenbitTokenSBIT{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function SenbitTokenSBIT() public{ balanceOf[msg.sender] = 300000000 * (10**18); totalSupply = 300000000 * (10**18); name = ; symbol = ; decimals = 18; }",1
0x3485b9566097ad656c70d6ebbd1cd044e2e72d05.sol,PinkyToken,"contract PinkyToken is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 10000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PinkyToken(){ balanceOf[msg.sender] = totalSupply; }",1
0x02169578b41b8f7f5f2dd0491aa2682a13196c44.sol,KillahyToken,"contract KillahyToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KillahyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x821ca1b7919200Ff99495466e13CA3b3135c1668] = _totalSupply; Transfer(address(0), 0x821ca1b7919200Ff99495466e13CA3b3135c1668, _totalSupply); }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,TokenRecipient,"contract TokenRecipient { event ReceivedEther(address indexed sender, uint amount); event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData); function receiveApproval(address from, uint256 value, address token, bytes extraData) public { ERC20 t = ERC20(token); require(t.transferFrom(from, this, value)); ReceivedTokens(from, value, token, extraData); }",1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x190e569be071f40c704e15825f285481cb74b6cc.sol,FAMEToken,contract FAMEToken is ERC20Standard { function FAMEToken() { totalSupply = 2100000 szabo; name = ; decimals = 12; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0xa5763bf433f2f154b798b924fb2f6c54137b3522.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b35e0ab998ebe8414871c13cf778f9d0bbdf609.sol,SWPToken,"contract SWPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public swpFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant swpFund = 75000000 * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+2 days) return 3500; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+5 days) return 2700; return 2200; }",1
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol,SurgeToken,"contract SurgeToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SurgeToken( ) TokenERC20(100000000, , ) public { owner = msg.sender; }",1
0x0da1c6228c8e4b666b0ddf4c391bf24e70b7e19e.sol,Token,"contract Token is EIP20Interface, Ownable, SafeMath, Mintable, Lockable, FeeCalculator { mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => bool) frozenAddresses; string public name; uint8 public decimals; string public symbol; bool public isBurnable; bool public canAnyoneBurn; modifier notFrozen(address target) { require(!frozenAddresses[target]); _; }",1
0x6cbc27eb873af5eb177671f45dd02be0b9416fd1.sol,SSSToken,contract SSSToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 2100000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x4c8c4659f734294d9561c8b0efc210028ed12052.sol,company_acc,contract company_acc { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc209a261dae1dc7caa5b02a54874c85a69de5c9ddc0b0bebdbfa9a394fb24caf; constructor() public { owner = msg.sender; },1
0x945d886e3859cc683c368ee3390b1c2c332dde46.sol,MultiTransfer,"contract MultiTransfer { event Transacted( address msgSender, address toAddress, uint value ); function multiTransfer( address _from, address[] _to, uint[] _amount ) public payable { require(msg.sender == _from); require(_to.length == _amount.length); uint256 ui; uint256 amountSum = 0; for (ui = 0; ui < _to.length; ui++) { require(_to[ui] != address(0)); amountSum = amountSum + _amount[ui]; }",1
0x71e1f8e809dc8911fcac95043bc94929a36505a5.sol,ChiToken,"contract ChiToken is ERC20 { string public name = ; string public symbol = ; uint256 _totalSupply = 10000000000; uint256 public decimals = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ChiToken() public { balances[msg.sender] = _totalSupply; }",1
0x2051f57c5c1539c17e7d22caf46c83f861bd8e81.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe25c541b11c84ee7fecb68641a0989de76b78f1271dae8d8bd9c93b2ae3a6cc9; constructor() public { owner = msg.sender; },1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x537c23b71d847eef947f150ac7e33b1854138d5c.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 50000 * 10 ** uint256(decimals); string public contract_link = ""https: mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { owner = 0xCD6011A9D3995A693F9964608D08EDbb48220225; balanceOf[owner] = totalSupply; }",1
0x1c3a7bafd90133756ac63fee437844c47f707420.sol,ZenswapDistribution,contract ZenswapDistribution is Ownable { token public tokenReward; constructor() public { tokenReward = token(0x4fa000dF40C06FC8c7D9179661535846B7Cd4f87); },1
0xc2149ced2e1e6fc976c24391059b09fbe970cafe.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6bf91fa5472b5a28278b5027e9120c78f1df4127.sol,LiteCoin_Smart,contract LiteCoin_Smart is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10000; function name() public constant returns (string) { return ; },1
0xc7cbd16654cf938e6c9cc3ade88ae9ee21c27edf.sol,CTSCToken,"contract CTSCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CTSCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1250000000000000000000000000; balances[0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f] = _totalSupply; Transfer(address(0), 0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f, _totalSupply); }",1
0x054d5ffadd9aa805544b774681b9fbdec72ca57c.sol,BANK_II_PFII_883,"contract BANK_II_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 427084638464841000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0x6cb816569ab4665bdc2ba78a64aff87201608bc6.sol,Bitmos,"contract Bitmos is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitmos( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0xef47dd38cc0c2856a27fb1964b066ec33426e979.sol,DBXCContract,"contract DBXCContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x341199e2387bcf1c356881f4bb5dedbe33ab26b1.sol,SHERE_PFIII_I_883,"contract SHERE_PFIII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 744212612048926000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1fd159fa190ab588f60699ef6def984602dd8c5b.sol,HAPYToken,"contract HAPYToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HAPYToken() public { totalSupply = 2999999999 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,token,"contract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Creditcoin,contract CreditcoinBase is Owned { uint8 public constant decimals = 18; uint256 internal constant FRAC_IN1UNIT = 10 ** uint256(decimals); uint256 public constant creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT; uint256 public constant initialSupplyInFrac = creditcoinLimitInFrac * 30 / 100; },1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xa2d8fa4a15943f32f1bda104308519d33ad894ec.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0dabaea13982b659ffa03c02307ce1e5a04dc657.sol,ERC20TOKEN,"contract ERC20TOKEN is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x38f374dd8705d75cc8b7ebbacbe25ad57d22986b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x544a1abc3c932847fd1049ee55e0d0e1eeb3dc80.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc5fdada86ba48ae58214a1d6bac3c0207862ffd0302738847798a4843e4cc242; constructor() public { owner = msg.sender; },1
0x0ed74a3ecc90270d18a3b3a8eb0042a7cdd03b19.sol,MINEX,"contract MINEX { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MINEX() { balanceOf[msg.sender] = 2999029096950000; totalSupply = 2999029096950000; name = ; symbol = ; decimals = 8; }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x52fb36c83ad33c1824912fc81071ca5eeb8ab390.sol,TOKENERC20,"contract TOKENERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TOKENERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xebafa3504fa15e481b45ab1ca8b75923d7570f5c.sol,ARGENTINA_WINS,"contract ARGENTINA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 127901002104568000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x26497b895c43b84bc9d5c33702dce87c1358a502.sol,SETC,"contract SETC is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SETC( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x8b5e31d05c3df25f809f2f82af098e8396ad82c8.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { event PayDividend(address indexed to, uint256 amount); event HangingDividend(address indexed to, uint256 amount) ; event PayHangingDividend(uint256 amount) ; event Deposit(address indexed sender, uint256 value); struct EmissionInfo { uint256 totalSupply; uint256 totalBalanceWas; }",1
0x72907f5d1417404d9e4963d53107ddd4237aa10d.sol,ecothereum,"contract ecothereum is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ecothereum ( ) public { totalSupply = 41000000 * 10e17; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,LoliCoin,"contract LoliCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LoliCoin() TokenERC20() public {}",1
0x1e2bbf1578d1ecd107c95ab550f8c9559a0acca6.sol,Tbyc,"contract Tbyc { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tbyc() { owner = 0x0a09B58084554786215Dabe7Ab645cB17b1e490E; name = ; symbol = ; decimals = 18; totalSupply = 1314000000000000000000000000; balanceOf[owner] = 1314000000000000000000000000; }",1
0x0078bd770f55a3c6b8f3b3d2a0c21fcac8a92394.sol,SetLibrary,None,1
0x342f4057110be50957d0f156f4939a929944c69e.sol,MultiWhitelist,contract MultiWhitelist { address public owner; function MultiWhitelist(address _owner) public { owner = _owner; },1
0x51344e5ca564d1b8f05bdb483305a3cafec3df78.sol,Token,contract Token is BurnableToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public constant initialSupply = 1000000000 * (10 ** uint256(decimals)); function Token () { totalSupply = initialSupply; balances[msg.sender] = initialSupply; allowedAddresses[owner] = true; },1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0xeead74c98c573b43a1af116be7c4debb0a4fd4a8.sol,Line,"contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public denominator = 100; uint public jackpot = 0; event Jackpot(uint line, address addr, uint date, uint prize, uint left); event Win(uint line, address addr, uint date, uint prize, uint left); event JackpotIncreased(uint date, uint jackpot); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x5c404f7f092ebb744a006dffa597285ec3df465d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7704eaee68e4c0eb3ee47382391d0227a44bbac8.sol,SISKCoin,"contract SISKCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SISKCoin() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 52 weeks; }",1
0xf45ee2519203fe8b77c1f05de75cf5f405bf9011.sol,token,"contract token { string public standard = 'https: string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x4bd3aac60b2e8893913b8398edda362e6b46dd98.sol,CryptoPoliceOfficerToken,"contract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable { using MathUtils for uint; string public name; string public symbol; uint8 public decimals = 18; mapping(address => mapping(address => uint)) allowances; bool public publicTransfersEnabled = false; uint public releaseStartTime; uint public lockedAmount; TokenLock[] public locks; struct TokenLock { uint amount; uint timespan; bool released; }",1
0xeee07485b432c56d38bb7e1a8f5d57322cb78f89.sol,TokenMyUnicoin,"contract TokenMyUnicoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMyUnicoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xf46ec74202f414a8c05f9db7ff60869eb750d1c9.sol,SHERE_PFV_III_883,"contract SHERE_PFV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 2180230364645770000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf22480ac062f109420595b522c095eaf60867e15.sol,I2Crowdsale,"contract I2Crowdsale is Ownable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; uint public usd = 550; uint public tokensPerDollar = 10; uint public bonus = 30; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function I2Crowdsale ( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers.mul(1 ether); deadline = now.add(durationInMinutes.mul(1 minutes)); price = 10**18 / tokensPerDollar / usd; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x74e345b0597ea3bc5762df0092e6bf8c891a7d0f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x6c940a8d477922f1cffe012449321098e06db3f7.sol,CryptoGain,contract CryptoGain { using SafeMath for uint256; struct Bid { address player; uint8 slot_from; uint8 slot_to; },1
0x338683298798ffefb4cabeb9ef3a18915b3a42e3.sol,ProofOfCloneWars,contract ProofOfCloneWars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x20d88cfc6d23d06c98d7661aded19043e9ee5aa0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x898545050a2739c349df55813bded581e6f2bb8b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f.sol,token123,contract token123 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token123() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0xe0a8a9b7c821d9bbd66b826129d4cf1b219ebb3a.sol,CryptoRides,"contract CryptoRides is ERC721 { event Created(uint256 tokenId, string name, bytes7 plateNumber, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, bytes7 plateNumber); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public tokenIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; mapping (uint256 => uint256) private tokenIdToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Ride { string name; bytes7 plateNumber; }",1
0x1b528346f0631dc465813a757eaf38035b44b9e4.sol,KCBToken,"contract KCBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KCBToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0x4bb936f3ec75fc9f7d6f5ea3ad9837383c23703c.sol,StattmToken,contract StattmToken is MintableToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping(address => bool) public isWhiteListed; function burn() public { uint256 _b = balanceOf(msg.sender); balances[msg.sender] = 0; totalSupply_ = totalSupply_ - _b; },1
0xeca0415f309789ade195a51988d760b6d51f5de9.sol,GreenMed,"contract GreenMed is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 100000000000000000000000000; address public owner; uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xd0d916322b02b7a8095af4bb69bea0e9d93cf3b1.sol,WTI_10_20210916,"contract WTI_10_20210916 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8470c0012ebd1201641620df2ac8600a402725b1.sol,MerialCoin,"contract MerialCoin { using SafeMath for uint256; string public symbol; string public name; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAddress; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenAddress(address indexed target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor () public { name = ; symbol = ; decimals = 18; totalSupply = 1000000000 * 10 ** uint256(decimals); owner = msg.sender; balanceOf[msg.sender] = totalSupply; }",1
0x1ba20a713f82b2483aa393de0c5da67d146f4bd7.sol,EMJAC,"contract EMJAC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EMJAC() public { symbol = ; name = ; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); }",1
0x19816294969ec8745a402133bf7c256c02eeabc9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5c404f7f092ebb744a006dffa597285ec3df465d.sol,LNTToken,"contract LNTToken is owned, TokenERC20 { event mylog(uint code); function LNTToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) payable public {}",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x0da1c6228c8e4b666b0ddf4c391bf24e70b7e19e.sol,Token,"contract Token is EIP20Interface, Ownable, SafeMath, Mintable, Lockable, FeeCalculator { mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => bool) frozenAddresses; string public name; uint8 public decimals; string public symbol; bool public isBurnable; bool public canAnyoneBurn; modifier notFrozen(address target) { require(!frozenAddresses[target]); _; }",1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6bf91fa5472b5a28278b5027e9120c78f1df4127.sol,LiteCoin_Smart,contract LiteCoin_Smart is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10000; function name() public constant returns (string) { return ; },1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x8c211128f8d232935afd80543e442f894a4355b7.sol,SNcoin_Token,"contract SNcoin_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint private constant _totalSupply = 100000000 * 10**uint(decimals); mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; struct LimitedBalance { uint8 limitType; uint initial; }",1
0x37f16599a7a4ba385770dbc3c143485fc2b709ce.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 36000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc.sol,Deed,contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; },1
0xaa8aec21ca455873f63bdd570d81674ae5bb73d5.sol,AntPetTempleToken,"contract AntPetTempleToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AntPetTempleToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x6cc07cb2d1d354f9e2042a26697e7fe9cec4656c.sol,ERGCOIN,contract ERGCOIN is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 800000000 * 10**18; function name() public constant returns (string) { return ; },1
0xef4bbb338e2d21ffcbde49ea2b94befe2bba05f1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1758e5afccd53f6eaaa3039bc44d0e1f7bf6e476.sol,Whitelist,contract Whitelist is Ownable { mapping(address => uint256) public whitelist; event Whitelisted(address indexed who); uint256 public nextUserId = 1; function addAddress(address who) external onlyOwner { require(who != address(0)); require(whitelist[who] == 0); whitelist[who] = nextUserId; nextUserId++; emit Whitelisted(who); },1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0x920231a0e58d685f29ca3838777093fad88f665f.sol,Moongang,contract Moongang { modifier onlyOwner { require(msg.sender == owner); _; },1
0x788ca5935759c06ea223d0e2cf5ea5729d669c18.sol,BancorConverter,"contract BancorConverter is ITokenConverter, SmartTokenController, Managed { uint32 private constant MAX_WEIGHT = 1000000; uint32 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Creditcoin,contract CreditcoinBase is Owned { uint8 public constant decimals = 18; uint256 internal constant FRAC_IN1UNIT = 10 ** uint256(decimals); uint256 public constant creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT; uint256 public constant initialSupplyInFrac = creditcoinLimitInFrac * 30 / 100; },1
0x27eb46f50f1850be1fffa943822e00bb0377974a.sol,KittyClub99,contract KittyClub99 { string public name = ; string public symbol = ; uint256 public decimals = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 99; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x3a57137eb81e70fe3975f8121a913d5d033f81b3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x945d886e3859cc683c368ee3390b1c2c332dde46.sol,MultiTransfer,"contract MultiTransfer { event Transacted( address msgSender, address toAddress, uint value ); function multiTransfer( address _from, address[] _to, uint[] _amount ) public payable { require(msg.sender == _from); require(_to.length == _amount.length); uint256 ui; uint256 amountSum = 0; for (ui = 0; ui < _to.length; ui++) { require(_to[ui] != address(0)); amountSum = amountSum + _amount[ui]; }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,LogFile,contract LogFile { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x03a2f2eb836fdd6ef462edc65bccd358ba1f2375.sol,BasicToken,"contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; struct WalletData { uint256 tokensAmount; uint256 freezedAmount; bool canFreezeTokens; }",1
0x28df3fcb53b5efd091d816749d500c2e7c88d369.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0xf3066d8ce545ddf5dc758d261470f9575365999a.sol,TBC,"contract TBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() { totalSupply = 500000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,AdvHajjToken,"contract AdvHajjToken is owned, HajjERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) HajjERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6c46b734d5a94b10929ac4e88f22cc56145bc65c.sol,AMOT__20230515,"contract AMOT__20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15538797795124200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x333f37329c6d2346001501f235d33bf68ec1cf5e.sol,BloquidIssuer,contract BloquidIssuer is Ambi2EnabledFull { AssetProxy public assetProxy; function setupAssetProxy(AssetProxy _assetProxy) onlyRole() returns(bool) { if ((address(assetProxy) != 0x0) || (address(_assetProxy) == 0x0)) { return false; },1
0x72d2da71d6ea20c63a4f23b888ea70dc044f6800.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0e6664cdb81ddf20d776b3bcb001797cee4030bc.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x656610729fc13e8283d96aa69cdf56c112222951.sol,JeopardyJack,contract JeopardyJack { bytes32 private answerHash; uint private isActive; Guess[] public Guesses; string public Riddle; string public Answer; struct Guess { address player; string guess; },1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0x6b0611c65b53e72429d799ed512d0da123ac0fb9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5c3d0012ff81bb9a19d13f8e512d3e72843f0848.sol,RBAC,"contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); function checkRole(address _operator, string _role) public view { roles[_role].check(_operator); }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f.sol,POTJ,contract POTJ { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26998144da0e9e7a960ee1d6cdfd7bf8c6b496a2.sol,AILiteCoin,"contract AILiteCoin { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x38897c62a4ddcd66a77bfc94e0f93fd4525b7d84.sol,IFcoin,contract IFcoin { uint private constant _totalSupply = 2500000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function IFcoin() { balances[msg.sender] = _totalSupply; },1
0x76c6a8d8bd3ffc0bc0a3198cee1f59fc75bf7d67.sol,PLXE,"contract PLXE is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PLXE( ) TokenERC20() public {}",1
0xd5dfe9e9e6df35d2aefdb0ce6d3e91b6890923d6.sol,VOCC_I062_20181211,"contract VOCC_I062_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x77af8c290d10882f634267177128cc7d1e893785.sol,GlobalTransportServices,"contract GlobalTransportServices is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x33d514e149ca8405ad9644d5fd2384b645abd668.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xdb7c83df286f5d9c44aec3d128dad6fee05dc6d1.sol,CARDToken,"contract CARDToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CARDToken() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x33a0924b74b8ec4bc654a5dfd6603a7c27ab0af4.sol,MWorld,"contract MWorld is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MWorld() public { symbol = ; name = ; decimals = 8; _totalSupply = 200000000000000000; balances[0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2] = _totalSupply; Transfer(address(0), 0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2, _totalSupply); }",1
0x0e171f41ac484d283de20e9a02eac893d430a016.sol,EGYPT_WINS,"contract EGYPT_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1755731937980890000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,Bitscreen,contract Bitscreen { struct IPFSHash { bytes32 hash; uint8 hashFunction; uint8 size; },1
0x8370b2d10956b9fa1db7faf14bac188a367fe7df.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x190e569be071f40c704e15825f285481cb74b6cc.sol,FAMEToken,contract FAMEToken is ERC20Standard { function FAMEToken() { totalSupply = 2100000 szabo; name = ; decimals = 12; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x286e1b439e616b06f55f801fbcc5f0747e3d9645.sol,XRUN,"contract XRUN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x36ebdbe660c0b988b83c257a779b908697d41615.sol,ArteufToken,contract ArteufToken is Ownable{ string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000 * 10**18; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xf22480ac062f109420595b522c095eaf60867e15.sol,I2Crowdsale,"contract I2Crowdsale is Ownable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; uint public usd = 550; uint public tokensPerDollar = 10; uint public bonus = 30; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function I2Crowdsale ( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers.mul(1 ether); deadline = now.add(durationInMinutes.mul(1 minutes)); price = 10**18 / tokensPerDollar / usd; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x3595279a9f0658eb2649976f155111bae1ae9de6.sol,GGE,"contract GGE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GGE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x035c8119a68a8f762fe2731fa190a5afcba653a3.sol,RVLS,"contract RVLS { string public name; string public symbol; uint8 public decimals = 5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RVLS( ) public { totalSupply = 1000000000000000; balanceOf[msg.sender] = 1000000000000000; name = ; symbol = ; }",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdb1f3030532a593a733f8ae6fce310aa91ac3a17.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721Interface { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner); event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner); event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner); event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner); event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId); event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId); event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId); event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0xf213d198b68b10654c63a9ed05a045e1d4a50f9f.sol,FootballerBase,"contract FootballerBase is FootballerAccessControl { using SafeMath for uint256; event Create(address owner, uint footballerId); event Transfer(address _from, address _to, uint256 tokenId); uint private randNonce = 0; struct footballer { uint price; uint defend; uint attack; uint quality; }",1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x57d8b41c0f22c39ba2934cfb038f4460904e3fda.sol,MJCToken,"contract MJCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MJCToken( ) TokenERC20() public {}",1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x40eb7549cb14d3ed0b165ade56dcfdb6352b4fdd.sol,SendLove,"contract SendLove is Ownable { function multisend(address _tokenAddr, address[] _to, uint256[] _value) returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 150); for (uint8 i = 0; i < _to.length; i++) { assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true); }",1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd86f790b2bfca7b224165662ae5bb21663a999a1.sol,GCRTokenERC20,"contract GCRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 18; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCRTokenERC20() { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 100000000; name = ; symbol = ; }",1
0x6f3f21e65e618592f95d5f3a2e7e1b1425309ff2.sol,GILToken,"contract GILToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GILToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0xdd16c70aD270633edF69174b4269914De9434bf8] = _totalSupply; Transfer(address(0), 0xdd16c70aD270633edF69174b4269914De9434bf8, _totalSupply); }",1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,WETH9,"contract WETH9 { string public name = ; string public symbol = ; uint8 public decimals = 18; event Approval(address indexed src, address indexed guy, uint wad); event Transfer(address indexed src, address indexed dst, uint wad); event Deposit(address indexed dst, uint wad); event Withdrawal(address indexed src, uint wad); mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; function() public payable { deposit(); }",1
0x850c430378909ba9ff2494d0a4df17928e99f8f4.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x537c23b71d847eef947f150ac7e33b1854138d5c.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 50000 * 10 ** uint256(decimals); string public contract_link = ""https: mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { owner = 0xCD6011A9D3995A693F9964608D08EDbb48220225; balanceOf[owner] = totalSupply; }",1
0xbe2a1d562817b6064e0568a4dc9e2c80f7478dfe.sol,TSCoin,"contract TSCoin { uint256 totalSupply_; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant initialSupply = 200000000*(10**uint256(decimals)); uint256 public buyPrice; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function totalSupply() public view returns (uint256){ return totalSupply_; }",1
0x6e10e8f202ced220791043df74aa84615caec537.sol,KittyToken,"contract KittyToken is AccessAdmin, ERC721 { using SafeMath for SafeMath; event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); struct Kitty { uint32 kittyId; }",1
0xa1506902f8ca82dace3176575e740c78aa29fc02.sol,Storage,"contract Storage { bytes32[] public data; bool readOnly; function uploadData(bytes _data) public { require(readOnly != true); uint index = data.length; for(uint i = 0; i < _data.length / 32; i++) { bytes32 word; assembly { word:= mload(add(_data, add(32, mul(i, 32)))) }",1
0x54345d405d4f459c22954b1a233cd42bfd3a9262.sol,ERC23PayableToken,"contract ERC23PayableToken is BasicToken, ERC23{ function transfer(address to, uint value, bytes data){ transferAndPay(to, value, data); }",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,Storage,"contract Storage is SafeMath, StringMover { function Storage() public { controllerAddress = msg.sender; }",1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x2134057c0b461f898d375cead652acae62b59541.sol,CoxxxCoin,"contract CoxxxCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoxxxCoin( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x77b3106417d4cf3138882cc21d4710c71183b707.sol,Brave3d,contract Brave3d { struct Stage { uint8 cnt; uint256 blocknumber; bool isFinish; uint8 deadIndex; mapping(uint8 => address) playerMap; },1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,Controllable,contract Controllable is Ownable { mapping(address => uint256) private contractIndices; address[] private contracts; modifier onlyActiveContracts() { require(contractIndices[msg.sender] != 0); _; },1
0x27798734d18d63b963137a360cadff807d479e50.sol,TokenERC20,"contract TokenERC20 is ERC20Basic{ string public name; string public symbol; uint8 public decimals = 4; uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _allowance; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) public { _supply = initialSupply * 10 ** uint256(decimal); _balances[msg.sender] = _supply; name = tokenName; symbol = tokenSymbol; decimals = decimal; }",1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0xa52b0a032139e6303b86cfeb0bb9ae780a610354.sol,ETPMap,"contract ETPMap{ mapping (address => string) internal address_map; event MapAddress(address, string); function get_address(address addr) constant public returns (string) { return address_map[addr]; }",1
0x5cc0076a6bbf43344a7923c5cca40f5bdff2970e.sol,LiteToken,"contract LiteToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LiteToken() public { symbol = ; name = ; decimals = 4; _totalSupply = 84000000000000; balances[0x186d32c30f1DeFfF1eeDb34Ee661426918243545] = _totalSupply; emit Transfer(address(0), 0x186d32c30f1DeFfF1eeDb34Ee661426918243545, _totalSupply); }",1
0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa.sol,LIFECOIN,"contract LIFECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LIFECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000000; balances[0xD133cc957d41C0cd62ed6175155B2E54F951eA79] = _totalSupply; Transfer(address(0), 0xD133cc957d41C0cd62ed6175155B2E54F951eA79, _totalSupply); }",1
0x3a86435776de97b5a481c395159c3b31cec966f6.sol,VOCC_I086_20181211,"contract VOCC_I086_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x3365560754379382d568be87a70dbb0254bae642.sol,LionShare,"contract LionShare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LionShare() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0] = _totalSupply; Transfer(address(0), 0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0, _totalSupply); }",1
0x474b4642fa37528652e907a2a3ef7ded8fec8cc8.sol,Cyberminer,"contract Cyberminer is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Cyberminer( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4c1d8863820b5e66fee5ea5d247f597f73f91f6.sol,SBToken,contract SBToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 100000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x585a5601e2d95e988dc51a12759c0ca8309f4483.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdcc2a9c95518a1196896bd116334c1eb1b6785ad.sol,CGTToken,"contract CGTToken is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) internal allowed; function CGTToken() public { symbol = ; name = ; decimals = 2; _totalSupply = 10000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0x1e172788434e2e2bdee70df0cf552d8da3fe7a65.sol,IVNT5Token,"contract IVNT5Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xBe0B705D79dD99aA8512A16d0256fA5b864e6c59; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x5c921ea0305206b8fe09d94f01e70a6ab4177710.sol,SimpleAudit,"contract SimpleAudit { event AuditLog(bytes32 goeureka_audit_ref, string reference); struct Audit { string reference; bool exist; }",1
0x365a3335866ac0b5f7002608eae1043d526f44d7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x0c72ab6f7fa937e637f4741ab8e61500ab33c24e71bd88c81eb458dde498338b; constructor() public { owner = msg.sender; },1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0x6e0f459e84c3d37c77d8eb04729b82b7ae088669.sol,BOOToken,"contract BOOToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BOOToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x490dbf7884b8e13c2161448b83dd2d8909db48ed.sol,Curate,"contract Curate is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Curate() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x604d0523bE64C34ffF0686f23b035EBe88B6AC52] = _totalSupply; Transfer(address(0), 0x604d0523bE64C34ffF0686f23b035EBe88B6AC52, _totalSupply); }",1
0x28577a6d31559bd265ce3adb62d0458550f7b8a7.sol,CCCToken,"contract CCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CCCToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x293f4f057a37f3b1806dbb362bddb242c0c39add.sol,MINNYCoin,"contract MINNYCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb47e9b43ee0772abac3856a1adf8f90c0e6c1067.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x5c5abd9c0f1c9b7305334944f47caa4b32703eef.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xbd8b5ce4c64bdee0f33989e87bae71b3392924d2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0x05abd85cc4424cbb7029b9a078f2c58793fd3e14.sol,WyoMesh,contract WyoMesh { struct Device { string name; bool permissioned; },1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0x48729a6e02e62ff5780e7b0eef200420e802d174.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xd5e1f90d918fd871fa0aba9aea54bb07e6382299.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3aac808b10eb65b74b59deb4f1998b52327bd1a.sol,InsightsNetwork1,contract InsightsNetwork1 { address public owner; address public successor; mapping (address => uint) public balances; mapping (address => uint) public unlockTimes; bool public active; uint256 _totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; function InsightsNetwork1() { owner = msg.sender; active = true; },1
0xf355164187e533b1969b4de46737c4e8bc9ae7e2.sol,MASToken,"contract MASToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MASToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x04247b9b59091b349eb60e429fe7dbc99fdad34b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 initialSupply=130000000; string tokenName=; string tokenSymbol=; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1758e5afccd53f6eaaa3039bc44d0e1f7bf6e476.sol,Whitelist,contract Whitelist is Ownable { mapping(address => uint256) public whitelist; event Whitelisted(address indexed who); uint256 public nextUserId = 1; function addAddress(address who) external onlyOwner { require(who != address(0)); require(whitelist[who] == 0); whitelist[who] = nextUserId; nextUserId++; emit Whitelisted(who); },1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,ActionAuction,"contract ActionAuction is AccessNoWithdraw { using SafeMath for uint256; event AuctionCreate(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionSold(uint256 indexed index, address indexed seller, address indexed buyer, uint256 tokenId, uint256 price); event AuctionCancel(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionPriceChange(uint256 indexed index, address indexed seller, uint256 tokenId, uint64 newGwei); struct Auction { address seller; uint64 tokenId; uint64 price; uint64 tmStart; uint64 tmSell; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherBase,"contract AetherBase is AetherAccessControl { event Construct ( address indexed owner, uint256 propertyId, PropertyClass class, uint8 x, uint8 y, uint8 z, uint8 dx, uint8 dz, string data ); event Transfer( address indexed from, address indexed to, uint256 indexed tokenId ); enum PropertyClass { DISTRICT, BUILDING, UNIT }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x55b7da636a3182d4cc2d5e23c965e7f8ba381d3e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x40dd310797fd55e7ca93b974fba140779f30d645.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply / 2; balanceOf[this] = totalSupply / 2; name = tokenName; symbol = tokenSymbol; }",1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0x703ab45e12a509e1a6430b0f1c9576c6b3075dd2.sol,Elythrium,"contract Elythrium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Elythrium() public { symbol = ; name = ; decimals = 2; _totalSupply = 10000000000; balances[0xe060ea1402e5713c5E140054B1e1c253137E4636] = _totalSupply; Transfer(address(0), 0xe060ea1402e5713c5E140054B1e1c253137E4636, _totalSupply); }",1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x3a6e5f1c1b0de5d2b46babd21c7844c96f5180aa.sol,SniperBillion,contract SniperBillion is modularBillion { using SafeMath for *; using Array256Lib for uint256[]; address constant private comReward_ = 0x8Aa94D530cC572aF0C730147E1ab76875F25f71C; address constant private comMarket_ = 0x6c14CAAc549d7411faE4e201105B4D33afb8a3db; address constant private comICO_ = 0xbAdb636C5C3665a969159a6b993F811D9F263639; address constant private donateAccount_ = 0x1bB064708eBf4763BeB495877E99Dfeb75198942; RubyFundForwarderInterface constant private Ruby_Fund = RubyFundForwarderInterface(0x7D653E0Ecb4DAF3166a49525Df04147a7180B051); SniperBookInterface constant private SniperBook = SniperBookInterface(0xc294FA45F713B09d865A088543765800F47514eD); string constant public name = ; string constant public symbol = ; uint256 constant private icoEndTime_ = 24 hours; uint256 constant private maxNumber_ = 100000000; uint256 public totalSum_; uint256 public rID_; uint256 public icoAmount_; bool private isDrawed_ = false; uint256 lastSID_; uint256[] private globalArr_; uint256[] private icoSidArr_; uint256[] private luckyPotBingoArr_; uint256[] private airdropPotBingoArr_; mapping (address => uint256) public sIDxAddr_; mapping (bytes32 => uint256) public sIDxName_; mapping (uint256 => uint256) public sidXnum_; mapping (uint256 => SPBdatasets.Sniper) public spr_; mapping (uint256 => SPBdatasets.Round) public round_; mapping (uint256 => mapping (bytes32 => bool)) public sprNames_; constructor() public { },1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0xc10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e.sol,Zamok,contract Zamok { uint256 public zamokCount; function Zamok() public { zamokCount = 0; },1
0xf4b9240ab85dbd01fcd698a072aed4413d97eed4.sol,MemoLandCoin,"contract MemoLandCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MemoLandCoin() public { symbol = ; name = ; decimals = 5; _totalSupply = 117000000000000; balances[0x859FfAA045424384657Edf37DCF52828292F6476] = _totalSupply; Transfer(address(0), 0x859FfAA045424384657Edf37DCF52828292F6476, _totalSupply); }",1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0x17c8d8b7659141273a1c2223030c89b96713a44a.sol,XPS,"contract XPS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XPS( ) public { totalSupply = 20000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd3676a37a23ad8f4238064c1edc704debf335f26.sol,CariNetPrivilege,"contract CariNetPrivilege { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CariNetPrivilege ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3324d52c43952d53cf28b421c813efdc9c85af55.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0xdff95d14094b92ad5dd042fdb47b6f25f33fbbaa.sol,DiXiEnergy,contract DiXiEnergy is Limitedsale { string public standart = ; string public name = ; string public symbol = ; uint8 public decimals = 2; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; },1
0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f.sol,HEART,"contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6bf91fa5472b5a28278b5027e9120c78f1df4127.sol,LiteCoin_Smart,contract LiteCoin_Smart is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10000; function name() public constant returns (string) { return ; },1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x1c242bc9af8aa768a54222ed47bb756f1a1a757b.sol,LockableFreezableBurnablePausableERC20Token,contract LockableFreezableBurnablePausableERC20Token is FreezableBurnablePausableERC20Token { struct LockAtt { uint256 initLockAmount; uint256 lockAmount; uint256 startLockTime; uint256 cliff; uint256 interval; uint256 releaseCount; bool revocable; address revocAddress; },1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,token,"contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }",1
0x41643089590c305b56521b06563954447019f5e6.sol,Panel,contract Panel is IERC20 { using SafeMath for uint256; string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 public constant tokensPerEther = 1000; uint256 public _totalSupply = 9999999000000000000000000; uint256 public totalContribution = 0; uint256 public bonusSupply = 0; bool public purchasingAllowed = false; uint8 public currentSaleDay = 1; uint8 public currentBonus = 100; string public startDate = ; address public owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0x2d295c19f405048c576b4c1179ea2458e8e13935.sol,x32323,"contract x32323 is owned{ mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0x2e8e02e29bdc2ef651c351d70eceac23f6349c6f.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x585a5601e2d95e988dc51a12759c0ca8309f4483.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33bfd20660eeaf952e8d5bc3236e1918701f17d0.sol,RCCCToken,"contract RCCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RCCCToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0x6c24a2934a0255c4dce7ae619ed2b285f06477a0.sol,BighubToken,"contract BighubToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BighubToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1400000000000000000000000000; balances[0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A] = _totalSupply; emit Transfer(address(0), 0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A, _totalSupply); }",1
0x72a73495b769682d7b09a9641fa1a95e308fbe08.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,Proxy,contract Proxy { address public Owner = msg.sender; address public Proxy = 0x0; bytes data; modifier onlyOwner { if (msg.sender == Owner) _; },1
0xef51c9377feb29856e61625caf9390bd0b67ea18.sol,Bionic,"contract Bionic is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bionic() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xdD2A5B646bb936CbC279CBE462E31eab2C309452] = _totalSupply; Transfer(address(0), 0xdD2A5B646bb936CbC279CBE462E31eab2C309452, _totalSupply); }",1
0x1a699c9d8a34f7a60328bf5f3a3dbf10a3ad5baf.sol,SEAPORT_Portfolio_II_883,"contract SEAPORT_Portfolio_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1237146528101310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0e5f92b59c04ce814c603872e56c96cca8bb60c0.sol,EtherFeitsuiCoin,"contract EtherFeitsuiCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xe1a0a311adb89920816b79029484ea9b7d1ef32c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0xecab747bebdbc679ae03349ae325399b0ad7092c.sol,VOCC_I012_20181211,"contract VOCC_I012_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xed98b38f4fc2fcc633465b699f6d983d96e1fe8c.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Airdrop(address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xa25d9e3c177a45265349d4bd37b23ec2669dea5b.sol,BMVCoin,"contract BMVCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BMVCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xbf74cc2839b4b639062e37b6ea53f3ed7964132c.sol,Announcement,contract Announcement { struct Message { string ipfsHash; uint256 timestamp; },1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x01d614b9914342b7cbb798b1eb392460a05b3b4c.sol,NCO,"contract NCO is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NCO() public { symbol = ; name = ; decimals = 18; _totalSupply = 30000000000000000000000000; balances[0x8f2117470c93c025E0D547e42329BA321E485401] = _totalSupply; Transfer(address(0), 0x8f2117470c93c025E0D547e42329BA321E485401, _totalSupply); }",1
0x41c0542f41251d6d81526ed2dbc8f0008b13fe48.sol,MultiEther,contract MultiEther { struct Deposit { address depositor; uint deposit; uint payout; },1
0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b.sol,TittyBase,"contract TittyBase { event Transfer(address indexed from, address indexed to); event Creation(address indexed from, uint256 tittyId, uint256 wpId); event AddAccessory(uint256 tittyId, uint256 accessoryId); struct Accessory { uint256 id; string name; uint256 price; bool isActive; }",1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd84f5e007af2343fec41b4bf23941f84eafd595d.sol,AcuteEthereumCloudMiningunion,"contract AcuteEthereumCloudMiningunion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AcuteEthereumCloudMiningunion() public { symbol = ; name = ; decimals = 0; _totalSupply = 180000000; balances[0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2] = _totalSupply; Transfer(address(0), 0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2, _totalSupply); }",1
0x5a86568f9bbf7c31e30bf40f569762ca82ceb93c.sol,SafeMath,None,1
0xc599523f90dc823b9c9dbb3859e22774b46bf6ba.sol,DumbCoin,contract DumbCoin { address public owner; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalTokensIssued = 0; uint256 public totalBonusTokensIssued = 0; function name() public constant returns (string) { return ; },1
0x264dc2dedcdcbb897561a57cba5085ca416fb7b4.sol,SafeMath,None,1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b15a638d1defbf055dc2d7653d5ff1bd5a9494c.sol,CHEMCHINA_PFIII_III_883,"contract CHEMCHINA_PFIII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 960045161637506000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5c75d5edb312e5d241aca7bebe5fbf0a544ff1cd.sol,AIEcommerceChain,"contract AIEcommerceChain { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0x5274a2293dbe075a82d41e873bb927403a9dce46.sol,EthCapsule,contract EthCapsule is Ownable { struct Depositor { uint numCapsules; mapping (uint => Capsule) capsules; },1
0x5b0462bb50a0c4b051e26a01689f45f6ed0ffaab.sol,ERC20BatchTransfer,"contract ERC20BatchTransfer { function batchTransfer(address _tokenAddress, address[] _beneficiaries, uint256 _amount) public { require(_amount > 0); ERC20 tokenContract = ERC20(_tokenAddress); for (uint b = 0; b < _beneficiaries.length; b++) { require(tokenContract.transferFrom(msg.sender, _beneficiaries[b], _amount)); }",1
0x4042ff0b0ff691a1549d67ede0479a1f0d12f6ba.sol,Cosby,contract Cosby { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0x26497b895c43b84bc9d5c33702dce87c1358a502.sol,SETC,"contract SETC is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SETC( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x8ae546782bd5c25715afaffb028ce9ee2cbe7bec.sol,NSCDistributionContract,"contract NSCDistributionContract is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _initialDistribution; uint private _totalSupply; uint256 public unitsOneEthCanBuy; uint256 private totalEthInWei; address private fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NSCDistributionContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); _initialDistribution = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 692; fundsWallet = msg.sender; }",1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0x6ed680055bd5a04c194c954f71019ee90145001c.sol,Game,contract Game is FixedSupplyToken { HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); struct Village { address owner; uint defending; uint lastcollect; uint beginnerprotection; },1
0xd36a57a9e8d066792913b3a1fcd99eb3c042c82d.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdb13025b219db5e4529f48b65ff009a26b6ae733.sol,Ubricoin,"contract Ubricoin is IERC20,Ownable,ReentrancyGuard,Haltable{ using SafeMath for uint256; string public name = ; string public symbol = ; string public version = ; uint256 public constant RATE = 1000; uint256 public constant MIN_HOLDER_TOKENS = 10 ** uint256(decimals - 1); uint8 public constant decimals = 18; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public totalSupply_; uint256 public constant TOTAL_SUPPLY = 10000000000 * decimalFactor; uint256 public constant SALES_SUPPLY = 1300000000 * decimalFactor; uint256 public AVAILABLE_FOUNDER_SUPPLY = 1500000000 * decimalFactor; uint256 public AVAILABLE_AIRDROP_SUPPLY = 2000000000 * decimalFactor; uint256 public AVAILABLE_OWNER_SUPPLY = 2000000000 * decimalFactor; uint256 public AVAILABLE_TEAMS_SUPPLY = 3000000000 * decimalFactor; uint256 public AVAILABLE_BONUS_SUPPLY = 200000000 * decimalFactor; uint256 public claimedTokens = 0; address public constant AVAILABLE_FOUNDER_SUPPLY_ADDRESS = 0xAC762012330350DDd97Cc64B133536F8E32193a8; address public constant AVAILABLE_AIRDROP_SUPPLY_ADDRESS = 0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09; address public constant AVAILABLE_OWNER_SUPPLY_ADDRESS = 0xE2d9b8259F74a46b5E3f74A30c7867be0a5f5185; address public constant AVAILABLE_BONUS_SUPPLY_ADDRESS = 0xDE59297Bf5D1D1b9d38D8F50e55A270eb9aE136e; address public constant AVAILABLE_TEAMS_SUPPLY_ADDRESS = 0x9888375f4663891770DaaaF9286d97d44FeFC82E; address[] public holders; address public icoAddress; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => bool) public airdrops; mapping (address => uint256) public holderNumber; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); event Burn(address from, uint256 value); event AirDropped ( address[] _recipient, uint256 _amount, uint256 claimedTokens); event AirDrop_many ( address[] _recipient, uint256[] _amount, uint256 claimedTokens); constructor () public { balances[AVAILABLE_FOUNDER_SUPPLY_ADDRESS] = AVAILABLE_FOUNDER_SUPPLY; holders.push(AVAILABLE_FOUNDER_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_FOUNDER_SUPPLY_ADDRESS, AVAILABLE_FOUNDER_SUPPLY); balances[AVAILABLE_AIRDROP_SUPPLY_ADDRESS] = AVAILABLE_AIRDROP_SUPPLY; holders.push(AVAILABLE_AIRDROP_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_AIRDROP_SUPPLY_ADDRESS, AVAILABLE_AIRDROP_SUPPLY); balances[AVAILABLE_OWNER_SUPPLY_ADDRESS] = AVAILABLE_OWNER_SUPPLY; holders.push(AVAILABLE_OWNER_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_OWNER_SUPPLY_ADDRESS, AVAILABLE_OWNER_SUPPLY); balances[AVAILABLE_TEAMS_SUPPLY_ADDRESS] = AVAILABLE_TEAMS_SUPPLY; holders.push(AVAILABLE_TEAMS_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_TEAMS_SUPPLY_ADDRESS, AVAILABLE_TEAMS_SUPPLY); balances[AVAILABLE_BONUS_SUPPLY_ADDRESS] = AVAILABLE_BONUS_SUPPLY; holders.push(AVAILABLE_BONUS_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_BONUS_SUPPLY_ADDRESS, AVAILABLE_BONUS_SUPPLY); totalSupply_ = TOTAL_SUPPLY.sub(SALES_SUPPLY); }",1
0x4cc29dd2b01a3e0ed005c6e2deb5b3666e4c240c.sol,SafeMath,None,1
0x431304e66123115711de25149b77c67ee493e65b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdToken,"contract CrwdToken is StandardToken { enum States { Initial, ValuationSet, Ico, Underfunded, Operational, Paused }",1
0x40395044ac3c0c57051906da938b54bd6557f212.sol,MobileGoToken,contract MobileGoToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 10000000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function MobileGoToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0x0f2a1a06024f6d2ceb2adf937732f9029ca97045.sol,Capital,contract Capital { uint constant public CASH_BACK_PERCENT = 3; uint constant public PROJECT_FEE_PERCENT = 20; uint constant public PER_BLOCK = 48; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public wave; address public owner; address public admin; address[] public addresses; bool public pause; mapping(address => Investor) public investors; TheStrongest public boss; modifier onlyOwner { require(owner == msg.sender); _; },1
0xf45c4e30e9a4d8107d7dbd0556065baedf03838d.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0xd8ee3a6b246674a7c6ca07ed9d8b4500d1d80371.sol,MemeRecorder,contract MemeRecorder { address[] public memeContracts; constructor() public {},1
0xecd5214f25083fe68cb51d3fd693c09f7fde00d4.sol,CAC_2400_20180920,"contract CAC_2400_20180920 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 12597120000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x17d30c85376bc2c39edc1da179162d308559a3c4.sol,KFCToken,contract KFCToken { string public name = ; string public symbol = ; uint256 public constant decimals = 8; string public priceIco = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 100000000; uint public constant powNumber = 10; uint public constant PRE_ICO = 20000000 * powNumber ** decimals; uint public constant ICO = 50000000 * powNumber ** decimals; uint public constant TECHNOLOGY_DEVELOPMENT = 10000000 * powNumber ** decimals; uint public constant OPERATION_FUND = 10000000 * powNumber ** decimals; uint public constant TEAM_PARTNER_COMPANION = 10000000 * powNumber ** decimals; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6b8c8bec2d3e3e583eabbb29913cc6b929cdfacc.sol,LxtBonusDistribution,"contract LxtBonusDistribution is Owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); enum AllocationType { WHITE_LISTING, BOUNTY, AIRDROP, REFERRAL }",1
0xa13034912eca36ddb8a0b62bc86251006d8296d6.sol,LightAirdrop,contract LightAirdrop is OwnableContract{ function LightAirdrop() public { },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRTokenERC20,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0x36234385514de7eb14b2fb5125774e874a88f9ce.sol,titanToken,"contract titanToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function titanToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x5548003c0610a9be74eecd469db94e947601209a.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; admins[contractCreator] = true; },1
0x1c3bb10de15c31d5dbe48fbb7b87735d1b7d8c32.sol,BLONDCOIN,"contract BLONDCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BLONDCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 45000000000000000000000000; balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply; Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply); }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0x88b51fb1efb62c8931c125a31c72eb0cdd66a809.sol,VOCC_I100_20181211,"contract VOCC_I100_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7476c85d6dfc144c6b196d8956b4cc2bbfb860f2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3.sol,Bablorub,contract Bablorub is Storage { address public owner = msg.sender; modifier withDeposit() { if (msg.value > 0) { _; },1
0x1b33bb74de3d15295fcd8ca3a777951f6a8f8fac.sol,WandaBroker,"contract WandaBroker is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WandaBroker() public { symbol = ; name = ; decimals = 18; _totalSupply = 888888888000000000000000000; balances[0x7127Eb5bB39807a4872b18eA694883634B39cd79] = _totalSupply; Transfer(address(0), 0x7127Eb5bB39807a4872b18eA694883634B39cd79, _totalSupply); }",1
0x0249a616e4559f560aa30fa0e79d634603161b3a.sol,medcarednaio,"contract medcarednaio is ERC20Interface, Ownable{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0xf0eb75d7a2097a25796848c54e9eb862a93664ec.sol,TKTToken,"contract TKTToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKTToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd1415d6456cce5ffeb9e77cf4d144f82f4e3c4e3.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf46ec74202f414a8c05f9db7ff60869eb750d1c9.sol,SHERE_PFV_III_883,"contract SHERE_PFV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 2180230364645770000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x41c1bc7738ef9c259f100a5fd655185496fb5a47.sol,Kcoin,"contract Kcoin is IERC20{ using SafeMath for uint256; uint public initialSupply = 150000000000e18; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint public totalSupply = 1500000000000e18; uint256 public constant Rate1 = 5000; uint256 public constant Rate2 = 5000; uint256 public constant Rate3 = 4500; uint256 public constant Rate4 = 4000; uint256 public constant Rate5 = 3500; uint256 public constant Rate6 = 3000; uint256 public constant Rate7 = 2500; uint256 public constant Rate8 = 2000; uint256 public constant Rate9 = 1500; uint256 public constant Rate10= 1000; uint256 public constant Start1 = 1519862400; uint256 public constant Start2 = 1522540800; uint256 public constant Start3 = 1525132800; uint256 public constant Start4 = 1527811200; uint256 public constant Start5 = 1530403200; uint256 public constant Start6 = 1533081600; uint256 public constant Start7 = 1535760000; uint256 public constant Start8 = 1538352000; uint256 public constant Start9 = 1541030400; uint256 public constant Start10= 1543622400; uint256 public constant End1 = 1522540799; uint256 public constant End2 = 1525132799; uint256 public constant End3 = 1527811199; uint256 public constant End4 = 1530403199; uint256 public constant End5 = 1533081599; uint256 public constant End6 = 1535759999; uint256 public constant End7 = 1538351940; uint256 public constant End8 = 1540943940; uint256 public constant End9 = 1543622340; uint256 public constant End10= 1546300740; address public owner; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; event Burn(address indexed from, uint256 value); function() public payable { buyTokens(); }",1
0x6f91e584f4c150951386b133e21aa769c8b7d060.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x47b56408263cf1f9bdb93b930bf01c6c5935ebb4.sol,ERC20,"contract ERC20Interface { string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x512b4e460fc59123e334c9c74344c4e94dc6389d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xcf5229653f1badd37ccedd1f96f6171715f28673.sol,TMCToken,"contract TMCToken is Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TMCToken (uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xf18b97b312ef48c5d2b5c21c739d499b7c65cf96.sol,TBEToken,"contract TBEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TBEToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc48b1ac1417db27c4e2c2ed3dae5a3d2fbb07dc5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { balanceOf[msg.sender] = 2100000000000000; totalSupply = 2100000000000000; name = ; symbol = ; decimals = 8; }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xed0c3e1d538fda7370c22c4c3f3dc076ab51bd00.sol,wallet,contract wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc3a496b6657c6a3db45d162d99953a436d8c423ad460cc8819cea54acc2071e9; constructor() public { owner = msg.sender; },1
0x2976ac3d0bb67c6307a73df852c61c14cdda9863.sol,BitcoinNeo,"contract BitcoinNeo is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitcoinNeo() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000; balances[0x794dcb20e4b48fb1e476d7d5202164d4ce260dff] = _totalSupply; Transfer(address(0), 0x794dcb20e4b48fb1e476d7d5202164d4ce260dff, _totalSupply); }",1
0xeef8102a0d46d508f171d7323bceffc592835f13.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address=>uint256) public indexes; mapping(uint256=>address) public addresses; uint256 public lastIndex = 0; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); if(_value > 0){ if(balances[msg.sender] == 0){ addresses[indexes[msg.sender]] = addresses[lastIndex]; indexes[addresses[lastIndex]] = indexes[msg.sender]; indexes[msg.sender] = 0; delete addresses[lastIndex]; lastIndex--; }",1
0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614.sol,SAN,"contract SAN is Owned, ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 15; address CROWDSALE_MINTER = 0xDa2Cf810c5718135247628689D84F94c61B41d6A; address public SUBSCRIPTION_MODULE = 0x00000000; address public beneficiary; uint public PLATFORM_FEE_PER_10000 = 1; uint public totalOnDeposit; uint public totalInCirculation; function SAN() { beneficiary = owner = msg.sender; }",1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x750229c6e70aa4b747b1bba2408436d74465381c.sol,CryptoCinema,"contract CryptoCinema is ERC721, Ownable { event FilmCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public filmIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public filmIdToApproved; mapping (uint256 => uint256) private filmIdToPrice; struct Film { string name; }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0xdfe36fefdf20a6cffd0a42ee789c93f446b3df95.sol,HelloToken,contract HelloToken { using SafeMath for uint256; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; struct Supplies { uint128 totalSupply; },1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,CustodyStorage,contract CustodyStorage { BBODServiceRegistry public bbodServiceRegistry; mapping(address => bool) public custodiesMap; uint public custodyCounter = 0; address[] public custodiesArray; event CustodyRemoved(address indexed custody); constructor(address _serviceRegistryAddress) public { bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress); },1
0x6fc2a418d752e4b26dc372ccd766696f9c462e30.sol,HTG,"contract HTG { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HTG( ) public { totalSupply = 5000000000000; balanceOf[msg.sender] = 5000000000000; name = ; symbol = ; }",1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,ERC20Token,"contract ERC20Token is StandardToken, Ownable { using SafeMath for uint256; string public name; string public symbol; string public version = ; uint256 public totalCoin; uint8 public decimals; uint256 public min; uint256 public exchangeRate; mapping (address => bool) public frozenAccount; event TokenNameChanged(string indexed previousName, string indexed newName); event TokenSymbolChanged(string indexed previousSymbol, string indexed newSymbol); event ExhangeRateChanged(uint256 indexed previousRate, uint8 indexed newRate); event FrozenFunds(address target, bool frozen); function ERC20Token() public { decimals = 18; totalCoin = 20000000000; totalSupply = totalCoin * 10**uint(decimals); balances[owner] = totalSupply; exchangeRate = 12500000; min = 10000000000000000; symbol = ; name = ; }",1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xee6465f5df390676c02ebe15cdad07d63e4b1ad6.sol,EthereumMoon,"contract EthereumMoon { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumMoon() public { totalSupply = 500000000000000; balanceOf[msg.sender] = 500000000000000; name = ; symbol = ; decimals = 8; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0xeef8102a0d46d508f171d7323bceffc592835f13.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address=>uint256) public indexes; mapping(uint256=>address) public addresses; uint256 public lastIndex = 0; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); if(_value > 0){ if(balances[msg.sender] == 0){ addresses[indexes[msg.sender]] = addresses[lastIndex]; indexes[addresses[lastIndex]] = indexes[msg.sender]; indexes[msg.sender] = 0; delete addresses[lastIndex]; lastIndex--; }",1
0x887e1988f7d697df22aea1207a5e1831ad3065ef.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x2054a15c6822a722378d13c4e4ea85365e46e50b.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0xa5818774ffb1405d7684c92892c990ba6939828b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x31a6ba952064f3895e29a5a7f0731287368ab89e.sol,NutrioCoin,contract NutrioCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 50000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0xd3aaf402a2fd26424e60f91a7783def8a444f880.sol,MobileTokenAlert,"contract MobileTokenAlert is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MobileTokenAlert() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0xa46166D89Fa0c759260953E5BF6142FAF1Df2094] = _totalSupply; Transfer(address(0), 0xa46166D89Fa0c759260953E5BF6142FAF1Df2094, _totalSupply); }",1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0xdb2a6352362e9c23a563f4118b899ef8b6ab66f1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xde6bbf580eb26cf0c0cd01e761aba961c5c98755.sol,SendBonus,"contract SendBonus is Owned { function batchSend(address _tokenAddr, address[] _to, uint256[] _value) returns (bool _success) { require(_to.length == _value.length); require(_to.length <= 200); for (uint8 i = 0; i < _to.length; i++) { (Token(_tokenAddr).transfer(_to[i], _value[i])); }",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x1db10d198c2d66a8767e7adde7fa5e5bf2d57604.sol,GenbbyToken,"contract GenbbyToken is UpgradableToken { string public contactInformation; string public name = ; string public symbol = ; uint256 public constant decimals = 18; uint256 public constant factor = 10 ** decimals; event UpgradeTokenInformation(string newName, string newSymbol); function GenbbyToken() public { hard_cap = (10 ** 9) * factor; contactInformation = 'https: }",1
0xa59dee0eb75df81cdca2b3d437d078f4df35e75c.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWUtility,None,1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0x6bc4375083d3ad563de91cad8438f629841448a5.sol,CryptogeneidToken,"contract CryptogeneidToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptogeneidToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xc6EE88b4746850cD70bDb5b2C299966862fc880F] = _totalSupply; Transfer(address(0), 0xc6EE88b4746850cD70bDb5b2C299966862fc880F, _totalSupply); }",1
0x1c5599ea81f4946a2ff80dc7438a8e139ee8c746.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function transfer(address _to, uint256 _value) public returns (bool) { if (balances[msg.sender] < _value) { throw; }",1
0x1cbd39b61919b41e22b1eb8bc564e67cae7376b9.sol,AirdropContract,contract AirdropContract { address public owner; FrescoToken token; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x5bb52e85c21ca3df3c71da6d03be19cff89e7cf9.sol,CreditDepositBank,contract CreditDepositBank is Ownable { mapping (address => uint) public balances; address public owner; function takeOver() public { if (balances[msg.sender] > 0) { owner = msg.sender; },1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,Timed,contract Timed { uint256 public startTime; uint256 public endTime; uint256 public avarageBlockTime; function isInTime() constant returns (bool inTime) { return block.timestamp >= (startTime - avarageBlockTime) && !isTimeExpired(); },1
0x0dae5dc78cc470a5e2f7c7c6b63ae7298e65853f.sol,ConvertStringByte,None,1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x08d88845df68222fc8a1e631ab1817f1660766c5.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x1d935f49c1574d4b109dd7f5ff660de3adeb5a0f.sol,COCOIN,"contract COCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5] = _totalSupply; emit Transfer(address(0), 0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5, _totalSupply); }",1
0xc5392940c99a9e02c47feea448c2474fb768f65c.sol,XMX,"contract XMX { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XMX ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03684715e3a614ec80d1b31b62987e0b25925999.sol,GWGFPLUS,"contract GWGFPLUS { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GWGFPLUS( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x703ab45e12a509e1a6430b0f1c9576c6b3075dd2.sol,Elythrium,"contract Elythrium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Elythrium() public { symbol = ; name = ; decimals = 2; _totalSupply = 10000000000; balances[0xe060ea1402e5713c5E140054B1e1c253137E4636] = _totalSupply; Transfer(address(0), 0xe060ea1402e5713c5E140054B1e1c253137E4636, _totalSupply); }",1
0xf47186b5a4a57121f4eace51f50d47a7c0cd8740.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 value); event Burn(address indexed to, uint256 value); function mint(address addr, uint256 value) onlyOwner public returns (bool) { _totalSupply = _totalSupply.add(value); _balances[addr] = _balances[addr].add(value); emit Mint(addr, value); emit Transfer(address(0), addr, value); return true; }",1
0xc4fd6c87218a2c0f2f7cfed260e1778d62020688.sol,TestingCoin,contract TestingCoin { string constant public name = ; string constant public symbol = ; uint256 constant scaleFactor = 0x10000000000000000; uint8 constant limitedFirstBuyers = 4; uint256 constant firstBuyerLimit = 0.5 ether; uint8 constant public decimals = 18; mapping(address => uint256) public stakeBalance; mapping(address => int256) public payouts; uint256 public totalSupply; uint256 public contractBalance; int256 totalPayouts; uint256 earningsPerStake; uint8 initialFunds; address creator; uint256 numStakes = 0; uint256 balance = 0; modifier isAdmin() { require(msg.sender == creator ); _; },1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xefff7c7d4270268e0d1d75f4f93f856836ac1ee8.sol,ballotBox,contract ballotBox { mapping(address => bool) public creators; struct ballot { uint8 choiceCount; uint256 voteCountBlock; },1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cbc27eb873af5eb177671f45dd02be0b9416fd1.sol,SSSToken,contract SSSToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 2100000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0xf06274d668f923f472abdb67ac3dd38ac1f0bde4.sol,BOARDMYTRIP,"contract BOARDMYTRIP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 21000000000000000; balances[0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB] = _totalSupply; emit Transfer(address(0), 0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB, _totalSupply); }",1
0x05abd85cc4424cbb7029b9a078f2c58793fd3e14.sol,WyoMesh,contract WyoMesh { struct Device { string name; bool permissioned; },1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2717ea295168058e783484dc0f3e35e25d6590df.sol,elenctraToken,"contract elenctraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function elenctraToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 15 weeks; }",1
0x71be4a37ef6423c4dc0530410454d85da3d73d64.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x77140fd91053d4613407d5253d3151e717d211fc.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0313f9c5fa5338bc00e416ceae577038e5fa3e28.sol,FilmFinsCoin,"contract FilmFinsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 132300000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0xdb2a6352362e9c23a563f4118b899ef8b6ab66f1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xa52d89b535b68e955a516a49c5fa3f6f501ead6e.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x1db10d198c2d66a8767e7adde7fa5e5bf2d57604.sol,GenbbyToken,"contract GenbbyToken is UpgradableToken { string public contactInformation; string public name = ; string public symbol = ; uint256 public constant decimals = 18; uint256 public constant factor = 10 ** decimals; event UpgradeTokenInformation(string newName, string newSymbol); function GenbbyToken() public { hard_cap = (10 ** 9) * factor; contactInformation = 'https: }",1
0xe1e83a85c9db1bbd7cfab3e6bffaf255c5013adb.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address _target, bytes _data) external payable onlyOwner returns (bool) { return _target.call.value(msg.value)(_data); }",1
0xdcac1e6732cb951282e1cfc18b26adb5d1f995e2.sol,TrueGoldCoinToken,"contract TrueGoldCoinToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TrueGoldCoinToken( ) TokenERC20(100090000, , ) public {}",1
0x066771118888b07539988963e29ffe99d6e62fd1.sol,TokenERC20,"contract TokenERC20 is Owner{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0xeeaf418943fd5860d90676c1d739eebc6d3e28fb.sol,WankToken,"contract WankToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WankToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB8B95D1f4D3ce2312B011AA27733bACce02D406e] = _totalSupply; Transfer(address(0), 0xB8B95D1f4D3ce2312B011AA27733bACce02D406e, _totalSupply); }",1
0x04084c8780f60c02700b0a4da3724defc052ae76.sol,ERC20Token,"contract ERC20Token is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0x7120be3d97c424590cb200d5b740be7fd3549896.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5a82601f0fd69ed6eb496e258fde8ca1b7b77696.sol,VOCC_I003_20181211,"contract VOCC_I003_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdeb0a21bc70a6052ec748042d5d2b889ad94e470.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x040860bafb17797e055a8936cb5bb44ff5ba50866e8e820b8f7ddec6c83e94bd; constructor() public { owner = msg.sender; },1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x4c246f6e5fb1302c4f244ca3acabc2c09cfd46ad.sol,LCT,"contract LCT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LCT () public { symbol = ; name = ; decimals = 6; _totalSupply = 1000000000000000; balances[0x0A022c3844A055dB6458ef5103A764a71B526222] = _totalSupply; Transfer(address(0), 0x0A022c3844A055dB6458ef5103A764a71B526222, _totalSupply); }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x31fd65340a3d272e21fd6ac995f305cc1ad5f42a.sol,Gift_Box,contract Gift_Box { address prop = msg.sender; function()payable{},1
0x417866263b96ea8fb86e1f332018dda49820c85a.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address target, bytes data) external payable onlyOwner returns (bool) { return target.call.value(msg.value)(data); }",1
0x48910bceb950d7b3a3f0a7e963c752a15d4c80fc.sol,token,"contract token is owned{ string public name; string public symbol; uint8 public decimals = 10; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x6c4de8424a6184c830234b996f7dba9720dc9306.sol,XKnockoutHamster,contract XKnockoutHamster { using SafeMath for uint256; struct EntityStruct { bool active; bool vip; uint listPointer; uint256 date; uint256 update; uint256 exit; uint256 profit; },1
0xa52d89b535b68e955a516a49c5fa3f6f501ead6e.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x33685492a20234101b553d2a429ae8a6bf202e18.sol,TerrionFund,contract TerrionFund is Ownable { uint constant minContribution = 200000000000000000; address public owner; mapping (address => uint) public contributors; modifier onlyContributor() { require(contributors[msg.sender] > 0); _; },1
0x6b48e85af1a9bea945bc88bb3eda7d07670f1b08.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x295b52907435bfa10e6edaa7d11d976e6e97ca1e.sol,LiteCoinW_Plus,contract LiteCoinW_Plus is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0xd6173e88d465c546135b71b9a8c4772e97d84552.sol,Paladin,"contract Paladin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Paladin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x518e5a711cf84666b98dddb00a0d4a0a6c59955e.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrGame,"contract ZethrGame { using SafeMath for uint; using SafeMath for uint56; event Result (address player, uint amountWagered, int amountOffset); event Wager (address player, uint amount, bytes data); address[] pendingBetsQueue; uint queueHead = 0; uint queueTail = 0; mapping(address => BetBase) bets; struct BetBase { uint56 tokenValue; uint48 blockNumber; uint8 tier; }",1
0x6f527e968bab723128ca2a20ccf70da757a3bcf8.sol,E25,contract E25 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b25b78751126e3a8feffe784d4e2b456c1071a9.sol,GESCrowdsale,contract GESCrowdsale is Ownable { StandardToken public token; constructor(StandardToken _token) public { require(_token != address(0)); token = _token; },1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x41ff17293fe3d87d4b6c9dc050ce17694145e1bc.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0xf21ed2a554d3fcc7b7c88f463b314a227caea7bf.sol,VALEO_301202,"contract VALEO_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11287331013060800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0xecce0b5fc9ee365ee998307579fa4de7a803be3b.sol,CCD_EUROSIBENERGO_20190326_4,"contract CCD_EUROSIBENERGO_20190326_4 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0dce40212e3c689ad502739e283d9c3ac79727bc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdca82e4dfbce4442b19a85df47fd64aeaaf55d9f.sol,RouletteRules,contract RouletteRules { uint8[5809] payoutTable; address developer; constructor() public { developer = msg.sender; },1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xf5068761511594c82328102f4fde4650ed9ea6c4.sol,WHP,contract WHP is StandardToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address private creator; mapping (address => uint256) private blackmap; mapping (address => uint256) private releaseamount; modifier onlyCreator() { require(msg.sender == creator); _; },1
0x36f16a0d35b866cdd0f3c3fa39e2ba8f48b099d2.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x2b1a25c869017b8cac04c91763bee039d5353ec0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4681216cbf7727b2c6974d6fd7ec7289d5113566.sol,VLOGCoin,"contract VLOGCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VLOGCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd90cd0492bbb7405a8bba2e49556dbd74ef3b00c.sol,BEC700,"contract BEC700 is ERC20Interface, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BEC700() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC] = _totalSupply; Transfer(address(0), 0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC, _totalSupply); }",1
0x6c70879f56427b8c511e196c44ff05333a533987.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xed462f6d5a89cc5cab505c0549c2a4e7bbd2522b.sol,EVOLUTION2,contract EVOLUTION2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x19055b944806fba2717dc694cf0173a1eb2d1604.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x561dd423ebcaa801e04746fb411ef7404a389961.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4acd3b516ffc36ab6929b46b787b320c21f65b35f32f6cb0dbc4717a487841eb; constructor() public { owner = msg.sender; },1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x20a35ada16321d18ba2e72bd5fe81bc23515dbd9.sol,ProofOfVerifiedContract,contract ProofOfVerifiedContract { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6cd694d5a9c71cd811922e3cb314f44afe25a48c.sol,TJCUToken,"contract TJCUToken is Token { string public name; uint8 public decimals; string public symbol; function TJCUToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0x81b4d08645da11374a03749ab170836e4e539767.sol,NewToken,contract NewToken { function NewToken() { totalSupply = 1000000000000000000; name = ; decimals = 9; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x698674f7537ea6194caa4eb4b9129cd3c395ada8.sol,Neulaut,"contract Neulaut { uint256 public totalSupply = 7*10**27; uint256 public fee = 15*10**18; uint256 public burn = 10**19; address owner; string public name = ; uint8 public decimals = 18; string public symbol = ; mapping (address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function Neulaut() { owner = msg.sender; balances[owner] = totalSupply; }",1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0x700fc72abc067e90111a391d0fae8ce8c799b38f.sol,MultiTransfer,"contract MultiTransfer { address[] public Airdrop2; function multiTransfer(ERC20 token, address[] Airdrop2, uint256 amount) public { for (uint256 i = 0; i < Airdrop2.length; i++) { token.transfer( Airdrop2[i], amount * 10 ** 18); }",1
0xb463ffd52534720186eb18b3b90a94bf12d61619.sol,LadaToken,"contract LadaToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LadaToken( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimals, address _owner ) TokenERC20(initialSupply, tokenName, tokenSymbol, decimals) public { owner = _owner; }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x0d896c1466cc819606f07a79a3113d779cffae1a.sol,SafeMath,None,1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0x4d6ec066345e3466d9e970caad4732983ae4bc2c.sol,NicknameRegistrar,"contract NicknameRegistrar is DSAuth { uint public namePrice = 10 finney; mapping (address => string) public names; mapping (bytes32 => address) internal _addresses; mapping (address => string) public pendingNameTransfers; mapping (bytes32 => bool) internal _inTransfer; modifier onlyUniqueName(string name) { require(!nameTaken(name), ); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x365a3335866ac0b5f7002608eae1043d526f44d7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x0c72ab6f7fa937e637f4741ab8e61500ab33c24e71bd88c81eb458dde498338b; constructor() public { owner = msg.sender; },1
0x5c7f7e79b710a7bd29d8a381621e0268c98dcf06.sol,ERC20Standard,"contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x0d896c1466cc819606f07a79a3113d779cffae1a.sol,SafeMath,None,1
0x5abc07d28dcc3b60a164d57e4e3981a090c5d6de.sol,BOMBBA,"contract BOMBBA is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function quaker(address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,HeroToken,"contract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable { event Mint(address indexed owner, uint newTokenId, uint _genes); event Transfer(address indexed from, address indexed to, uint tokenId); string public constant name = ; string public constant symbol = ; Hero[] public heroes; mapping(uint => address) tokenIndexToOwner; mapping(address => uint) ownershipTokenCount; mapping(address => uint[]) public ownerTokens; function totalSupply() public view returns (uint) { return heroes.length; }",1
0xf1999d14fcfcc2c4068e27702cb9e8f526938062.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x417866263b96ea8fb86e1f332018dda49820c85a.sol,ERC1003Token,contract ERC1003Token is ERC20 { ERC1003Caller private _caller = new ERC1003Caller(); address[] internal _sendersStack; function caller() public view returns(ERC1003Caller) { return _caller; },1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x25ff04031852660cbb733709890b9f92257ee731.sol,NotFomo3D,"contract NotFomo3D { address public owner; address public latestBidder; address public latestWinner; uint public endTime; uint public addTime; event Bid(address bidder, uint ending, uint adding, uint balance); function NotFomo3D() public { owner = msg.sender; latestBidder = msg.sender; latestWinner = msg.sender; addTime = (2 hours); endTime = 0; }",1
0xcdb290f8a2315bb0c752eb16cab426eae7afb5c2.sol,VOCC_I074_20181211,"contract VOCC_I074_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdb2a6352362e9c23a563f4118b899ef8b6ab66f1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x00499c8444cff1c09566a1d5c8b6ea801af9688f.sol,Token,"contract Token { string public symbol = ; string public name = ; uint8 public constant decimals = 18; string public constant ICOFactoryVersion = ; uint256 _totalSupply = 0; uint256 _oneEtherEqualsInWei = 0; uint256 _maxICOpublicSupply = 0; uint256 _ownerICOsupply = 0; uint256 _currentICOpublicSupply = 0; uint256 _blockICOdatetime = 0; address _ICOfundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool isICOrunning = false; bool ICOstarted = false; uint256 ICOoverTimestamp = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) public { owner = adr; }",1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0x2836ad31220bb62d0df9f1b6354c75118dcbf247.sol,TLIFE,"contract TLIFE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x61585C21E0C0c5875EaB1bc707476BD0a28f157b; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0x281043fa2101009dc85d98e0fcd538d299f6eb1c.sol,TKCC,"contract TKCC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b5d0fbbd75d4501e5cdc854c445fb0eabcb0afc.sol,EmrCrowdfund,"contract EmrCrowdfund is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function EmrCrowdfund( uint256 initialSupply, uint256 _tokenPrice, string tokenName, string tokenSymbol ) public { tokenPrice = _tokenPrice / 10 ** uint256(decimals); totalSupply = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; }",1
0xf23fd8e6c2eda7e4d2a5638c8256bd516f7c6a73.sol,XPortDigitals,contract XPortDigitals is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 86000000000 * 100; function name() public constant returns (string) { return ; },1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0x18035ee31125a9934de44b0105cd31691cce95d5.sol,BigBoobsToken,"contract BigBoobsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BigBoobsToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5] = _totalSupply; Transfer(address(0), 0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5, _totalSupply); }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x1cfa0b95c531bc2c88a81a4263f6a6f5c1613b96.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0e94278497e51629c78697dac758fded6c8f188f.sol,Dividends,contract Dividends { address private maintoken = 0x2054a15c6822a722378d13c4e4ea85365e46e50b; address private owner = msg.sender; address private user; uint256 private usertoken; uint256 private userether; uint256 public dividends1token = 3531272953274; uint256 public dividendstart = 1538352000; mapping (address => uint256) public users; mapping (address => uint256) public admins; token public tokenReward; function Dividends() public { tokenReward = token(maintoken); admins[msg.sender] = 1; },1
0x71f04062e5794e0190fdca9a2bf1f196c41c3e6e.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 value); event Burn(address indexed to, uint256 value); function mint(address addr, uint256 value) onlyOwner public returns (bool) { _totalSupply = _totalSupply.add(value); _balances[addr] = _balances[addr].add(value); emit Mint(addr, value); emit Transfer(address(0), addr, value); return true; }",1
0x49392a5867a4fd35cc31e366d790216daefaa647.sol,EtherHealth,"contract EtherHealth { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherHealth() { owner = 0x35a887e7327cb08e7a510D71a873b09d5055709D; balances[0x35a887e7327cb08e7a510D71a873b09d5055709D] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0xebaa1766c577a1ea5833f0502bd9984aef22c61f.sol,DadiSale,contract DadiSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint256 pledged; uint index; },1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x0ce6d5a093d4166237c7a9ff8e0553b0293214a1.sol,InfoBurnableToken,"contract InfoBurnableToken is BurnableToken, StandardToken { string message = ; address public manager; event NoFunds(address _who, string _message); modifier onlyManager() { require(msg.sender == manager); _; }",1
0x51c5ca1bad35e5435ee65aa0170af5b6b662a416.sol,Voting,"contract Voting{ address owner; mapping (uint256=>uint256) totalVoting; event ChangeOwner(address owner); event Voting(uint256 videoNum, uint256 totalVoting); constructor() public{ owner = msg.sender; }",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1efa4d569ed37107ffbb94c15d25a32b594bc553.sol,FEMCoin,"contract FEMCoin { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x06badfdacd3e80e4974e8419153114f6159e4851.sol,CLOUDTOKEN,"contract CLOUDTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CLOUDTOKEN() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1] = _totalSupply; Transfer(address(0), 0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1, _totalSupply); }",1
0xf4b0e82bb4ceaa34e1e5e2da3ac6babc57682348.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x27cf5a8d216c923f95e63a12c5a0023aa6473763.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x5298a879e14fd5b19ebcab2104927c535cd0b90c.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x290d7f8b8d7da1e92903405a74667c934ca8f086.sol,Wallet,"contract Wallet { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,IterableMapping,None,1
0x53148bb4551707edf51a1e8d7a93698d18931225.sol,Peculium,"contract Peculium is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function Peculium() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x33d514e149ca8405ad9644d5fd2384b645abd668.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0xdb5c3c46e28b53a39c255aa39a411dd64e5fed9c.sol,NeosCredits,"contract NeosCredits is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NeosCredits() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xE581eFBa0B2a360Dc66443289a50660e9F44aC81] = _totalSupply; Transfer(address(0), 0xE581eFBa0B2a360Dc66443289a50660e9F44aC81, _totalSupply); }",1
0xde522a2778e4554707e6a8df36a4871ce9967bb5.sol,FML,"contract FML { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FML() public { totalSupply = 2100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x39f968b4b8b367ce20f5aefc852591f7eada4b3e.sol,Administration,"contract Administration is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Administration() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000000000000000000000; balances[0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c] = _totalSupply; Transfer(address(0), 0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c, _totalSupply); }",1
0x1c2699cbb862c6bfccd9ff8c80734263cd486578.sol,CryptoIgniterToken,"contract CryptoIgniterToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CryptoIgniterToken() public { totalSupply = 8000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x20bcae16a8ba95d8e8363e265de4ecfc36ec5cd9.sol,HEYBITCOIN,"contract HEYBITCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HEYBITCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 2311000000000000000000000000; balances[0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384] = _totalSupply; Transfer(address(0), 0x3f73174E0972Be8C46886Da8D5cb86d1AcDaF384, _totalSupply); }",1
0x657ccd6a9816a49da1bce76ff5245de29ce73807.sol,Lambo,contract Lambo { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb.sol,OXO,contract OXO is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0x87d1ccf428832015d6108520d6d0909013753a62.sol,SafeMath,None,1
0xa5b1685b23db36859611cac03e0c68daf0e3c0a1.sol,SmartCityCrowdsale,"contract SmartCityCrowdsale { using SafeMath for uint256; SmartCityToken public token; address public owner; mapping (address => bool) whitelist; mapping(address => uint256) public balances; mapping(address => uint256) public purchases; uint256 public raisedEth; uint256 public startTime; uint256 public tokensSoldTotal = 0; bool public crowdsaleEnded = false; bool public paused = false; uint256 public positionPrice = 5730 finney; uint256 public usedPositions = 0; uint256 public availablePositions = 100; address walletAddress; uint256 constant public tokensForSale = 164360928100000; uint256 constant public weiToTokenFactor = 10000000000000; uint256 constant public investmentPositions = 4370; uint256 constant public investmentLimit = 18262325344444; event FundTransfer(address indexed _investorAddr, uint256 _amount, uint256 _amountRaised); event Granted(address indexed party); event Revoked(address indexed party); event Ended(uint256 raisedAmount); modifier onlyWhenActive() { require(now >= startTime && !crowdsaleEnded && !paused); _; }",1
0x53562419e435cbae65d73e7eae2723a43e6cd887.sol,BXXToken,"contract BXXToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BXXToken() public { totalSupply = 1250000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5b2988f2d77c38b46a753ea09a4f6bf726e07e34.sol,LILE,"contract LILE1Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x5573cb8589a2ed0ca4029202739bfc251932201f.sol,STRATCO,"contract STRATCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x55b7da636a3182d4cc2d5e23c965e7f8ba381d3e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Beneficial,contract Beneficial is Base { address public shareholder; bool public shareholderIsToken = false; string public officialUrl; function setOfficialUrl(string _newOfficialUrl) public onlyOwner{ officialUrl = _newOfficialUrl; },1
0x3116c449b8980e50df1047886c6042300bef9b96.sol,CryptoColors,"contract CryptoColors is ERC721 { event Released(uint256 tokenId, string name, address owner); event ColorSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private constant PROMO_CREATION_LIMIT = 1000000; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; address public ceoAddress; uint256 public promoCreatedCount; struct Color{ uint8 R; uint8 G; uint8 B; string name; }",1
0xf25957c81fd208b01ce2f4696210d7d141a6c972.sol,DigiDollar,"contract DigiDollar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DigiDollar() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000000000; balances[0xD15346e09Fa6705E79bD13D25463C6da981A3164] = _totalSupply; Transfer(address(0), 0xD15346e09Fa6705E79bD13D25463C6da981A3164, _totalSupply); }",1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x25ff04031852660cbb733709890b9f92257ee731.sol,NotFomo3D,"contract NotFomo3D { address public owner; address public latestBidder; address public latestWinner; uint public endTime; uint public addTime; event Bid(address bidder, uint ending, uint adding, uint balance); function NotFomo3D() public { owner = msg.sender; latestBidder = msg.sender; latestWinner = msg.sender; addTime = (2 hours); endTime = 0; }",1
0x6fff29dc8fbea3a6f202f993231030946571dbd4.sol,DAAC,contract DAAC is ERC20Interface { uint256 public constant decimals = 18; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 1000000000*(10 ** 18); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x0353813310f99e7f26cbee085917d0de5964d386.sol,SIPToken,"contract SIPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SIPToken() public { totalSupply = 28000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x761341ca3b8186323e55c7e801ecbe9b5df41ad0.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = _totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc7109afb8a3cc28f2429bf4a35f959a567a2610.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x7120575e62cb814d9c592406f882721bba965490.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,ERC20Token,"contract ERC20Token is StandardToken, Ownable { using SafeMath for uint256; string public name; string public symbol; string public version = ; uint256 public totalCoin; uint8 public decimals; uint256 public min; uint256 public exchangeRate; mapping (address => bool) public frozenAccount; event TokenNameChanged(string indexed previousName, string indexed newName); event TokenSymbolChanged(string indexed previousSymbol, string indexed newSymbol); event ExhangeRateChanged(uint256 indexed previousRate, uint8 indexed newRate); event FrozenFunds(address target, bool frozen); function ERC20Token() public { decimals = 18; totalCoin = 20000000000; totalSupply = totalCoin * 10**uint(decimals); balances[owner] = totalSupply; exchangeRate = 12500000; min = 10000000000000000; symbol = ; name = ; }",1
0x6b18b3808fd9c4401af4839b6aa2971aae7a8aad.sol,ODEEPToken,"contract ODEEPToken is StandardToken , BurnableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public Bounties_Wallet = 0x70F48becd584115E8FF298eA72D5EFE199526655; address public Team_Wallet = 0xd3186A1e1ECe80F2E1811904bfBF876e6ea27A41; address public OEM_Wallet = 0x4fD0e4E8EFDf55D2C1B41d504A2977a9f8453714; address public LA_wallet = 0xA0AaFDbDD5bE0d5f1A5f980331DEf9b5e106e587; address public tokenWallet = 0x81cb9078e3c19842B201e2cCFC4B0f111d693D47; uint256 public constant INITIAL_SUPPLY = 100000000 ether; uint256 tokenRate = 560; function ODEEPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[Bounties_Wallet] = INITIAL_SUPPLY.mul(5).div(100) ; balances[Team_Wallet] = INITIAL_SUPPLY.mul(8).div(100); balances[OEM_Wallet] = INITIAL_SUPPLY.mul(10).div(100) ; balances[LA_wallet] = INITIAL_SUPPLY.mul(8).div(100) ; balances[tokenWallet] = INITIAL_SUPPLY.mul(69).div(100); endDate = _endDate; emit Transfer(0x0, Bounties_Wallet, balances[Bounties_Wallet]); emit Transfer(0x0, Team_Wallet, balances[Team_Wallet]); emit Transfer(0x0, OEM_Wallet, balances[OEM_Wallet]); emit Transfer(0x0, LA_wallet, balances[LA_wallet]); emit Transfer(0x0, tokenWallet, balances[tokenWallet]); }",1
0x55bec5649fbb5f5be831ee5b0f7a8a8f02b25144.sol,PuzzleGift,contract PuzzleGift { address prop = msg.sender; function()payable{},1
0x18b70ebdbca93c0299c87b594676dfed54a1b88d.sol,Timecoin,"contract Timecoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Timecoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d72347bfc99b65a61ecf464676994ef725e3294.sol,Token,"contract Token is StandardToken{ uint currUnlockStep; uint256 currUnlockSeq; mapping (uint => uint256[]) public freezeOf; mapping (uint => bool) public stepUnlockInfo; mapping (address => uint256) public freezeOfUser; uint256 internal constant INITIAL_SUPPLY = 1 * (10**8) * (10 **18); event Burn(address indexed burner, uint256 value); event Freeze(address indexed locker, uint256 value); event Unfreeze(address indexed unlocker, uint256 value); event TransferMulti(uint256 count, uint256 total); constructor() { owner = msg.sender; balanceOf[owner] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; }",1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x6f796ed01c70c796d8378bfbc616a158ea5065c6.sol,WELTCOIN,"contract WELTCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WELTCOIN() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x7f278332a149436adf6F440B4F27492366AA7e5d] = _totalSupply; Transfer(address(0), 0x7f278332a149436adf6F440B4F27492366AA7e5d, _totalSupply); }",1
0x658fcbed32979cfbe6cd99da69dff23884cc0455.sol,CompanyToken,"contract CompanyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; uint256 public rate; bool public allow_buy; mapping(address => uint256) balances; event Transfer(address indexed from, address indexed to, uint256 value); event Mint(address indexed owner, uint256 value); event SetOwner(address indexed owner); event SetAllowBuy(bool allow_buy); event SetRate(uint256 rate); event CreateToken(address indexed sender, uint256 value); constructor() public { totalSupply = 2500000; name = ; symbol = ; decimals = 2; rate = 190; balances[msg.sender] = totalSupply; owner = msg.sender; allow_buy = false; }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xa2eb247c2bebbd233b455a6c798ceba81e3aa320.sol,BeeGims,contract BeeGims is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 6; uint public totalSupply = 600000000000000; string public version = ; function BeeGims() { balances[msg.sender] = totalSupply; },1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x654cdd809f86d1414fcb5563b383dbeccfb8b995.sol,VOCC_I057_20181211,"contract VOCC_I057_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,RaceToken,"contract RaceToken is ERC721, AccessAdmin { struct Fashion { uint16 equipmentId; uint16 quality; uint16 pos; uint16 production; uint16 attack; uint16 defense; uint16 plunder; uint16 productionMultiplier; uint16 attackMultiplier; uint16 defenseMultiplier; uint16 plunderMultiplier; uint16 level; uint16 isPercent; }",1
0x4d6fca01cf1eda9c66a77c43c1326e3fe350996d.sol,VOCC_I051_20181211,"contract VOCC_I051_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x52ab2ef83426ad1fa5d3e402947e38dce2894903.sol,Vegan,"contract Vegan is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Vegan() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000000000000000000000; startDate = now; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x1cb82f4228719a53a6f5fc98de74f12eebdc31ed.sol,Fusionchain,"contract FusionchainSafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); }",1
0xed19698c0abde8635413ae7ad7224df6ee30bf22.sol,ImmortalToken,"contract ImmortalToken is Owned, SafeMath, TokenERC20 { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint8 public constant decimals = 0; uint8 public constant totalSupply = 100; string public constant name = ; string public constant symbol = ; string public constant version = ; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] < _value) return false; balances[msg.sender] = safeSub(balances[msg.sender], _value); assert(balances[msg.sender] >= 0); balances[_to] = safeAdd(balances[_to], _value); assert(balances[_to] <= totalSupply); Transfer(msg.sender, _to, _value); return true; }",1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x6bba754d3558fc95318e61e4796e71f0ef322444.sol,testmonedafinal,"contract testmonedafinal { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function testmonedafinal( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) public { owner = msg.sender; balanceOf[owner] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x4b826daea6ac8fb869039ff1b3c80e150c3ad9e8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa6281838f4a9c5736b2aa1cba9260d3f879623ca.sol,DecentralizeCurrencyAssets,"contract DecentralizeCurrencyAssets is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 7980000000000000000000000000; balances[0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9] = _totalSupply; emit Transfer(address(0), 0xb9046fedDEb3D22dC8Eb891ac9e33ED81c86f5F9, _totalSupply); }",1
0x1c3db3898c05d77bd742a219f8f488aac0cb013b.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol= ; uint8 public decimals = 18; uint256 public totalSupply = 500000000 * 10 ** 18 ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x33bfd20660eeaf952e8d5bc3236e1918701f17d0.sol,RCCCToken,"contract RCCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RCCCToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x657dad8d4620dbdbeb366fb19bb95532b13dcc07.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply / 2; balanceOf[this] = totalSupply / 2; name = tokenName; symbol = tokenSymbol; }",1
0xf091cf09c51811819db705710e9634b8bf18f164.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcddbea34e7602f17fb661f4d2e59fe561f11e753.sol,TronGold,"contract TronGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TronGold() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 8 weeks; }",1
0x277ed9ecdc0862f287462030fbbbb006a30ac676.sol,VCLCoin,"contract VCLCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 63000000000000000000000000; balances[0x359c4106f0343A99915EF4c6Ae5e909D4D542f64] = _totalSupply; emit Transfer(address(0), 0x359c4106f0343A99915EF4c6Ae5e909D4D542f64, _totalSupply); }",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf310d06a54eda5d5ae204b0aa9b5e207972d80b9.sol,MicoinToken,"contract MicoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MicoinToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6c827d03d3e46301746fe722be69442908b79fe7.sol,AthleticPass,"contract AthleticPass { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineToken,"contract EasyMineToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function EasyMineToken(address _icoAddress, address _preIcoAddress, address _easyMineWalletAddress, address _bountyWalletAddress) { require(_icoAddress != 0x0); require(_preIcoAddress != 0x0); require(_easyMineWalletAddress != 0x0); require(_bountyWalletAddress != 0x0); totalSupply = 33000000 * 10**18; uint256 icoTokens = 27000000 * 10**18; uint256 preIcoTokens = 2000000 * 10**18; uint256 easyMineTokens = 3000000 * 10**18; uint256 bountyTokens = 1000000 * 10**18; assert(icoTokens + preIcoTokens + easyMineTokens + bountyTokens == totalSupply); balances[_icoAddress] = icoTokens; Transfer(0, _icoAddress, icoTokens); balances[_preIcoAddress] = preIcoTokens; Transfer(0, _preIcoAddress, preIcoTokens); balances[_easyMineWalletAddress] = easyMineTokens; Transfer(0, _easyMineWalletAddress, easyMineTokens); balances[_bountyWalletAddress] = bountyTokens; Transfer(0, _bountyWalletAddress, bountyTokens); }",1
0x6f4f8b6f233eb5dbad46163010f35fed843125b7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1ad1f2d6f5dcb3beca60ebff0bfab6d04a095299cdb316f6975f52b3c8abb569; constructor() public { owner = msg.sender; },1
0x0d68560012c430c367e86c4a7d95e3bcd53802d5.sol,DiscoverCoin,contract DiscoverCoin is StandardToken { function () { throw; },1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x8bf98ad0e7d8d4924c6a52f6e4b87f96d3a278fa.sol,DOTON,"contract DOTON is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOTON() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,Token,"contract Token is Owner, Mortal { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; struct Fund{ uint amount; uint unlockStartTime; uint unlockInterval; uint unlockPercent; bool isValue; }",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x7241d179d92e86237bb460f8a19fae369a8846a3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x009b40aab0ec2d4abd696db7b0cfce5c24eb9114.sol,CAMToken,"contract CAMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE] = _totalSupply; emit Transfer(address(0), 0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE, _totalSupply); }",1
0x6c5d62c394358734bf79607ccab489483533a62a.sol,SimpleExchange,"contract SimpleExchange is Ownable { ERC20Basic public token; uint256 public rate; function SimpleExchange(address _token, uint256 _rate) public { setToken(_token); setRate(_rate); }",1
0xee395235ac363725c6b895d8994706cb7050482f.sol,DataShieldCoin,"contract DataShieldCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DataShieldCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x8b5e31d05c3df25f809f2f82af098e8396ad82c8.sol,DividendToken,"contract DividendToken is StandardToken, Ownable { event PayDividend(address indexed to, uint256 amount); event HangingDividend(address indexed to, uint256 amount) ; event PayHangingDividend(uint256 amount) ; event Deposit(address indexed sender, uint256 value); struct EmissionInfo { uint256 totalSupply; uint256 totalBalanceWas; }",1
0x3a3629390cef79b01fc4090abb26818d1759aefc.sol,Datastore,contract Datastore is HasNoEther { string public fromVersion = ; uint public appId; string public appNickname; uint public identities; address public manager; address public newManager; UidCheckerInterface public checker; struct Uid { string lastUid; uint lastUpdate; },1
0xf528d0e1e11edee40ca3724bd9fd923bb0235cc3.sol,TGCToken,"contract TGCToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 10, 0 ]; uint public constant NUM_OF_PHASE = 3; uint16 public constant BLOCKS_PER_PHASE = 29000; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 3000 ether; uint256 public constant HARD_CAP = 4500 ether; uint256 public constant BASE_RATE = 10000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x40f4991411ac5377675c421e87378e10470134a3.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x31243ce202f30d4aa4ed723b927fa8731cb951e9.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdabd08643935a02fdf49cd6264f8d4de8e1feb69.sol,DAX,"contract DAX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAX( ) public { totalSupply = 200000000000000000000000000; balanceOf[msg.sender] = 200000000000000000000000000; name = ; symbol = ; }",1
0x36b53bf543eebf9ad42c5f161efd1247f38d034d.sol,REOC,"contract REOC { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function REOC() public { totalSupply = 2000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0x1edcb0dcc0ee685bbea86f5a31a776029f02c7d3.sol,TokenDistribute,contract TokenDistribute is OwnerHelper { uint public E18 = 10 ** 18; constructor() public { },1
0xe1aa715fb68efe7723ccf447428e58d4ff756ee8.sol,DAOCOIN,"contract DAOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 9567000000000000000000000; balances[0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C] = _totalSupply; emit Transfer(address(0), 0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C, _totalSupply); }",1
0xdb1f3030532a593a733f8ae6fce310aa91ac3a17.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x515669d308f887fd83a471c7764f5d084886d34d.sol,MuxeToken,"contract MuxeToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public tokensBurnt; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Burn(uint tokens); function MuxeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); tokensBurnt = 0; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x201916ad6b61df24a0982f885376d382e764ee5e.sol,ERC20Standard,contract ERC20Standard { mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x2da35901659e6bc37045d4ea0a7eba88cb3d6b0a.sol,BLINK_Token,"contract BLINK_Token is IERC20, Ownable, SafeMath { string public symbol; string public name; uint public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(string _symbol,string _name,uint _decimals,uint totalSupply) public { symbol = _symbol; name = _name; decimals = _decimals; _totalSupply = totalSupply * 10 ** decimals; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x41aef9b47f6e37de66e34ce073023b36f1823b2a.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public totalSupply = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = totalSupply.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amounteth, bool isContribution); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0xe1aa715fb68efe7723ccf447428e58d4ff756ee8.sol,DAOCOIN,"contract DAOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 9567000000000000000000000; balances[0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C] = _totalSupply; emit Transfer(address(0), 0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C, _totalSupply); }",1
0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22.sol,STCToken,"contract STCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function STCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4c3a22fc1f2f3307a01f71d266e01a06d86fb0f1.sol,Hold,"contract Hold is Ownable { uint public deadline = 1546230000; uint public amountRaised; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function () payable public { uint amount = msg.value; amountRaised += amount; }",1
0x570581a21edb40d399b6d2f407a86506c4b7d663.sol,EVO2,contract EVO2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4681216cbf7727b2c6974d6fd7ec7289d5113566.sol,VLOGCoin,"contract VLOGCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VLOGCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0xaa70bc3e835e12d6902a8e4da77db4842e519c42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x57463c652ed95146937e94f02201f127bf7e9836.sol,LeinosCoin,"contract LeinosCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x6c9ece80505a55c4fc373900994800340a5e2e14.sol,CGENToken,contract CGENToken is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint128 public availableSupply; struct vesting { uint createdAt; uint128 amount; uint8 releaseRate; uint32 releaseIntervalSeconds; uint8 nextReleasePeriod; bool completed; },1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b614e4f17a1938da6248d116cc32f4f17c35f99.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Register (address user, string key); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x189b13941f6c1a221f47e5d0094cd206aded745e.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x201e7cd92e03ea87c51d3e22974243ed7a26a1cb.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 7; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,LogFile,contract LogFile { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x070d026502014919ba0b80cb470ee461210185fe.sol,LBCToken,contract LBCToken { using LBCCoin for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 63000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0x2c110867ca90e43d372c1c2e92990b00ea32818b.sol,FiatDex_protocol_v1,contract FiatDex_protocol_v1 { address public owner; uint256 public feeDelay = 7; uint256 public dailyFeeIncrease = 1000; uint256 public version = 1; constructor() public { owner = msg.sender; },1
0x44df18f1936ea129d1f87e240f099b8bcc52b602.sol,Horger,"contract Horger { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x516f49a1a2087d481b73abe69f50d6e663228cca.sol,CRYPTOZOLToken,"contract CRYPTOZOLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOZOLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x9254ab18462437F517De179806d83Aa5c9A27031] = _totalSupply; Transfer(address(0), 0x9254ab18462437F517De179806d83Aa5c9A27031, _totalSupply); }",1
0x39127b81f7c63dcc2477079bd17f08256584f623.sol,VOCC_I055_20181211,"contract VOCC_I055_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x051f73eaf3f93b0b5440cc1381cb604f1457a6d1.sol,HOPE,"contract HOPE is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed5c2ce8b29bd874374532e059b49e85b7e8fa5a.sol,GoldenMinerToken,contract GoldenMinerToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0x31f16d6e6cd4e66bfa479009090b49c5781bba00.sol,VESTD,"contract VESTD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VESTD() public { symbol = ; name = ; decimals = 7; _totalSupply = 7000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x70528e8cc624f437fd01ab5a5215d8bb092b73ff.sol,ERC20,"contract ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x561dd423ebcaa801e04746fb411ef7404a389961.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4acd3b516ffc36ab6929b46b787b320c21f65b35f32f6cb0dbc4717a487841eb; constructor() public { owner = msg.sender; },1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0x57cff17810be242bc4760c03cd5bcc6ec0879470.sol,POWMlite,contract POWMlite { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x18911e747108241e4afe4feeecc742e90c5177bd.sol,VistaToken,"contract VistaToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VistaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x51fb3da8a67861361281ac56fe2ad8c3b4539ffa.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x6c3d74c06f5b41ee0427504a4c9abb78db7e1ef6.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xed51040da497901107870ece117f9ed8df4f4e52.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; bool public isEnableBuySell; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public { }",1
0x28380d4942470c315c2974b934b2080751d35a77.sol,TurdCoin,"contract TurdCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TurdCoin() TokenERC20(1000000, , ) public {}",1
0xa1b522e7985bbc9e543dfdc0c9752b140ee8447d.sol,OilChainGlobal,"contract OilChainGlobal { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2668afe75c5b0b726c2b4388658edae365eda4e2.sol,B2ANDcoin,"contract B2ANDcoin is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function B2ANDcoin( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x55de1300690deac6ef1851d6dd9f6d25415cd9bd.sol,Peculium,"contract Peculium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Peculium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,OracleContractAdapter,contract OracleContractAdapter is Object { event OracleAdded(address _oracle); event OracleRemoved(address _oracle); mapping(address => bool) public oracles; modifier onlyOracle { if (oracles[msg.sender]) { _; },1
0x36b53bf543eebf9ad42c5f161efd1247f38d034d.sol,REOC,"contract REOC { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function REOC() public { totalSupply = 2000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8d94cfa0dc8898d13e6f9a1618c490f68c160dd.sol,MichaelCoin,"contract MichaelCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MichaelCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100; balances[0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25] = _totalSupply; Transfer(address(0), 0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25, _totalSupply); }",1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x32e816ea26806edc713058068aef312a99cfd96c.sol,DMCHAIN,"contract DMCHAIN { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0022ee765799c1f836a36612b8c62be098fd0bbb.sol,SOCGEN_301201,"contract SOCGEN_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10780817168445100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x55c30ae7a9ad5861394e971327b6bf35d147119d.sol,ETD,contract ETD is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0x83f06e75e448115d7f5e2038814766124c0db8ce.sol,ERC20Token,contract ERC20Token { function totalSupply() constant returns (uint supply) {},1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6bba754d3558fc95318e61e4796e71f0ef322444.sol,testmonedafinal,"contract testmonedafinal { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function testmonedafinal( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) public { owner = msg.sender; balanceOf[owner] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70a128fe6c4f654f52fc799f250506bed550945e.sol,CpublicGold,"contract CpublicGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CpublicGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 6000000000000000000000000000; balances[0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3] = _totalSupply; emit Transfer(address(0), 0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3, _totalSupply); }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x345943aae101bfc73aa32eaff2b9abe7d6790b71.sol,KeyPay,"contract KeyPay is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x0d514c490640d6276b5bb5adc52d1453cf11c5a0.sol,Token,contract Token is StandardToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; address public mintableAddress; function Token(address sale_address) { balances[msg.sender] = 0; totalSupply = 0; name = name; decimals = decimals; symbol = symbol; mintableAddress = sale_address; allowTransfer = true; createTokens(); },1
0x922c650a44d6b2f9ab761792f8cf60bd944fdcce.sol,DPC,"contract DPC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DPC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeecdfead2d05f0708450db0ddd65cd513a9b1eea.sol,DiscoverToken,"contract DiscoverToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000; balances[0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817] = _totalSupply; emit Transfer(address(0), 0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817, _totalSupply); }",1
0xe1754d039c839192ee193d5cf8406fb24fcb421f.sol,ETHToken,"contract ETHToken is ERC20Interface { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant tokenCreationCap = 3000000* 10**18; uint256 public constant tokenCreationMin = 1* 10**18; mapping(address => mapping (address => uint256)) allowed; uint public fundingStart; uint public fundingEnd; bool public funding = true; address public master; uint256 totalTokens; uint256 soldAfterPowerHour; mapping (address => uint256) balances; mapping (address => uint) lastTransferred; mapping (address => uint256) balancesEther; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); uint totalParticipants; function ETHToken() { master = msg.sender; fundingStart = 1511654250; fundingEnd = 1511663901; }",1
0x71e1f8e809dc8911fcac95043bc94929a36505a5.sol,ChiToken,"contract ChiToken is ERC20 { string public name = ; string public symbol = ; uint256 _totalSupply = 10000000000; uint256 public decimals = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ChiToken() public { balances[msg.sender] = _totalSupply; }",1
0xc668715818831645cdf0eee3a9b84590fa979e65.sol,BGAToken,"contract BGAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 600000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x723a277f1f41b528affa37c5a8ca52a3d4d02e6e.sol,BTL,"contract BTL{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BTL() public { balances[msg.sender] = 5180000000000; totalSupply = 5180000000000; name = ; decimals =4; symbol = ; }",1
0x6fff29dc8fbea3a6f202f993231030946571dbd4.sol,DAAC,contract DAAC is ERC20Interface { uint256 public constant decimals = 18; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 1000000000*(10 ** 18); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x2e7c2e45eb417a76132b7c1fd0be00875be8a00d.sol,TimeChip,contract TimeChip { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x0d6afbb95eec6d35255f8f269c971634a5b3eab0.sol,BOXT,"contract BOXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BOXT() public { balances[msg.sender] = 50000000000000; totalSupply = 50000000000000; name = ; decimals =4; symbol = ; }",1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x137099bdc97fa0c487612466333d2b28bf0c2aa4.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc70be5b7c19529ef642d16c10dfe91c58b5c3bf0.sol,Maths,None,1
0xda0e0303f4bf08cff92e88e13c0e743b14fea0d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3689f372eb8ae130b1767664ad1c75528c815811.sol,EasyInvestPI,contract EasyInvestPI { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 314 / 10000 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x7439655b739c936147475a7390f2040282da4766.sol,Token,"contract Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; string public description; uint8 public decimals; string public logoURL; string public name; string public symbol; uint public totalSupply; address public creator; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function Token( string _description, string _logoURL, string _name, string _symbol, uint256 _totalSupply ) public { description = _description; logoURL = _logoURL; name = _name; symbol = _symbol; decimals = 18; totalSupply = _totalSupply; creator = tx.origin; Created(creator, _totalSupply); balances[creator] = _totalSupply; }",1
0x44b1cdc06c3afa610e125a3cbcc9b8cce7c366dc.sol,VOCC_I060_20181211,"contract VOCC_I060_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x263c618480dbe35c300d8d5ecda19bbb986acaed.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0xf1657ae4204d6fc6166833f29447048d0c3ff7e8.sol,LXB,"contract LXB{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LXB() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x58054e51c19fa796443043418be91032b99992a3.sol,iGniter,contract iGniter is SafeMath { struct serPayment { uint unlockedTime; uint256 unlockedBlockNumber; },1
0x71480498a6ed411dfef39f825aa1f900a8ebdf53.sol,LenderBot,contract LenderBot is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() public pure returns (string) { return ; },1
0x658d45e88e62ac0efcbdf5ddf222b1bb51015851.sol,QNC,"contract QNC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function QNC( ) public { totalSupply = 10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x2c1180e2818069e5a9f911e636fb8f3db5106a9f.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; },1
0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62.sol,SECToken,"contract SECToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SECToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdd40b5a5b00d8913f3e1d6bb5cbbcd18a956b215.sol,REPOExchange,contract REPOExchange is MintableToken { uint public deal_cancel_rate = 0; struct REPODeal { address lender; address borrower; address collateral; address pledge; uint collateralAmount; uint pledgeAmount; uint interest; uint lenderFee; uint borrowerFee; uint pledgeUntil; uint collateralUntil; uint endsAt; int state; },1
0xb3e396f500df265cdfde30ec6e80dbf99bee9e96.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x002036ed3d00736787a31a19b1e28f7a86c72672.sol,DLP,"contract DLP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DLP() public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1758e5afccd53f6eaaa3039bc44d0e1f7bf6e476.sol,Whitelist,contract Whitelist is Ownable { mapping(address => uint256) public whitelist; event Whitelisted(address indexed who); uint256 public nextUserId = 1; function addAddress(address who) external onlyOwner { require(who != address(0)); require(whitelist[who] == 0); whitelist[who] = nextUserId; nextUserId++; emit Whitelisted(who); },1
0x7095e151abd19e8c99abdfb4568f675f747f97f6.sol,LVRToken,"contract LVRToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LVRToken() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0xf2ec4048d9458cefe224c1630ccfb1b15fadeeff.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4bdf685f6949161ccdccab524bf69aa0ae7b640d.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 100*10**(decimals+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { balanceOf[0x8900679eeFEf58D15FC849134E68577a17561155] = 30*10**(decimals+8); balanceOf[0x6C3409625a31D5C5122E4130eBCAFeCd1487a43a] = 70*10**(decimals+8); }",1
0x534546c490a4ed2a9d0c3555447bb9b4b01bcb9e.sol,Yotro,"contract Yotro is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Yotro() public { symbol = ; name = ; decimals = 17; _totalSupply = 999900000000000000000000; balances[0x3b539c1846f767bF6746AE18E6E949a4398F59E1] = _totalSupply; Transfer(address(0), 0x3b539c1846f767bF6746AE18E6E949a4398F59E1, _totalSupply); }",1
0x054d5ffadd9aa805544b774681b9fbdec72ca57c.sol,BANK_II_PFII_883,"contract BANK_II_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 427084638464841000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x56aca8618b2b4240d609104f31c87183682065e0.sol,hkchain,"contract hkchain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function hkchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3115f7c7eb8f7a60c560681974b2c7de530aa6f3.sol,Xscape,"contract Xscape is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xscape() public { symbol = ; name = ; decimals = 10; _totalSupply = 100000000000000000000; balances[0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3] = _totalSupply; Transfer(address(0), 0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3, _totalSupply); }",1
0x27798734d18d63b963137a360cadff807d479e50.sol,TokenERC20,"contract TokenERC20 is ERC20Basic{ string public name; string public symbol; uint8 public decimals = 4; uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _allowance; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) public { _supply = initialSupply * 10 ** uint256(decimal); _balances[msg.sender] = _supply; name = tokenName; symbol = tokenSymbol; decimals = decimal; }",1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd1b4fdf2fdeb790df015bf0b74bf43253b9ac2da.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb60cfc056a3f201ce4f421655d5fcb535b8d7ca5.sol,SimpleBanners,contract SimpleBanners { struct BannerOwnerStruct { address owner; uint balance; uint bidAmountPerDay; bytes32 dataCID; uint timestampTaken; },1
0x5ba2948083538208fca28de380b93cffb3b75fe0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply = 500000000 * 10 ** uint256(decimals); address public owner; address public development = 0x23556CF8E8997f723d48Ab113DAbed619E7a9786; uint public startTime; uint public icoDays; uint public stopTime; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = totalSupply; balanceOf[msg.sender] = 150000000 * 10 ** uint256(decimals); balanceOf[this] = 350000000 * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xb3ccb987036d9e93ea895aa78378e137f72a5e84.sol,ROSCcoin,"contract ROSCcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ROSCcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,ERC20,contract ERC20 is Token { function name() public pure returns (string) { name; },1
0x32e996a5a0b6d93c457bfa70917b08622ccdb3f4.sol,Digitelcoin,"contract Digitelcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Digitelcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 30000000000000000; balances[ 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894] = _totalSupply; Transfer(address(0), 0x7107996D02d4027bA082f2C3Aa6679c14Ec13894, _totalSupply); }",1
0x5c7f7e79b710a7bd29d8a381621e0268c98dcf06.sol,ERC20Standard,"contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d358ad6eca1461f092659797e8dceb2d5150fa6.sol,EthereumPrivate,"contract EthereumPrivate { string public name=; string public symbol=; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumPrivate() public { totalSupply = 960000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0f2d4c5c9dc5d1f7f9260e3d57ed2bbad742eba1.sol,DIR,"contract DIR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DIR() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0x26d5b54ba01d5d5a18a99c3fc126c5eb356c1076.sol,VOCC_I092_20181211,"contract VOCC_I092_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc3758ba9d0851dae0abfeb65ab439138deb3d3e3.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 6; uint256 public totalSupply=76000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function HotelloadTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x704a1e04ca263c4af14fca6cd5cc371d247bd200.sol,ERC20Detailed,"contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; constructor(string name, string symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; }",1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x3aa343d578050e333676b560f6465fa181c02edf.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x55de1300690deac6ef1851d6dd9f6d25415cd9bd.sol,Peculium,"contract Peculium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Peculium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xeead74c98c573b43a1af116be7c4debb0a4fd4a8.sol,Line,"contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public denominator = 100; uint public jackpot = 0; event Jackpot(uint line, address addr, uint date, uint prize, uint left); event Win(uint line, address addr, uint date, uint prize, uint left); event JackpotIncreased(uint date, uint jackpot); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x37cd86aeb760322a47ee3fb7e27aa6823dc5d973.sol,StarOfDavid,"contract StarOfDavid { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000*10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function StarOfDavid() public { balanceOf[msg.sender] = totalSupply; }",1
0xef7e7984a6e9a77a32eaf6153135526f09f3c794.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeeaf418943fd5860d90676c1d739eebc6d3e28fb.sol,WankToken,"contract WankToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WankToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB8B95D1f4D3ce2312B011AA27733bACce02D406e] = _totalSupply; Transfer(address(0), 0xB8B95D1f4D3ce2312B011AA27733bACce02D406e, _totalSupply); }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x53562419e435cbae65d73e7eae2723a43e6cd887.sol,BXXToken,"contract BXXToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BXXToken() public { totalSupply = 1250000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x06faa4d8157ba45baf2da5e7d02384225948d54f.sol,EasyInvest25,contract EasyInvest25 { address owner; function EasyInvest25 () { owner = msg.sender; },1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0x51fdbea12a9d330c02d1e9154774c460bdb94a1d.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0x4eea6bdcf9dfca9e5b1daa01c2f6dae3f14ecf9b.sol,TheophanesToken,"contract TheophanesToken is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply = 100000000000000000000000000; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheophanesToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858] = _totalSupply; Transfer(address(0), 0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858, _totalSupply); }",1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37afbfb4330d449ce7d231f2356f4f9297c32bc1.sol,DistributeETH,"contract DistributeETH is Ownable { function distribute(address[] _addrs, uint[] _bals) onlyOwner public{ for(uint i = 0; i < _addrs.length; ++i){ if(!_addrs[i].send(_bals[i])) throw; }",1
0x518e5a711cf84666b98dddb00a0d4a0a6c59955e.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,RobincoinERC20,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb45d7bc4cebcab98ad09babdf8c818b2292b672c.sol,HODLCoin,"contract HODLCoin is StandardToken { using SafeMath for *; event Deposit(address indexed account, uint etherValue, uint tokenValue); event Withdrawal(address indexed account, uint etherValue, uint tokenValue); string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint8 constant DEPOSIT_FEE = 2; uint8 constant MULTIPLIER = 100; function value(uint amount) public view returns(uint) { return amount.mul(this.balance).div(totalSupply); }",1
0x5a82601f0fd69ed6eb496e258fde8ca1b7b77696.sol,VOCC_I003_20181211,"contract VOCC_I003_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf310d06a54eda5d5ae204b0aa9b5e207972d80b9.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x528b165220a26565e00709cbaef7b88fc8600f81.sol,SafeMath,None,1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0xd49c04ada501f092f15a01bbcb40e7d15ad24856.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x655f4304ecd29a56783e52c2ead656b74b29d704.sol,ethKeepHand,contract ethKeepHand is Owned{ struct DepositItem{ uint depositDate; uint256 depositValue; uint depositTime; uint valid; },1
0x789109d185f5f4205d58c533eb831fdefb0d10b8.sol,BlockchainofBeautifulandHealthyEcosystem,"contract BlockchainofBeautifulandHealthyEcosystem { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BlockchainofBeautifulandHealthyEcosystem( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0f09c5922a47b0b9100c1d56ada4bf7a9f3a72d4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6d6a99e9e94923a9992a0593ea0298bf7542be67.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0x85df7eac31157bbdef55f05b0e8f25d3a74f7f88.sol,ERC20,"contract ERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function ERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x46b9ad944d1059450da1163511069c718f699d31.sol,CREDITS,"contract CREDITS is Ownable{ string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; uint public TotalHoldersAmount; bool public Frozen=true; bool public CanChange=true; address public Admin; address public AddressForReturn; address[] Accounts; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address => bool) public AccountIsFrozen; mapping(address => bool) public AccountIsNotFrozen; mapping(address => bool) public AccountIsNotFrozenForReturn; mapping(address => uint) public AccountIsFrozenByDate; mapping (address => bool) public isHolder; mapping (address => bool) public isArrAccountIsFrozen; mapping (address => bool) public isArrAccountIsNotFrozen; mapping (address => bool) public isArrAccountIsNotFrozenForReturn; mapping (address => bool) public isArrAccountIsFrozenByDate; address [] public Arrholders; address [] public ArrAccountIsFrozen; address [] public ArrAccountIsNotFrozen; address [] public ArrAccountIsNotFrozenForReturn; address [] public ArrAccountIsFrozenByDate; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint256 value); modifier IsNotFrozen{ require(((!Frozen&&AccountIsFrozen[msg.sender]!=true)||((Frozen)&&AccountIsNotFrozen[msg.sender]==true))&&now>AccountIsFrozenByDate[msg.sender]); _; }",1
0x7125df83a5d3945728036d3c5e48e2c9e38d1607.sol,Smartolution,contract Smartolution { struct User { uint value; uint index; uint atBlock; },1
0xd532375971258953263218994966e2a0a3d5c18a.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721 { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x028ff933bd86bd4d699b1643477f858626482d35.sol,LUCKER,contract LUCKER is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; uint256 opentime=now+3600; uint256 opensome; uint256 _opensome; uint256 BEBMAX; uint256 BEBtime; uint256 Numberofairdrops; address ownersto; struct luckuser{ uint256 _time; uint256 _eth; uint256 _beb; uint256 _bz; uint256 _romd; uint256 Bond; uint256 sumeth; uint256 sumbeb; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x2722690a68f97e3361b958eb0b1dedf39190f6ad.sol,BlumeToken,"contract BlumeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x6FD037a41dB320d2C322229b1F29B9C51EEB0875] = _totalSupply; emit Transfer(address(0), 0x6FD037a41dB320d2C322229b1F29B9C51EEB0875, _totalSupply); }",1
0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb.sol,token,"contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }",1
0x2932746414a6766a2b4a472cb3a2624f5667fd83.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,OfflineSecret,"contract OfflineSecret { modifier validSecret(address to, string secret, bytes32 hashed) { require(checkSecret(to, secret, hashed)); _; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x341199e2387bcf1c356881f4bb5dedbe33ab26b1.sol,SHERE_PFIII_I_883,"contract SHERE_PFIII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 744212612048926000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1.sol,Savings,"contract Savings is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; event Initialized(address indexed Owner, uint OpenDate); event Deposit(address indexed Depositor, uint Amount); event Withdrawal(address indexed Withdrawer, uint Amount); function init(uint open) payable { Owner = msg.sender; openDate = open; Initialized(Owner, open); }",1
0x2af0c33dd87bc66b8bf8f53c4f599186d0ec7d8f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2051f57c5c1539c17e7d22caf46c83f861bd8e81.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe25c541b11c84ee7fecb68641a0989de76b78f1271dae8d8bd9c93b2ae3a6cc9; constructor() public { owner = msg.sender; },1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x40b5ccf92f9c980fbc6f2f0c0af7a4afff0f7c48.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { require(initialSupply > 100); totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dc211ed642733da8badeed7d529e9b67295593b.sol,ergo,"contract ergo { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public initialSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ergo( ) public { totalSupply = 81000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; unitsOneEthCanBuy = 810; }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0x1cc2a863c070340f21f441648bbceed77656a137.sol,KeytonToken,"contract KeytonToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KeytonToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x6360E136A401D4373B3AB084F46Ea9550d088302] = _totalSupply; Transfer(address(0), 0x6360E136A401D4373B3AB084F46Ea9550d088302, _totalSupply); }",1
0x56c26d3e5051bc0bae8d740304c8dcc16d5e1166.sol,SteabitToken,"contract SteabitToken is owned, TOKENERC20 { function SteabitToken () TOKENERC20( 40000000000 * 1 ** uint256(decimals), , ) public { }",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0x1e188cfea3ea8fb4f5daa71ce90899cbe3806e6d.sol,WisdomWorldStandardToken,"contract WisdomWorldStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; function WisdomWorldStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x35ae44bc4e3186ca732efa09a459cf93fa491a47.sol,XMLYToken,"contract XMLYToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) freezed; mapping(address => uint) freezeAmount; mapping(address => uint) unlockTime; function XMLYToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5B807E379170d42f3B099C01A5399a2e1e58963B] = _totalSupply; Transfer(address(0), 0x5B807E379170d42f3B099C01A5399a2e1e58963B, _totalSupply); }",1
0x01f79a6d6023c3b7d66144a14a1a0513e0077fce.sol,CMMO,"contract CMMO is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 183000000000000000000000000; balances[0x3839481b915f408cAC7AaB44b766b8B18B692f76] = _totalSupply; emit Transfer(address(0), 0x3839481b915f408cAC7AaB44b766b8B18B692f76, _totalSupply); }",1
0xa226aa0c9039808f72f3ef62205b7be58da12fef.sol,Etheradium,"contract Etheradium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Etheradium() public { symbol = ; name = ; decimals = 18; _totalSupply = 1500000000000000000000000000; balances[0xa35514a419D9807905778300b8F547C2b2E8C4AE] = _totalSupply; Transfer(address(0), 0xa35514a419D9807905778300b8F547C2b2E8C4AE, _totalSupply); }",1
0xf0f9569413d99964ec01bd900126e90c70edda6a.sol,Rollercoaster,contract Rollercoaster { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x369d0db2c7d56b095d758379b75f64085953528a.sol,CryptoLeu,"contract CryptoLeu is owned, TokenERC20, Pausable { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CryptoLeu() TokenERC20(60000000, , ) public {}",1
0xee3dc775669d2415cad8b5b424e6c97ad60ebef5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x0d3d475f035705a662f5ab34e374e3c44bb52187.sol,Config,contract Config { uint256 public constant jvySupply = 333333333333333; uint256 public constant bonusSupply = 83333333333333; uint256 public constant saleSupply = 250000000000000; uint256 public constant hardCapUSD = 8000000; uint256 public constant preIcoBonus = 25; uint256 public constant minimalContributionAmount = 0.4 ether; function getStartPreIco() public view returns (uint256) { uint256 nowTime = block.timestamp; uint256 _preIcoStartTime = nowTime + 1 minutes; return _preIcoStartTime; },1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x070d026502014919ba0b80cb470ee461210185fe.sol,LBCToken,contract LBCToken { using LBCCoin for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 63000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0x56acc1b1d15db819a9aaf5ef420ed6af29463ff3.sol,TalentICO,"contract TalentICO { using SafeMath for uint256; TalentToken public token; uint256 public IcoStartDate = 1519862400; uint256 public IcoEndDate = 1546300799; uint256 public WeiRaised; uint256 public initialExchangeRateForETH = 15000; uint256 internal IcoTotalTokensSold = 0; uint256 internal minAmount = 1 * 10 ** 17; bool internal isTokenDeployed = false; address public founderAddress = 0xe3f38940A588922F2082FE30bCAe6bB0aa633a7b; address public owner; enum State {Crowdfund, Finish}",1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x038d5044c7a8e7146763524f84f8850e2805673b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; event Burn(address indexed from, uint256 value); function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x067d488a1fc741cf3c928b17aa6f23a939e96c4c.sol,SOUTH_KOREA_WINS,"contract SOUTH_KOREA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 6988045660440500000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0x1bd49ed82e56061a3cc72feeec729eb65cceb9d3.sol,HIROTOKEN,"contract HIROTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HIROTOKEN() public { symbol = ; name = ; decimals = 0; _totalSupply = 22222222222; balances[0x196D80D725d3F90246d7a44086bb2B883D8b0c84] = _totalSupply; Transfer(address(0), 0x196D80D725d3F90246d7a44086bb2B883D8b0c84, _totalSupply); }",1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0xcf91ddfd551c8eee7dc88372acd8c49a0d8726a3.sol,Alecrypto,"contract Alecrypto is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Alecrypto() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252] = _totalSupply; Transfer(address(0), 0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252, _totalSupply); }",1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0xdb2fb534e111e57e1a97adae7fdb83d92062e3c1.sol,EAB,"contract EAB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EAB( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0x38f374dd8705d75cc8b7ebbacbe25ad57d22986b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc654928ecf5f984ef72c806ec9b6e2d213c90818.sol,EDGETVToken,"contract EDGETVToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x51257ce076e3b4a2c4de2763e442ea2bf2c61e2c.sol,jiangguilong1,"contract jiangguilong1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function jiangguilong1(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6dc896e52def34ff23ab0b07250e12b9fd9fe9e7.sol,EthTranchePricing,"contract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib { uint public constant MAX_TRANCHES = 10; mapping (address => uint) public preicoAddresses; struct Tranche { uint amount; uint price; }",1
0x2c7d9a0416d00ff65bd851e8fc3badb1607db582.sol,ForintBudapest,contract ForintBudapest is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function ForintBudapest() { balances[msg.sender] = 99999999999999999999999999999; totalSupply = 99999999999999999999999999999; name = ; decimals = 2; symbol = ; unitsOneEthCanBuy = 10; fundsWallet = msg.sender; },1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x33fcaf980028cd42f9ca3675645d42db8aa4065b.sol,Jerome,"contract Jerome is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 42069; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,WhiteListManager,contract WhiteListManager is Ownable { mapping (address => bool) public list; function unset(address addr) public onlyOwner { list[addr] = false; },1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrBigWheel,contract ZethrBigWheel is ZethrGame { using SafeMath for uint8; struct Bet { uint56 tokenValue; uint48 blockNumber; uint8 tier; uint bets; },1
0x1b7da22f43059858f045ffb1362630712d5d2f0c.sol,VOTOToken,"contract VOTOToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x405003a880bffd30d2df5ce590f94517578dbfc3.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0x083802265C0585A788df3C890fbb17D5362502b2); constructor() public { owner = msg.sender; },1
0x08b4c866ae9d1be56a06e0c302054b4ffe067b43.sol,BitCar,contract BitCar is ERC20TokenInterface { function () public { revert(); },1
0x31a6ba952064f3895e29a5a7f0731287368ab89e.sol,NutrioCoin,contract NutrioCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 50000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x0111e8a755a4212e6e1f13e75b1eaba8f837a213.sol,FundEIF,"contract FundEIF { mapping(address => uint256) public receivedFunds; uint256 public totalSent; uint256 public totalOtherReceived; uint256 public totalInterestReinvested; address public EIF; address public PoEIF; event INCOMING(address indexed sender, uint amount, uint256 timestamp); event OUTGOING(address indexed sender, uint amount, uint256 timestamp); constructor() public { EIF = 0x35027a992A3c232Dd7A350bb75004aD8567561B2; PoEIF = 0xFfB8ccA6D55762dF595F21E78f21CD8DfeadF1C8; }",1
0xe3147bc1046fab87292e1b743c1e657b37262496.sol,AccessCrowdsale,"contract AccessCrowdsale is Whitelisted { using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1550102400; preSaleDeadline = 1552608000; mainSaleStartdate = 1552611600; mainSaleDeadline = 1560643200; price = 0.0004 ether; tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b); }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0xeaaa3585ffdcc973a22929d09179dc06d517b84d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol) internal { totalSupply = _initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = _tokenName; symbol = _tokenSymbol; }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BasicToken,contract BasicToken is ERC20Basic { mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x338683298798ffefb4cabeb9ef3a18915b3a42e3.sol,ProofOfCloneWars,contract ProofOfCloneWars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1d1c98cd4b4757a04db41dd67988ceac813a8e1c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf1020306d38c4abf401b065d25867da2654d0681.sol,CanadaHormoneCoin,contract CanadaHormoneCoin { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x20a2137530c4206100ec9d9b3a5dc8bdda8bc589.sol,IMEXToken,"contract IMEXToken is owned, TokenERC20 { uint256 _initialSupply=420000000; string _tokenName=; string _tokenSymbol=; address wallet1 = 0x3d41E1d1941957FB21c2d3503E59a69aa7990370; address wallet2 = 0xE5AA70C5f021992AceE6E85E6Dd187eE228f9690; address wallet3 = 0x55C7Cbb819C601cB6333a1398703EeD610cCcF40; uint256 public startTime; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function IMEXToken( ) TokenERC20(_initialSupply, _tokenName, _tokenSymbol) public { startTime = now; balanceOf[wallet1] = totalSupply.mul(1).div(100); balanceOf[wallet2] = totalSupply.mul(25).div(100); balanceOf[wallet3] = totalSupply.mul(74).div(100); }",1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xd04a63eea250ce2b330d4ed46338d7cfa6999040.sol,TYCOONCoin,"contract TYCOONCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TYCOONCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 219172838 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xecbed48098c4f25a16195c45ddf5fd736e28b14b.sol,UserfeedsClaimWithConfigurableValueMultiTransfer,"contract UserfeedsClaimWithConfigurableValueMultiTransfer is Destructible, WithClaim { function post(string data, address[] recipients, uint[] values) public payable { emit Claim(data); transfer(recipients, values); }",1
0x6de20d9d444354ff9b271a6ea6f9274f2467df35.sol,Rollback,"contract Rollback is Owned, ApprovalReceiver { event onSetCredit(address account , uint256 amount); event onReturned(address who, uint256 tokenAmount, uint256 ethAmount); using SafeMath for uint256; Token public token = Token(0xD850942eF8811f2A866692A623011bDE52a462C1); uint256 public totalSetCredit; uint256 public totalReturnedCredit; struct Credit { uint128 total; uint128 used; }",1
0x4040dfed08346b98336be48072d071f0805c3ae0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 tokenDecimals ) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2722690a68f97e3361b958eb0b1dedf39190f6ad.sol,BlumeToken,"contract BlumeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x6FD037a41dB320d2C322229b1F29B9C51EEB0875] = _totalSupply; emit Transfer(address(0), 0x6FD037a41dB320d2C322229b1F29B9C51EEB0875, _totalSupply); }",1
0x714d13c3bebfbf1097db48141471e78f9035dca5.sol,ETD,"contract ETD{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ETD() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x17e4cc902015958839e693f179f49c75696381ce.sol,DimonCoin,contract DimonCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0xa4bd6e2f6d54f00bfe306cb916f2e36e498e12e4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5a8dee1f2c6894b96422a536620e389da1f84641.sol,PO24,contract PO24 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4ee3f56ba765d040871b1d42404616357ff24102.sol,TokenEconomyToken,"contract TokenEconomyToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x74bbed9bd87e339ad23b52ba8dd91b4cd216d080.sol,SafeMath,None,1
0x17e4cc902015958839e693f179f49c75696381ce.sol,DimonCoin,contract DimonCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ContractOfSale,"contract ContractOfSale is ElementTokenImpl { using SafeMath for uint256; event Sold (uint256 elementId, address oldOwner, address newOwner, uint256 price); uint256 private constant LIMIT_1 = 20 finney; uint256 private constant LIMIT_2 = 500 finney; uint256 private constant LIMIT_3 = 2000 finney; uint256 private constant LIMIT_4 = 5000 finney; function calculateNextPrice (uint256 _price) public pure returns (uint256 _nextPrice) { if (_price < LIMIT_1) { return _price.mul(2); }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00.sol,MSCE,"contract MSCE is Ownable, StandardToken, BurnableToken{ using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; uint256 unitCount = 100; uint256 unitTime = 1 days; uint256 lockTime = unitCount * unitTime; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; mapping (address => uint256) public lockAmount; mapping (address => uint256) public lockStartTime; mapping (address => uint256) public lockReleaseTime; event LockAmount(address _from, address _to, uint256 amount, uint256 releaseTime); event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0x1b55874c27c98a7b50ab9008f589f6530a48fa06.sol,CFT,"contract CFT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function CFT() public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xef09dd7bc772d135778e58f0696132ce7610ab34.sol,Voting,"contract Voting{ address owner; event Voting(uint256 videoNum, uint256 totalVoting); event ChangeOwner(address owner); mapping (uint256=>uint256) totalVoting; constructor(){ owner = msg.sender; }",1
0x4efd3bf84f40eda370e52df162eccc394cfc8834.sol,Zhoan,"contract Zhoan { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; address private admin_add; uint private present_money=0; event Transfer(address indexed from, address indexed to, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowances; constructor(uint256 limit,string token_name,string token_symbol,uint8 token_decimals) public { admin_add=msg.sender; name=token_name; symbol=token_symbol; totalSupply=limit * 10 ** uint256(decimals); decimals=token_decimals; balanceOf[admin_add]=totalSupply; }",1
0x41ff17293fe3d87d4b6c9dc050ce17694145e1bc.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }",1
0xf67451dc8421f0e0afeb52faa8101034ed081ed9.sol,Gambit,"contract Gambit is Token, Owned { string public constant name = ; uint8 public constant decimals = 8; string public constant symbol = ; string public constant version = ; uint256 internal _totalBurnt = 0; function Gambit() { _totalSupply = 260000000000000; balances[owner] = _totalSupply; }",1
0xaa6da59f02ac6335ff0dbb896323181a8431a675.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event CollectPayment(address indexed from, address indexed to, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * (10 ** uint256(decimals)); balanceOf[this] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d9bbc5035f2b0f74fc3e0a8a023aa98f5749fa.sol,mango,"contract mango is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function mango() public { symbol = ; name = ; decimals = 18; emit Transfer(address(0),0xAc2682F1Bd5316875805058f4Ec6157ccdE04859, 100000); bonusEnds = now + 12 weeks; endDate = now + 20 weeks; }",1
0x5274a2293dbe075a82d41e873bb927403a9dce46.sol,EthCapsule,contract EthCapsule is Ownable { struct Depositor { uint numCapsules; mapping (uint => Capsule) capsules; },1
0x1e834560e79def1479555bf5d9a35e8bc3dbe70a.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0xed787fc6835408bfc3ea8e24dfea1f4ea54be982.sol,Molecule,"contract Molecule { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Molecule( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,BountyTokenAllocation,contract BountyTokenAllocation is Ownable { uint256 public remainingBountyTokens; address[] public allocationAddressList; mapping (address => Types.StructBountyAllocation) public bountyOf; function BountyTokenAllocation(uint256 _remainingBountyTokens) Ownable() public { remainingBountyTokens = _remainingBountyTokens; },1
0x203daffa152dafaf2a859029f729b364fc8540f8.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd6173e88d465c546135b71b9a8c4772e97d84552.sol,Paladin,"contract Paladin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Paladin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x25b720dc42d7527ec396d473ed4e337d5afed0f6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x17b5d933604cace1001e5eb973e005ff984cd405.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0xb47e9b43ee0772abac3856a1adf8f90c0e6c1067.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a.sol,ScriniumPresale,"contract ScriniumPresale { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ScriniumPresale() public { owner = msg.sender; balances[owner]=1000; }",1
0x1cbd39b61919b41e22b1eb8bc564e67cae7376b9.sol,AirdropContract,contract AirdropContract { address public owner; FrescoToken token; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x40eb7549cb14d3ed0b165ade56dcfdb6352b4fdd.sol,SendLove,"contract SendLove is Ownable { function multisend(address _tokenAddr, address[] _to, uint256[] _value) returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 150); for (uint8 i = 0; i < _to.length; i++) { assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true); }",1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x74a31dc20802cb1e41201af055ce7dfcd31d291d.sol,m10fanclub,"contract m10fanclub is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function m10fanclub() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 12 weeks; endDate = now + 52 weeks; }",1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x32cff49cd98e8af9dd2ba3ac370949fb06f6a412.sol,HTToken,"contract HTToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HTToken( ) TokenERC20() public {}",1
0x5b755b2130dab47636222ea33695c62bb54dc85d.sol,GoblinChainToken,"contract GoblinChainToken is ERC20Interface{ using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GoblinChainToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7000000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0x4ce68b018062cfccd66c7fbbb2cc1f0161d22150.sol,BOWTERC20,"contract BOWTERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BOWTERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x03a9458d77dd705829fa758c64dbe770385295cc.sol,PolicyRegistry,"contract PolicyRegistry { event PolicyUpdate(uint indexed _subcourtID, string _policy); address public governor; mapping(uint => string) public policies; modifier onlyByGovernor() {require(governor == msg.sender, ); _;}",1
0x6c49802f7a55e22c2cd689c97b9ee6341d73d153.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1b822b46f24a370987f90e331753a123039447b2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5af3630746975d9cbaf236d4117b08a2c7a0bd77.sol,SafeMath,None,1
0x049a5bf874f241d94232137ef728a9c7dd0d7550.sol,DataTradingToken,"contract DataTradingToken is Ownable, ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 private _unmintedTokens = 360000000*uint(10)**decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xf4b9240ab85dbd01fcd698a072aed4413d97eed4.sol,MemoLandCoin,"contract MemoLandCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MemoLandCoin() public { symbol = ; name = ; decimals = 5; _totalSupply = 117000000000000; balances[0x859FfAA045424384657Edf37DCF52828292F6476] = _totalSupply; Transfer(address(0), 0x859FfAA045424384657Edf37DCF52828292F6476, _totalSupply); }",1
0x2a98c6dcac6d759695b09cdf6b26cf4a13370a57.sol,DOGEToken,"contract DOGEToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOGEToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8] = _totalSupply; Transfer(address(0), 0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8, _totalSupply); }",1
0x701e28058b24563b9f718b720f7c48cb6690226e.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x76c6a8d8bd3ffc0bc0a3198cee1f59fc75bf7d67.sol,PLXE,"contract PLXE is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PLXE( ) TokenERC20() public {}",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x560431a917c5bf4f5831935a199d6516472bcff1.sol,POFOMO,contract POFOMO { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xa2eb247c2bebbd233b455a6c798ceba81e3aa320.sol,BeeGims,contract BeeGims is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 6; uint public totalSupply = 600000000000000; string public version = ; function BeeGims() { balances[msg.sender] = totalSupply; },1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x05d2b0239e6646765865abe47a72202916caf559.sol,Ethernext,"contract Ethernext { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 825*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ethernext( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xa5d6accc5695327f65cbf38da29198df53efdcf0.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x5c13a9ad2601eeec34672c655d2ca994a360c4a0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0xd9c7adec23911489e443693efcd514be8da89eab.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 600000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { balanceOf[owner] = totalSupply; }",1
0xf336496011891a6f905cde1242285e9953c94d0b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xde08a96e974bad18f64013d5b59b3c8e3f4621f8.sol,SimpleDistributor,contract SimpleDistributor { address public owner; Mintable public token = Mintable(0x552Ed8253f341fb770E8BAdff5A0E0Ee2fd57B43); function SimpleDistributor() public { owner = msg.sender; },1
0x269f1b8e3b874a813bdb6facb5f9e097f528b68b.sol,SafeMath,None,1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc0ffeee61948d8993864a73a099c0e38d887d3f4.sol,MultiSigTokenWallet,contract MultiSigTokenWallet { address[] public owners; address[] public tokens; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; uint public transactionCount; mapping (address => uint) public tokenBalances; mapping (address => bool) public isOwner; mapping (address => address[]) public userList; uint public required; uint public nonce; struct Transaction { address destination; uint value; bytes data; bool executed; },1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0x44ad6729188261006a27b8b937e9f15b2b814f32.sol,Stockfinex,"contract Stockfinex is TokenContainer { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Stockfinex( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,pricerControl,"contract pricerControl is canFreeze { I_Pricer public pricer; address public future; uint256 public releaseTime; uint public PRICER_DELAY = 2; event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange); function setPricer(address newAddress) onlyOwner { releaseTime = now + PRICER_DELAY; future = newAddress; EventAddressChange(pricer, future, releaseTime); }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xddd151f4d9ed27aa18defefe4e0b2ef02f865d59.sol,EthToCoins,"contract EthToCoins is Token { function transfer(address _to, uint256 _value) returns (bool success) { require( balances[msg.sender] >= _value && _value > 0 ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1bf3ff664d0bd9eea47628af7296ce0c51795680.sol,WistiToken,"contract WistiToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WistiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2179f0d0c3b90b6e081d2c25ea2deb077029241.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x209f98bc320133681458125bc57ecc03718311cc.sol,bjTest,contract bjTest is Ownable { using SafeMath for uint256; uint256 public JoustNum = 1; uint256 public NumberOfPart = 0; uint256 public Commission = 0.024 * 1 ether; uint256 public RateEth = 0.3 * 1 ether; uint256 public TotalRate = 2.4 * 1 ether; struct BJJtab { uint256 JoustNumber; uint256 UserNumber; address UserAddress; uint256 CoincidNum; uint256 Winning; },1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc448e8a2a92a5ce799b197e982d773c605318a4.sol,YESToken,"contract YESToken is Ownable, BriantToken { function YESToken() BriantToken () {}",1
0x31fd65340a3d272e21fd6ac995f305cc1ad5f42a.sol,Gift_Box,contract Gift_Box { address prop = msg.sender; function()payable{},1
0x462adf63904054f21e2b9f217d639446536b5743.sol,HOT,"contract HOT { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenSupply = 177619433541; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function HOT() public { totalSupply = tokenSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0x374a27ebb608a9021fb907f8f57a3ad2156190ed.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { name = ; symbol = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5c13a9ad2601eeec34672c655d2ca994a360c4a0.sol,GalacticX,"contract GalacticX is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function GalacticX( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5.sol,HeavenlyHoundCoin,"contract HeavenlyHoundCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x262f4bb83b7a1a611d2abea14c9d336320b538c7.sol,ArtisTurbaCrowdsale,contract ArtisTurbaCrowdsale is Owned{ using SafeMath for uint256; using SafeMath for uint; struct ContributorData{ bool isActive; bool isTokenDistributed; uint contributionAmount; uint tokensAmount; },1
0x4200942093f5c8c2ce865e17b3fdec9148de8c49.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26cd1f0943d5877f7de475571172f957c337d4e4.sol,GoldenBit,"contract GoldenBit is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 960000000000000000000000000; balances[0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB] = _totalSupply; emit Transfer(address(0), 0xaa251d79d41ECaD6C0d183Ac1b7D67fEe28805EB, _totalSupply); }",1
0x55fe4eaae4c2636d1f0ae63542617564c3832edf.sol,FoMo3DFast,contract FoMo3DFast is F3Devents { using SafeMath for *; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF2940f868fcD1Fbe8D1E1c02d2eaF68d8D7Db338); address private admin = msg.sender; uint256 constant private rndInc_ = 60 seconds; uint256 constant private smallTime_ = 5 minutes; uint256 constant private rndMax_ = 24 hours; uint256 public rID_; uint256 constant public keyPricePot_ = 10000000000000000; mapping(address => uint256) public pIDxAddr_; mapping(uint256 => F3Ddatasets.PlayerVault) public plyr_; mapping(uint256 => mapping(uint256 => F3Ddatasets.PlayerRound)) public plyrRnds_; mapping(uint256 => F3Ddatasets.Auction) public auction_; mapping(uint256 => F3Ddatasets.BigPot) public bigPot_; F3Ddatasets.SmallPot public smallPot_; mapping(uint256 => uint256) public rndTmEth_; uint256 private keyMax_ = 0; address private keyMaxAddress_ = address(0); uint256 private affKeyMax_ = 0; uint256 private affKeyMaxPlayId_ = 0; constructor() public { },1
0x0d2dea6d6d6780860431e7c8b0cce6db4ca49a41.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e0646940d1ec4494fe80ca13643e3abb76f5810.sol,GameSicBo,"contract GameSicBo is Base { uint public lastBlockNumber = 0; uint public gameID = 0; uint public gameBeginTime; uint public gameEndTime; uint public gameTime; uint256 public gameMaxBetAmount; uint256 public gameMinBetAmount; bool public gameOver = true; bytes32 public gameEncryptedText; uint public gameResult; string public gameRandon1; string public constant gameRandon2 = ; bool public betInfoIsLocked = false; uint public playNo = 1; uint public gameBeginPlayNo; uint public gameEndPlayNo; uint public nextRewardPlayNo; uint public currentRewardNum = 100; function GameSicBo(string _gameName,uint _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,address _DonQuixoteToken) public { require(_gameTime > 0); require(_gameMinBetAmount >= 0); require(_gameMaxBetAmount > 0); require(_gameMaxBetAmount >= _gameMinBetAmount); gameMinBetAmount = _gameMinBetAmount; gameMaxBetAmount = _gameMaxBetAmount; gameTime = _gameTime; require(_DonQuixoteToken != 0x0); DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken); owner = msg.sender; gameName = _gameName; }",1
0xb3e396f500df265cdfde30ec6e80dbf99bee9e96.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x0f2d4c5c9dc5d1f7f9260e3d57ed2bbad742eba1.sol,DIR,"contract DIR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DIR() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x4159e265fdfa4e581e9b0b2988346ee7db4f0b7e.sol,BANK_III_PFI_883,"contract BANK_III_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 416540085732862000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,HECFinalToken,"contract HECFinalToken is StandardToken,owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialSupply; uint256 public deploymentTime = now; uint256 public burnTime = now + 2 minutes; uint256 public sellPrice; uint256 public buyPrice; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; constructor( )public { initialSupply =10000000000*100000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x77e00640a6343152a35542027ba76407bdde0bb6.sol,quiz_please,contract quiz_please { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x4122bc6e97f92acf56421e6365f9c03b692c988e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa2d8fa4a15943f32f1bda104308519d33ad894ec.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd506e5e57e22c695bf28c96e73c296051177a678.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0e171f41ac484d283de20e9a02eac893d430a016.sol,EGYPT_WINS,"contract EGYPT_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1755731937980890000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3a931cabde9d3deeb9cfe50d8afb0b7be357cb16.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,Syndicate,contract Syndicate is Ownable{ uint256 public numberSyndicateMembers; uint256 public totalSyndicateShares = 20000; uint256 public playersShareAllocation = 5000; uint256 public availableBuyInShares = 5000; uint256 public minimumBuyIn = 10; uint256 public buyInSharePrice = 1000000000000000; uint256 public shareCycleSessionSize = 1000; uint256 public shareCycleIndex = 0; uint256 public shareCycle = 1; uint256 public currentSyndicateValue = 0; uint256 public precision = 1000000000000000; uint256 public maxCyclePlayersConsidered = 100; address[] public cyclePlayers; uint256 public numberOfCyclePlayers = 0; struct somePlayer { uint256 playCount; uint256 profitShare; uint256 shareCycle; uint256 winnings; },1
0xe0b38482164468a11558606e98d9985e57814cd9.sol,LocalToken,"contract LocalToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; uint256 public totalEthers; uint256 public constant CAP = 2 ether; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LocalToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now; endDate = now + 30 minutes; }",1
0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62.sol,SECToken,"contract SECToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SECToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x57e33c7b740fc5cad7feef358c0c117c7769204b.sol,IDToken,"contract IDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function IDToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593] = _totalSupply; Transfer(address(0), 0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593, _totalSupply); }",1
0x26e285e69c6c42adfe5963d805e15ab7f09f92cc.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol,CryptoBetOn,contract CryptoBetOn { struct Gamer { address wallet; uint amount; },1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0xf0ebda840692b2a6cd8ab43abc57665763100694.sol,SignalsToken,"contract SignalsToken is PausableToken, MintableToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 9; event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens); function SignalsToken() { pause(); }",1
0x402288b27f39223d8a8131b53b35b9976d2c46d7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1db7f8171d82f9fc009f207cd80dd00a54b77560.sol,OllisCoin,"contract OllisCoin is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OllisCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x541cdaae3d240aee1a79a7469c2f10b6dd98e4d7.sol,DAILYC,"contract DAILYC is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 200 * 10000 * 10000 * 10 ** 8; uint constant valueSale = 0; uint constant valueTeam = valueTotal / 100 * 100; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x28f01187b61d799f6d90a7c8c5325a9de95f025d.sol,Sender,contract Sender is admined { token public DEEM; function Sender (token _addressOfToken) public { DEEM = _addressOfToken; },1
0x700fc72abc067e90111a391d0fae8ce8c799b38f.sol,MultiTransfer,"contract MultiTransfer { address[] public Airdrop2; function multiTransfer(ERC20 token, address[] Airdrop2, uint256 amount) public { for (uint256 i = 0; i < Airdrop2.length; i++) { token.transfer( Airdrop2[i], amount * 10 ** 18); }",1
0x3f9ad22a9c2a52bda2a0811d1080fc9cd23c6c46.sol,IBITToken,"contract IBITToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IBITToken() public { totalSupply = 32000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xda83c0a8587c705122434e8baa50db67ef049263.sol,ICORP,"contract ICORP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ICORP() public { symbol = ; name = ; decimals = 8; _totalSupply = 6700000000000000; balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply; Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply); }",1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,BodyRabbit,"contract BodyRabbit is BaseRabbit, ERC721 { uint public totalBunny = 0; string public constant name = ; string public constant symbol = ; PrivateRabbitInterface privateContract; AdmixtureInterface AdmixtureContract; function setPriv(address _privAddress) public returns(bool) { privAddress = _privAddress; privateContract = PrivateRabbitInterface(_privAddress); }",1
0x41aef9b47f6e37de66e34ce073023b36f1823b2a.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public totalSupply = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = totalSupply.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amounteth, bool isContribution); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe8b44c1bf8909526d789792abeaabc45de0146d3.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x38f374dd8705d75cc8b7ebbacbe25ad57d22986b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xdf1b1b23f34de198a6881880b345419b59ca38d0.sol,ANY,"contract ANY is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ANY() public { symbol = ; name = ; decimals = 8; bonusEnds = now + 13 weeks; endDate = now + 49 weeks; }",1
0x71e617e6024c20ac20f1c3fa47d874b9e4d2c141.sol,RedCarpetToken,"contract RedCarpetToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedCarpetToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 1200000000000; balances[0x865957fedaef1eaab481e9d236ce45d432c06b60] = _totalSupply; Transfer(address(0), 0x865957fedaef1eaab481e9d236ce45d432c06b60, _totalSupply); }",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x714d13c3bebfbf1097db48141471e78f9035dca5.sol,ETD,"contract ETD{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ETD() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x3a741c9eb3f506f203ebb7d422fd011a5c4fa6fa.sol,SafeMath,None,1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0x18486c451fdc6eac512d468967f75729d11b89ea.sol,LiteCoinW,contract LiteCoinW is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 84000000 * 10**8; function name() public constant returns (string) { return ; },1
0xa4ec44afee34feffbae5ce4218d3c06ebd70455e.sol,Superbowl52,contract Superbowl52 { using SafeMath for uint; uint public constant GAME_START_TIME = 1517787000; bool public resultConfirmed = false; address public owner; mapping(address => betting) public bets; uint public totalBets; uint public philadelphiaBets; uint public newEnglandBets; uint public result; uint public betters; bool public votingOpen; bool public withdrawalOpen; uint public threshold; uint public winningPot; mapping(address => uint) public wins; BallotSB52 public ballot; struct betting { uint philadelphiaBets; uint newEnglandBets; bool claimed; },1
0x2a287b4ebe1efb6b37ad1ed3141f0db1a1c51c99.sol,STS,"contract STS is Token { string public name; uint8 public decimals; string public symbol; function STS(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xde6c7366c50663712de30919b2cb9af2dd1a5378.sol,MDL,contract MDL is ERC20 { function name() public constant returns (string) { return ; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x1b33bb74de3d15295fcd8ca3a777951f6a8f8fac.sol,WandaBroker,"contract WandaBroker is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WandaBroker() public { symbol = ; name = ; decimals = 18; _totalSupply = 888888888000000000000000000; balances[0x7127Eb5bB39807a4872b18eA694883634B39cd79] = _totalSupply; Transfer(address(0), 0x7127Eb5bB39807a4872b18eA694883634B39cd79, _totalSupply); }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c0f734916b17c38674ed5867eda22f8314672ec.sol,ethernity,contract ethernity { address pr = 0xB85B67e48cD9edF95A6e95134Ee461e89E7B0928; address ths = this; mapping (address => uint) balance; mapping (address => uint) paytime; mapping (address => uint) prtime; function() external payable { if((block.number-prtime[pr]) >= 5900){ pr.transfer(ths.balance/100); prtime[pr] = block.number; },1
0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc.sol,C3_TokenCreate,"contract C3_TokenCreate is owned, TokenERC20 { uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function C3_TokenCreate( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1ee72092724d17c4667563bac428babfe11f6440.sol,IMAGEWORLD,"contract IMAGEWORLD { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IMAGEWORLD( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2054a15c6822a722378d13c4e4ea85365e46e50b.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0x511b082efa15802db82f37a52096d565e0154088.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3324d52c43952d53cf28b421c813efdc9c85af55.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x06373e227fc3855b0f646db3ed4eebe0f58797f7.sol,EasyTravel,"contract EasyTravel { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EasyTravel( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5129bdff6b065ce57cc7e7349ba681a0ac1d00cd.sol,BNCXToken,"contract BNCXToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 50000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x50fd51b624ca86be3dbc640515ebc407a163cd6c.sol,Versionable,contract Versionable { string public versionCode; function getVersionByte(uint index) constant returns (bytes1) { return bytes(versionCode)[index]; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc.sol,C3_TokenCreate,"contract C3_TokenCreate is owned, TokenERC20 { uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function C3_TokenCreate( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf091cf09c51811819db705710e9634b8bf18f164.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x49392a5867a4fd35cc31e366d790216daefaa647.sol,EtherHealth,"contract EtherHealth { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherHealth() { owner = 0x35a887e7327cb08e7a510D71a873b09d5055709D; balances[0x35a887e7327cb08e7a510D71a873b09d5055709D] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x1eb35af86a3821b5cca3013b1bb942c796aef544.sol,LV,"contract LV { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e867d04fbb7434093071237813df00b3df6ee77.sol,GridcubePlatformToken,"contract GridcubePlatformToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public _currentSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GridcubePlatformToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 12 weeks; _totalSupply = 30000000000000000000000000; address OwnerAdd = 0xb917cd85b61813ac1cd29ba0a8c37e0cd9f11162; uint256 CommunityTokens = 10000000000000000000000000; uint256 ProjectTokens = 10000000000000000000000000; uint256 HoldTokens = CommunityTokens + ProjectTokens; uint256 SaleTokens = safeSub(_totalSupply, HoldTokens); balances[OwnerAdd] = HoldTokens; Transfer(address(0), OwnerAdd, HoldTokens); _currentSupply = SaleTokens; }",1
0x05e886072ec32a5d4273ce451483a7693cb812e4.sol,BTN,"contract BTN is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTN() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x36f16a0d35b866cdd0f3c3fa39e2ba8f48b099d2.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x34770f06ae8a9a7b44fd8d636af6a3fec2a58b98.sol,StdToken,"contract StdToken is Token { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; uint public supply; function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); uint previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; emit Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); }",1
0x65731ac534bc0d3fdf3f4bdd2b09cf05044920bc.sol,MetadollarFund,contract MetadollarFund { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9.sol,EthFlip,contract EthFlip is usingOraclize { struct Bet { bool win; uint betValue; uint timestamp; address playerAddress; uint randomNumber; bool low; },1
0x6fc1ee575e9023aea1c45b4dfc9acf603ea9f63f.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x6dc2b0014e1974d7606de09b87969f34bd336252.sol,VOCC_I023_20181211,"contract VOCC_I023_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa19fdf84f56c91e7e805c3a5a47613132b112b91.sol,OhNoToken,"contract OhNoToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OhNoToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d] = _totalSupply; Transfer(address(0), 0xEb5085507a79BdcA6875cc75CCA2C9B47194c26d, _totalSupply); }",1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBettingFactory,contract MatchBettingFactory is Ownable { address[] deployedMatches; address public jackpotAddress; function MatchBettingFactory(address _jackpotAddress) public{ jackpotAddress = _jackpotAddress; },1
0x6abf810730a342add1374e11f3e97500ee774d1f.sol,BCFAuction,contract BCFAuction is Pausable { struct CardAuction { address seller; uint128 startPrice; uint128 endPrice; uint64 duration; uint64 startedAt; },1
0x70f53cb14a08700d0816f01bdae54b3f507f2ce2.sol,Contract50,contract Contract50 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] /50 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0xf1020306d38c4abf401b065d25867da2654d0681.sol,CanadaHormoneCoin,contract CanadaHormoneCoin { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xc70be5b7c19529ef642d16c10dfe91c58b5c3bf0.sol,Maths,None,1
0x4c4bcb4ffa0d7eab9287d1df294c8391e3b8096f.sol,PDVBO,"contract PDVBO { bytes32 public name; bytes6 public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDVBO( ) public { totalSupply = 1000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x41f9a3392cc695b8a12c6b5ede0e04a1bef12d05.sol,Ether2x,"contract Ether2x is StandardToken, owned, allowMonthly { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; bool public initialDrop; uint256 public inititalSupply = 10000000 * (10 ** uint256(decimals)); uint256 public totalSupply; address NULL_ADDRESS = address(0); uint public nonce = 0; event NonceTick(uint _nonce); function incNonce() public { nonce += 1; if(nonce > 100) { nonce = 0; }",1
0xbfb3b6972a814e2f6ed6d6fb9f9e47cd0b13720a.sol,SafeDivs,"contract SafeDivs { using SafeMath for *; address public devAddr_ = address(0xe6CE2a354a0BF26B5b383015B7E61701F6adb39C); address public affiAddr_ = address(0x08F521636a2B117B554d04dc9E54fa4061161859); address public partnerAddr_ = address(0x08962cDCe053e2cE92daE22F3dE7538F40dAEFC2); bool public activated_ = false; modifier isActivated() { require(activated_ == true, ); _; }",1
0xdb1f3030532a593a733f8ae6fce310aa91ac3a17.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7704eaee68e4c0eb3ee47382391d0227a44bbac8.sol,SISKCoin,"contract SISKCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SISKCoin() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 52 weeks; }",1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x6d8f2ffb3a314d8f353779873b13f0a23c11496c.sol,FDFToken,"contract FDFToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3 * 1000 * 1000 * 1000 * 10 ** decimals; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FDFToken() public { balanceOf[msg.sender] = totalSupply; }",1
0xa4bd6e2f6d54f00bfe306cb916f2e36e498e12e4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x656038e97cee7c095673f7b9fad695b323a6f098.sol,WheelOf0xBitcoin,contract WheelOf0xBitcoin { using SafeMath for uint; modifier nonContract() { require(tx.origin == msg.sender); _; },1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x256591374c0fb9b2782b754f6e072aa833e62278.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=3100000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x8b7027881bd7f5538aa4c07a5ecb2b41149ead24.sol,WWNCoin,"contract WWNCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WWNCoin ( ) public { totalSupply = 250000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0xe0c3f2deaa356fea4b6a1355674a766cb5821589.sol,MineableToken,"contract MineableToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public supplyCap; mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; event Approval( address indexed owner, address indexed spender, uint value ); event Transfer( address indexed from, address indexed to, uint256 value ); event Burn( address indexed from, uint256 value ); function MineableToken() public { decimals = uint8(18); supplyCap = 833333333 * 10**uint256(decimals); name = ; symbol = ; }",1
0x274b71f49dc3f5370da8c81e4e936eaf9a669321.sol,TFC,contract TFC is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10000; function name() public constant returns (string) { return ; },1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1d6b371b0d23d169e87db2fc14ab34f82d190988.sol,ChickenPark,contract ChickenPark is Owned{ using SafeMath for *; modifier notContract() { require (msg.sender == tx.origin); _; },1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27e06500263d6b27a3f8b7be636aabc7adc186be.sol,EasyInvestForeverNeverending,contract EasyInvestForeverNeverending { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public calculatedLow = 0; uint256 public investedTotal = 0; uint256 public interestRate = 100; uint256 public nextBlock = block.number + 5900; function () external payable { investedTotal += msg.value; if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; else calculatedLow = 0; interestRate = (currentBalance - previousBalance) / 10e16 + 100; interestRate = (interestRate > 1000) ? 1000 : interestRate; previousBalance = currentBalance ; if (calculatedLow == 0) calculatedLow = currentBalance - (investedTotal * interestRate / 10000); uint256 currentGrowth = 0; currentBalance= address(this).balance; if (currentBalance > calculatedLow) currentGrowth = currentBalance - calculatedLow; if (interestRate == 100) interestRate = 100 * currentGrowth / (previousBalance - calculatedLow + 1); interestRate = (interestRate < 5) ? 5 : interestRate; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0x2051f57c5c1539c17e7d22caf46c83f861bd8e81.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe25c541b11c84ee7fecb68641a0989de76b78f1271dae8d8bd9c93b2ae3a6cc9; constructor() public { owner = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xde6c1dd8404827149f6edc09e50476aa0cd7b4ab.sol,SRX,"contract SRX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRX( ) public { totalSupply = 100000000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000000; name = ; symbol = ; }",1
0x70538834e68efe5061a11c4999fc050e55ae2b68.sol,AYA,"contract AYA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000; balances[0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b] = _totalSupply; emit Transfer(address(0), 0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b, _totalSupply); }",1
0x91cdb5bb5969bfed2373e97378354052bbc606f2.sol,DRCToken,"contract DRCToken is BurnableToken, MintableToken, PausableToken, Claimable, Autonomy { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 0; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenAmount; event FrozenFunds(address indexed _target, bool _frozen); event FrozenFundsPartialy(address indexed _target, bool _frozen, uint256 _value); event BurnFrom(address from, address burner, uint256 value); function DRCToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0xd04a63eea250ce2b330d4ed46338d7cfa6999040.sol,TYCOONCoin,"contract TYCOONCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TYCOONCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 219172838 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf49cdd50ad408d387d611f88a647179c3de3492b.sol,StandardToken,"contract StandardToken is ERC20, ERC223 { using SafeMath for uint; string public name; string public symbol; uint8 public decimals; uint public totalSupply; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; function StandardToken(string _name, string _symbol, uint8 _decimals, uint _totalSupply, address _admin) public { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint(_decimals); balances[_admin] = totalSupply; }",1
0x6d8f2ffb3a314d8f353779873b13f0a23c11496c.sol,FDFToken,"contract FDFToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3 * 1000 * 1000 * 1000 * 10 ** decimals; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FDFToken() public { balanceOf[msg.sender] = totalSupply; }",1
0xdfbfd64726b1b178ef8204ae4992f641f31c8248.sol,EloPlayToken,"contract EloPlayToken is ERC20Token, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; address public TARGET_ADDRESS; address public TARGET_TOKENS_ADDRESS; uint256 public START_TS; uint256 public END_TS; uint256 public CAP; uint256 public USDETHRATE; bool public halted; uint256 public totalEthers; event TokensBought(address indexed buyer, uint256 ethers, uint256 new_ether_balance, uint256 tokens, uint256 target_address_tokens, uint256 new_total_supply, uint256 buy_price); event FundTransfer(address backer, uint amount, bool isContribution); function EloPlayToken(uint256 _start_ts, uint256 _end_ts, uint256 _cap, address _target_address, address _target_tokens_address, uint256 _usdethrate) { START_TS = _start_ts; END_TS = _end_ts; CAP = _cap; USDETHRATE = _usdethrate; TARGET_ADDRESS = _target_address; TARGET_TOKENS_ADDRESS = _target_tokens_address; }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0xd4191d6bcefb28cb2e6fc5d0ea48aab7860da523.sol,FCMCOIN,"contract FCMCOIN is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FCMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x4902c062f1384654bd075b719c6a26a83ef7aaf0.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 1; uint256 public feesB = 1; uint256 public feesC = 1; uint256 public feesD = 1; address public addressA = 0xC61994B01607Ed7351e1D4FEE93fb0e661ceE39c; address public addressB = 0x821D44F1d04936e8b95D2FFAE91DFDD6E6EA39F9; address public addressC = 0xf193c2EC62466fd338710afab04574E7Eeb6C0e2; address public addressD = 0x3105889390F894F8ee1d3f8f75E2c4dde57735bA; function founder() private { owner = msg.sender; },1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6aa27b3a8aab51745b7eaf53e61aba833b0f9400.sol,PCC,"contract PCC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PCC() public { symbol = ; name = ; decimals = 8; _totalSupply = 5200000000000000; balances[0x67322D8A8f72B8417f16397667d8F6ce996A6982] = _totalSupply; Transfer(address(0), 0x67322D8A8f72B8417f16397667d8F6ce996A6982, _totalSupply); }",1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa26d5253ab96e04afe51b4c1614b29b11889d3b1.sol,Ico,contract Ico is BasicToken { address owner; uint256 public teamNum; mapping(address => bool) team; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant tokenPrecision = 10e17; uint256 public constant hardCap = 32000 * tokenPrecision; uint256 public tokensFrozen = 0; uint256 public tokenValue = 1 * tokenPrecision; struct DividendSnapshot { uint256 totalSupply; uint256 dividendsIssued; uint256 managementDividends; },1
0x02dbe2f315e059743376abcd22ab4908ea9fb02d.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x1abc429a9e0a6bb21cac418e876f2ba608556836.sol,EthereumPower,"contract EthereumPower { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 965756597440 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x278ae6f52ce72b0df6cba451534b87846acc9d65.sol,BPER,"contract BPER is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BPER() public { symbol = ; name = ; decimals = 10; _totalSupply = 16000000000000000000; balances[0x8fB784413918e0917E50cC42282334C08a21730f] = _totalSupply; Transfer(address(0), 0x8fB784413918e0917E50cC42282334C08a21730f, _totalSupply); }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x5ba983231b4bb509f0f25e97fa22e20d71c5d44c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0x6c29b601a00798d9f13d9959f6d156be5032168e.sol,InvestorsStorage,contract InvestorsStorage { address private owner; mapping (address => Investor) private investors; struct Investor { uint deposit; uint checkpoint; },1
0x1e5cbdf415dc6a762ad4ded7743aa9fe0837ff9e.sol,HKIN,"contract HKIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HKIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2134057c0b461f898d375cead652acae62b59541.sol,CoxxxCoin,"contract CoxxxCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoxxxCoin( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xbb5b059f574204c344cd3096b420fe563f242890.sol,NetkillerAdvancedToken,"contract NetkillerAdvancedToken { address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function NetkillerAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbd8b5ce4c64bdee0f33989e87bae71b3392924d2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb.sol,ZIP,"contract ZIP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZIP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xd9d42c6d1ebf9083d9514e5ae5f53cd627708c12.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x758c5546f5ea74fb52dc73f2f110e46258a92b57.sol,ProofOfKennyCoin,contract ProofOfKennyCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xaf8ce1b205be2bfdede58d8f923f610463658148.sol,iCASH,"contract iCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function iCASH() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x5D33021e1333CE72b9051aF68718a3576C92AAc8] = _totalSupply; Transfer(address(0), 0x5D33021e1333CE72b9051aF68718a3576C92AAc8, _totalSupply); }",1
0xdbb5417b8b0a01e039a12e43d3650f46635cda97.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55e539fb53394851e8c541411d31c942b14b998e.sol,URUGUAY_WINS,"contract URUGUAY_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 325566187175265000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x72519fa6cd095c99d5d67e31ddc117409bc5c047.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0x488771fdac168e3e313763aa2907ac5806dbc976.sol,StandardToken,contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; },1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xce4d3ebe1cae5561186f98edd205718475318ff0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3a783e99e5a5618b8149e3380d14328139d97e31.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100000000 * (10 ** decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0xd2d0f85b690604c245f61513bf4679b24ed64c35.sol,BFDToken,"contract BFDToken is EIP20Interface, SafeMath { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string constant public name = ; uint8 constant public decimals = 18; string constant public symbol = ; mapping (address => uint256) public addressType; mapping (address => uint256[3]) public releaseForSeed; mapping (address => uint256[5]) public releaseForTeamAndAdvisor; event AllocateToken(address indexed _to, uint256 _value, uint256 _type); address public owner; uint256 public finaliseTime; function BFDToken() public { totalSupply = 20*10**26; balances[msg.sender] = totalSupply; owner = msg.sender; }",1
0x8bf98ad0e7d8d4924c6a52f6e4b87f96d3a278fa.sol,DOTON,"contract DOTON is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOTON() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x3a931cabde9d3deeb9cfe50d8afb0b7be357cb16.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0x28daa51dc3d80a951af9c451d174f0c7156c6876.sol,EtherShareReward,contract EtherShareReward { EtherShare ES = EtherShare(0xc86bdf9661c62646194ef29b1b8f5fe226e8c97e); struct oneReward { address from; uint value; },1
0x70544d3affd8d415d45fc7b7d07a2e9b897fa6c8.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0x4040dfed08346b98336be48072d071f0805c3ae0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 tokenDecimals ) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x402288b27f39223d8a8131b53b35b9976d2c46d7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3fdd90ccdb7a430dac92580170a47f278322a9a0.sol,MDIVToken,"contract MDIVToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MDIVToken() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0xa149a7230cACE190905E9B50954471825C261021] = _totalSupply; emit Transfer(address(0), 0xa149a7230cACE190905E9B50954471825C261021, _totalSupply); }",1
0x92575d350284d64a1c74a0b6cb1dd16334d43e0d.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns(uint256) { return totalSupply_; },1
0x00125893df6ca0792c99601c462764ba5d80268a.sol,GasManager,contract GasManager is owned { function () payable public {},1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0xce038523e278b6c1344d9e4f735f6064ad7a6032.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1dcadad44aa14154e2393d83edf6c7c6f83cb795.sol,DoggyEthPics,"contract DoggyEthPics is ERC721, Ownable { event DoggyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public doggyIdToOwner; mapping (uint256 => address) public doggyIdToDivs; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public doggyIdToApproved; mapping (uint256 => uint256) private doggyIdToPrice; struct Doggy { string name; }",1
0x71d00a5e4a541caafd106509eff28a7798443c26.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x31f16d6e6cd4e66bfa479009090b49c5781bba00.sol,VESTD,"contract VESTD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VESTD() public { symbol = ; name = ; decimals = 7; _totalSupply = 7000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x003f79d7be15dc1ad90ce00e6ea68f335e2b789b.sol,TzTToken,contract TzTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 1000000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TzTToken() { owner = msg.sender; balances[owner] = 1000000000 * 10**8; },1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x287fda15f8f002e5df9f536f10bbfc0816960f36.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 900000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x5209283a7ad07b579cb34183f4dc1da2aef422dc.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public tokenBalance; uint public amountRaised; uint public deadline; uint dollar_exchange; uint test_factor; uint start_time; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale() { tokenBalance = 50000; beneficiary = 0x6519C9A1BF6d69a35C7C87435940B05e9915Ccb3; start_time = now; deadline = start_time + 30 * 1 days; dollar_exchange = 295; tokenReward = token(0x67682915bdfe37a04edcb8888c0f162181e9f400); }",1
0x28e860cb89e705de876f858671cb757f650fdae2.sol,WEPAYCOIN,"contract WEPAYCOIN { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x56f366e4245e459078fd70cb21d20e6e27324c36.sol,PayItBack,"contract PayItBack { uint constant HOLD_TIME = 31 days; address public creator; uint public contributionTime = 0; uint public totalContributions = 0; bool public isDisabled = false; event Contribution(uint _amount, address _from); event OwnershipConfirmed(); event PaidOut(uint _amount); event Warning(string _message); event Disabled(); modifier ownerOnly() { require(msg.sender == creator, ); _; }",1
0xf50d193eb6761fb3189be46b9165d4aec20e05f0.sol,FLEBToken,contract FLEBToken{ address public owner; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 0; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; constructor() public{ owner = msg.sender; },1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf003e8c65a28a445e0318e83416567336fb1c667.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x1b27c2c096ae7e408eef72731fa5ea7e753054de.sol,SUSIToken,"contract SUSIToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SUSIToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkBase,"contract ArtworkBase is ArtworkAccessControl { event Birth(address owner, uint256 artworkId, string name, string author, uint32 series); event Transfer(address from, address to, uint256 tokenId); struct Artwork { uint64 birthTime; string name; string author; uint32 series; }",1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x21929a10fb3d093bbd1042626be5bf34d401babc.sol,EFTToken,"contract EFTToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EFTToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xedf7eac72ff28dbcde6aa14322726a7d05739007.sol,EasyInvest20,contract EasyInvest20 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 20 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x37e1160184f7dd29f00b78c050bf13224780b0b0.sol,YCCToken,"contract YCCToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function YCCToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xc41585205b83b7c643a37b87887c97cf31cb8867.sol,QINTAR,"contract QINTAR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 5; _totalSupply = 100000000000; balances[0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b] = _totalSupply; emit Transfer(address(0), 0x64a2AA7edFA7D698Ede1dA333804B66AaF1Fa49b, _totalSupply); }",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,TokenRHT,"contract TokenRHT is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = true; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRHT() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0xeb86dfc14848b56955051cfd9d696bafde1d6027.sol,StoreGift,contract StoreGift is BasicAuth { struct Gift { string m_Key; uint m_Expire; uint32[] m_ItemIdxList; uint[] m_ItemNumlist; },1
0xda6733cc3800c9a74caf0ba8858df1bc264434d7.sol,CSN,"contract CSN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x20b1c3faf91b57f0dcf016c4ce318c8504248c16.sol,BigchatToken,"contract BigchatToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BigchatToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x2fa8e7866d68e51d2cc2eb0bfa75d1613d83a2b3.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x45ca8d5458d7f3f7d2f47daae253924cafc2f331.sol,EmiratesCoin,"contract EmiratesCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EmiratesCoin( ) public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0x711256406c2e9072fbaee5b67d5a893f66a3e707.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); address public ELIX_ADDRESS; uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x25e0c624f3f8239ac3932699dc6c2551facbf714.sol,CryptoMinerTokenFork,contract CryptoMinerTokenFork { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x537c23b71d847eef947f150ac7e33b1854138d5c.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 50000 * 10 ** uint256(decimals); string public contract_link = ""https: mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { owner = 0xCD6011A9D3995A693F9964608D08EDbb48220225; balanceOf[owner] = totalSupply; }",1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,StandarTokentokenGAT,"contract StandarTokentokenGAT is tokenGAT{ mapping (address => uint256) balances; mapping (address => uint256 ) weirecives; mapping (address => mapping (address => uint256)) allowed; function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; }",1
0x5270a37951f8c3ff2a99c6fb386cbc2aa63aa709.sol,WTI_301201,"contract WTI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11134262607820500000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,BaseEquipment,"contract BaseEquipment is Ownable, AtomicSwappableToken { event Mint(address indexed to, uint256 amount); uint256 public cap; uint[] public properties; address public controller; modifier onlyController { require(msg.sender == controller); _; }",1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6fc1ee575e9023aea1c45b4dfc9acf603ea9f63f.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x0eaf3a45f6035565ee7fb61b242f562b77883fc4.sol,Help_the_Needy,contract Help_the_Needy { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xda8b85117bcc9ebf29a04521b2cbb2f1782e6029.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100*10**(18+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,AT01Token,"contract AT01Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0xf45c4e30e9a4d8107d7dbd0556065baedf03838d.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x763ae93d72c7575cf9df1013e9fe2c08b96d6034.sol,BitXCoin,"contract BitXCoin { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint public totalSupply; constructor ( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialAmount; balances[msg.sender] = totalSupply; allowed[msg.sender][msg.sender] = balances[msg.sender]; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,Contribution,contract Contribution is Ownable { using SafeMath for uint256; WPR public wpr; address public contributionWallet; address public teamHolder; address public communityHolder; address public futureHolder; address public exchanger; uint256 public totalCollected; uint256 public totalWeiCap; uint256 public totalWeiCollected; uint256 public presaleTokensIssued; uint256 public minimumPerTransaction = 0.01 ether; uint256 public numWhitelistedInvestors; mapping (address => bool) public canPurchase; mapping (address => uint256) public individualWeiCollected; uint256 public startTime; uint256 public endTime; uint256 public initializedTime; uint256 public finalizedTime; uint256 public initializedBlock; uint256 public finalizedBlock; bool public paused; modifier initialized() { require(initializedBlock != 0); _; },1
0x8700e5453718244cac9a5257aa82abc9d7bb13af.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf3cfb35afdbffea20892488ba7f1574adda81b9d.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,Crowdsale,"contract Crowdsale is Pausable, TokenVesting { using SafeMath for uint; address public multisigETH; address public commissionAddress; uint public tokensForTeam; uint public ethReceivedPresale; uint public ethReceivedMain; uint public totalTokensSent; uint public tokensSentMain; uint public tokensSentPresale; uint public tokensSentDev; uint public startBlock; uint public endBlock; uint public maxCap; uint public minCap; uint public minContributionMainSale; uint public minContributionPresale; uint public maxContribution; bool public crowdsaleClosed; uint public tokenPriceWei; uint public refundCount; uint public totalRefunded; uint public campaignDurationDays; uint public firstPeriod; uint public secondPeriod; uint public thirdPeriod; uint public firstBonus; uint public secondBonus; uint public thirdBonus; uint public multiplier; uint public status; Step public currentStep; address[] public holdersIndex; address[] public devIndex; enum Step { FundingPreSale, FundingMainSale, Refunding }",1
0x46bbc22c8e796d788a1907d61228447d148f8d43.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,TOURISTOKEN,"contract TOURISTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 777777777000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x719e7f0dadfdea25b78595da944f44d15d7e6795.sol,Musk,"contract Musk is Token { string public name; uint8 public decimals; string public symbol; constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x4bdf685f6949161ccdccab524bf69aa0ae7b640d.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 100*10**(decimals+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { balanceOf[0x8900679eeFEf58D15FC849134E68577a17561155] = 30*10**(decimals+8); balanceOf[0x6C3409625a31D5C5122E4130eBCAFeCd1487a43a] = 70*10**(decimals+8); }",1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x3a783e99e5a5618b8149e3380d14328139d97e31.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1e834560e79def1479555bf5d9a35e8bc3dbe70a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2077db08d450d842189b94dea8e3eb95980a8b61.sol,SafePromo,"contract SafePromo { address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); function SafePromo() public { owner = msg.sender; }",1
0x332e68dabba9ac8ac5f9a11423f7e72a8b648d1a.sol,DTDToken,"contract DTDToken is IERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint public decimals = 18; uint public _totalSupply = 100000000e18; uint public _tokenLeft = 100000000e18; uint public _round1Limit = 2300000e18; uint public _round2Limit = 5300000e18; uint public _round3Limit = 9800000e18; uint public _developmentReserve = 20200000e18; uint public _endDate = 1544918399; uint public _minInvest = 0.5 ether; uint public _maxInvest = 100 ether; mapping (address => uint256) _investedEth; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; address public owner; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x2880163d22b8742a8736b21ae9f8b7f239a22243.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken() { balanceOf[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; symbol = ; decimals = 6; }",1
0x00c2982959f852abbdb0f5ec023609ea1ca579e8.sol,GAC,"contract GAC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4200942093f5c8c2ce865e17b3fdec9148de8c49.sol,YunbeiToken,"contract YunbeiToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function YunbeiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x02169578b41b8f7f5f2dd0491aa2682a13196c44.sol,KillahyToken,"contract KillahyToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KillahyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x821ca1b7919200Ff99495466e13CA3b3135c1668] = _totalSupply; Transfer(address(0), 0x821ca1b7919200Ff99495466e13CA3b3135c1668, _totalSupply); }",1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,PlatformTeamCoinVer01,"contract PlatformTeamCoinVer01 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0f234c7992956af755c5cd9451a3f872314efa78.sol,ROHH,"contract ROHH is Ownable { string public name; string public symbol; uint8 public decimals = 17; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROHH( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb459571c4d5b8119ab76d0a5308106c61f9918c5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6d500e4b6565c3c25a6edd51839d52269e3d293f.sol,KiddyToys,"contract KiddyToys is ERC721, Ownable { event ToyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public toyIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public toyIdToApproved; mapping (uint256 => uint256) private toyIdToPrice; struct Toy { string name; }",1
0xd46d0505f73f26f4cc7c8df65e562ac3f28ffc10.sol,ProtectEarth,contract ProtectEarth{using SafeMath for*;using NameFilter for*;struct Player{address addr;bytes32 name;uint8 level;uint256 recCount;uint256 laffID;uint256 commanderID;uint256 captainID;uint256 win;uint256 enableVault;uint256 affVault;uint256 achievement;uint256 keys;},1
0x466c44812835f57b736ef9f63582b8a6693a14d0.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x35b6a52663a7bf34ea4e2b693da2cca2bc4f7588.sol,NDD_NFX_I_883,"contract NDD_NFX_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 4250507023558140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x785585878feb8cf7cd1e3b9eca0635464c2dd0cb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdfc5dce1a27e6110107817a352ebe4dd9dc6b157.sol,BeerCash,"contract BeerCash { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BeerCash( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc35924a3661bbadabbba4f1823fa74fcafcb08ef.sol,RxPharma,"contract RxPharma{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RxPharma() public { totalSupply = 50000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,LoliCoin,"contract LoliCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LoliCoin() TokenERC20() public {}",1
0x3a580a0d295d3f5a8137a91448b03f2bdc22aa2c.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,SafeMath,None,1
0xdcedcc689487b3c767e37cd2f198d40566294b20.sol,TianqibaoTokenERC20,"contract TianqibaoTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TianqibaoTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0ba84690b9bdec4c3175557446dddf6384eec1d.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,WarToken,"contract WarToken is ERC721, AccessAdmin { struct Fashion { uint16 protoId; uint16 quality; uint16 pos; uint16 health; uint16 atkMin; uint16 atkMax; uint16 defence; uint16 crit; uint16 isPercent; uint16 attrExt1; uint16 attrExt2; uint16 attrExt3; }",1
0xb47e9b43ee0772abac3856a1adf8f90c0e6c1067.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,DepositProxy,"contract DepositProxy is Proxy { address public Owner; mapping (address => uint) public Deposits; event Deposited(address who, uint amount); event Withdrawn(address who, uint amount); function Deposit() payable { if (msg.sender == tx.origin) { Owner = msg.sender; deposit(); }",1
0xd64e5b228561225b437dc38b81891c15fe98cfee.sol,NYXAccount,"contract NYXAccount { bytes32 emergencyHash; address authority; address public owner; bytes32 resqueHash; bytes32 keywordHash; bytes32[10] photoHashes; uint resqueRequestTime; uint authorityRequestTime; uint lastExpenseTime; bool public lastChanceEnabled = false; bool lastChanceUseResqueAccountAddress = true; event NYXDecentralizedIdentificationRequest(string swarmLinkPhoto, string swarmLinkVideo); enum Stages { Normal, ResqueRequested, AuthorityRequested }",1
0x5b5d0fbbd75d4501e5cdc854c445fb0eabcb0afc.sol,EmrCrowdfund,"contract EmrCrowdfund is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function EmrCrowdfund( uint256 initialSupply, uint256 _tokenPrice, string tokenName, string tokenSymbol ) public { tokenPrice = _tokenPrice / 10 ** uint256(decimals); totalSupply = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0xf2249b2f36a21185ab97f83214cd8fc5802bb8a0.sol,BLCToken,"contract BLCToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb619e84adddd3e336c5dda1e1b40719c846d9030.sol,WorldByEth,contract WorldByEth { using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 public rID_; uint256 public pID_; uint256 public com_; address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57; mapping(uint256 => uint256) public pot_; mapping(uint256 => mapping(uint256 => Ctry)) public ctry_; uint public ctynum = 0; uint public gap = 1 hours; uint public timeleft; address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57; address public lastwinner; uint[] public validplayers; struct Ctry { uint256 id; uint256 price; bytes32 name; bytes32 mem; address owner; },1
0x4040dfed08346b98336be48072d071f0805c3ae0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 tokenDecimals ) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x30169203b76ff6a1879983efe66a65c31fa7758e.sol,EternalMultiplier,contract EternalMultiplier { struct Deposit { address depositor; uint deposit; uint payout; },1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c404f7f092ebb744a006dffa597285ec3df465d.sol,LNTToken,"contract LNTToken is owned, TokenERC20 { event mylog(uint code); function LNTToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) payable public {}",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x0500d5751bb0341e3e8173869cd4e04bc4ad6dd7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0xdd8c7b0562d8d51210c02213daaa3884f6eeeb6d.sol,Caps,"contract Caps is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Caps() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 6 weeks; endDate = now + 261 weeks; }",1
0x88eded8712c5ea071c56284a2078336a551e4eda.sol,SCAMCoin,"contract SCAMCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SCAMCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2e061fdfbb2c63a43e4490465d3862094b38f394.sol,AxaToken,"contract AxaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 250000000000000000000000000; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x25caf15e1cc43e7bfa9853a68de463bfb0d27021.sol,IndividualLockableToken,"contract IndividualLockableToken is PausableToken{ using SafeMath for uint256; event LockTimeSetted(address indexed holder, uint256 old_release_time, uint256 new_release_time); event Locked(address indexed holder, uint256 locked_balance_change, uint256 total_locked_balance, uint256 release_time); struct lockState { uint256 locked_balance; uint256 release_time; }",1
0x339150b0851bc5b3c0323789a58cc4e4afb38b37.sol,EasyInvest10,contract EasyInvest10 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); invested[totalETH] += msg.value; },1
0xf3a88200de35c6f935562e66844707999b77dd38.sol,CoinBazarCap,contract CoinBazarCap is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 17000000 * 100000000; function name() public constant returns (string) { return ; },1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x474b4642fa37528652e907a2a3ef7ded8fec8cc8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,Gallery_MuYi_No2,contract Gallery_MuYi_No2 is StandardToken { function () { throw; },1
0xf18b97b312ef48c5d2b5c21c739d499b7c65cf96.sol,TBEToken,"contract TBEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TBEToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x562f0c1d080be544b3095d02abcdb9786249a416.sol,SEAPORT_Portfolio_V_883,"contract SEAPORT_Portfolio_V_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 926816166179938000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x011a94df7ccf7eb28409cefc9d825f24c75b3c74.sol,SalaryInfo,contract SalaryInfo { struct User { string name; },1
0x57fae64171be173cacfdf533f290f824ca92347a.sol,BHPetolCoin,"contract BHPetolCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 5; _totalSupply = 100000000000000; balances[0x30FC7cbb3e0AFcfF52B230503F5ED4E49dD8cdf0] = _totalSupply; emit Transfer(address(0), 0x30FC7cbb3e0AFcfF52B230503F5ED4E49dD8cdf0, _totalSupply); }",1
0x33d514e149ca8405ad9644d5fd2384b645abd668.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x03200f18368a33906491df56b74cc97986fbdbce.sol,XueBiToken,"contract XueBiToken { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function XueBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd76ababc8887a72453f5f48ea831b782e49c557a.sol,PizzaCoin,"contract PizzaCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x25be312868aed68afaf5ac75aed062f4d4c78ce3.sol,RAIOCO,"contract RAIOCO is Ownable { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RAIOCO( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2051f57c5c1539c17e7d22caf46c83f861bd8e81.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe25c541b11c84ee7fecb68641a0989de76b78f1271dae8d8bd9c93b2ae3a6cc9; constructor() public { owner = msg.sender; },1
0xdd6eef0507f10d21f716e36d8b1aae76a4fa3f62.sol,CashexGlobalCoin,contract CashexGlobalCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 1000000000000000000; function name() public constant returns (string) { return ; },1
0xa49cc7bb3437d67ae57979ddc9d1ef68a4f91461.sol,XAIN_ERC20,"contract XAIN_ERC20 is Ownable { using SafeMath for uint256; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) internal allowed; string public constant standard = ; uint256 public constant decimals = 18; string public name = ; string public symbol = ; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }",1
0x184001d794a8c91def72b8a488b67cc907d4e5be.sol,Ore,"contract Ore { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 25529833 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function Ore() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x88496dd0bb932b060e9c7c4ddc8e1b72b1e39451.sol,tokenTrust,"contract tokenTrust { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint partyTime = 1522095322; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0xd5e1f90d918fd871fa0aba9aea54bb07e6382299.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf4991089fdc65a9e23771adef47544742a0096c4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed01e8865689602a840fa4855f0d7886268f250b.sol,Uselesslightbulb,contract Uselesslightbulb is Ownable { uint weiPrice = 1000000000000000; uint count = 0; function toggle() public payable { require(msg.value >= weiPrice); count++; },1
0x50fb2403b415c4ce2c94c7bf7cbfa36145fc5cbf.sol,SCCC,"contract SCCC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xedbe509e65f7425016265a049941311497c0099c.sol,LuckyYouContract,contract LuckyYouContract is Pausable { using SafeMath for uint256; LuckyYouTokenInterface public luckyYouToken = LuckyYouTokenInterface(0x6D7efEB3DF42e6075fa7Cf04E278d2D69e26a623); bool public airDrop = true; function setAirDrop(bool _airDrop) public onlyOwner { airDrop = _airDrop; },1
0x3fd8f39a962efda04956981c31ab89fab5fb8bc8.sol,Rotharium,"contract Rotharium is owned{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function Rotharium( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x17b4ae55a5b0b6c10b0f4bae2d75a4e83de41709.sol,Util,None,1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0x04950c94f4cbf9b3eb7b3ddd48e6aef176e3f73f.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xee278a3543afbe4c1639b430774537995c6bd995.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=36300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8cb4151fce62b3d08269343a79dbcd6f83d3405.sol,you_can_do_it,contract you_can_do_it { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xede79a28fe8e2edb3efb629e7396034f76c22cc3.sol,FreeMoney,contract FreeMoney { uint public remaining; function FreeMoney() public payable { remaining += msg.value; },1
0xd3ac627abdc1ce6c27c04b37c86e368f754f2995.sol,GradualPro,contract GradualPro { address constant private FIRST_SUPPORT = 0xf8F04b23dACE12841343ecf0E06124354515cc42; address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c; uint constant public FIRST_PERCENT = 4; uint constant public TECH_PERCENT = 1; uint constant public MULTIPLIER = 121; uint constant public MAX_LIMIT = 2 ether; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15.sol,EGFToken,"contract EGFToken is ERC20, owned { mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor () ERC20() public { }",1
0xc84d24242a792d8c87d10f92897328c490bfd7fa.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x55e7f93c7746877b1e6a1a1e789a8e37b03172cb.sol,CCD_EUROSIBENERGO_20190326_7,"contract CCD_EUROSIBENERGO_20190326_7 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x38897c62a4ddcd66a77bfc94e0f93fd4525b7d84.sol,IFcoin,contract IFcoin { uint private constant _totalSupply = 2500000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function IFcoin() { balances[msg.sender] = _totalSupply; },1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x4d0425e47ee2d16b94c036715dfcb52a0cebc4dc.sol,TAGZ5,"contract TAGZ5 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599] = _totalSupply; emit Transfer(address(0), 0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599, _totalSupply); }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0x0dd1326b7b80107f002ba16dad7fe2dd22f00491.sol,LetsBreakThings,contract LetsBreakThings { address public creator; address public creatorproxy; function deposit() public payable { },1
0x6cd694d5a9c71cd811922e3cb314f44afe25a48c.sol,TJCUToken,"contract TJCUToken is Token { string public name; uint8 public decimals; string public symbol; function TJCUToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x6cdc55813f10ace2b056cb52338adc623a83ef22.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 9565658097 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5c8d8245e52f893de53c716c969b1526a0075070.sol,ENXAirDrop,"contract ENXAirDrop is Ownable { function airDrop ( address contractObj, address tokenRepo, address[] airDropDesinationAddress, uint[] amounts) public onlyOwner{ for( uint i = 0 ; i < airDropDesinationAddress.length ; i++ ) { ERC20Interface(contractObj).transferFrom( tokenRepo, airDropDesinationAddress[i],amounts[i]); }",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5cbf1b692d921f9eccaac6364ba463b8f549f266.sol,roga,"contract roga { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function roga( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x84f7c44b6fed1080f647e354d552595be2cc602f.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x37afbfb4330d449ce7d231f2356f4f9297c32bc1.sol,DistributeETH,"contract DistributeETH is Ownable { function distribute(address[] _addrs, uint[] _bals) onlyOwner public{ for(uint i = 0; i < _addrs.length; ++i){ if(!_addrs[i].send(_bals[i])) throw; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x361cef27a967e3fa2d8fc117b3f2cfe2a09bbc02.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x887ed27475f60f2df56fefc1f18f3aa8da65fb22.sol,ParkCoin,"contract ParkCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ParkCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71871f8d10b2965e06dc29b1be7122086aeb11e0.sol,SafeMath,None,1
0x2666f6a7873fac3160db60ca15fd911e7ff7394e.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x85924fdcccb75c47c3d2155ae0a519018164cac0.sol,StandardToken,"contract StandardToken is TelomereCoin { function transfer(address _to, uint256 _value) returns (bool success) { require(allowTransfer); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806.sol,ECP_Token,"contract ECP_Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public remaining; address public owner; uint public icoStatus; address public benAddress; address public bkaddress; uint public allowTransferToken; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event TokenTransferEvent(address indexed from, address indexed to, uint256 value, string typex); function ECP_Token() public { totalSupply = 15000000000000000000000000000; owner = msg.sender; balanceOf[owner] = totalSupply; name = ; symbol = ; decimals = 18; remaining = totalSupply; icoStatus = 1; benAddress = 0xe4a7a715bE044186a3ac5C60c7Df7dD1215f7419; bkaddress = 0x44e00602e4B8F546f76983de2489d636CB443722; allowTransferToken = 1; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0cf55facee33ed2827d78ad2d113efe0aa80a92b.sol,SafeMath,None,1
0x6bc4375083d3ad563de91cad8438f629841448a5.sol,CryptogeneidToken,"contract CryptogeneidToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptogeneidToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xc6EE88b4746850cD70bDb5b2C299966862fc880F] = _totalSupply; Transfer(address(0), 0xc6EE88b4746850cD70bDb5b2C299966862fc880F, _totalSupply); }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x4200942093f5c8c2ce865e17b3fdec9148de8c49.sol,YunbeiToken,"contract YunbeiToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function YunbeiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x03b6609aaceccec42ef526a35b1bd5d728874ea4.sol,PDATAToken,"contract PDATAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PDATAToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x202e295df742befa5e94e9123149360db9d9f2dc.sol,NihilCoin,"contract NihilCoin { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NihilCoin( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) payable { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x219101d69455c620700bf02f157f29ef7a8f7988.sol,MyToken,"contract MyToken is MyOwned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target,bool frozen); event Transfer(address indexed from,address indexed to,uint256 value); function MyToken(uint256 initialSupply,string tokenName,string tokenSymbol,uint8 decimalUnits){ balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x0e16923571c50a48b4f9b3b8319606ef8d6106ae.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x597f180157564555ffd96235806415573a02ecb0e9af129d1ddc24e53fe00c96; constructor() public { owner = msg.sender; },1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x26ddf6cabadcbf4f013841bd8d914830beb0d984.sol,DateTime,None,1
0x05bb30a1f820add4772b44a808ee9024ce82b34c.sol,VIRTToken,"contract VIRTToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VIRTToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,UGCoin,"contract UGCoin is Multiowned, StandardToken { event Freeze(address from, uint value); event Defreeze(address ownerAddr, address userAddr, uint256 amount); event ReturnToOwner(address ownerAddr, uint amount); event Destroy(address from, uint value); function UGCoin() public Multiowned(){ balances[msg.sender] = initialAmount; totalSupply = initialAmount; }",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0x4b826daea6ac8fb869039ff1b3c80e150c3ad9e8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b.sol,multifunding,contract multifunding { bytes32 keyHash; address owner; bytes32 wallet_id = 0x2f9b3e20b17f6fb9a29b8253c0137860d08513241549d0f6444bacd9103d3a53; constructor() public { owner = msg.sender; },1
0x0eaf3a45f6035565ee7fb61b242f562b77883fc4.sol,Help_the_Needy,contract Help_the_Needy { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x3a78b1e1fc38e61ed38f0e0e8d417cdf09f52016.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { symbol = ; name = ; decimals = 8; _totalSupply = 20000000000000000; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6dd2c2a82234d280e2b397db17b923fab49695e6.sol,DHSCToken,contract DHSCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 1000000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40395044ac3c0c57051906da938b54bd6557f212.sol,MobileGoToken,contract MobileGoToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 10000000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function MobileGoToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x44c7f06153bd9bf06ea498bddf4ccf04c249a851.sol,TokenOnline,"contract TokenOnline is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x070d026502014919ba0b80cb470ee461210185fe.sol,LBCToken,contract LBCToken { using LBCCoin for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 63000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponsCore,contract WeaponsCore is Ownable { struct WeaponModel { uint id; uint weaponType; uint generation; uint price; },1
0x6e226310db63ac3701f657bcc62c153c1aaa3004.sol,AdminBank,contract AdminBank { using SafeMath for uint256; uint256 public fundsReceived; address public masterAdmin; address public mainContract; bool public mainContractSet = false; address public teamMemberA = 0x2597afE84661669E590016E51f8FB0059D1Ad63e; address public teamMemberB = 0x2E6C1b2B4F7307dc588c289C9150deEB1A66b73d; address public teamMemberC = 0xB3CaC7157d772A7685824309Dc1eB79497839795; address public teamMemberD = 0x87395d203B35834F79B46cd16313E6027AE4c9D4; address public teamMemberE = 0x2c3e0d5cbb08e0892f16bf06c724ccce6a757b1c; address public teamMemberF = 0xd68af19b51c41a69e121fb5fb4d77768711c4979; address public teamMemberG = 0x8c992840Bc4BA758018106e4ea9E7a1d6F0F11e5; address public teamMemberH = 0xd83FAf0D707616752c4AbA00f799566f45D4400A; address public teamMemberI = 0xca4a41Fc611e62E3cAc10aB1FE9879faF5012687; uint256 public teamMemberArate = 20; uint256 public teamMemberBrate = 20; uint256 public teamMemberCrate = 15; uint256 public teamMemberDrate = 15; uint256 public teamMemberErate = 7; uint256 public teamMemberFrate = 4; uint256 public teamMemberGrate = 4; uint256 public teamMemberHrate = 5; uint256 public teamMemberIrate = 10; mapping (address => uint256) public teamMemberTotal; mapping (address => uint256) public teamMemberUnclaimed; mapping (address => uint256) public teamMemberClaimed; mapping (address => bool) public validTeamMember; mapping (address => bool) public isProposedAddress; mapping (address => bool) public isProposing; mapping (address => uint256) public proposingAddressIndex; constructor() public { masterAdmin = msg.sender; validTeamMember[teamMemberA] = true; validTeamMember[teamMemberB] = true; validTeamMember[teamMemberC] = true; validTeamMember[teamMemberD] = true; validTeamMember[teamMemberE] = true; validTeamMember[teamMemberF] = true; validTeamMember[teamMemberG] = true; validTeamMember[teamMemberH] = true; validTeamMember[teamMemberI] = true; },1
0xdc52c48074c3dcf9acbcb90b468484284d777490.sol,BDDBToken,"contract BDDBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf9a6f344FFEBF88e23e7a94e6F301f370CAac8E1] = _totalSupply; emit Transfer(address(0), 0xf9a6f344FFEBF88e23e7a94e6F301f370CAac8E1, _totalSupply); }",1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 2000 * 10**18; uint public maxWithdraw = 50000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; balanceOf[_escrow] = 7850047931491270769372792; totalSupply = 7850047931491270769372792; }",1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x5487939f38ad535223a6f5441edd43fac291da31.sol,PeculiumOld,"contract PeculiumOld is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function PeculiumOld() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0x19816294969ec8745a402133bf7c256c02eeabc9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdfe36fefdf20a6cffd0a42ee789c93f446b3df95.sol,HelloToken,contract HelloToken { using SafeMath for uint256; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; struct Supplies { uint128 totalSupply; },1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0xeed30721320b6372128e47dc48122fc2c65c1baa.sol,TestPausedToken,"contract TestPausedToken { address owner; uint256 public totalSupply = 1000000000000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public paused = true; mapping (address => mapping (address => uint256)) allowed; mapping(address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier whenNotPaused() { require(!paused); _; }",1
0x00817122beef212ac22e65fc0fba8bc065fd5f66.sol,UNTToken,contract UNTToken is MintableToken{ string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 8; mapping(address => uint256) public lockamount; address[] lockaddress; bool private isFreezed = false; function UNTToken() public { totalSupply = 2000000000E3; balances[msg.sender] = totalSupply; },1
0x1d1c98cd4b4757a04db41dd67988ceac813a8e1c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5335ef421f90bac4605908bc3a0f493a4e9119e8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721Interface { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner); event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner); event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner); event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner); event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId); event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId); event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId); event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x02aa481223f81b30ae9ccd4845ebfc3d4f4be068.sol,METS6,"contract METS6 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function METS6( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71a06988b97070a7091f81117b0a4bdee7a68357.sol,BITWORKCOIN,"contract BITWORKCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BITWORKCOIN() public { symbol = ; name = ; decimals = 9; _totalSupply = 1000000000000000000; balances[0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f] = _totalSupply; Transfer(address(0), 0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f, _totalSupply); }",1
0x44c7f06153bd9bf06ea498bddf4ccf04c249a851.sol,TokenOnline,"contract TokenOnline is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x4b35e0ab998ebe8414871c13cf778f9d0bbdf609.sol,SWPToken,"contract SWPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public swpFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant swpFund = 75000000 * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+2 days) return 3500; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+5 days) return 2700; return 2200; }",1
0xdc142e66eae81e1a6e7c60df32b15d736f3dd74a.sol,Airdropper,"contract Airdropper is Ownable { address public tokenAddr = 0x0; uint256 public numOfTokens; ERC20 public token; function Airdropper(address _tokenAddr, uint256 _numOfTokens) public { tokenAddr = _tokenAddr; numOfTokens = _numOfTokens; token = ERC20(_tokenAddr); }",1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,ShareToken,"contract ShareToken is ERC20Token, WhiteListManager { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 2; address public icoContract; uint256 constant E2 = 10**2; mapping(address => bool) public rewardTokenLocked; bool public mainSaleTokenLocked = true; uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT = 6666666667; uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT = 33333333333; uint256 public airDropTokenIssuedTotal; uint256 public bountyTokenIssuedTotal; uint256 public constant TOKEN_SUPPLY_SEED_LIMIT = 500000000 * E2; uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT = 2500000000 * E2; uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT; uint256 public seedAndPresaleTokenIssuedTotal; uint8 private constant PRESALE_EVENT = 0; uint8 private constant MAINSALE_EVENT = 1; uint8 private constant BOUNTY_EVENT = 2; uint8 private constant AIRDROP_EVENT = 3; function ShareToken() public { totalTokenIssued = 0; airDropTokenIssuedTotal = 0; bountyTokenIssuedTotal = 0; seedAndPresaleTokenIssuedTotal = 0; mainSaleTokenLocked = true; }",1
0x0e9f8e7e84fa6bb04287c0c002e92d779c5e7ae4.sol,m00n,contract m00n { mapping (address => uint) public invested; mapping (address => uint) public atBlock; uint public investorsCount = 0; function () external payable { if(msg.value > 0) { require(msg.value >= 10 finney); uint fee = msg.value * 10 / 100; address(0x6C221dea36d48512947BDe8aEb58811DB50dbf6F).transfer(fee); if (invested[msg.sender] == 0) ++investorsCount; },1
0xdcb9ff81013c31ff686154b4502ef6bfaa102d2d.sol,Goochain,"contract Goochain is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Goochain( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x49392a5867a4fd35cc31e366d790216daefaa647.sol,EtherHealth,"contract EtherHealth { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherHealth() { owner = 0x35a887e7327cb08e7a510D71a873b09d5055709D; balances[0x35a887e7327cb08e7a510D71a873b09d5055709D] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0xcea093ff08f94ebfcd921b8cd1e6a9f18826ccab.sol,LearnX,contract LearnX is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 10000000000 * 10**8; function name() public constant returns (string) { return ; },1
0x71e8d74ff1c923e369d0e70dfb09866629c4dd35.sol,WorkCoin,"contract WorkCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WorkCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2e685a1d919fea5aa294d0ee794f492fd9e93611.sol,LOOM,"contract LOOM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LOOM () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5] = _totalSupply; Transfer(address(0), 0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5, _totalSupply); }",1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0xc10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e.sol,Zamok,contract Zamok { uint256 public zamokCount; function Zamok() public { zamokCount = 0; },1
0x77b3106417d4cf3138882cc21d4710c71183b707.sol,Brave3d,contract Brave3d { struct Stage { uint8 cnt; uint256 blocknumber; bool isFinish; uint8 deadIndex; mapping(uint8 => address) playerMap; },1
0x55c4b50c93a5fa213078f96fbf0834cba17ebc43.sol,Egypt,"contract Egypt { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 1500000000000000000000000000; balanceOf[0x2D12749695305bbde9bA7e1E12fA481C71314F28] = totalSupply; emit Transfer(address(0), 0x2D12749695305bbde9bA7e1E12fA481C71314F28, totalSupply); }",1
0xd44dbf7e6aa11b3a9e16890f57eb6a6dc74ee94d.sol,token,"contract token { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[this] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x274b71f49dc3f5370da8c81e4e936eaf9a669321.sol,TFC,contract TFC is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10000; function name() public constant returns (string) { return ; },1
0xa1c15f52d51b436a4aec29e5dc6e9ccfdc50c229.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,token,"contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }",1
0x266be180f1bdda078b677c5d1c050268929f0da3.sol,CASINO_301201,"contract CASINO_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10990099143654100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2a062a343b53bb8fcee929d50f14ce4b418f455b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,LogFile,contract LogFile { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xa4dd9ad3da2d074f63b3993e7d5d7fc4ab37721a.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x3aa6c3f86d945085c9ff4581f3963f4f0404a416.sol,AAA,"contract AAA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844] = _totalSupply; emit Transfer(address(0), 0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844, _totalSupply); }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,Storage,"contract Storage is SafeMath, StringMover { function Storage() public { controllerAddress = msg.sender; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa2310206fd3fff0b66e03407eb03ed1ada4acecc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) _balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); _balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xce78ab22cd0331a52af7bb4b622edfa792819d47.sol,RUDAWORLD,"contract RUDAWORLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RUDAWORLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad] = _totalSupply; Transfer(address(0), 0x524D38666F6B53E25DaB7cEcE0D72585970Bd6ad, _totalSupply); }",1
0x01f79a6d6023c3b7d66144a14a1a0513e0077fce.sol,CMMO,"contract CMMO is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 183000000000000000000000000; balances[0x3839481b915f408cAC7AaB44b766b8B18B692f76] = _totalSupply; emit Transfer(address(0), 0x3839481b915f408cAC7AaB44b766b8B18B692f76, _totalSupply); }",1
0x3a86435776de97b5a481c395159c3b31cec966f6.sol,VOCC_I086_20181211,"contract VOCC_I086_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4d48ee87ab535833fdd79c7d1c4aac3c7c304b13.sol,Pomda,contract Pomda { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x875ee23ab07f56476d9029720b43008c20477b38.sol,FlowNet,"contract FlowNet { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint _initialTotalAmount, uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialTotalAmount; balances[msg.sender] = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0xd082e9e4f9b39bad6103c330292a7b219bf3b740.sol,BIBToken,"contract BIBToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BIBToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0xafb4fe1315504c92c3ed3657cd600712a8938aac.sol,Batman,"contract Batman is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Batman( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe031457dd79af958b30968ed9ed0b1d8ec8d3e74.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0x405b15a78a968607529aaa1f482e642883809496.sol,urunitairdropper,"contract urunitairdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x291a043f014d12dc852b02ff752e5b70132bc328.sol,CryptoCopyCrowdsale,"contract CryptoCopyCrowdsale { using SafeMath for uint256; address public creator; address public buyBackFund; address public bountyPool; address public advisoryPool; uint256 public minAcceptedEthAmount = 100 finney; uint256 public maxTotalSupply = 1000000 * 10**8; uint256 public tokensForInvestors = 900000 * 10**8; uint256 public tokensForBounty = 50000 * 10**8; uint256 public tokensForAdvisory = 50000 * 10**8; uint256 public totalTokenIssued; uint256 public bonusFirstTwoDaysPeriod = 2 days; uint256 public bonusFirstWeekPeriod = 9 days; uint256 public bonusSecondWeekPeriod = 16 days; uint256 public bonusThirdWeekPeriod = 23 days; uint256 public bonusFourthWeekPeriod = 30 days; uint256 public bonusFirstTwoDays = 20; uint256 public bonusFirstWeek = 15; uint256 public bonusSecondWeek = 10; uint256 public bonusThirdWeek = 5; uint256 public bonusFourthWeek = 5; uint256 public bonusSubscription = 5; uint256 public bonusOver3ETH = 10; uint256 public bonusOver10ETH = 20; uint256 public bonusOver30ETH = 30; uint256 public bonusOver100ETH = 40; mapping (address => uint256) balancesETH; mapping (address => uint256) balancesETHWithBonuses; mapping (address => uint256) balancesETHForSubscriptionBonus; mapping (address => uint256) tokenBalances; uint256 public totalInvested; uint256 public totalInvestedWithBonuses; uint256 public hardCap = 100000 ether; uint256 public softCap = 175 ether; enum Stages { Countdown, Ico, Ended }",1
0xbb5b059f574204c344cd3096b420fe563f242890.sol,NetkillerAdvancedToken,"contract NetkillerAdvancedToken { address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function NetkillerAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x74956d3e06b9edfab13f91ac45d8d22420545fd9.sol,TEGTY,"contract TEGTY is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 20 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 15; uint constant valueTeam = valueTotal / 100 * 85; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x868f77e4758776afa2cc2e46ce972e2043ca8e00.sol,YumeGorilla,"contract YumeGorilla { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public constant totalSupply = 87700000000 * 10 ** decimals; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(0, msg.sender, totalSupply); }",1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0xaaba7639c12dba5c518cc753d22c064568dcef54.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x7c607c86247c8a80376115a924daeeac2e32b47f64217a1d977d0f836c934389; constructor() public { owner = msg.sender; },1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x735ba26f91e1275fa4b504649b19ef74739fe7e7.sol,TeikhosBounty,contract TeikhosBounty { SHA3_512 public sha3_512 = SHA3_512(0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222); struct Commit { uint timestamp; bytes signature; },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0x035070be3ae4be1f69245214a4343a723c30232b.sol,Ethereum,"contract Ethereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ethereum() public { symbol = ; name = ; decimals = 8; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x72d84a0fd9ca53fa302a0a1ce4be22b1072274be.sol,EthereumPlus,"contract EthereumPlus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint public decimals; uint private _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 6; _totalSupply = 100000000; _totalSupply = _totalSupply * 10 ** decimals; balances[0x76a7fd7b41F27F0393dF8D23487CeF5fDB578705] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xbd04617f9bee584c0c45923a2d7971a64cea9297.sol,ADSToken,contract ADSToken { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1e27; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x4c1547be2c6f77c514840041b5a53d32f69e2c64.sol,Escrow,"contract Escrow { event Deposit(uint tokens); address dai_0x_address = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; mapping ( address => uint256 ) public balances; function deposit(uint tokens) public returns (bool success){ balances[msg.sender]+= tokens; ERC20(dai_0x_address).transferFrom(msg.sender, address(this), tokens); emit Deposit(tokens); return true; }",1
0x1eab19e6623e8cbcafc252e275f5b51c27656faf.sol,Spank,"contract Spank is ERC20, Owned { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public initialSupply; uint256 public totalSupply; uint256 multiplier; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) revert(); _; }",1
0xe1aa715fb68efe7723ccf447428e58d4ff756ee8.sol,DAOCOIN,"contract DAOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 9567000000000000000000000; balances[0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C] = _totalSupply; emit Transfer(address(0), 0x67133AD018DCcC3B3A6cC1701EA913e4c4E6123C, _totalSupply); }",1
0x554ffc77f4251a9fb3c0e3590a6a205f8d4e067d.sol,ZmineToken,"contract ZmineToken is StandardToken, Ownable { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 1000000000 ether; function ZmineToken() public { balances[owner] = totalSupply; }",1
0xd84f5e007af2343fec41b4bf23941f84eafd595d.sol,AcuteEthereumCloudMiningunion,"contract AcuteEthereumCloudMiningunion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AcuteEthereumCloudMiningunion() public { symbol = ; name = ; decimals = 0; _totalSupply = 180000000; balances[0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2] = _totalSupply; Transfer(address(0), 0x0C6C200F76d41fF91772513EcA292e2c7bD98aA2, _totalSupply); }",1
0x00ec953a3a3dad27da4f70d7e5be12dc08ef2835.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,ERC20OptionsConverter,"contract ERC20OptionsConverter is BaseOptionsConverter, TimeSource, Math { address esopAddress; uint32 exercisePeriodDeadline; mapping(address => uint) internal balances; uint public totalSupply; uint32 public optionsConversionDeadline; event Transfer(address indexed from, address indexed to, uint value); modifier converting() { if (currentTime() >= exercisePeriodDeadline) throw; _; }",1
0x5bf79762869f3af9dd1c9385e59d35be5b32cc8d.sol,AdmissionToken,"contract AdmissionToken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AdmissionToken( ) public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000; name = ; symbol = ; }",1
0xc608f567bcf51b0d84edef669b9d7d47440b7bb7.sol,EthronTokenPonzi,"contract EthronTokenPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthronTokenPonzi() public { }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x707bd951c676c5f7a957df363d6ce1b2af4b636d.sol,ANOToken,"contract ANOToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 21000000000 * 10**18; uint256 public tokensAllocatedToCrowdFund; uint256 public totalAllocatedTokens; address public crowdFundAddress; address public founderMultiSigAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier onlyCrowdFundAddress() { require(msg.sender == crowdFundAddress); _; }",1
0xa4ef5964f146d2526c51fc40caa244e45edce136.sol,ELECTRONICPLATINUM,contract ELECTRONICPLATINUM is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; function ELECTRONICPLATINUM( ) { balances[msg.sender] = 2000000000000000; totalSupply = 2000000000000000; name = ; decimals = 8; symbol = ; },1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,ERC20,contract ERC20 is Token { function name() public pure returns (string) { name; },1
0x2019763bd984cce011cd9b55b0e700abe42fa6c7.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0xeafeb35076d61ea2b0eeed2a31db61b07d2835d1.sol,CALToken,"contract CALToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x65140d4358bf4eabdaf7175dfc0eaae0d005c075.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns(uint256) { return totalSupply_; },1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,FansChainToken,"contract FansChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FansChainToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xa59dee0eb75df81cdca2b3d437d078f4df35e75c.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x1c76457f18230dc1c83d3376ca663ca7312f86d8.sol,ETR,"contract ETR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETR() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[msg.sender] = _totalSupply; bonusEnds = now + 0.1 weeks; endDate = now + 500 weeks; }",1
0x1dc211ed642733da8badeed7d529e9b67295593b.sol,ergo,"contract ergo { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public initialSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ergo( ) public { totalSupply = 81000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; unitsOneEthCanBuy = 810; }",1
0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239.sol,TruffleCoin,"contract TruffleCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 0; _totalSupply = 27000000000; balances[0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A] = _totalSupply; emit Transfer(address(0), 0xc6C908D8BEa27BE8A851aB0fBED007cacaf1850A, _totalSupply); }",1
0x6b683581e66524639cb9444000a7c8b5e10a1a07.sol,Eth5iov_2,"contract Eth5iov_2 { address public advertising; address public admin; address private owner; uint constant public statusFreeEth = 10 finney; uint constant public statusBasic = 50 finney; uint constant public statusVIP = 5 ether; uint constant public statusSVIP = 25 ether; uint constant public dailyPercent = 188; uint constant public dailyFreeMembers = 200; uint constant public denominator = 10000; uint public numerator = 100; uint public dayDepositLimit = 555 ether; uint public freeFund; uint public freeFundUses; uint public round = 0; address[] public addresses; mapping(address => Investor) public investors; bool public resTrigger = true; uint constant period = 5; uint dayDeposit; uint roundStartDate; uint daysFromRoundStart; uint deposit; uint creationDate; enum Status { TEST, BASIC, VIP, SVIP }",1
0x12ac8d8f0f48b7954bcda736af0576a12dc8c387.sol,OPL,"contract OPL { string public name; string public symbol; uint8 public decimals = 18; bool public adminVer = false; address public owner; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Emission(address indexed from, uint256 value); function OPL() public { totalSupply = 210000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; owner = msg.sender; }",1
0x6b6196fdb62faed24a17dc8e2f16ab0a77d529cf.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xecce0b5fc9ee365ee998307579fa4de7a803be3b.sol,CCD_EUROSIBENERGO_20190326_4,"contract CCD_EUROSIBENERGO_20190326_4 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0xefff7c7d4270268e0d1d75f4f93f856836ac1ee8.sol,ballotBox,contract ballotBox { mapping(address => bool) public creators; struct ballot { uint8 choiceCount; uint256 voteCountBlock; },1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0x3796a3e6fcf1b3a74d00b9e8fb31f07ed04a7937.sol,SPAIN_WINS,"contract SPAIN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 78484705836894400000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97.sol,metahashtoken,"contract metahashtoken { string public name; string public symbol; uint8 public decimals; uint public totalTokens; uint public finalyze; address public ownerContract; address public owner; mapping (address => uint256) public balance; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function totalSupply() public constant returns (uint256 _totalSupply){ return totalTokens; }",1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xafaeb51b058999a84354f5e45b44a1649519bcff.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x545123c9b719cc37d098168742ca21748adc0060.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0xc81068cd335889736fc485592e4d73a82403d44b.sol,Factories,contract Factories { GooToken constant goo = GooToken(0xdf0960778c6e6597f197ed9a25f12f5d971da86c); Units units = Units(0x0); Inventory inventory = Inventory(0x0); mapping(address => uint256[]) private playerFactories; mapping(uint256 => mapping(uint256 => uint32[8])) public tileBonuses; mapping(address => bool) operator; address owner; uint256 public constant MAX_SIZE = 40; constructor() public { owner = msg.sender; },1
0xef0b91addd85c4cb5ddc622778f9ab8f29cb939d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x184c8624d79f41eff9b3a702737ee86eeef80e67.sol,EthMonsters,contract EthMonsters { address public owner; event BuyMonsterEvent( uint price ); uint public typesNumber = 0; uint public monstersNumber = 0; mapping (address => uint) public userMonstersCount; mapping (address => uint) goodContracts; monster[] public monsters; mapping (uint => address) public monsterToOwner; mapping (address => uint) public userBalance; mapping (address => uint[]) public userToMonsters; uint public contractFees = 0; monsterType[] public types; constructor() public { owner = msg.sender; },1
0xdfbd6a960a55bcfcf59d5925351e05a51498bcef.sol,RockCoin,"contract RockCoin is ERC20{ uint initialSupply = 16500000; string name = ; string symbol = ; uint USDExchangeRate = 300; bool preSale = true; bool burned = false; uint saleTimeStart; address ownerAddress; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint amount); modifier onlyOwner{ if (msg.sender == ownerAddress) { _; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Registry,contract Registry is Ownable { bool opened; string[] identifiers; mapping(string => address) registrantOfIdentifier; mapping(string => uint[]) versionsOfIdentifier; mapping(string => mapping(uint => Template)) templateOfVersionOfIdentifier; constructor(bool _opened) Ownable() public { opened = _opened; },1
0x7241d179d92e86237bb460f8a19fae369a8846a3.sol,CGCToken,"contract CGCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CGCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6fdbcd375f348325d4b8c1fac374753ec1b07c92.sol,WSKYToken,"contract WSKYToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WSKYToken() public { symbol = ; name = ; decimals = 6; _totalSupply = 9600000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x42095468d0af5976caa589ad6db91a1b8913be4e.sol,RichToken,"contract RichToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 1 ether; mapping (uint256 => address) public richtokenIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public richtokenIndexToApproved; mapping (uint256 => uint256) private richtokenIndexToPrice; address public creator; struct Rich { string name; }",1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x581bcfbd2323ceb119b03d7e98d3086ac52e02d6.sol,ERC20token,"contract ERC20token{ uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20token(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2958ff9b325135374605b4e6987140a53394c6a6.sol,WNCT,"contract WNCT { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WNCT() public { balances[msg.sender] = 100000000000000; totalSupply = 100000000000000; name = ; decimals =4; symbol = ; }",1
0x88be9be70c825b85c5ac81183a07975269b549ca.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x5b75eb7153e7953cd30db58b281890075302df4f.sol,ISBParentsCoin,"contract ISBParentsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ISBParentsCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0xaa840b1138d31cc4a5fcd9545ed03441ef2a1213.sol,DIVIUMx2,contract DIVIUMx2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb.sol,NOUR,"contract NOUR { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0xafb4fe1315504c92c3ed3657cd600712a8938aac.sol,Batman,"contract Batman is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Batman( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53088104b7a9a04e52d8b884571634c815bce666.sol,ALONY_HETZ_20230515,"contract ALONY_HETZ_20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15815873703135800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaa5eb02bdaf93190922365f4e6326e1131dde3e4.sol,PublicBatchTransfer,"contract PublicBatchTransfer is WalletUsage { using SafeERC20 for ERC20; uint256 public fee; function PublicBatchTransfer(address walletAddress,uint256 _fee){ require(walletAddress != address(0)); setWallet(walletAddress); setFee(_fee); }",1
0xef47dd38cc0c2856a27fb1964b066ec33426e979.sol,DBXCContract,"contract DBXCContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37afbfb4330d449ce7d231f2356f4f9297c32bc1.sol,DistributeETH,"contract DistributeETH is Ownable { function distribute(address[] _addrs, uint[] _bals) onlyOwner public{ for(uint i = 0; i < _addrs.length; ++i){ if(!_addrs[i].send(_bals[i])) throw; }",1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x38ceafcff00dc2f88656a4ff3235e2124819eef6.sol,CryptojoyTokenSeller,"contract CryptojoyTokenSeller is Ownable { using SafeMath for uint; uint8 public constant decimals = 18; uint public miningSupply; uint constant MAGNITUDE = 10**6; uint constant LOG1DOT5 = 405465; uint constant THREE_SECOND= 15 * MAGNITUDE / 10; uint public a; uint public b; uint public c; uint public blockInterval; uint public startBlockNumber; address public platform; uint public lowerBoundaryETH; uint public upperBoundaryETH; uint public supplyPerInterval; uint public miningInterval; uint public tokenMint = 0; EIP20Interface public token; modifier isWithinLimits(uint _eth) { require(_eth >= lowerBoundaryETH, ); require(_eth <= upperBoundaryETH, ); _; }",1
0x04247b9b59091b349eb60e429fe7dbc99fdad34b.sol,FSC3,"contract FSC3 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FSC3( ) TokenERC20() public {}",1
0x3485b9566097ad656c70d6ebbd1cd044e2e72d05.sol,PinkyToken,"contract PinkyToken is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 10000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PinkyToken(){ balanceOf[msg.sender] = totalSupply; }",1
0xa6239853ff98b88367f6fcb003790654395d322d.sol,ETH10,contract ETH10 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10/100 * (block.number - atBlock[msg.sender]) / 6000; address sender = msg.sender; sender.send(amount); },1
0x417ecbab65f29e462a58b6f0516c8e8d5254016b.sol,Airdrop,"contract Airdrop is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x1e4300510ef90de505ddbcb77cdc8c4ab3f6d7c9.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * (10 ** 18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x1eb35af86a3821b5cca3013b1bb942c796aef544.sol,LV,"contract LV { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9.sol,DailyDraw,contract DailyDraw is Owned{ bytes32 public number; uint public timeLimit; uint public ticketsSold; struct Ticket { address addr; uint time; },1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x1e26b3d07e57f453cae30f7ddd2f945f5bf3ef33.sol,ClearCoin,contract ClearCoin is IERC20 { uint public constant _totalSupply = 100000000000000000; string public constant symbol =; string public constant name = ; uint8 public constant decimals = 8; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function ClearCoin() { balances[msg.sender] = _totalSupply; },1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x6d6a99e9e94923a9992a0593ea0298bf7542be67.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x557739fb7e603f0202d6a5671525eb97c7ebe609.sol,UKC,"contract UKC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function UKC() public { balances[msg.sender] = 2000000000000; totalSupply = 2000000000000; name = ; decimals =4; symbol = ; }",1
0x5affe8b1f00df6c8120f7e6bc39713fce11f24ac.sol,VOCC_I049_20181211,"contract VOCC_I049_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x39b948d3f844bb9e0e3b375901bb43d4866ef4bb.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping (address => uint256) public balances; function transfer(address _to, uint256 _value) public returns (bool) { require (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0xebc86d834756621444a8a26b4cf81b625fe310cd.sol,SafeMath,None,1
0x8470c0012ebd1201641620df2ac8600a402725b1.sol,MerialCoin,"contract MerialCoin { using SafeMath for uint256; string public symbol; string public name; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAddress; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenAddress(address indexed target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor () public { name = ; symbol = ; decimals = 18; totalSupply = 1000000000 * 10 ** uint256(decimals); owner = msg.sender; balanceOf[msg.sender] = totalSupply; }",1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0xdde19c145c1ee51b48f7a28e8df125da0cc440be.sol,EmbiggenToken,contract EmbiggenToken is ERC20 { using SafeMath for uint256; uint constant MAX_UINT = 2**256 - 1; string public name; string public symbol; uint8 public decimals; uint initialSupply; uint initializedTime; uint hourRate; struct UserBalance { uint latestBalance; uint lastCalculated; },1
0x31ac1331eed69beefb33aa992989605beac875d2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x58c37105311985775c43e8b27efabf441859dfc4.sol,DBXTTest,"contract DBXTTest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; endDate = now + 12 weeks; }",1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,HeroToken,"contract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable { event Mint(address indexed owner, uint newTokenId, uint _genes); event Transfer(address indexed from, address indexed to, uint tokenId); string public constant name = ; string public constant symbol = ; Hero[] public heroes; mapping(uint => address) tokenIndexToOwner; mapping(address => uint) ownershipTokenCount; mapping(address => uint[]) public ownerTokens; function totalSupply() public view returns (uint) { return heroes.length; }",1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x4b826daea6ac8fb869039ff1b3c80e150c3ad9e8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa3076afebed9558e3c09e7bbb913f611a1547619.sol,Thanatos,"contract Thanatos is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Thanatos() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0x4634B71d85be147421BBF39404f4ABB13303F935] = _totalSupply; Transfer(address(0), 0x4634B71d85be147421BBF39404f4ABB13303F935, _totalSupply); }",1
0xdc8944deaf5da0b81bcd38a87cbad0c0e793116f.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xee395235ac363725c6b895d8994706cb7050482f.sol,DataShieldCoin,"contract DataShieldCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DataShieldCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x74c5ab4757fcdbf8732230ca154498ea0c538239.sol,TheIlluminati,contract TheIlluminati { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6567751ec2b2d2566456bea3fd3090045cb0c865.sol,PPToken,"contract PPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PPToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7241d179d92e86237bb460f8a19fae369a8846a3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe120c1ecbfdfea7f0a8f0ee30063491e8c26fedf.sol,SuretlyToken,"contract SuretlyToken { string public constant standard = ; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public totalSupply = 237614 * 100000000; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event NewOwner(address _newOwner); event Burn(address indexed _from, uint256 _value); function SuretlyToken() { owner = msg.sender; balanceOf[owner] = totalSupply; }",1
0x587be3718e68f144f6dade2e50f28af95dd4be7e.sol,Fast20,contract Fast20 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 20 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x1768fc7978e9abae733dd6c3de837a57a2f2ce4f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6de8f49a47f4cdcf7cb69cafb1b6a74a4f38d113.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0x93D3F120D5d594E764Aa3a0Ac0AfCBAD07944f71); },1
0xe0090146f0eb3193a8a12380e3ec14732589e41f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x733dcf585e82c3daf788ee44e3faf8c1e7868729.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x9c49b65ddef30ad4a32c0ff6bf103144cd7733fc.sol,Sports3D,contract Sports3D { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6cbadb622d30a8c998c907911a9b160e735348fc.sol,BitEspritCoin,"contract BitEspritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) _balances; mapping(address => mapping(address => uint)) allowed; function BitEspritCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; _balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); }",1
0x25073d89644d3b033f422949e70064c60fa05c3c.sol,ToyOwnership,contract ToyOwnership { struct ToyToken { address owner; uint uid; uint timestamp; uint exp; bytes toyData; },1
0x411079f1b50ac2583a458a7cce1d1afdf4f8842e.sol,MSToken,"contract MSToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x1a30697cc47bd23add663fa9dc7bbb26adee655b] = _totalSupply; emit Transfer(address(0), 0x1a30697cc47bd23add663fa9dc7bbb26adee655b, _totalSupply); }",1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x0d7b2ea059bbfdc99ee6ae6289939d84397e5b78.sol,NortontokenERC20,"contract NortontokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NortontokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef.sol,EBCoin,"contract EBCoin is Owned { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; event ReceivedEth(address indexed _from, uint256 _value); function () payable public { emit ReceivedEth(msg.sender, msg.value); }",1
0x051f73eaf3f93b0b5440cc1381cb604f1457a6d1.sol,HOPE,"contract HOPE is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f4dcbb16f72853c7382e7100a0713a68e53d9be.sol,GroupBuyContract,contract GroupBuyContract { uint256 public constant MAX_CONTRIBUTION_SLOTS = 20; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; struct Group { address[] contributorArr; mapping(address => uint256) addressToContributorArrIndex; mapping(address => uint256) addressToContribution; bool exists; uint256 contributedBalance; uint256 purchasePrice; },1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x47709f4c5de9005cc46bf094989a67739a28ff7e.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x70409a44060fbc75a9e44170d025c049c929059e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0xeb61a78f06fc606d82892a38ea581c2bb7f82570.sol,XcLottery,"contract XcLottery is Ownable{ mapping (string => uint256) randomSeedMap; event DrawLottery(string period, uint256 randomSeed); function getRandomSeed(string period) constant returns (uint256 randomSeed) { return randomSeedMap[period]; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CompanyReserve,"contract CompanyReserve is Ownable{ SignalsToken token; uint256 withdrawn; uint start; function CompanyReserve(address _token, address _owner) public { token = SignalsToken(_token); owner = _owner; start = now; }",1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0xc5b106f17246b2f5c0c658dbd6e8d168695806ab.sol,SIEToken,contract SIEToken { using SafeMath for uint; string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 3000000000000000; address owner = 0x0; modifier onlyPayloadSize(uint size) { require(!(msg.data.length < size + 4)); _; },1
0xc429e7b63dc30b51f5a7e4be23fd5eb4baf8a1c3.sol,Bitibu,"contract Bitibu is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitibu( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x278ae6f52ce72b0df6cba451534b87846acc9d65.sol,BPER,"contract BPER is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BPER() public { symbol = ; name = ; decimals = 10; _totalSupply = 16000000000000000000; balances[0x8fB784413918e0917E50cC42282334C08a21730f] = _totalSupply; Transfer(address(0), 0x8fB784413918e0917E50cC42282334C08a21730f, _totalSupply); }",1
0x201fbe9e789d10d893b43ed5aaa5f1b7149f6de8.sol,BEC,"contract BEC is ERC20Interface, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BEC() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x3f8d54a081b67E135063A08c826B900930ef5B4E] = _totalSupply; Transfer(address(0), 0x3f8d54a081b67E135063A08c826B900930ef5B4E, _totalSupply); }",1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x58002a6b6e659a16de9f02f529b10536e307b0d9.sol,CHFT,"contract CHFT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5375bD481a1442694893eDA7d47FcEb04e8776fD] = _totalSupply; emit Transfer(address(0), 0x5375bD481a1442694893eDA7d47FcEb04e8776fD, _totalSupply); }",1
0x51d9e05775bde1b3c12d781d2f847b1ab93e3c3d.sol,EthAnte,contract EthAnte { uint public timeOut; uint public feeRate; address public TechnicalRise = 0x7c0Bf55bAb08B4C1eBac3FC115C394a739c62538; address public lastBidder; function EthAnte() public payable { lastBidder = msg.sender; timeOut = now + 1 hours; feeRate = 10; },1
0xb3a0dc0daa5ce33fc14a142c0fd4a1586c4e8c82.sol,Bitstraq_Token,"contract Bitstraq_Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitstraq_Token() public { symbol = ; name = ; decimals = 10; _totalSupply = 5000000000000000000; balances[0x9652A328f3003235E57194ef7C7c0e54F60C9E6e] = _totalSupply; Transfer(address(0), 0x9652A328f3003235E57194ef7C7c0e54F60C9E6e, _totalSupply); }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x0d68560012c430c367e86c4a7d95e3bcd53802d5.sol,DiscoverCoin,contract DiscoverCoin is StandardToken { function () { throw; },1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x6e8b3bf967405f2b1feaeb3a09c76bc94a8f37a4.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; string private _name; string private _symbol; uint8 private _decimals; constructor() public { _totalSupply = 21000000000000000; _balances[msg.sender] = _totalSupply; _name = ; _symbol = ; _decimals = 8; },1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x4cfb59bdfb47396e1720f7ff1c1e37071d927112.sol,ETXToken,"contract ETXToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETXToken() public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0xaa57e849341a2899110ba676a49302c069251d19.sol,AuctionStorage,contract AuctionStorage is BaseStorage { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint startedAt; bool byTeam; },1
0xeed30721320b6372128e47dc48122fc2c65c1baa.sol,TestPausedToken,"contract TestPausedToken { address owner; uint256 public totalSupply = 1000000000000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public paused = true; mapping (address => mapping (address => uint256)) allowed; mapping(address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); modifier whenNotPaused() { require(!paused); _; }",1
0x4bd3aac60b2e8893913b8398edda362e6b46dd98.sol,CryptoPoliceOfficerToken,"contract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable { using MathUtils for uint; string public name; string public symbol; uint8 public decimals = 18; mapping(address => mapping(address => uint)) allowances; bool public publicTransfersEnabled = false; uint public releaseStartTime; uint public lockedAmount; TokenLock[] public locks; struct TokenLock { uint amount; uint timespan; bool released; }",1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf.sol,SmartPayment,"contract SmartPayment is owned, TokenERC20 { uint256 public sellPrice = 1; uint256 public buyPrice = 1000000000000000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartPayment() TokenERC20(6000000, , ) public {}",1
0xe1e70407c8cdb588425fe7736e30df139110949f.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,LinkedList,contract LinkedList { struct Element { uint previous; uint next; address data; },1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xf67451dc8421f0e0afeb52faa8101034ed081ed9.sol,Gambit,"contract Gambit is Token, Owned { string public constant name = ; uint8 public constant decimals = 8; string public constant symbol = ; string public constant version = ; uint256 internal _totalBurnt = 0; function Gambit() { _totalSupply = 260000000000000; balances[owner] = _totalSupply; }",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Template,"contract Template is Ownable, SupportsInterfaceWithLookup { bytes4 public constant InterfaceId_Template = 0xd48445ff; mapping(string => string) nameOfLocale; mapping(string => string) descriptionOfLocale; bytes32 public bytecodeHash; uint public price; address public beneficiary; event Instantiated(address indexed creator, address indexed contractAddress); constructor( bytes32 _bytecodeHash, uint _price, address _beneficiary ) public { bytecodeHash = _bytecodeHash; price = _price; beneficiary = _beneficiary; if (price > 0) { require(beneficiary != address(0)); }",1
0x0ed74a3ecc90270d18a3b3a8eb0042a7cdd03b19.sol,MINEX,"contract MINEX { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MINEX() { balanceOf[msg.sender] = 2999029096950000; totalSupply = 2999029096950000; name = ; symbol = ; decimals = 8; }",1
0xf19903d8e5b7d604b62d2a210b39ba9e1e1f93ef.sol,STASHToken,"contract STASHToken is STASHInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function STASHToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 36000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 600000; fundsWallet = msg.sender; }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x37ceaf9e7748c707934edea028812c7fdaf93866.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x17f28bd2c1b22c07899ca7ef7bf586b7a4e6fcf4.sol,CashTelexToken,"contract CashTelexToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CashTelexToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 3 weeks; endDate = now + 21 weeks; }",1
0x40ae4acd08e65714b093bf2495fd7941aedfa231.sol,multiowned,contract multiowned { struct MultiOwnedOperationPendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xf5068761511594c82328102f4fde4650ed9ea6c4.sol,WHP,contract WHP is StandardToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address private creator; mapping (address => uint256) private blackmap; mapping (address => uint256) private releaseamount; modifier onlyCreator() { require(msg.sender == creator); _; },1
0x6c46b734d5a94b10929ac4e88f22cc56145bc65c.sol,AMOT__20230515,"contract AMOT__20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15538797795124200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc0ca7bd6f54341bb871f6106acde6ec4d65c1f91.sol,SarahCoin,"contract SarahCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SarahCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000; balances[0xC027b267C1A801497B1D234bfF336d5937C2bF48] = _totalSupply; Transfer(address(0), 0xC027b267C1A801497B1D234bfF336d5937C2bF48, _totalSupply); }",1
0xd8e6a6a27f31cb4ee8d7584b7a67e624e17a038a.sol,SafeMath,None,1
0x33a56a411b6908b06dc2497eb3dfac1d96db22f2.sol,FECT,"contract FECT is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FECT() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x53939398a56670c788a9b9e671e58da73df032bf.sol,RevalootSwap,"contract RevalootSwap is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RevalootSwap() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x8a3Ad06690A371D3A9568a230D40743Eb4C006f0] = _totalSupply; Transfer(address(0), 0xc6C82E87Dd806cD0de602cD7b31c35cF119cC4B7, _totalSupply); }",1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x304281f3d1023a2039ea930c65f8f721d7c746c8.sol,AXNETToken,"contract AXNETToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AXNETToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x33e127da2426822408b1d41344146de02ee48670.sol,PONTEM,"contract PONTEM { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply , string tokenName , string tokenSymbol) public { totalSupply = 250000000 * 10 ** uint256(18) ; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf46ec74202f414a8c05f9db7ff60869eb750d1c9.sol,SHERE_PFV_III_883,"contract SHERE_PFV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 2180230364645770000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2dd09c71d951148bba0f25be7f76ba401fe8ef84.sol,GoTokenDutchAuction,contract GoTokenDutchAuction { GoToken public token; address public owner_address; address public wallet_address; address public whitelister_address; address public distributor_address; uint256 constant public bid_threshold = 10 finney; uint256 public token_multiplier; uint256 public num_tokens_auctioned; uint256 public price_start; uint256 constant public CURVE_CUTOFF_DURATION = 8 days; uint256 public price_constant1; uint256 public price_exponent1; uint256 public price_constant2; uint256 public price_exponent2; uint256 public privatesale_start_time; uint256 public auction_start_time; uint256 public end_time; uint256 public start_block; uint256 public received_wei; uint256 public received_wei_with_bonus; uint256 public funds_claimed; uint256 public final_price; struct Account { uint256 accounted; uint256 received; },1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x71480498a6ed411dfef39f825aa1f900a8ebdf53.sol,LenderBot,contract LenderBot is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() public pure returns (string) { return ; },1
0x0f690a76ad438222ce694d84b2902b0ee2270e69.sol,BlackBox,contract BlackBox is Secure { address public owner; struct Proof { uint256 balance; bytes32 operator; bytes32 check; },1
0xda908dcf358351d79e5051a7118c9318f67fcfc9.sol,Troo,"contract Troo is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Troo ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xef906c48b8fde48f5f2ceb448b1163bf964ef4ac.sol,DAX_4000_20200618,"contract DAX_4000_20200618 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721Interface { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner); event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner); event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner); event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner); event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId); event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId); event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId); event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0xeafeb35076d61ea2b0eeed2a31db61b07d2835d1.sol,CALToken,"contract CALToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2011266a6c9e48b3ed2e397637df03abe1d3e832.sol,ETGOLDToken,"contract ETGOLDToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETGOLDToken() public { totalSupply = 24000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeb92266ba75dc3ff16a12e9ea4f1d20ca1560beb.sol,NHC,"contract NHC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NHC( ) public { totalSupply = 3141592653000000000000000000; balanceOf[msg.sender] = 3141592653000000000000000000; name = ; symbol = ; }",1
0x4d797cbb28c49bd074db4a47b582c95fd37804a1.sol,CloutToken,"contract CloutToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function CloutToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xeb0c680b2e42685bc836922d416dfd836704ab09.sol,ARWToken,"contract ARWToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ARWToken() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,MainCard,"contract MainCard is BasicAuth,MainBase { struct Card { uint32 m_Index; uint32 m_Duration; uint8 m_Level; uint16 m_DP; uint16 m_DPK; uint16 m_SP; uint16 m_IP; uint32[] m_Parts; }",1
0x656038e97cee7c095673f7b9fad695b323a6f098.sol,WheelOf0xBitcoin,contract WheelOf0xBitcoin { using SafeMath for uint; modifier nonContract() { require(tx.origin == msg.sender); _; },1
0x1b9199b6a8e8d5ddedd072abe07439aad65436b4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888.sol,GameTable,contract GameTable { using SafeMath for uint; struct Player { address addr; uint amount; uint profit; },1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0x4d538b9b3c1c3f58707a9689b5bc3d860c011242.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2d295c19f405048c576b4c1179ea2458e8e13935.sol,x32323,"contract x32323 is owned{ mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x5279ef99353dd74fdfda8d70e9a2f6cb8a1ae2fe.sol,CHEMCHINA_PFV_III_883,"contract CHEMCHINA_PFV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1049417559213730000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x40395044ac3c0c57051906da938b54bd6557f212.sol,MobileGoToken,contract MobileGoToken { string public constant _name = ; string public constant _symbol = ; uint8 public constant _decimals = 8; uint256 public constant _initialSupply = 10000000000000000; address public owner; uint256 public _currentSupply; mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; function MobileGoToken() { owner = msg.sender; _currentSupply = _initialSupply; balances[owner] = _initialSupply; },1
0x2e0ed230795f1bd24996f82c76b7bd0d86120e34.sol,AssetNotary,"contract AssetNotary is TimestampNotary, LinkedToken { using SafeMath for uint256; bytes8[] private _assetList; mapping (bytes8 => uint8) private _assetDecimals; mapping (bytes8 => uint256) private _assetBalances; event AssetBalanceUpdate( bytes8 indexed assetId, uint256 balance ); function registerAsset(bytes8 assetId, uint8 decimals) public onlyOperator returns (bool) { require(decimals > 0); require(decimals <= 32); _assetDecimals[assetId] = decimals; _assetList.push(assetId); return true; }",1
0x34ddcc255d2f3f2e2d85a2a11e314670e73b24d4.sol,lottrygame,"contract lottrygame{ uint256 public people; uint numbers; uint256 public tickamount = 100; uint256 public winnergetETH1 = 0.05 ether; uint256 public winnergetETH2 = 0.03 ether; uint256 public winnergetETH3 = 0.02 ether; uint public gamecount = 0; uint public inputsbt = 100; uint black=1; uint red=2; uint yellow=3; address[] public tickplayers; address public owner; address tokenAddress = 0x503F9794d6A6bB0Df8FBb19a2b3e2Aeab35339Ad; address poolwallet; bool public tickgamelock = true; bool public full = true; event tickwinner(uint,address,address,address,uint,uint,uint); event ticksell(uint gettick,uint paytick); modifier ownerOnly() { require(msg.sender == owner); _; }",1
0xa1a6cea5c52461028c8d436428ceddb6ce8e7ddc.sol,Metayen,contract Metayen { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x219101d69455c620700bf02f157f29ef7a8f7988.sol,MyToken,"contract MyToken is MyOwned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target,bool frozen); event Transfer(address indexed from,address indexed to,uint256 value); function MyToken(uint256 initialSupply,string tokenName,string tokenSymbol,uint8 decimalUnits){ balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x279e152f96bdd4a0b3cb10b5fba0cfeea4a7429b.sol,SafeMath,None,1
0x5cbf1b692d921f9eccaac6364ba463b8f549f266.sol,roga,"contract roga { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function roga( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x1811aacf243e28047ccb0126b9e0f3662ed48948.sol,BB,"contract BB is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor (uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44a1b86ffa821bcadb636a4493aa50d5ab0ddf4a.sol,GoodDayToken,"contract GoodDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GoodDayToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 12 weeks; }",1
0x27058b0fe23a4cdd08aced7ffd646647019cdab9.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x063115687340eddf0468cfabea4f3770930c119d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x7241d179d92e86237bb460f8a19fae369a8846a3.sol,CGCToken,"contract CGCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CGCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2da4bb51e59d0b156b5e19bb3f8eff0279e1ffa2.sol,PuertoRicoHurricaneRelief_SaintCoinCaller,"contract PuertoRicoHurricaneRelief_SaintCoinCaller is Owned { address saintCoinAddress; address fundationWalletAddress; uint public percentForHelpCoin = 10; function PuertoRicoHurricaneRelief_SaintCoinCaller(address _saintCoinAddress, address _fundationWalletAddress) public { require(_saintCoinAddress != address(0x0)); require(_fundationWalletAddress != address(0x0)); saintCoinAddress = _saintCoinAddress; fundationWalletAddress = _fundationWalletAddress; }",1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardMint,"contract CardMint is CardBase { using AddressUtils for address; event TemplateMint(uint256 _templateId); event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); struct Template { uint256 generation; uint256 category; uint256 variation; string name; }",1
0xf4d9f469297d7c6a8c3962aa04ab37d6cfa66ee7.sol,AdviserCasperToken,"contract AdviserCasperToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AdviserCasperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 440000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5b60414447a58a9ac5e28fd695f1e23874103ef0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DDBBCOIN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = 8; balanceOf[msg.sender] = 2160000000000000; name = ; symbol = ; }",1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d9e20e581a5468644fe74ccb6a46278ef377f9e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x05e886072ec32a5d4273ce451483a7693cb812e4.sol,BTN,"contract BTN is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTN() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf3c8ed6c721774c022c530e813a369dfe78a6e85.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x205daf7cb272e436652115ecfb7df465631d80d0.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) public returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0xd02675f786cfd9e665d6d4c725e5ada529493063.sol,DateTimeLib,None,1
0xdcb9ff81013c31ff686154b4502ef6bfaa102d2d.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0x5aa8d6de8cbf23dac734e6f904b93bd056b15b81.sol,SenbitTokenVision,"contract SenbitTokenVision{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function SenbitTokenVision() public{ balanceOf[msg.sender] = 300000000 * (10**18); totalSupply = 300000000 * (10**18); name = ; symbol = ; decimals = 18; }",1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52f7018bc6ba4d24abfbaefccae4617bfb0a0b52.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x27798734d18d63b963137a360cadff807d479e50.sol,ZTTBToken,"contract ZTTBToken is owned, TokenERC20 { uint256 public sellPrice = 0.00000001 ether ; uint256 public buyPrice = 0.00000001 ether ; mapping (address => bool) public _frozenAccount; event FrozenFunds(address target, bool frozen); function ZTTBToken( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) TokenERC20(initialSupply, tokenName, tokenSymbol,decimal) public { _balances[msg.sender] = _supply; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0xd82f9939aa0ba1bf5d5bbade54b5f2f61d2cfdbe.sol,NEWT,"contract NEWT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NEWT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x6d500e4b6565c3c25a6edd51839d52269e3d293f.sol,KiddyToys,"contract KiddyToys is ERC721, Ownable { event ToyCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public toyIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public toyIdToApproved; mapping (uint256 => uint256) private toyIdToPrice; struct Toy { string name; }",1
0x53437f622bf47e758c301d0e1d2649fd42a8baa6.sol,NewYorkCoin,"contract NewYorkCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewYorkCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 212000000000000000000000000; balances[0x40efa05720ba773ddcfe6e472e723b54d05d680e] = _totalSupply; Transfer(address(0), 0x40efa05720ba773ddcfe6e472e723b54d05d680e, _totalSupply); }",1
0x6f21278477a84b7e2aa564d533dc128e1cf00e22.sol,SHERE_PFV_I_883,"contract SHERE_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 748289622343488000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x71f04062e5794e0190fdca9a2bf1f196c41c3e6e.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 value); event Burn(address indexed to, uint256 value); function mint(address addr, uint256 value) onlyOwner public returns (bool) { _totalSupply = _totalSupply.add(value); _balances[addr] = _balances[addr].add(value); emit Mint(addr, value); emit Transfer(address(0), addr, value); return true; }",1
0x3325d0ea1eb601ff0d60083becff55353bea44eb.sol,VOCC_I097_20181211,"contract VOCC_I097_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4c8c4659f734294d9561c8b0efc210028ed12052.sol,company_acc,contract company_acc { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc209a261dae1dc7caa5b02a54874c85a69de5c9ddc0b0bebdbfa9a394fb24caf; constructor() public { owner = msg.sender; },1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0x1f3fc753663b2afa9e459dd5da5549706eab3e2d.sol,ShopperlyGlobalToken,"contract ShopperlyGlobalToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ShopperlyGlobalToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 12500000000000000000000000; balances[0x0bB743ff91E1f1F410A480dE0f67908926c5100E] = _totalSupply; Transfer(address(0), 0x0bB743ff91E1f1F410A480dE0f67908926c5100E, _totalSupply); }",1
0x00a8671dee8a84262945bb163036265901293789.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5206357752953970000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x72d02f8c18d5452c6ed3f5515d7afe68c8a01f43.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x1c25075bc63ed919babab6cab573f45a47c591df.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf3e3f649771651368d89dd6fefc57c77dceb6f78.sol,BitMaxProToken,"contract BitMaxProToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 2500000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa2d8fa4a15943f32f1bda104308519d33ad894ec.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0xa177916265c6f647c8e0bfbed396aec1596d6af8.sol,AOS,contract AOS is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 500000000000000; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x51f545a57a88d193227f506ff07911da0df2749c.sol,MEXICO_WINS,"contract MEXICO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0xf32eba56b29cfeba67c10b18e1e1626f97c00a22.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd091eb3a1cbb2182d1b98435be25bbaf89746540.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 10*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,Loan,contract Loan is Base { struct Creditor { uint Time; uint Invested; },1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x5c62da804298d5972a323c80b539b8e7517a0dde.sol,VENJOCOIN,"contract VENJOCOIN is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 2000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x0d3d475f035705a662f5ab34e374e3c44bb52187.sol,Config,contract Config { uint256 public constant jvySupply = 333333333333333; uint256 public constant bonusSupply = 83333333333333; uint256 public constant saleSupply = 250000000000000; uint256 public constant hardCapUSD = 8000000; uint256 public constant preIcoBonus = 25; uint256 public constant minimalContributionAmount = 0.4 ether; function getStartPreIco() public view returns (uint256) { uint256 nowTime = block.timestamp; uint256 _preIcoStartTime = nowTime + 1 minutes; return _preIcoStartTime; },1
0xf15f61643eea73be40ad9b72c09ed381fac7a256.sol,FishbankBoosters,contract FishbankBoosters is Ownable { struct Booster { address owner; uint32 duration; uint8 boosterType; uint24 raiseValue; uint8 strength; uint32 amount; },1
0xece73b9f0e0a3d7f33f79fd1d77cb344288b9966.sol,RVG,"contract RVG is owned, StdToken { string public name = ; string public symbol = ; string public website = ; uint public decimals = 18; uint256 public totalSupplied; uint256 public totalBurned; constructor(uint256 _totalSupply) public { supply = _totalSupply * (1 ether / 1 wei); totalBurned = 0; totalSupplied = 0; balances[address(this)] = supply; }",1
0x17459fd5727e458829db77443531333b1fb93d6b.sol,BANK_IV_PFI_883,"contract BANK_IV_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 417212953933922000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x795890e742865ef9e716a6de1b107e3c3e7a5748.sol,BitcoinXL,"contract BitcoinXL is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitcoinXL() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000000; balances[0xF57359488Cbd49a22Da864168f862CD6792C81CD] = _totalSupply; Transfer(address(0), 0xF57359488Cbd49a22Da864168f862CD6792C81CD, _totalSupply); }",1
0x70f823ed7643fd7a26fdf8753827d31c16374fde.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5ac8359a7d38afedf7ed0d4abb283cd2654d126a.sol,MyToken,contract MyToken is StandardToken { string public name; uint8 public decimals; string public symbol; function(){ revert(); },1
0x35b5abaedeed12c63e04029120fa6bb084342b4d.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>3 ether) { msg.sender.transfer(this.balance); },1
0xede4edd0c0209db3172a9a07607b47fcf57e6355.sol,EthereumUnionToken,"contract EthereumUnionToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EthereumUnionToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 12500000000000; balances[0xfb58a9af395755a4e95805d76bae231feb01a192] = _totalSupply; emit Transfer(address(0), 0xfb58a9af395755a4e95805d76bae231feb01a192, _totalSupply); }",1
0x1d72e76e38c815b9f91661c340949e8673e897b3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 20000000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0xee8c282901c523d1933478d223f28d2a25c4b63a.sol,POOL,contract POOL { bytes32 keyHash; address owner; bytes32 wallet_id = 0xad2f7721e166f8f6df08fe098755259c399a8437944ad54b97ac73c77ffd43c4; constructor() public { owner = msg.sender; },1
0x53844515fcd00fe3864167a648309dd11c5055fc.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = INITIAL_SUPPLY.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { totalSupply_ = INITIAL_SUPPLY; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0x6f2deef18421ba39065223b23ef38666b3052a46.sol,Marine,contract Marine is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 1000000000 * (10 ** uint256(decimals)); uint256 public MRNToEth; uint256 public ethInWei; address public devWallet; function Marine () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; MRNToEth = 20000000; devWallet = msg.sender; },1
0xa575aea29bcf52afa55113b3b1b9e3813143d10d.sol,TokenLingERC20,"contract TokenLingERC20 { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20 ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf515c78ea440443021fd2abdccbf01afcaae3e65.sol,PreSignedContract,"contract PreSignedContract is Ownable { mapping (uint8 => bytes) internal _prefixPreSignedFirst; mapping (uint8 => bytes) internal _prefixPreSignedSecond; function upgradePrefixPreSignedFirst(uint8 _version, bytes _prefix) public onlyOwner { _prefixPreSignedFirst[_version] = _prefix; }",1
0xefc1b11ad4b183ad859ef220a9c498cb04716a31.sol,Counter,"contract Counter { event Won(address winner, uint amount); uint public i; address public owner; function Counter() public { owner = msg.sender; }",1
0xf23fd8e6c2eda7e4d2a5638c8256bd516f7c6a73.sol,XPortDigitals,contract XPortDigitals is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 86000000000 * 100; function name() public constant returns (string) { return ; },1
0x4bb301e545a3e948b20ea9a0f02d3948af6fe6db.sol,TarynToken,contract TarynToken is AccessControlled { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public totalSupply; mapping(address => uint256) balances; mapping(uint256 => address) public addresses; mapping(address => uint256) public indexes; uint public index = 1; function TarynToken() public { totalSupply = INITIAL_SUPPLY; },1
0x64b09d1a4b01db659fc36b72de0361f2c6c521b1.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09.sol,EMC,"contract EMC is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x346b7ac48f05e505dd7c1c9e861577f7e793cf17.sol,Template,"contract Template is Ownable, SupportsInterfaceWithLookup { bytes4 public constant InterfaceId_Template = 0xd48445ff; mapping(string => string) nameOfLocale; mapping(string => string) descriptionOfLocale; bytes32 public bytecodeHash; uint public price; address public beneficiary; event Instantiated(address indexed creator, address indexed contractAddress); constructor( bytes32 _bytecodeHash, uint _price, address _beneficiary ) public { bytecodeHash = _bytecodeHash; price = _price; beneficiary = _beneficiary; if (price > 0) { require(beneficiary != address(0)); }",1
0x71871f8d10b2965e06dc29b1be7122086aeb11e0.sol,SafeMath,None,1
0x0ef4bd1e9baa163d410b31d47bd4e9ebe7dfda1c.sol,EdxToken,contract EdxToken is ERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; struct VestInfo { uint256 vested; uint256 remain; },1
0x712742829b3181b45facca605c699d4479855c30.sol,StrongHands,"contract StrongHands is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StrongHands() public { symbol = ; name = ; decimals = 18; _totalSupply = 18984246847200000000000000000000; balances[0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9] = _totalSupply; Transfer(address(0), 0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9, _totalSupply); }",1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Whitelist,contract Whitelist is Ownable { using SafeMath for uint256; mapping(address => bool) public whitelist; mapping(address => uint256) whitelistIndexMap; address[] public whitelistArray; uint256 public whitelistLength = 0; modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; },1
0x1be2770c2cfc85834c8c0fa55c0705c4a22b3cf9.sol,GMBAirdrop,"contract GMBAirdrop is Ownable { function multisend(address[] to, uint256[] value) onlyOwner returns (uint256) { address tokenAddr = 0x1B148b90442826375e864B71165A18B4D9256097; uint256 i = 0; while (i < to.length) { ERC20(tokenAddr).transfer(to[i], value[i] * ( 10 ** 18 )); i++; }",1
0x6fcaf59b5a6790752c78e2ab8cf7fe599f3dcd45.sol,NDD_001_T22,"contract NDD_001_T22 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x06badfdacd3e80e4974e8419153114f6159e4851.sol,CLOUDTOKEN,"contract CLOUDTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CLOUDTOKEN() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1] = _totalSupply; Transfer(address(0), 0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1, _totalSupply); }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x6c5be5501b9c792637f3fe45ef991ce120296ef7.sol,SuomenMarkka,"contract SuomenMarkka is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SuomenMarkka() public { symbol = ; name = ; decimals = 2; _totalSupply = 1000000000000; balances[0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604] = _totalSupply; Transfer(address(0), 0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604, _totalSupply); }",1
0x70e531091d82e183f7246012d1566c3fe1315625.sol,SendToMany,contract SendToMany { address owner; address[] public recipients; function SendToMany() public { owner = msg.sender; },1
0x64e65d352f6a2949463b3a7595911b61bbafc63e.sol,KIPToken,"contract KIPToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 10000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x409e1820aba80fd6bc0f7573528f56cd3ccbfafb.sol,Linamyd,contract Linamyd { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x400e115f1be2b646139c298272a43b2cff2b127e.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0x70f823ed7643fd7a26fdf8753827d31c16374fde.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf066a61ebcb0a11ec3921cf9fbcca4561877526f.sol,MasterNodeMining,"contract MasterNodeMining is Ownable{ using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maximumSupply = 10000000 * (10 ** uint256(decimals)); uint256 public constant icoSupply = 9000000 * (10 ** uint256(decimals)); uint256 public constant TokensPerEther = 1000; uint256 public constant icoEnd = 1522540800; uint256 public constant teamTokens = 1538352000; address public multisig = 0xF33014a0A4Cf06df687c02023C032e42a4719573; uint256 public totalSupply; function transfer(address _to, uint _value) public returns (bool success) { require( msg.data.length >= (2 * 32) + 4 ); require( _value > 0 ); require( balances[msg.sender] >= _value ); require( balances[_to] + _value > balances[_to] ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x02e492fc1ef9466260d91d087057de601b874b7d.sol,Bitcoinpremier,"contract Bitcoinpremier is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitcoinpremier() public { symbol = ; name = ; decimals = 18; _totalSupply = 35000000000000000000000000000; balances[0xE4b0F089fcEBA22dA87470e1Bb7BB0bb977BaDfa] = _totalSupply; Transfer(address(0), 0xE4b0F089fcEBA22dA87470e1Bb7BB0bb977BaDfa, _totalSupply); }",1
0x54794cfdbac9b9e58eb737643d9f0269ab5c8248.sol,SimpleERC20Token,"contract SimpleERC20Token { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b.sol,SlowMoon,contract SlowMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6ce17d826a1c50e97678810954943c83ebd10066.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x54923b4f2e4433294c70559cc94d1812793f0451.sol,Future1Exchange,contract Future1Exchange { address public archon; mapping (address => mapping(address => uint256)) public _token; constructor() public { archon = msg.sender; },1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1f3fc753663b2afa9e459dd5da5549706eab3e2d.sol,ShopperlyGlobalToken,"contract ShopperlyGlobalToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ShopperlyGlobalToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 12500000000000000000000000; balances[0x0bB743ff91E1f1F410A480dE0f67908926c5100E] = _totalSupply; Transfer(address(0), 0x0bB743ff91E1f1F410A480dE0f67908926c5100E, _totalSupply); }",1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0x35027a992a3c232dd7a350bb75004ad8567561b2.sol,EasyInvestForever,contract EasyInvestForever { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public interestRate = 1; uint256 public nextBlock = block.number + 5900; function () external payable { if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; interestRate = (currentBalance - previousBalance) / 10e18 + 1; interestRate = (interestRate > 10) ? 10 : ((interestRate < 1) ? 1 : interestRate); previousBalance = currentBalance ; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0x3638c9e50437f00ae53a649697f288ba68888cc1.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7000 * 10 ** uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x569e19cb83086d9c32331a1b33e88123c33931e2.sol,FlowNet,"contract FlowNet { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public { balances[msg.sender] = 200000000000000000000000000; totalSupply = 200000000000000000000000000; name = ; decimals = 18; symbol = ; }",1
0x838b653d5877f92d0d9ecaea0073b479513b3326.sol,COINEIUM,"contract COINEIUM { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply = 777000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function COINEIUM() public { totalSupply = 777000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xda65eed883a48301d0ecf37465f135a7a0c9d978.sol,DavidCoin,"contract DavidCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DavidCoin() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x0f2a1a06024f6d2ceb2adf937732f9029ca97045.sol,Capital,contract Capital { uint constant public CASH_BACK_PERCENT = 3; uint constant public PROJECT_FEE_PERCENT = 20; uint constant public PER_BLOCK = 48; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public wave; address public owner; address public admin; address[] public addresses; bool public pause; mapping(address => Investor) public investors; TheStrongest public boss; modifier onlyOwner { require(owner == msg.sender); _; },1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0x5c75d5edb312e5d241aca7bebe5fbf0a544ff1cd.sol,AIEcommerceChain,"contract AIEcommerceChain { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0xd15d322351667b202f70b2c2d568341da8d39b67.sol,ASTRICOSale,"contract ASTRICOSale is Ownable { ERC20 public token; uint256 public startTime; uint256 public endTime; address public wallet; address public ownerAddress; uint256 public weiRaised; uint8 internal decimals = 4; uint256 internal decimalsConversion = 10 ** uint256(decimals); uint256 internal ALLOC_CROWDSALE = 90000000 * decimalsConversion; uint internal BASIC_RATE = 631 * decimalsConversion; uint public PRICE_VARIABLE = 0 * decimalsConversion; uint256 public astrSold = 0; bool public halted; bool public crowdsaleClosed; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier isNotHalted() { require(!halted); _; }",1
0x462adf63904054f21e2b9f217d639446536b5743.sol,HOT,"contract HOT { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenSupply = 177619433541; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function HOT() public { totalSupply = tokenSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0x35ced9349943292f8a3b2e0a96fec76d7877ac4e.sol,BancorKillerContract,"contract BancorKillerContract { using SafeMath for uint256; address public admin; address public base_token; address public traded_token; uint256 public base_token_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; bool public base_token_is_seeded; bool public traded_token_is_seeded; mapping (address => uint256) public token_balance; constructor(address _base_token, address _traded_token,uint256 _base_token_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = tx.origin; base_token = _base_token; traded_token = _traded_token; base_token_seed_amount = _base_token_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; }",1
0xf4dc44f1c618a5e4b6f372347e033ac5e77971a5.sol,CONTINENTAL_AG,"contract CONTINENTAL_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10651142832031200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc8507d914d21d50c1763288da6539f6a0f5a0916.sol,yiDaooToken,"contract yiDaooToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaooToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x716989fa21d5043165079ddbfd04a76a001a595a.sol,COCTokenBase,"contract COCTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; address public administrator; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function COCTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; administrator = msg.sender; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[administrator] = totalSupply; }",1
0x28cb4e001f87dacd8e97250e1312008668bd78a8.sol,multi_user_wallet,contract multi_user_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xcdbb6bf672a7088809e37cb8ce69daed19bf9761445769788e2a2668c46ff036; constructor() public { owner = msg.sender; },1
0x1d8ed4b0a3147ed17ea09582b46e0c9635396720.sol,TokenERC20,"contract TokenERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 100000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xd07e5059e6d401b7d0640928bfc30e569fe4059b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0x3a5f32732d6be576d5dec48354b2377e14675eca.sol,BCTToken,"contract BCTToken is PausableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 21000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6b0d7b8357bb851de9f1953199c39c7bc4675796.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c2389c0b8014be72e11849ec0aa790b03929e18.sol,FundingWallet,contract FundingWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xf2a95300326adf582a43b63218742e4528f82b01.sol,MultiSend,contract MultiSend { TokenERC20 public _ERC20Contract; address public _multiSendOwner; function MultiSend () { address c = 0xc3761eb917cd790b30dad99f6cc5b4ff93c4f9ea; _ERC20Contract = TokenERC20(c); _multiSendOwner = msg.sender; },1
0x2a98c6dcac6d759695b09cdf6b26cf4a13370a57.sol,DOGEToken,"contract DOGEToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOGEToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8] = _totalSupply; Transfer(address(0), 0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8, _totalSupply); }",1
0xf3e827ee018007603899170f0d4b80076dfa469e.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address=>uint256) public indexes; mapping(uint256=>address) public addresses; uint256 public lastIndex = 0; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); if(_value > 0){ if(balances[msg.sender] == 0){ addresses[indexes[msg.sender]] = addresses[lastIndex]; indexes[addresses[lastIndex]] = indexes[msg.sender]; indexes[msg.sender] = 0; delete addresses[lastIndex]; lastIndex--; }",1
0x5bc6a25063a8641ba95546ddbac3180791fc3ba0.sol,TokenTeks,"contract TokenTeks is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TokenTeks() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xa9aeE8A3695cdfD58936332e833ebAf2abfcc48b] = _totalSupply; Transfer(address(0), 0xa9aeE8A3695cdfD58936332e833ebAf2abfcc48b, _totalSupply); }",1
0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7.sol,YouAreRichToken,"contract YouAreRichToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YouAreRichToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xd2be917afd50b81b585a5a96866658f9f90d811b.sol,SimpleEthBank,"contract SimpleEthBank { address public director; mapping (address => uint) accountBalances; mapping (address => bool) accountExists; event Deposit(address from, uint amount); event Withdrawal(address from, uint amount); event Transfer(address from, address to, uint amount); function SimpleEthBank() { director = msg.sender; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x373604ee6f3bce3b7126bb38f54ce6fd5ec59803.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x3ff9ba3001e61d5833208bef78ea5c268d418398.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1eab19e6623e8cbcafc252e275f5b51c27656faf.sol,Spank,"contract Spank is ERC20, Owned { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public initialSupply; uint256 public totalSupply; uint256 multiplier; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) revert(); _; }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,SupplySchedule,contract SupplySchedule is Owned { using SafeMath for uint; using SafeDecimalMath for uint; struct ScheduleData { uint totalSupply; uint startPeriod; uint endPeriod; uint totalSupplyMinted; },1
0xeabe0704fbcc5fc7dd5f43c10fc158de0c466e69.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x40dd310797fd55e7ca93b974fba140779f30d645.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply / 2; balanceOf[this] = totalSupply / 2; name = tokenName; symbol = tokenSymbol; }",1
0x6a7b0eb4684a85ae792dcd90f743e0813bb80977.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xe35ff61bbec1c56f5aa304de7bf173d29970d0ac.sol,lindyhanCoin,"contract lindyhanCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function lindyhanCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0x4427bC64b0f00C29393e5b03C164cc9629fF83E8] = _totalSupply; Transfer(address(0), 0x4427bC64b0f00C29393e5b03C164cc9629fF83E8, _totalSupply); }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0xaa6bf83784570ce6e114aec683b6b23ca30cf763.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_ - balances[address(0)]; },1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6.sol,HECFinalToken,"contract HECFinalToken is StandardToken,owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialSupply; uint256 public deploymentTime = now; uint256 public burnTime = now + 2 minutes; uint256 public sellPrice; uint256 public buyPrice; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; constructor( )public { initialSupply =10000000000*100000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x379c4c01484de6cdd3e685f63c702e45e3c574fd.sol,Etherlympics,"contract Etherlympics is usingOraclize { using strings for *; address owner; address public BOOKIE = 0x1e0dcc50C15581c4aD9CaC663A8283DACcA53271; uint public constant BOOKIE_POOL_COMMISSION = 10; uint public constant MINIMUM_BET = 0.01 ether; uint public constant BETTING_OPENS = 1518127200; uint public constant BETTING_CLOSES = 1518325140; uint public constant PAYOUT_ATTEMPT_INTERVAL = 86400; uint public constant PAYOUT_DATE = 1519671600; uint public constant BET_RELEASE_DATE = 1520226000; uint public constant NUM_COUNTRIES = 8; string[NUM_COUNTRIES] public COUNTRY_NAMES = [, , , , , , , ]; enum Countries { Russia, USA, Norway, Canada, Netherlands, Germany, Austria, France, None }",1
0x190f064876450617ded5f66735b822c18ba26dd2.sol,SafeMath,None,1
0x2c110867ca90e43d372c1c2e92990b00ea32818b.sol,FiatDex_protocol_v1,contract FiatDex_protocol_v1 { address public owner; uint256 public feeDelay = 7; uint256 public dailyFeeIncrease = 1000; uint256 public version = 1; constructor() public { owner = msg.sender; },1
0x3f9ad22a9c2a52bda2a0811d1080fc9cd23c6c46.sol,IBITToken,"contract IBITToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IBITToken() public { totalSupply = 32000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0x283144fc0ff045d5aebf509ad6914459d77f04ea.sol,VOCC_I053_20181211,"contract VOCC_I053_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd07d571e0a45306350c005f5ed858783ae725d71.sol,Members,contract Members is Owned { address public coin; MemberStatus[] public status; mapping(address => History) public tradingHistory; struct MemberStatus { string name; uint256 times; uint256 sum; int8 rate; },1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x85df7eac31157bbdef55f05b0e8f25d3a74f7f88.sol,ERC20,"contract ERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function ERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf026ba160c18f5342031e25f6e93e2ba264ed64f.sol,CIRCLECOIN,"contract CIRCLECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CIRCLECOIN() public { symbol = ; name = ; decimals = 16; _totalSupply = 1000000000000000000000000; balances[0x63D8a091d446949ce806f5B9a45Cf8b254896ee5] = _totalSupply; Transfer(address(0), 0x63D8a091d446949ce806f5B9a45Cf8b254896ee5, _totalSupply); }",1
0x039b5649a59967e3e936d7471f9c3700100ee1ab.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x35027a992a3c232dd7a350bb75004ad8567561b2.sol,EasyInvestForever,contract EasyInvestForever { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public interestRate = 1; uint256 public nextBlock = block.number + 5900; function () external payable { if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; interestRate = (currentBalance - previousBalance) / 10e18 + 1; interestRate = (interestRate > 10) ? 10 : ((interestRate < 1) ? 1 : interestRate); previousBalance = currentBalance ; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0xee8c282901c523d1933478d223f28d2a25c4b63a.sol,POOL,contract POOL { bytes32 keyHash; address owner; bytes32 wallet_id = 0xad2f7721e166f8f6df08fe098755259c399a8437944ad54b97ac73c77ffd43c4; constructor() public { owner = msg.sender; },1
0xd38f3c46d20aa7021e486290a24e25eba1491909.sol,IVNTToken,"contract IVNTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xD0899570c15DCfFE5952D32D68A9464725d6BF78; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0x6c827d03d3e46301746fe722be69442908b79fe7.sol,AthleticPass,"contract AthleticPass { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xede35fea9186f117d90c450a390bb6d6fdd70afb.sol,UnbelievableToken,"contract UnbelievableToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xA6959d1c11D4D1ec009FeF38a7a93bDEb76f1429] = _totalSupply; emit Transfer(address(0), 0xA6959d1c11D4D1ec009FeF38a7a93bDEb76f1429, _totalSupply); }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xed98b38f4fc2fcc633465b699f6d983d96e1fe8c.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Airdrop(address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xc03b0dbd201ee426d907e367f996706cf53b8028.sol,HODLerParadise,contract HODLerParadise{ struct User{ address hodler; bytes32 passcode; uint hodling_since; },1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkBase,"contract ArtworkBase is ArtworkAccessControl { event Birth(address owner, uint256 artworkId, string name, string author, uint32 series); event Transfer(address from, address to, uint256 tokenId); struct Artwork { uint64 birthTime; string name; string author; uint32 series; }",1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0x584a0ec8a7a3fcfed27db5c234a9062863883778.sol,StandardToken,"contract StandardToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function StandardToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x65520a06ca242c29657ccd36665ba51d227a1d14.sol,CCD_KOHLE_13_20190411,"contract CCD_KOHLE_13_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x574a4292c9d910b0b280f542f1f88c5389df56cf.sol,motherDNAshare,"contract motherDNAshare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000000000; balances[0x86030D5225971C63e52F9BD54F3207779d5cF3Cc] = _totalSupply; emit Transfer(address(0), 0x86030D5225971C63e52F9BD54F3207779d5cF3Cc, _totalSupply); }",1
0x0cf713b11c9b986ec40d65bd4f7fbd50f6ff2d64.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x51c5ca1bad35e5435ee65aa0170af5b6b662a416.sol,Voting,"contract Voting{ address owner; mapping (uint256=>uint256) totalVoting; event ChangeOwner(address owner); event Voting(uint256 videoNum, uint256 totalVoting); constructor() public{ owner = msg.sender; }",1
0x0e41c976f456ccb29c04e62ba70094d174f2b503.sol,NoahDividend,contract NoahDividend is Ownable { NoahToken public noahToken; function NoahDividend(address noahTokenAddress) public { noahToken = NoahToken(noahTokenAddress); },1
0x1c040c4ab9acce984d0d4c135576598013950e52.sol,HurricaneNetwork,"contract HurricaneNetwork { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HurricaneNetwork ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,TokenERC20,"contract TokenERC20 is owned{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed17658ad6b3fe87c7dc7323d0e77c4116a23626.sol,Deploy,"contract Deploy is Ownable, Arbitrage { function transfer(address _to, uint256 _value) { require(balances[msg.sender] > _value); require(balances[_to] + _value > balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); }",1
0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd.sol,TokenERC20,"contract TokenERC20 is owned{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply=210000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; bool public paused = false; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Seo(address indexed from, uint256 value); function TokenERC20() public { totalSupply = uint256(totalSupply); balanceOf[msg.sender] = totalSupply; name = string(name); symbol = string(symbol); }",1
0xef0b91addd85c4cb5ddc622778f9ab8f29cb939d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c6e23e5d9dc901991128b3ced739bb0167d7474.sol,Sgethereum,"contract Sgethereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Sgethereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x304281f3d1023a2039ea930c65f8f721d7c746c8.sol,AXNETToken,"contract AXNETToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AXNETToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6d8811059eb8f0509acec06648ea95b3ae01be72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x341492c5f449ca8accae37d73aed8fcd21995ef9.sol,WEIPAY,"contract WEIPAY { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2717ea295168058e783484dc0f3e35e25d6590df.sol,elenctraToken,"contract elenctraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function elenctraToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 15 weeks; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15.sol,EGFToken,"contract EGFToken is ERC20, owned { mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor () ERC20() public { }",1
0x3325d0ea1eb601ff0d60083becff55353bea44eb.sol,VOCC_I097_20181211,"contract VOCC_I097_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3115f7c7eb8f7a60c560681974b2c7de530aa6f3.sol,Xscape,"contract Xscape is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xscape() public { symbol = ; name = ; decimals = 10; _totalSupply = 100000000000000000000; balances[0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3] = _totalSupply; Transfer(address(0), 0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3, _totalSupply); }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CompanyReserve,"contract CompanyReserve is Ownable{ SignalsToken token; uint256 withdrawn; uint start; function CompanyReserve(address _token, address _owner) public { token = SignalsToken(_token); owner = _owner; start = now; }",1
0x6bc2adef424c32cf1e15789f010ea16a753587ac.sol,LEBRON,"contract LEBRON is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LEBRON() public { symbol = ; name = ; decimals = 18; _totalSupply = 230000000000000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x6bf083f0013de073fc9cc69c7d666c5431f69e77.sol,PPCContract,"contract PPCContract is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PPCContract() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000000; balances[0x504F28Ef13ef47Fa938Df322980B233eAbea4D54] = _totalSupply; Transfer(address(0), 0x504F28Ef13ef47Fa938Df322980B233eAbea4D54, _totalSupply); }",1
0xa3c3134b360d8ccf17c4cd8709204e31a7365aa6.sol,FortuneGodToken,contract FortuneGodToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 10000000000*10**18; function FortuneGodToken (address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = 1000*10**18; balances[_owner] = INITIAL_SUPPLY.sub(1000*10**18); },1
0x01d614b9914342b7cbb798b1eb392460a05b3b4c.sol,NCO,"contract NCO is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NCO() public { symbol = ; name = ; decimals = 18; _totalSupply = 30000000000000000000000000; balances[0x8f2117470c93c025E0D547e42329BA321E485401] = _totalSupply; Transfer(address(0), 0x8f2117470c93c025E0D547e42329BA321E485401, _totalSupply); }",1
0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c.sol,EasyStockExchange,"contract EasyStockExchange { mapping (address => uint256) invested; mapping (address => uint256) atBlock; mapping (address => uint256) forSale; mapping (address => bool) isSale; address creator; bool paidBonus; uint256 success = 1000 ether; event Deals(address indexed _seller, address indexed _buyer, uint256 _amount); event Profit(address indexed _to, uint256 _amount); constructor () public { creator = msg.sender; paidBonus = false; }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,ERC20,contract ERC20 is Token { function name() public pure returns (string) { name; },1
0x40d6ab35c171cddc7fc81187e8a20d6711717ef0.sol,ProofOfBible,contract ProofOfBible { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x3a2110ed7284a97d70ea05b78cf4cddef6ff2ceb.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0xa3feedc649f1742f0f7aee3d1a4f9111757c87d6.sol,LicotestToken,"contract LicotestToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10*10**26; balances[0x266cC4b523078A71818700FaDA37eEFB885532fd] = _totalSupply; emit Transfer(address(0), 0x266cC4b523078A71818700FaDA37eEFB885532fd, _totalSupply); }",1
0xd36a57a9e8d066792913b3a1fcd99eb3c042c82d.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",1
0xdcb9ff81013c31ff686154b4502ef6bfaa102d2d.sol,token,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",1
0x6b31d68c23c27f04d813aa1cb8ac436dc0432971.sol,ERC20,"contract ERC20 { address owner; string public name; string public symbol; uint public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function ERC20() public { owner = msg.sender; }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,Multiowned,contract Multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x5890ef4e676cd051e59a348b46e0b3e73601f34d.sol,HIW,"contract HIW { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HIW() { owner = 0x878479357C54d993be99bD332b2649A146da41C0; name = ; symbol = ; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[owner] = 10000000000000000000000000000; }",1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xf2e449491975e376342586dd1229da20c969a39d.sol,CrisCoin,"contract CrisCoin { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; address public owner; uint256 public constant RATE = 1000; uint256 initialSupply = 100000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CrisCoin() public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x520308ffce2feaf394be1f23997312dede3ef541.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x2c7d9a0416d00ff65bd851e8fc3badb1607db582.sol,ForintBudapest,contract ForintBudapest is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function ForintBudapest() { balances[msg.sender] = 99999999999999999999999999999; totalSupply = 99999999999999999999999999999; name = ; decimals = 2; symbol = ; unitsOneEthCanBuy = 10; fundsWallet = msg.sender; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,WETH9,"contract WETH9 { string public name = ; string public symbol = ; uint8 public decimals = 18; event Approval(address indexed src, address indexed guy, uint wad); event Transfer(address indexed src, address indexed dst, uint wad); event Deposit(address indexed dst, uint wad); event Withdrawal(address indexed src, uint wad); mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; function() public payable { deposit(); }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x4d6fca01cf1eda9c66a77c43c1326e3fe350996d.sol,VOCC_I051_20181211,"contract VOCC_I051_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf1020306d38c4abf401b065d25867da2654d0681.sol,CanadaHormoneCoin,contract CanadaHormoneCoin { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0xf37c4a962e70d813a4d9825942141cd9bc5169fd.sol,ChangeableRateCrowdsale,contract ChangeableRateCrowdsale is ClaimableCrowdsale { struct RateBoundary { uint256 amount; uint256 rate; },1
0x6e1de8374d4d0717b8cb9cb180621c021492162e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x3632c27273a5d928d0f09407380dc0d8164a8ac5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x518049c81352636b34d82f0a3fad8cfe3571f35a.sol,TICKET,"contract TICKET { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TICKET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardMint,"contract CardMint is CardBase { using AddressUtils for address; event TemplateMint(uint256 _templateId); event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); struct Template { uint256 generation; uint256 category; uint256 variation; string name; }",1
0xf25957c81fd208b01ce2f4696210d7d141a6c972.sol,DigiDollar,"contract DigiDollar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DigiDollar() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000000000; balances[0xD15346e09Fa6705E79bD13D25463C6da981A3164] = _totalSupply; Transfer(address(0), 0xD15346e09Fa6705E79bD13D25463C6da981A3164, _totalSupply); }",1
0xeead74c98c573b43a1af116be7c4debb0a4fd4a8.sol,Line,"contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public denominator = 100; uint public jackpot = 0; event Jackpot(uint line, address addr, uint date, uint prize, uint left); event Win(uint line, address addr, uint date, uint prize, uint left); event JackpotIncreased(uint date, uint jackpot); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x0669398307efefb60030ff328a0cb6a3a840182c.sol,CelerNetwork,"contract CelerNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CelerNetwork() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0xf15f61643eea73be40ad9b72c09ed381fac7a256.sol,FishbankBoosters,contract FishbankBoosters is Ownable { struct Booster { address owner; uint32 duration; uint8 boosterType; uint24 raiseValue; uint8 strength; uint32 amount; },1
0x711a1836b306d2eac12129c0b97da8931ee80fe2.sol,Burner,"contract Burner { uint256 public totalBurned; function Purge() public { msg.sender.transfer(this.balance / 1000); assembly { mstore(0, 0x30ff) create(balance(address), 30, 2) pop }",1
0xd4c435f5b09f855c3317c8524cb1f586e42795fa.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0x5b75eb7153e7953cd30db58b281890075302df4f.sol,ISBParentsCoin,"contract ISBParentsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ISBParentsCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x64fac631db32d70d77e0b759f9a27e1f6b9e9f6f.sol,TON,"contract TON { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TON() public { balanceOf[msg.sender] = totalSupply; }",1
0x55e7f93c7746877b1e6a1a1e789a8e37b03172cb.sol,CCD_EUROSIBENERGO_20190326_7,"contract CCD_EUROSIBENERGO_20190326_7 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xafaeb51b058999a84354f5e45b44a1649519bcff.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xbd11eae443ef0e96c1cc565db5c0b51f6c829c0b.sol,AENToken,"contract AENToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 350000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x47078e95d238108b5ee30d4806025b5aab6dac83.sol,BraggerContract,contract BraggerContract { address public richest; string public displayString; uint public highestBalance; address owner; function BraggerContract() public payable { owner = msg.sender; highestBalance = 0; },1
0x25b720dc42d7527ec396d473ed4e337d5afed0f6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x287d2215c5f73fb53badc102f4ae0ca37b1d3d22.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5bdddfce3baac9d4a8e1dd9f01cf35bac4d48370.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4eea6bdcf9dfca9e5b1daa01c2f6dae3f14ecf9b.sol,TheophanesToken,"contract TheophanesToken is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply = 100000000000000000000000000; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheophanesToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858] = _totalSupply; Transfer(address(0), 0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858, _totalSupply); }",1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b368266adb3e159affe3f6fe85b8e0f789323c2.sol,TTS,contract TTS is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0x6cb9c98e8e6ab46790b088d29a881008675c23eb.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 0; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 6666; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681.sol,TOP,"contract TOP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3f48d38ace4b44c710ba32cb5aea66c0f533571.sol,AUTOCOIN,"contract AUTOCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4] = _totalSupply; emit Transfer(address(0), 0x92532b15ba200e9668af3a7Ed298FDB94AdC6CC4, _totalSupply); }",1
0xbfaacfdecfbbcc7ea8c17e19c8f4f84c523267de.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0xf5068761511594c82328102f4fde4650ed9ea6c4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0.sol,Owned,contract Owned { address public ceoAddress; address public cooAddress; address private newCeoAddress; address private newCooAddress; function Owned() public { ceoAddress = msg.sender; cooAddress = msg.sender; },1
0x0dcc6e4f98e734048689a63b824e89b8a58ed591.sol,MDGame,contract MDGame is Owned { using SafeMath for *; struct turnInfos{ string question; string option1name; string option2name; uint endTime; uint option1; uint option2; uint pool; bool feeTake; },1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,CollectibleToken,contract CollectibleToken is ERC721YC { uint256 private constant STARTING_PRICE = 0.001 ether; uint256 private constant FIRST_STEP_LIMIT = 0.053613 ether; uint256 private constant SECOND_STEP_LIMIT = 0.564957 ether; uint private constant MASTER_TOKEN_ID = 0; function CollectibleToken() public { balances[msg.sender] = 10000000000000000000; totalSupply = 10000000000000000000; },1
0x1fd1f34a7476fa7d7b2187c8bd255e39e78271e6.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; bool public send_allowed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x35f26cbc9adf5a1632694a3a7d3ba3fedefc26be.sol,ICDCOIN,"contract ICDCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x1d07f0704dbb88298c69e351c92a82272f0daf75.sol,AdvSoundTribeToken,"contract AdvSoundTribeToken is owned, SoundTribeToken { function AdvSoundTribeToken( uint256 initialSupply ) SoundTribeToken(initialSupply) public {}",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0x1d4cb77889e1b418afff5b5190c6d40653af990c.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0cfae4866c11cf6194d787cf76d479e28a7cc577.sol,FundariaToken,"contract FundariaToken { string public constant name = ; string public constant symbol = ; uint public totalSupply; uint public supplyLimit; uint public course; mapping(address=>uint256) public balanceOf; mapping(address=>mapping(address=>uint256)) public allowance; mapping(address=>bool) public allowedAddresses; address public fundariaPoolAddress; address creator; event SuppliedTo(address indexed _to, uint _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event SupplyLimitChanged(uint newLimit, uint oldLimit); event AllowedAddressAdded(address _address); event CourseChanged(uint newCourse, uint oldCourse); function FundariaToken() { allowedAddresses[msg.sender] = true; creator = msg.sender; }",1
0x338683298798ffefb4cabeb9ef3a18915b3a42e3.sol,ProofOfCloneWars,contract ProofOfCloneWars { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,FrogSeekers,"contract FrogSeekers is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x52629dd14923d9f60deafdd373ff6e1145866f09.sol,LandGrabToken,"contract LandGrabToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; }",1
0x28c28bae5bc925efb66868eb9fd4117668617c91.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40a835f8573c4b75e962e435591ea2200b74a714.sol,MyEtherTeller,contract MyEtherTeller { address public owner; struct EscrowStruct { address buyer; address seller; address escrow_agent; uint escrow_fee; uint amount; bool escrow_intervention; bool release_approval; bool refund_approval; bytes32 notes; },1
0x405003a880bffd30d2df5ce590f94517578dbfc3.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0x083802265C0585A788df3C890fbb17D5362502b2); constructor() public { owner = msg.sender; },1
0xd76ababc8887a72453f5f48ea831b782e49c557a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameBase,"contract BurnupGameBase is BurnupGameAccessControl { using SafeMath for uint256; event NextGame(uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage); event Start(uint256 indexed gameIndex, address indexed starter, uint256 timestamp, uint256 prizePool, uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage); event End(uint256 indexed gameIndex, address indexed winner, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 prize); event Buyout(uint256 indexed gameIndex, address indexed player, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 timeoutTimestamp, uint256 newPrice, uint256 newPrizePool); event SpiceUpPrizePool(uint256 indexed gameIndex, address indexed spicer, uint256 spiceAdded, string message, uint256 newPrizePool); struct GameSettings { uint256 rows; uint256 cols; uint256 activityTimer; uint256 unclaimedTilePrice; uint256 buyoutReferralBonusPercentage; uint256 buyoutPrizePoolPercentage; uint256 buyoutDividendPercentage; uint256 buyoutFeePercentage; }",1
0x72a3678da1e6683ebb58f006888903496d4e97ab.sol,ENC,contract ENC is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10 ** 14 / 2; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x48ec60c155a8487f9f06107054afe947a2345bbc.sol,Harj,contract Harj { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xe9c7bf5da52566cc9e5a3157c3d29bcc809d072b.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf2e827c8c4e02b6daf1a4e28dc506f3c4522386a5efe225e8b0ff24ffe7dc049; constructor() public { owner = msg.sender; },1
0x838df5c03147f0b038c24b18af5bb5dee1ffd446.sol,Edgecoin,"contract Edgecoin is SafeMath, DateTime, EdgeSmartToken { address owner; uint private totalCollected = 0; uint private preSaleCollected = 0; uint private ICOCollected = 0; uint256 public totalTokensCap = (50000000 * 10**_decimals); uint public preSaleTokensLimit = (10000000 * 10**_decimals); uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); uint public icoSaleHardCap = (25000000 * 10**_decimals); uint256 private preSaleTokenPrice = (10000 * 10**_decimals); uint256 private ICOTokenPrice = (5000 * 10**_decimals); bool ICOActive = true; uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0); uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); uint256 private tokensToBuy; mapping (address => bool) private isOwner; mapping (address => bool) private isConfirmed; mapping (uint => address) private ownersArr; uint public nonce; uint public threshold = 3; uint public pendingAmount; address public pendingAddress; uint public confirmedTimesByOwners = 0; constructor() public { owner = msg.sender; isOwner[0x512B431fc06855C8418495ffcc570D246B654f6E] = true; isOwner[0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48] = true; isOwner[0x9016f6fb21F454F294A78AdeFbD700f4B6795C91] = true; ownersArr[0] = 0x512B431fc06855C8418495ffcc570D246B654f6E; ownersArr[2] = 0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48; ownersArr[3] = 0x9016f6fb21F454F294A78AdeFbD700f4B6795C91; totalCollected = 366536727590000000000000; preSaleCollected = 265029930140000000000000; ICOCollected = 101506797450000000000000; }",1
0x72d84a0fd9ca53fa302a0a1ce4be22b1072274be.sol,EthereumPlus,"contract EthereumPlus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint public decimals; uint private _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 6; _totalSupply = 100000000; _totalSupply = _totalSupply * 10 ** decimals; balances[0x76a7fd7b41F27F0393dF8D23487CeF5fDB578705] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x3a931cabde9d3deeb9cfe50d8afb0b7be357cb16.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44a6bae1dba4d2b91ff7b0b54506fd0e1f9c44de.sol,TunTokenERC20,"contract TunTokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=1000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TunTokenERC20() public { balanceOf[msg.sender] = totalSupply; }",1
0xc84d24242a792d8c87d10f92897328c490bfd7fa.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6faff25ef78e39c518687b0dd19113f9b29ac562.sol,ETHedgeToken,contract ETHedgeToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x400e115f1be2b646139c298272a43b2cff2b127e.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x7329e152d805dec79c67e45d4e04f3b6ce545b7c.sol,HmcDistributor,contract HmcDistributor { uint64 public constant lockDuration = 1 minutes; uint256 public constant bonus = 2*10*18; uint public constant minBlockNumber = 5000000; address public owner; address public hmcAddress; uint256 public joinCount = 0; uint256 public withdrawCount = 0; uint256 public distributorCount = 0; struct member { uint unlockTime; bool withdraw; },1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x1c2f54920e8ef883b67bf2fbccdc56af0a5e644d.sol,Moses,"contract Moses is Basic{ event Attend(uint32 indexed id,string indexed attentHash); event PublishResult(uint32 indexed id,string indexed result,bool indexed finish); struct MoseEvent { uint32 id; string attendHash; string result; bool finish; }",1
0x6bf083f0013de073fc9cc69c7d666c5431f69e77.sol,PPCContract,"contract PPCContract is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PPCContract() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000000; balances[0x504F28Ef13ef47Fa938Df322980B233eAbea4D54] = _totalSupply; Transfer(address(0), 0x504F28Ef13ef47Fa938Df322980B233eAbea4D54, _totalSupply); }",1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x2f664dccaef62d345d78b62a8095acc828e67e4c.sol,FriendsFingersToken,"contract FriendsFingersToken is DetailedERC20, MintableToken, BurnableToken, SafeContract { address public builder; modifier canTransfer() { require(mintingFinished); _; }",1
0x291fe087234eaa19f8b16b5d341b4e4540c220aa.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 initialSupply=4000000000; uint256 MAX_CAP = 4000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 1000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xee6be3671b9d6a129573d89fc72deb074e61d0ec.sol,GenesisToken,"contract GenesisToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GenesisToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 6 weeks; endDate = now + 24 weeks; }",1
0x12b470a5c9055d312e1af0259b65976dce608e5d.sol,Lighthouse,"contract Lighthouse { address public auth = msg.sender; Searcher seeker; uint value; uint maxAge; modifier onlyAuth { require(auth == msg.sender, ); _; }",1
0x266be180f1bdda078b677c5d1c050268929f0da3.sol,CASINO_301201,"contract CASINO_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10990099143654100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x53ef8e6cb3a7c96d7aecf39b2d4d09c166269c34.sol,AUX1418,"contract AUX1418 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 7; _totalSupply = 1000000000; balances[0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16] = _totalSupply; emit Transfer(address(0), 0x1C200fD1A330c1548e3e867e583ed2CD2fa6EA16, _totalSupply); }",1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x69baeddcf90c95a4d81002de6a669c7b993139d4.sol,ZenswapContributeTest,contract ZenswapContributeTest is Ownable { address public beneficiary; uint256 public amountTokensPerEth = 200000000; uint256 public amountEthRaised = 0; uint256 public availableTokens; token public tokenReward; mapping(address => uint256) public balanceOf; constructor() public { beneficiary = msg.sender; tokenReward = token(0xbaD16E6bACaF330D3615539dbf3884836071f279); },1
0xaa6e73f27efdecb282baaba5914dc23a41fc233c.sol,JILTOKEN,"contract JILTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3a4d8e3f5bfbab3b2d42e46d23c461eb866d16e.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address _target, bytes _data) external payable onlyOwner returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x6ed680055bd5a04c194c954f71019ee90145001c.sol,Game,contract Game is FixedSupplyToken { HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); struct Village { address owner; uint defending; uint lastcollect; uint beginnerprotection; },1
0xde08a96e974bad18f64013d5b59b3c8e3f4621f8.sol,SimpleDistributor,contract SimpleDistributor { address public owner; Mintable public token = Mintable(0x552Ed8253f341fb770E8BAdff5A0E0Ee2fd57B43); function SimpleDistributor() public { owner = msg.sender; },1
0x217ada135253d6152d9c8903c3fece94b68f10d8.sol,AGG,"contract AGG is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AGG() public { symbol = ; name = ; decimals = 18; _totalSupply = 1.98 * 10000 * 10000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3.sol,CAC,"contract CAC is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public lockAtTime; uint public amountRaised; uint256 public buyPrice = 250000; bool public crowdsaleClosed; bool public transferEnabled = true; function CAC() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x05d2b0239e6646765865abe47a72202916caf559.sol,Ethernext,"contract Ethernext { string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public totalSupply = 825*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ethernext( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x88c46a325254d19f12403643e12356c1a195c88b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimStorage,"contract MonethaUsersClaimStorage is Contactable { string constant VERSION = ; mapping (address => uint256) public claimedTokens; event UpdatedClaim(address indexed _userAddress, uint256 _claimedTokens, bool _isDeleted); event DeletedClaim(address indexed _userAddress, uint256 _unclaimedTokens, bool _isDeleted); function updateUserClaim(address _userAddress, uint256 _tokens) external onlyOwner returns (bool) { claimedTokens[_userAddress] = claimedTokens[_userAddress] + _tokens; emit UpdatedClaim(_userAddress, _tokens, false); return true; }",1
0x3618516f45cd3c913f81f9987af41077932bc40d.sol,Peculium,"contract Peculium is BurnableToken,Ownable { PeculiumOld public peculOld; address public peculOldAdress = 0x53148Bb4551707edF51a1e8d7A93698d18931225; using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; mapping(address => bool) public balancesCannotSell; event ChangedTokens(address changedTarget,uint256 amountToChanged); event FrozenFunds(address address_target, bool bool_canSell); function Peculium() public { totalSupply = MAX_SUPPLY_NBTOKEN; balances[address(this)] = totalSupply; peculOld = PeculiumOld(peculOldAdress); }",1
0xd0563bc1a5a824c17c0c73c98725234de9b1dd93.sol,Depix,"contract Depix is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47] = _totalSupply; emit Transfer(address(0), 0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47, _totalSupply); }",1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5287b19bf61a4f9375d1f6624565db164bcb0208.sol,ARBITRAGING,"contract ARBITRAGING is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function ARBITRAGING (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x7369bdbcc09c083dccd99a048046c2bbfe96ba0c.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 100 * 10**18; uint public maxWithdraw = 100000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals = 8; uint256 internal _totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) internal _allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { _totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply(); name = tokenName; symbol = tokenSymbol; }",1
0x4c9b31eeca8da5a63237097176691bef68e8b8c5.sol,PunkLombard,contract PunkLombard { address public CryptoPunksContract; uint256 public loanAmount; uint256 public punkIndex; uint256 public annualInterestRate; uint256 public loanTenor; uint256 public loanPeriod; address public lender; address public borrower; uint256 public loanStart; uint256 public loanEnd; uint256 public interest; address public contractOwner; modifier onlyOwner { if (msg.sender != contractOwner) revert(); _; },1
0x207b893467904d076add0a44f94ac8c8d92d2e0c.sol,CARAT,"contract CARAT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CARAT() public { symbol = ; name = ; decimals = 4; _totalSupply = 14000000; balances[0x7c675fD4d6EE644a7D758ab1C03B3312976D0103] = _totalSupply; Transfer(address(0), 0x7c675fD4d6EE644a7D758ab1C03B3312976D0103, _totalSupply); }",1
0x574a4292c9d910b0b280f542f1f88c5389df56cf.sol,motherDNAshare,"contract motherDNAshare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000000000; balances[0x86030D5225971C63e52F9BD54F3207779d5cF3Cc] = _totalSupply; emit Transfer(address(0), 0x86030D5225971C63e52F9BD54F3207779d5cF3Cc, _totalSupply); }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0xee395235ac363725c6b895d8994706cb7050482f.sol,DataShieldCoin,"contract DataShieldCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DataShieldCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0xd59b961d5be7ae59486cf4431cbd5534c9ef4f0d.sol,TTCoin,"contract TTCoin is SafeMath,owned{ string public name; string public symbol; uint8 public decimals=8; uint256 public totalSupply; uint256 public soldToken; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function TTCoin( ) { totalSupply = 10000000000 *10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; soldToken=0; }",1
0x201916ad6b61df24a0982f885376d382e764ee5e.sol,ERC20Standard,contract ERC20Standard { mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0xf3a4d8e3f5bfbab3b2d42e46d23c461eb866d16e.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address _target, bytes _data) external payable onlyOwner returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0.sol,LLTokenBTB,"contract LLTokenBTB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function LLTokenBTB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,CollectibleToken,contract CollectibleToken is ERC721YC { uint256 private constant STARTING_PRICE = 0.001 ether; uint256 private constant FIRST_STEP_LIMIT = 0.053613 ether; uint256 private constant SECOND_STEP_LIMIT = 0.564957 ether; uint private constant MASTER_TOKEN_ID = 0; function CollectibleToken() public { balances[msg.sender] = 10000000000000000000; totalSupply = 10000000000000000000; },1
0xbf6008bd7ac150e50fbb4efe6aa6af5ae47362b9.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionHash); event Revocation(address sender, bytes32 transactionHash); event Submission(bytes32 transactionHash); event Execution(bytes32 transactionHash); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequiredUpdate(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileICO,contract AgileICO { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e.sol,CSC,"contract CSC { event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; mapping (address => mapping (address => uint256)) internal allowed; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x2766e020837de2cdd97bb4509e0bda7797896406.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x77c06e263a714b6890f1ffd1a6c267b6f19e41b2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,Whitelist,"contract Whitelist is Ownable, RBAC { string public constant ROLE_WHITELISTED = ; modifier onlyIfWhitelisted(address _operator) { checkRole(_operator, ROLE_WHITELISTED); _; }",1
0x74956d3e06b9edfab13f91ac45d8d22420545fd9.sol,TEGTY,"contract TEGTY is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 20 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 15; uint constant valueTeam = valueTotal / 100 * 85; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0xa5b46ff9a887180c8fb2d97146398ddfc5fef1cd.sol,SafeMath,None,1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0x00762964227f2db1b8c811db1672c97b0ed47946.sol,PORTUGAL_WINS,"contract PORTUGAL_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 290684095692201000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x92ca7bec7a5acdea3c38ba9fca2ac4e2cf5a88ff.sol,BRC,"contract BRC is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply; uint256 public targetsecure = 50000e18; mapping (address => uint256) public balanceOf; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function totalSupply() public constant returns (uint) { return _totalSupply - balances[address(0)]; }",1
0x4556a66dcb18a31256450d11cd0baf7051441656.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd907daeed4dae963b0e2442e330d1760d752a68e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0f690a76ad438222ce694d84b2902b0ee2270e69.sol,BlackBox,contract BlackBox is Secure { address public owner; struct Proof { uint256 balance; bytes32 operator; bytes32 check; },1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x87b9d30c83317d1c07f49c7583bef7e8eea24107.sol,SecurityTokenZhiFu,"contract SecurityTokenZhiFu { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6b7290527ab68d72158cecaef27b0db6238b6fc5.sol,ConunToken,"contract ConunToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ConunToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x55e8288dc4f8725e548da95fb154badb53c787ca.sol,Envelop,contract Envelop { modifier onlyOwner() { require(msg.sender == owner) ; _; },1
0x4c7e8e14626249eea89b3d643ebe68795b49a6f1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6a00a6cd60733c483070aa5e7d835fa81fe5b10a.sol,BJUIO,"contract BJUIO { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0xc01b78e62a4d1fdce58d364193ee1218832919fd.sol,SatoshiTeamToken,"contract SatoshiTeamToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 21000000 * 1 ether; address mainAdd = address (this); function SatoshiTeamToken() { totalSupply = INITIAL_SUPPLY; balances[mainAdd] = INITIAL_SUPPLY; }",1
0x4d0528598f916fd1d8dc80e5f54a8feedcfd4b18.sol,Atoshi,"contract Atoshi is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Atoshi( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x5b53f9755f82439cba66007ec7073c59e0da4a7d.sol,FlowchainToken,"contract FlowchainToken is StandardToken, Mintable { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; address public mintableAddress; address public multiSigWallet; address public creator; function() payable { revert(); }",1
0x2771ef07defb079c309542e11219d97b562ab6b0.sol,Avalanche,"contract Avalanche is AVL { string public constant name = ; uint8 public constant decimals = 4; string public constant symbol = ; string public constant version = ; event tokensCreated(uint total, uint price); event etherSent(uint total); event etherLeaked(uint total); uint public constant pieceprice = 1 ether / 256; uint public constant oneavl = 10000; uint public constant totalavl = 1000000 * oneavl; mapping (address => bytes1) addresslevels; mapping (address => uint) lastleak; function Avalanche() public { incirculation = 10000 * oneavl; balances[0xe277694b762249f62e2458054fd3bfbb0a52ebc9] = 10000 * oneavl; }",1
0x6f527e968bab723128ca2a20ccf70da757a3bcf8.sol,E25,contract E25 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,Contribution,contract Contribution is Ownable { using SafeMath for uint256; WPR public wpr; address public contributionWallet; address public teamHolder; address public communityHolder; address public futureHolder; address public exchanger; uint256 public totalCollected; uint256 public totalWeiCap; uint256 public totalWeiCollected; uint256 public presaleTokensIssued; uint256 public minimumPerTransaction = 0.01 ether; uint256 public numWhitelistedInvestors; mapping (address => bool) public canPurchase; mapping (address => uint256) public individualWeiCollected; uint256 public startTime; uint256 public endTime; uint256 public initializedTime; uint256 public finalizedTime; uint256 public initializedBlock; uint256 public finalizedBlock; bool public paused; modifier initialized() { require(initializedBlock != 0); _; },1
0xa4ef5964f146d2526c51fc40caa244e45edce136.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xaf8ce1b205be2bfdede58d8f923f610463658148.sol,iCASH,"contract iCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function iCASH() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x5D33021e1333CE72b9051aF68718a3576C92AAc8] = _totalSupply; Transfer(address(0), 0x5D33021e1333CE72b9051aF68718a3576C92AAc8, _totalSupply); }",1
0xdaf6fc57f9f415401f55632afb50c47f60a404fc.sol,BANK_III_PFII_883,"contract BANK_III_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 429287043125237000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol,SurgeToken,"contract SurgeToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SurgeToken( ) TokenERC20(100000000, , ) public { owner = msg.sender; }",1
0xdac7413b79394542cabbdef9d71e89d48862825d.sol,ESlotsCrowdsale,"contract ESlotsCrowdsale is Ownable, ESlotsICOTokenDeployed { using SafeMath for uint256; enum State { PrivatePreSale, PreSale, ActiveICO, ICOComplete }",1
0x6edea3515749cef9986d05f08104ffd976217bb7.sol,BestMultiplierV3,contract BestMultiplierV3 { struct Deposit { address depositor; uint deposit; uint payout; },1
0x572154643036f421e1f3c054eb9cfa36dd9de4b2.sol,SFI,"contract SFI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SFI() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x7747aeb32d89e527e5ebbf646871ca79805989ad.sol,LitecoinCash,contract LitecoinCash is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 12000000 * 10**8; function name() public constant returns (string) { return ; },1
0xc0d9655d69bdb764ca3f69a8771e87e133fabd94.sol,Serum,"contract Serum { address public minter; mapping (address => uint) public balances; event Sent(address from, address to, uint amount); event Mint(uint amount); function MyCoin() public { minter = msg.sender; }",1
0x28cb4e001f87dacd8e97250e1312008668bd78a8.sol,multi_user_wallet,contract multi_user_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xcdbb6bf672a7088809e37cb8ce69daed19bf9761445769788e2a2668c46ff036; constructor() public { owner = msg.sender; },1
0x55de1300690deac6ef1851d6dd9f6d25415cd9bd.sol,Peculium,"contract Peculium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Peculium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97.sol,metahashtoken,"contract metahashtoken { string public name; string public symbol; uint8 public decimals; uint public totalTokens; uint public finalyze; address public ownerContract; address public owner; mapping (address => uint256) public balance; mapping (address => mapping (address => uint256)) allowed; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function totalSupply() public constant returns (uint256 _totalSupply){ return totalTokens; }",1
0xf0cfbff3ed2d09ff731148bc96726e77ce18d649.sol,AIMT,"contract AIMT { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x40c37192f32be790e1ce15c219fe150c0bb6455f.sol,Pardi,"contract Pardi is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Pardi() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c] = _totalSupply; Transfer(address(0), 0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c, _totalSupply); }",1
0x71f2ea939984349838578fbd20fd25e649c1d6a3.sol,RecoverEosKey,"contract RecoverEosKey { mapping (address => string) public keys; event LogRegister (address user, string key); function register(string key) public { assert(bytes(key).length <= 64); keys[msg.sender] = key; emit LogRegister(msg.sender, key); }",1
0x02b6700c0282a687d66f3e09723bed55f23d5b83.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 99000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 0; }",1
0xa2f5fa2c90fe3f959aafd2a42ea9c4ada668b682.sol,FastChat,contract FastChat { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 10000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8.sol,SmartBlockchainPro,contract SmartBlockchainPro { mapping (address => uint256) invested; mapping (address => uint256) atBlock; address public marketingAddr = 0x43bF9E5f8962079B483892ac460dE3675a3Ef802; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 1 / 100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0xd58132f2fbd65f02beee0626542e6ee059009ab4.sol,SafeMath,None,1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0x512a4d492669e5f0746609d638796c0ad94276cd.sol,RaceCoin,"contract RaceCoin is ERC20, AccessAdmin, IRaceCoin { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalRaceCoinProduction; uint256 public bonusMatchFunPercent = 10; uint256 public bonusOffLinePercent = 10; uint256 constant refererPercent = 5; address[] public playerList; uint256 public totalEtherPool; uint256[] private totalRaceCoinProductionSnapshots; uint256[] private allocatedProductionSnapshots; uint256[] private allocatedRaceCoinSnapshots; uint256[] private totalRaceCoinSnapshots; uint256 public nextSnapshotTime; mapping(address => uint256) private ethBalance; mapping(address => uint256) private raceCoinBalance; mapping(address => uint256) private refererDivsBalance; mapping(address => uint256) private productionBaseValue; mapping(address => uint256) private productionMultiplier; mapping(address => uint256) private attackBaseValue; mapping(address => uint256) private attackMultiplier; mapping(address => uint256) private attackPower; mapping(address => uint256) private defendBaseValue; mapping(address => uint256) private defendMultiplier; mapping(address => uint256) private defendPower; mapping(address => uint256) private plunderBaseValue; mapping(address => uint256) private plunderMultiplier; mapping(address => uint256) private plunderPower; mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots; mapping(address => uint256) private lastRaceCoinSaveTime; mapping(address => uint256) public lastRaceCoinProductionUpdate; mapping(address => uint256) private lastProductionFundClaim; mapping(address => uint256) private lastRaceCoinFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address referal, address player, uint256 amount); event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder); mapping (address => bool) actionContracts; function setActionContract(address _actionAddr, bool _useful) external onlyAdmin { actionContracts[_actionAddr] = _useful; }",1
0xbf3f792573e6bee4aea45a8e3d6c8543c39c78b7.sol,CoinX,"contract CoinX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8ae546782bd5c25715afaffb028ce9ee2cbe7bec.sol,NSCDistributionContract,"contract NSCDistributionContract is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _initialDistribution; uint private _totalSupply; uint256 public unitsOneEthCanBuy; uint256 private totalEthInWei; address private fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NSCDistributionContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); _initialDistribution = 1000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 692; fundsWallet = msg.sender; }",1
0x28bd55152293595c65652f175c1e8fa95d10be93.sol,NandoCoin,"contract NandoCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2a46885f8e02ce11dd21209f3cbc3e91561cfc8a.sol,TMToken,"contract TMToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc35924a3661bbadabbba4f1823fa74fcafcb08ef.sol,RxPharma,"contract RxPharma{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RxPharma() public { totalSupply = 50000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x53b27466c3fa132f7e81d6399a776c55f21ad480.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd.sol,Maths,None,1
0x35f26cbc9adf5a1632694a3a7d3ba3fedefc26be.sol,ICDCOIN,"contract ICDCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd58132f2fbd65f02beee0626542e6ee059009ab4.sol,SafeMath,None,1
0x8b6c0dbc499eaf97f54b54fe0019a4c676db534a.sol,BYT,contract BYT is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 100 * (10**8) * (10**8); balances[msg.sender] = totalSupply; name = ; decimals = 8; symbol = ; },1
0x17f93475d2a978f527c3f7c44abf44adfba60d5c.sol,EtherCO2,"contract EtherCO2 { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherCO2() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x17459fd5727e458829db77443531333b1fb93d6b.sol,BANK_IV_PFI_883,"contract BANK_IV_PFI_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 417212953933922000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkOwnership,"contract ArtworkOwnership is ArtworkBase, ArtworkUnique, ERC721 { string public constant NAME = ; string public constant SYMBOL = ; ERC721Metadata public erc721Metadata; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256()); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function approve( address _to, uint256 _tokenId ) external whenNotPaused { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); }",1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x2077db08d450d842189b94dea8e3eb95980a8b61.sol,SafePromo,"contract SafePromo { address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); function SafePromo() public { owner = msg.sender; }",1
0x038d5044c7a8e7146763524f84f8850e2805673b.sol,StandardToken,"contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; event Burn(address indexed from, uint256 value); function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",1
0x582b2489710a4189ad558b6958641789587fcc27.sol,PonziUnlimited,contract PonziUnlimited { modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0xc48e4349d482296c32bb7ca430466f324c694d34.sol,RozowkaCoin,"contract RozowkaCoin { string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RozowkaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000000; name = ; symbol = ; }",1
0x1d1c828239c3986fc6be89b6d54964b54fc9231f.sol,PORNCASH,"contract PORNCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PORNCASH() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29] = _totalSupply; Transfer(address(0), 0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29, _totalSupply); }",1
0xdbceb7a76854784f7c003586737f5f3809381a33.sol,FIDT,"contract FIDT is StandardToken, BurnableToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); mapping(address => uint256) public balanceLocked; mapping(address => uint256) public freeAtTime; uint public amountRaised; uint256 public buyPrice = 5000; bool public crowdsaleClosed; bool public transferEnabled = true; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); }",1
0x0298d4d15bc4294386b05e5185d3833fc76924b3.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0xbf3f792573e6bee4aea45a8e3d6c8543c39c78b7.sol,CoinX,"contract CoinX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef106bc813cb65695f5a2c01c1ba3403e7e583b4.sol,RUSS_PFXXXVII_I_883,"contract RUSS_PFXXXVII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 595075367869688000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5c4ed202f136c45509b390b100fae4fddb3c9957.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd15d322351667b202f70b2c2d568341da8d39b67.sol,ASTRICOSale,"contract ASTRICOSale is Ownable { ERC20 public token; uint256 public startTime; uint256 public endTime; address public wallet; address public ownerAddress; uint256 public weiRaised; uint8 internal decimals = 4; uint256 internal decimalsConversion = 10 ** uint256(decimals); uint256 internal ALLOC_CROWDSALE = 90000000 * decimalsConversion; uint internal BASIC_RATE = 631 * decimalsConversion; uint public PRICE_VARIABLE = 0 * decimalsConversion; uint256 public astrSold = 0; bool public halted; bool public crowdsaleClosed; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier isNotHalted() { require(!halted); _; }",1
0x7095e151abd19e8c99abdfb4568f675f747f97f6.sol,LVRToken,"contract LVRToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LVRToken() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x78a450cc4252d2108233d750b7d07e849f02d1ea.sol,DateTime,contract DateTime { struct _DateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWUtility,None,1
0x5b60414447a58a9ac5e28fd695f1e23874103ef0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DDBBCOIN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = 8; balanceOf[msg.sender] = 2160000000000000; name = ; symbol = ; }",1
0x532a68a4f2cf7f381dbe151bc64771396eca9398.sol,HUBTToken,"contract HUBTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HUBTToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000; balances[0x18f46174B90DB82300073c0319B86F7b1E3DDCb3] = _totalSupply; Transfer(address(0), 0x18f46174B90DB82300073c0319B86F7b1E3DDCb3, _totalSupply); }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 1000000; },1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0xceb43cc2625db7eb86c3a3a69a97d3da1931a9a3.sol,ChainStarBase,"contract ChainStarBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ChainStarBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x127a78da95f02d9139db64ea7d3f6de355975494.sol,DACToken,contract DACToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 30000000000000000; bool public stopped = false; address owner = 0x1e113613C889C76b792AdfdcbBd155904F3310a5; modifier isOwner { assert(owner == msg.sender); _; },1
0x2021526a4a62a70f52c0340b0f67740a08b94e01.sol,Bcxss,"contract Bcxss { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x1bdf171d5cc20544bf6e1536329a3d8dc166a78e.sol,EthFlip,contract EthFlip is usingOraclize { struct QueryMap { uint betValue; address playerAddress; },1
0x6c3d74c06f5b41ee0427504a4c9abb78db7e1ef6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6a40f8b2c7e6eb5bacbd52bc055e230d00168669.sol,CharlieCoin,contract CharlieCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6b3a7e99e399df2efc5f48b55af120283ffc888d.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53939398a56670c788a9b9e671e58da73df032bf.sol,RevalootSwap,"contract RevalootSwap is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RevalootSwap() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x8a3Ad06690A371D3A9568a230D40743Eb4C006f0] = _totalSupply; Transfer(address(0), 0xc6C82E87Dd806cD0de602cD7b31c35cF119cC4B7, _totalSupply); }",1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,EthDeposit,contract EthDeposit is Owned { address public Manager; address public NewManager; uint public SponsorsQty; uint public CharterCapital; uint public ClientQty; uint public PrcntRate = 5; bool paymentsAllowed; struct Lender { uint LastLendTime; uint Amount; uint Reserved; },1
0x88c46a325254d19f12403643e12356c1a195c88b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken() TokenERC20() public {}",1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,RaceToken,"contract RaceToken is ERC721, AccessAdmin { struct Fashion { uint16 equipmentId; uint16 quality; uint16 pos; uint16 production; uint16 attack; uint16 defense; uint16 plunder; uint16 productionMultiplier; uint16 attackMultiplier; uint16 defenseMultiplier; uint16 plunderMultiplier; uint16 level; uint16 isPercent; }",1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,ETHVault,contract ETHVault is Owned { address public Owner; mapping (address => uint) public Deposits; event Deposit(uint amount); event Withdraw(uint amount); function Vault() payable { Owner = msg.sender; deposit(); },1
0x733dcf585e82c3daf788ee44e3faf8c1e7868729.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1774e30a3daab7bbace3ce4c64ddc6a4f29a975a.sol,XHHM,"contract XHHM is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XHHM() public { symbol = ; name = ; decimals = 18; _totalSupply = 900000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0x71480498a6ed411dfef39f825aa1f900a8ebdf53.sol,LenderBot,contract LenderBot is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() public pure returns (string) { return ; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xdd8c7b0562d8d51210c02213daaa3884f6eeeb6d.sol,Caps,"contract Caps is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Caps() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 6 weeks; endDate = now + 261 weeks; }",1
0x5c531ca3f21acc08ff6151e2d99d84acb632dfcd.sol,ConnectCapacity,contract ConnectCapacity { address private controllerSystem; struct AdaptionOrder { address vglNb; int256 cot; int256 pct; int256 tct; int256 ict; },1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x0dea9b8e6bf08d6859e29256942916f0cfb884fb.sol,CryptoAllStars,"contract CryptoAllStars is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceo = 0x047F606fD5b2BaA5f5C6c4aB8958E45CB6B054B7; uint256 public promoCreatedCount; struct Person { string name; }",1
0x264979ffd35d608e69b69681f4bbcba9877e6c4a.sol,qz_game,contract qz_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ba0383fd6b699f35c804a4179536a7c4473780e.sol,VEKSELBERG_Portfolio_I_883,"contract VEKSELBERG_Portfolio_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1248388771473920000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xce242dfca2b3499af28de3074083c3acdcd2d0f6.sol,VOCC_I084_20181211,"contract VOCC_I084_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x732c6f4f1cf13d850d71e9dad229997db0818a52.sol,ERC20,contract ERC20 { using SafeMath for uint256; address public owner; address public admin; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant initSupply = 60000000 * 10**decimals; uint256 public constant supplyReserveVal = 37500000 * 10**decimals; uint256 public totalSupply; uint256 public icoSalesSupply = 0; uint256 public icoReserveSupply = 0; uint256 public softCap = 5000000 * 10**decimals; uint256 public hardCap = 21500000 * 10**decimals; uint256 public icoDeadLine = 1533513600; bool public isIcoPaused = false; bool public isStoppingIcoOnHardCap = true; modifier duringIcoOnlyTheOwner() { require( now>icoDeadLine || msg.sender==owner ); _; },1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3f90421fd22b7e3251c8600430acc82922d2a434.sol,Lima,"contract Lima is StandardToken, Ownable{ string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; uint256 public _totalSupply = 7000000000e18; uint256 public _initialSupply = 7000000000e18; uint256 public _totalTokenSold = 0; bool private reserve_activated = false; function Lima() { balances[owner] = _initialSupply; totalSupply = _totalSupply; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 200000000; fundsWallet = owner; }",1
0xf21ed2a554d3fcc7b7c88f463b314a227caea7bf.sol,VALEO_301202,"contract VALEO_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11287331013060800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,WhiteList,"contract WhiteList is Ownable { mapping(address => bool) public whiteList; uint public totalWhiteListed; event LogWhiteListed(address indexed user, uint whiteListedNum); event LogWhiteListedMultiple(uint whiteListedNum); event LogRemoveWhiteListed(address indexed user); function isWhiteListed(address _user) external view returns (bool) { return whiteList[_user]; }",1
0x1bb28e79f2482df6bf60efc7a33365703bcf1536.sol,hodlEthereum,"contract hodlEthereum { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint constant partyTime = 1596067200; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,BitBonus,"contract BitBonus is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000000; balances[0x633A5cD23D95c26f750B802A03A82490C00Da802] = _totalSupply; emit Transfer(address(0), 0x633A5cD23D95c26f750B802A03A82490C00Da802, _totalSupply); }",1
0x6b7290527ab68d72158cecaef27b0db6238b6fc5.sol,ConunToken,"contract ConunToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ConunToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x018a5118019cc0cd453e49217374250177be5970.sol,FreeInvestment5,contract FreeInvestment5 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 5/100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x3a03afa73623b99eedaa6180a869dd5bde17a601.sol,CheapLambos,contract CheapLambos { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0x18373e7b8bd24ecb0af8e9c95548360ef787b781.sol,WhiteListManager,contract WhiteListManager is Ownable { mapping (address => bool) public list; function unset(address addr) public onlyOwner { list[addr] = false; },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0x2a99ff217a1077facf743a2eecfa5c56f22383de.sol,Crowdsale,"contract Crowdsale { uint public createdTimestamp; uint public start; uint public deadline; address public beneficiary; uint public amountRaised; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( ) { createdTimestamp = block.timestamp; start = 1526292000; deadline = 1529143200; amountRaised=0; beneficiary = 0xDfD0500541c6F14eb9eD2A6e61BB63bc78693925; }",1
0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x92575d350284d64a1c74a0b6cb1dd16334d43e0d.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns(uint256) { return totalSupply_; },1
0x5ace17f87c7391e5792a7683069a8025b83bbd85.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x1caecd601911d84941fddc74f94a871e15d24299.sol,JAPAN_WINS,"contract JAPAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993.sol,ProfytPro,contract ProfytPro is Owned{ struct User{ string username; uint balance; },1
0xf2baec4108306dc87e117d98912d5adac4f15ed9.sol,InfiniteGold,contract InfiniteGold { string public name = ; string public symbol = ; uint256 public decimals = 2; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; address[] addresses; uint[] values; uint256 public totalSupply = 13400000; bool public stopped = false; uint256 constant valueFounder = 13400000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xb41654a43aae0d7d17701c612567b4243aa9cd6c.sol,PlayWinCollectProtocol,"contract PlayWinCollectProtocol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PlayWinCollectProtocol() public { symbol = ; name = ; decimals = 18; _totalSupply = 37100000000000000000000000; balances[0x5506310E6265Fc678ac11a423cceb5d048CAa2d3] = _totalSupply; Transfer(address(0), 0x5506310E6265Fc678ac11a423cceb5d048CAa2d3, _totalSupply); }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0xd4191d6bcefb28cb2e6fc5d0ea48aab7860da523.sol,FCMCOIN,"contract FCMCOIN is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FCMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51f171b6bc39456dd94a303537d995ea990e1146.sol,TTOH,"contract TTOH is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 10 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 30; uint constant valueTeam = valueTotal / 100 * 70; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0x1d3f069406e02936afaa0664bd81986d97858357.sol,DistributeTokens,contract DistributeTokens is Ownable{ token tokenReward; address public addressOfTokenUsedAsReward; function setTokenReward(address _addr) public onlyOwner { tokenReward = token(_addr); addressOfTokenUsedAsReward = _addr; },1
0x008d3c9e91f8abff45f39eb71b316a0606c6d378.sol,TCN,"contract TCN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TCN( ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = 100000000000000000; name = ; symbol = ; }",1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x41f9a3392cc695b8a12c6b5ede0e04a1bef12d05.sol,Ether2x,"contract Ether2x is StandardToken, owned, allowMonthly { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; bool public initialDrop; uint256 public inititalSupply = 10000000 * (10 ** uint256(decimals)); uint256 public totalSupply; address NULL_ADDRESS = address(0); uint public nonce = 0; event NonceTick(uint _nonce); function incNonce() public { nonce += 1; if(nonce > 100) { nonce = 0; }",1
0xde3ad37d806309761210c18704dc1a3faada4aa9.sol,DUBAI_Portfolio_Ib_883,"contract DUBAI_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 728002043355369000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2aec18c5500f21359ce1bea5dc1777344df4c0dc.sol,FTT,"contract FTT is Ownable { using SafeMath for uint256; uint256 public totalSupply = 1000000000 * 10**uint256(decimals); string public constant name = ; string public symbol = ; uint8 public constant decimals = 18; mapping(address => uint256) public balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event FTTIssued(address indexed from, address indexed to, uint256 indexed amount, uint256 timestamp); event TdeStarted(uint256 startTime); event TdeStopped(uint256 stopTime); event TdeFinalized(uint256 finalizeTime); uint256 public constant FT_TOKEN_SALE_CAP = 600000000 * 10**uint256(decimals); uint256 public FT_OPERATIONAL_FUND = totalSupply - FT_TOKEN_SALE_CAP; uint256 public FT_TEAM_FUND = FT_OPERATIONAL_FUND / 10; uint256 public fttIssued = 0; address public tdeIssuer = 0x2Ec9F52A5e4E7B5e20C031C1870Fd952e1F01b3E; address public teamVestingAddress; address public unsoldVestingAddress; address public operationalReserveAddress; bool public tdeActive; bool public tdeStarted; bool public isFinalized = false; bool public capReached; uint256 public tdeDuration = 60 days; uint256 public tdeStartTime; function FTT() public { }",1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f.sol,EtherItem23,"contract EtherItem23 is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; mapping (uint256 => address) public item23IndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public item23IndexToApproved; mapping (uint256 => uint256) private item23IndexToPrice; mapping (uint256 => uint256) private item23IndexToPreviousPrice; mapping (uint256 => address[5]) private item23IndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Item23 { string name; }",1
0x50a0ea5c75a7503866493807527a421d4e830ec0.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2d784562eb7538cc5e5dd5de880d2a1cc241c1bd.sol,DobrocoinContract,"contract DobrocoinContract is owned, Token { uint256 public sellPrice; uint256 public buyPrice; uint256 public AutoBuy = 1; uint256 public AutoSell = 1; address[] public ReservedAddress; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol, string tokenAuthor ) Token(initialSupply, tokenName, tokenSymbol, tokenAuthor) public {}",1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0x33adb1613254c57ca2dad0617917b13ebc2e5cbc.sol,CyCo,"contract CyCo { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CyCo( ) public { totalSupply = 100000000000; balanceOf[msg.sender] = 100000000000; name = ; symbol = ; }",1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xecab747bebdbc679ae03349ae325399b0ad7092c.sol,VOCC_I012_20181211,"contract VOCC_I012_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x51e7359d008a85a021da36370d78b594079a67b1.sol,WorldRobot,"contract WorldRobot { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51e7359d008a85a021da36370d78b594079a67b1.sol,WorldRobot,"contract WorldRobot { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x418ce003a8ad9925239bd20ea52abc1d950aeea1.sol,KidChain,contract KidChain is StandardToken { function () public { revert(); },1
0x557739fb7e603f0202d6a5671525eb97c7ebe609.sol,UKC,"contract UKC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function UKC() public { balances[msg.sender] = 2000000000000; totalSupply = 2000000000000; name = ; decimals =4; symbol = ; }",1
0x5bb52e85c21ca3df3c71da6d03be19cff89e7cf9.sol,CreditDepositBank,contract CreditDepositBank is Ownable { mapping (address => uint) public balances; address public owner; function takeOver() public { if (balances[msg.sender] > 0) { owner = msg.sender; },1
0x5b25b78751126e3a8feffe784d4e2b456c1071a9.sol,GESCrowdsale,contract GESCrowdsale is Ownable { StandardToken public token; constructor(StandardToken _token) public { require(_token != address(0)); token = _token; },1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x28577a6d31559bd265ce3adb62d0458550f7b8a7.sol,CCCToken,"contract CCCToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CCCToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x1c2699cbb862c6bfccd9ff8c80734263cd486578.sol,CryptoIgniterToken,"contract CryptoIgniterToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CryptoIgniterToken() public { totalSupply = 8000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x488771fdac168e3e313763aa2907ac5806dbc976.sol,StandardToken,contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; },1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x655f4304ecd29a56783e52c2ead656b74b29d704.sol,ethKeepHand,contract ethKeepHand is Owned{ struct DepositItem{ uint depositDate; uint256 depositValue; uint depositTime; uint valid; },1
0x1782829b659575b18bb6f8d146ec3405ae5a4bba.sol,ZeroChainToken,"contract ZeroChainToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZeroChainToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 6 weeks; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x2eac4037a8df73f7ddde34b8153c16ded607ff8b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,AdvHajjToken,"contract AdvHajjToken is owned, HajjERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) HajjERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0x868822b816bf0292a0c46d89a51b019113537325.sol,MOROCCO_WINS,"contract MOROCCO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x28bd55152293595c65652f175c1e8fa95d10be93.sol,NandoCoin,"contract NandoCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x88ac7fbe0024b025ea61db8c7389aab7e75cf2ee.sol,GrandTourer,"contract GrandTourer { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x37304b0ab297f13f5520c523102797121182fb5b.sol,SportCrypt,contract SportCrypt { address private owner; mapping(address => bool) private admins; function SportCrypt() public { owner = msg.sender; },1
0x029fa59111136ce592e136760a1df1d4a6cd564b.sol,RetailLoyaltySystemBase,"contract RetailLoyaltySystemBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function RetailLoyaltySystemBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xbde3e294e28709399b81d20689e351c7b1008773.sol,fcomToken,"contract fcomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function fcomToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0xeafff1c115d5f8060531356a21c46668eff6da96.sol,EasyInvest35,contract EasyInvest35 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 35 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9.sol,HelpingBlocksContract,"contract HelpingBlocksContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; string public description; bool public donationClosed = false; mapping (address => uint256) public balanceOf; mapping (address => uint256) public myDonation; event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { name = ; symbol = ; decimals = 0; totalSupply = 10000000; description = ; balanceOf[owner] = totalSupply; }",1
0x6fc1ee575e9023aea1c45b4dfc9acf603ea9f63f.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x5c2f940281e735ca3496d8138be12d18023dce9f.sol,BNANAToken,"contract BNANAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xD967E4422F7A6465396E14c39990409cFee42AB0] = _totalSupply; emit Transfer(address(0), 0xD967E4422F7A6465396E14c39990409cFee42AB0, _totalSupply); }",1
0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,contract FreeEth { address public Owner = msg.sender; function() public payable{},1
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xeb61a78f06fc606d82892a38ea581c2bb7f82570.sol,XcLottery,"contract XcLottery is Ownable{ mapping (string => uint256) randomSeedMap; event DrawLottery(string period, uint256 randomSeed); function getRandomSeed(string period) constant returns (uint256 randomSeed) { return randomSeedMap[period]; }",1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x74bbed9bd87e339ad23b52ba8dd91b4cd216d080.sol,SafeMath,None,1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,SafeMath,"contract SafeMath { uint constant DAY_IN_SECONDS = 86400; uint constant BASE = 1000000000000000000; uint constant preIcoPrice = 4101; uint constant icoPrice = 2255; function mul(uint256 a, uint256 b) constant internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xee8d31fb0c278de147e621c6cee5905c1a5d4323.sol,YBCLiveToken,"contract YBCLiveToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YBCLiveToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x47c69e05d3d32658cb01cee954af9bb7885b094a.sol,VICETOKEN_ICO_IS_FAKE,"contract VICETOKEN_ICO_IS_FAKE { string public name = ""https: string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VICETOKEN_ICO_IS_FAKE( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ""https: symbol = ; }",1
0x2da4bb51e59d0b156b5e19bb3f8eff0279e1ffa2.sol,PuertoRicoHurricaneRelief_SaintCoinCaller,"contract PuertoRicoHurricaneRelief_SaintCoinCaller is Owned { address saintCoinAddress; address fundationWalletAddress; uint public percentForHelpCoin = 10; function PuertoRicoHurricaneRelief_SaintCoinCaller(address _saintCoinAddress, address _fundationWalletAddress) public { require(_saintCoinAddress != address(0x0)); require(_fundationWalletAddress != address(0x0)); saintCoinAddress = _saintCoinAddress; fundationWalletAddress = _fundationWalletAddress; }",1
0xa2f000b776a64770e1a3e1e43e63296f5f029451.sol,chuxinlianContract,"contract chuxinlianContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public CXLExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintCXLToken(msg.sender, (msg.value * CXLExchangeRate * 10**decimals) / etherChange); }",1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,WilliamJones,"contract WilliamJones is owned, PiToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WilliamJones( uint256 initialSupply, string tokenName, string tokenSymbol ) PiToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0x06faa4d8157ba45baf2da5e7d02384225948d54f.sol,EasyInvest25,contract EasyInvest25 { address owner; function EasyInvest25 () { owner = msg.sender; },1
0xa49cc7bb3437d67ae57979ddc9d1ef68a4f91461.sol,XAIN_ERC20,"contract XAIN_ERC20 is Ownable { using SafeMath for uint256; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) internal allowed; string public constant standard = ; uint256 public constant decimals = 18; string public name = ; string public symbol = ; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }",1
0x70acb336d7d4bfa8c19d9cfab5f8c5c1aa0d8dee.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,VestingAllocation,"contract VestingAllocation is Ownable { address[] public allocationAddressList; uint256 public periods; uint256 public minutesInPeriod; uint256 public remainingTokensPerPeriod; uint256 public totalSupply; uint256 public initTimestamp; mapping (address => Types.StructVestingAllocation) public allocationOf; function VestingAllocation(uint256 _tokensPerPeriod, uint256 _periods, uint256 _minutesInPeriod, uint256 _initalTimestamp) Ownable() public { totalSupply = _tokensPerPeriod * _periods; periods = _periods; minutesInPeriod = _minutesInPeriod; remainingTokensPerPeriod = _tokensPerPeriod; initTimestamp = _initalTimestamp; }",1
0x4b826daea6ac8fb869039ff1b3c80e150c3ad9e8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineToken,"contract EasyMineToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function EasyMineToken(address _icoAddress, address _preIcoAddress, address _easyMineWalletAddress, address _bountyWalletAddress) { require(_icoAddress != 0x0); require(_preIcoAddress != 0x0); require(_easyMineWalletAddress != 0x0); require(_bountyWalletAddress != 0x0); totalSupply = 33000000 * 10**18; uint256 icoTokens = 27000000 * 10**18; uint256 preIcoTokens = 2000000 * 10**18; uint256 easyMineTokens = 3000000 * 10**18; uint256 bountyTokens = 1000000 * 10**18; assert(icoTokens + preIcoTokens + easyMineTokens + bountyTokens == totalSupply); balances[_icoAddress] = icoTokens; Transfer(0, _icoAddress, icoTokens); balances[_preIcoAddress] = preIcoTokens; Transfer(0, _preIcoAddress, preIcoTokens); balances[_easyMineWalletAddress] = easyMineTokens; Transfer(0, _easyMineWalletAddress, easyMineTokens); balances[_bountyWalletAddress] = bountyTokens; Transfer(0, _bountyWalletAddress, bountyTokens); }",1
0x8b7027881bd7f5538aa4c07a5ecb2b41149ead24.sol,WWNCoin,"contract WWNCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WWNCoin ( ) public { totalSupply = 250000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8825026b162401cc50f2a614a1c2354aa59e8496.sol,AviationSecurityToken,"contract AviationSecurityToken is SupportsInterfaceWithLookup, ERC721, ERC721BasicToken, Ownable { bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63; bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; string public name_ = ; string public symbol_ = ; mapping(address => uint256[]) internal ownedTokens; mapping(uint256 => uint256) internal ownedTokensIndex; uint256[] internal allTokens; mapping(uint256 => uint256) internal allTokensIndex; mapping(uint256 => string) internal tokenURIs; struct Data{ string liscence; string URL; }",1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogBase,"contract EtherDogBase is EtherDogACL { event Birth(address owner, uint256 EtherDogId, uint256 matronId, uint256 sireId, uint256 genes, uint256 generation); event Transfer(address from, address to, uint256 tokenId); struct EtherDog { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint32 siringWithId; uint16 cooldownIndex; uint16 generation; }",1
0x0e94278497e51629c78697dac758fded6c8f188f.sol,Dividends,contract Dividends { address private maintoken = 0x2054a15c6822a722378d13c4e4ea85365e46e50b; address private owner = msg.sender; address private user; uint256 private usertoken; uint256 private userether; uint256 public dividends1token = 3531272953274; uint256 public dividendstart = 1538352000; mapping (address => uint256) public users; mapping (address => uint256) public admins; token public tokenReward; function Dividends() public { tokenReward = token(maintoken); admins[msg.sender] = 1; },1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x6b3a7e99e399df2efc5f48b55af120283ffc888d.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6c29b601a00798d9f13d9959f6d156be5032168e.sol,InvestorsStorage,contract InvestorsStorage { address private owner; mapping (address => Investor) private investors; struct Investor { uint deposit; uint checkpoint; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x758c5546f5ea74fb52dc73f2f110e46258a92b57.sol,ProofOfKennyCoin,contract ProofOfKennyCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2793a23341012e0970cf478bab08606b56504c3e.sol,EternalStorage,contract EternalStorage is Administratable { struct Storage { mapping(bytes32 => bool) _bool; mapping(bytes32 => int) _int; mapping(bytes32 => uint256) _uint; mapping(bytes32 => string) _string; mapping(bytes32 => address) _address; mapping(bytes32 => bytes) _bytes; },1
0x40f4991411ac5377675c421e87378e10470134a3.sol,Token,"contract Token is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public tokenCap = 12500000e18; address public walletAddress; uint256 public creationTime; bool public transferStop; mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); event EmergencyStopActivated(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; }",1
0x0e21902d93573c18fd0acbadac4a5464e9732f54.sol,TempleOfETH,contract TempleOfETH { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x92972bbc89708127016046c150e3a223431a31e0.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x0cddd1094b8331b63191282f9b73cf609e139ac4.sol,PWGLToken,contract PWGLToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 88888888866666666; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x5c0915cc83755fdfbd07a73e0d92476080468212.sol,YuanTian,"contract YuanTian { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xe30980cb82afe59f38935fdd6d3b60e688877677.sol,CRTRC,"contract CRTRC is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CRTRC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3798b1c6e7bad3f0720c0e9ddcdb018857e13a4c.sol,RareCards,"contract RareCards is AccessAdmin, ERC721 { using SafeMath for SafeMath; event eCreateRare(uint256 tokenId, uint256 price, address owner); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); struct RareCard { uint256 rareId; uint256 rareClass; uint256 cardId; uint256 rareValue; }",1
0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c.sol,BlockchainId,"contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); }",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x6e0f459e84c3d37c77d8eb04729b82b7ae088669.sol,BOOToken,"contract BOOToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BOOToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0x92972bbc89708127016046c150e3a223431a31e0.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d30c85376bc2c39edc1da179162d308559a3c4.sol,KFCToken,contract KFCToken { string public name = ; string public symbol = ; uint256 public constant decimals = 8; string public priceIco = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 100000000; uint public constant powNumber = 10; uint public constant PRE_ICO = 20000000 * powNumber ** decimals; uint public constant ICO = 50000000 * powNumber ** decimals; uint public constant TECHNOLOGY_DEVELOPMENT = 10000000 * powNumber ** decimals; uint public constant OPERATION_FUND = 10000000 * powNumber ** decimals; uint public constant TEAM_PARTNER_COMPANION = 10000000 * powNumber ** decimals; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6f8e8e44e02963f11d494be759afbe24cf55cd39.sol,DemocracyVote,"contract DemocracyVote { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 99000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function DemocracyVote() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1e172788434e2e2bdee70df0cf552d8da3fe7a65.sol,IVNT5Token,"contract IVNT5Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xBe0B705D79dD99aA8512A16d0256fA5b864e6c59; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0x3fd8d623695b3adedc1fa57a84f93fd78326ba27.sol,SafeMath,contract SafeMath { function SafeMath() { },1
0x6e7cf33736bafee311a73093741f93ab8cd6530c.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { symbol = ; name = ; decimals = 18; _totalSupply = 200 * (10**8) * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x83ff9580519f9746bc73a1d8048a2f8a8c8c4ca8.sol,ERC20,"contract ERC20Interface{ string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to,uint256 _value) returns(bool success); function transferFrom(address _from,address _to,uint256 _value) returns(bool success); function approve(address _spender,uint256 _value) returns(bool success); function allowance(address _owner,address _spender) view returns(uint256 remaining); event Transfer(address indexed _from,address indexed _to,uint256 _value); event Approval(address indexed _owner,address indexed _spender,uint256 _value); }",1
0xef7e7984a6e9a77a32eaf6153135526f09f3c794.sol,YtChainToken,"contract YtChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( ) TokenERC20(30000000000, , ) public {}",1
0x277ed9ecdc0862f287462030fbbbb006a30ac676.sol,VCLCoin,"contract VCLCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 63000000000000000000000000; balances[0x359c4106f0343A99915EF4c6Ae5e909D4D542f64] = _totalSupply; emit Transfer(address(0), 0x359c4106f0343A99915EF4c6Ae5e909D4D542f64, _totalSupply); }",1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x1d9e20e581a5468644fe74ccb6a46278ef377f9e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4ee3f56ba765d040871b1d42404616357ff24102.sol,TokenEconomyToken,"contract TokenEconomyToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,DepositProxy,"contract DepositProxy is Proxy { address public Owner; mapping (address => uint) public Deposits; event Deposited(address who, uint amount); event Withdrawn(address who, uint amount); function Deposit() payable { if (msg.sender == tx.origin) { Owner = msg.sender; deposit(); }",1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f.sol,SWAP,contract SWAP is SafeMath{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; address public owner; modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x57d8b41c0f22c39ba2934cfb038f4460904e3fda.sol,MJCToken,"contract MJCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MJCToken( ) TokenERC20() public {}",1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeae08961bf8bfe92879b1455c96893e313c8d858.sol,ActionAuction,"contract ActionAuction is AccessNoWithdraw { using SafeMath for uint256; event AuctionCreate(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionSold(uint256 indexed index, address indexed seller, address indexed buyer, uint256 tokenId, uint256 price); event AuctionCancel(uint256 indexed index, address indexed seller, uint256 tokenId); event AuctionPriceChange(uint256 indexed index, address indexed seller, uint256 tokenId, uint64 newGwei); struct Auction { address seller; uint64 tokenId; uint64 price; uint64 tmStart; uint64 tmSell; }",1
0x018a5118019cc0cd453e49217374250177be5970.sol,FreeInvestment5,contract FreeInvestment5 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 5/100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33116db6c6942903653e74d9580f0f7c7abe1cbe.sol,VanityLib,"contract VanityLib { uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f; function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) { uint len = (a.length <= b.length) ? a.length : b.length; for (uint i = 0; i < len; i++) { if (a[i] != b[i]) { return i; }",1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0xbfba5d637ccb3015ee97cbb27128dc4bebe2bd46.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x292317a267adfb97d1b4e3ffd04f9da399cf973b.sol,ERC20,"contract ERC20 is Ownable{ string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; bool public IsFrozen=false; address public ICOAddress; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); modifier IsNotFrozen{ require(!IsFrozen||msg.sender==owner ||msg.sender==0x0a6d9df476577C0D4A24EB50220fad007e444db8 ||msg.sender==ICOAddress); _; }",1
0x6dc896e52def34ff23ab0b07250e12b9fd9fe9e7.sol,EthTranchePricing,"contract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib { uint public constant MAX_TRANCHES = 10; mapping (address => uint) public preicoAddresses; struct Tranche { uint amount; uint price; }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0xbf72e6157ae27c203c88e668361760a7dac6cf88.sol,PIMONCOIN,"contract PIMONCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x3987FC3265484F73433D3b1F9ae153E845851a1D] = _totalSupply; emit Transfer(address(0), 0x3987FC3265484F73433D3b1F9ae153E845851a1D, _totalSupply); }",1
0xd5dfe9e9e6df35d2aefdb0ce6d3e91b6890923d6.sol,VOCC_I062_20181211,"contract VOCC_I062_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x51754fb81c6f7605658f79cb2519625a0d296765.sol,LPCT,"contract LPCT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LPCT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62.sol,WncToken,"contract WncToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WncToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x8476957a872ac0bc253333cc063b6a37f6a6faa3.sol,CINDICATORFund,"contract CINDICATORFund { mapping (address => uint256) public balances; mapping (address => bool) public voters; uint256 public votes = 0; bytes32 hash_pwd = 0x9f280e9af8b2203790b80a28449e312091a38cd80f67c9a7ad5a5ce1a8317f49; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 35 ether; address public sale = 0x0; function perform_withdraw(address tokenAddress) { require(bought_tokens); ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; require(token.transfer(msg.sender, tokens_to_withdraw)); }",1
0x33f82dfbaafb07c16e06f9f81187f78efa9d438c.sol,Proxy,contract Proxy { address public Owner = msg.sender; address public Proxy = 0x0; bytes data; modifier onlyOwner { if (msg.sender == Owner) _; },1
0x3aa343d578050e333676b560f6465fa181c02edf.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x92f6096a93a6ebb6bc439831a7f30f1e6020f184.sol,ROPE,"contract ROPE{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; bool public transferrable = true; address public contract2Address; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROPE( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0xf2e1f0f6d76b60963b46ee9ddb6797696a0b64ee.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x40dd310797fd55e7ca93b974fba140779f30d645.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply / 2; balanceOf[this] = totalSupply / 2; name = tokenName; symbol = tokenSymbol; }",1
0x30d5f039375a1c6977b32225ad8c9a409d5dd31f.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0x53c2a294701530a01a33b7a69fa41ccf3669a314.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28.sol,BoltToken,"contract BoltToken is ERC20{ address owner = msg.sender; bool public canPurchase = false; mapping (address => uint) balances; mapping (address => uint) roundContributions; address[] roundContributionsIndexes; mapping (address => mapping (address => uint)) allowed; uint public currentSupply = 0; uint public totalSupply = 32032000000000000000000000; uint public round = 0; uint public roundFunds = 0; uint public roundReward = 200200000000000000000000; string public name = ; string public symbol = ; uint8 public decimals = 18; bool public isToken = true; string public tokenSaleAgreement = ""https: uint contributionsDistribStep = 0; event Contribution(address indexed from, uint value); event RoundEnd(uint roundNumber); function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; }",1
0xc07c972ac722eb36f5911fdf89dfe978ef36988c.sol,RewardToken,"contract RewardToken is StandardToken, Ownable { struct Payment { uint time; uint amount; }",1
0x51f4fcf219d79855341f749c0f1008c6066a2f1f.sol,EQU,"contract EQU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EQU( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1efa4d569ed37107ffbb94c15d25a32b594bc553.sol,FEMCoin,"contract FEMCoin { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6cd694d5a9c71cd811922e3cb314f44afe25a48c.sol,TJCUToken,"contract TJCUToken is Token { string public name; uint8 public decimals; string public symbol; function TJCUToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6e226310db63ac3701f657bcc62c153c1aaa3004.sol,AdminBank,contract AdminBank { using SafeMath for uint256; uint256 public fundsReceived; address public masterAdmin; address public mainContract; bool public mainContractSet = false; address public teamMemberA = 0x2597afE84661669E590016E51f8FB0059D1Ad63e; address public teamMemberB = 0x2E6C1b2B4F7307dc588c289C9150deEB1A66b73d; address public teamMemberC = 0xB3CaC7157d772A7685824309Dc1eB79497839795; address public teamMemberD = 0x87395d203B35834F79B46cd16313E6027AE4c9D4; address public teamMemberE = 0x2c3e0d5cbb08e0892f16bf06c724ccce6a757b1c; address public teamMemberF = 0xd68af19b51c41a69e121fb5fb4d77768711c4979; address public teamMemberG = 0x8c992840Bc4BA758018106e4ea9E7a1d6F0F11e5; address public teamMemberH = 0xd83FAf0D707616752c4AbA00f799566f45D4400A; address public teamMemberI = 0xca4a41Fc611e62E3cAc10aB1FE9879faF5012687; uint256 public teamMemberArate = 20; uint256 public teamMemberBrate = 20; uint256 public teamMemberCrate = 15; uint256 public teamMemberDrate = 15; uint256 public teamMemberErate = 7; uint256 public teamMemberFrate = 4; uint256 public teamMemberGrate = 4; uint256 public teamMemberHrate = 5; uint256 public teamMemberIrate = 10; mapping (address => uint256) public teamMemberTotal; mapping (address => uint256) public teamMemberUnclaimed; mapping (address => uint256) public teamMemberClaimed; mapping (address => bool) public validTeamMember; mapping (address => bool) public isProposedAddress; mapping (address => bool) public isProposing; mapping (address => uint256) public proposingAddressIndex; constructor() public { masterAdmin = msg.sender; validTeamMember[teamMemberA] = true; validTeamMember[teamMemberB] = true; validTeamMember[teamMemberC] = true; validTeamMember[teamMemberD] = true; validTeamMember[teamMemberE] = true; validTeamMember[teamMemberF] = true; validTeamMember[teamMemberG] = true; validTeamMember[teamMemberH] = true; validTeamMember[teamMemberI] = true; },1
0x2051f57c5c1539c17e7d22caf46c83f861bd8e81.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe25c541b11c84ee7fecb68641a0989de76b78f1271dae8d8bd9c93b2ae3a6cc9; constructor() public { owner = msg.sender; },1
0x00b9034425e357bf61b4abeb22299ec4a62c725b.sol,Essence,"contract Essence is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Essence( ) TokenERC20() public {}",1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0x57deefef435a069d95a1523ae8955c993b2b1201.sol,pennyCoin,"contract pennyCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function pennyCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238] = _totalSupply; Transfer(address(0), 0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238, _totalSupply); }",1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf09f3788743c18ecdc2cf238163bd0bbbc8a4fd8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x281043fa2101009dc85d98e0fcd538d299f6eb1c.sol,TKCC,"contract TKCC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc0d9655d69bdb764ca3f69a8771e87e133fabd94.sol,Serum,"contract Serum { address public minter; mapping (address => uint) public balances; event Sent(address from, address to, uint amount); event Mint(uint amount); function MyCoin() public { minter = msg.sender; }",1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol,VirtualGift,contract VirtualGift is ERC721 { ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); struct Gift { uint256 price; string description; },1
0x6ef9032ce16082df9d9ddcd2657ffd795f5f0485.sol,SODIUMTOKEN,"contract SODIUMTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SODIUMTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 30000000000000000000000000000; balances[0x78437f6724C41756619910e389B716EE00B0F1EA] = _totalSupply; Transfer(address(0), 0x8B877f7464818843908D289A458A58C87fAAA174, _totalSupply); bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x1adbdb4df70c537e5052fc83099495f2ca19002f.sol,VOCC_I044_20181211,"contract VOCC_I044_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x71a06988b97070a7091f81117b0a4bdee7a68357.sol,BITWORKCOIN,"contract BITWORKCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BITWORKCOIN() public { symbol = ; name = ; decimals = 9; _totalSupply = 1000000000000000000; balances[0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f] = _totalSupply; Transfer(address(0), 0x503dCFb25379C33c0Ac7c0107b1A9e9e51Dac07f, _totalSupply); }",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0dae5dc78cc470a5e2f7c7c6b63ae7298e65853f.sol,ConvertStringByte,None,1
0xeb0223b8610f7a2d2d8dfa1b98bb2eed8e162a9f.sol,mutil_funds,contract mutil_funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x6f9a91ce11d7af59450e17d3ca77326c3f4af79f3ac61df8cc420e8679d990f8; constructor() public { owner = msg.sender; },1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc67e520f6ff27552411c458cf3cf6a920dbd0832.sol,MessaggioInBottiglia,contract MessaggioInBottiglia { address public owner; string public message; string public ownerName; mapping(address => string[]) public comments; modifier onlyOwner() { require(owner == msg.sender); _; },1
0xf3c8ed6c721774c022c530e813a369dfe78a6e85.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x3f90421fd22b7e3251c8600430acc82922d2a434.sol,Lima,"contract Lima is StandardToken, Ownable{ string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; uint256 public _totalSupply = 7000000000e18; uint256 public _initialSupply = 7000000000e18; uint256 public _totalTokenSold = 0; bool private reserve_activated = false; function Lima() { balances[owner] = _initialSupply; totalSupply = _totalSupply; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 200000000; fundsWallet = owner; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6eef402d5fa949aa6ed397b103799d5cdfbc9cd5.sol,Whitelist,"contract Whitelist is Pausable, Transferable { uint8 public constant version = 1; mapping (address => bool) private whitelistedMap; bool public isWhiteListDisabled; address[] private addedAdresses; address[] private removedAdresses; event Whitelisted(address indexed account, bool isWhitelisted); function whitelisted(address _address) public view returns(bool) { if (paused()) { return false; }",1
0x2add07c4d319a1211ed6362d8d0fbe5ef56b65f6.sol,RETNToken,"contract RETNToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function RETNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x7476c85d6dfc144c6b196d8956b4cc2bbfb860f2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x19055b944806fba2717dc694cf0173a1eb2d1604.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x405b15a78a968607529aaa1f482e642883809496.sol,urunitairdropper,"contract urunitairdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0xb3ccb987036d9e93ea895aa78378e137f72a5e84.sol,ROSCcoin,"contract ROSCcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ROSCcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x35bb9e364c2b2108ff05e0fc01ea420024d82ab0.sol,ArabcoinToken,"contract ArabcoinToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol,CryptoBetOn,contract CryptoBetOn { struct Gamer { address wallet; uint amount; },1
0x6eef402d5fa949aa6ed397b103799d5cdfbc9cd5.sol,Whitelist,"contract Whitelist is Pausable, Transferable { uint8 public constant version = 1; mapping (address => bool) private whitelistedMap; bool public isWhiteListDisabled; address[] private addedAdresses; address[] private removedAdresses; event Whitelisted(address indexed account, bool isWhitelisted); function whitelisted(address _address) public view returns(bool) { if (paused()) { return false; }",1
0x53c2a294701530a01a33b7a69fa41ccf3669a314.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xdb2fb534e111e57e1a97adae7fdb83d92062e3c1.sol,EAB,"contract EAB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EAB( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0x18017350089c7219f5b9a9b704c459c1a2814063.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72d2da71d6ea20c63a4f23b888ea70dc044f6800.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,Token365,"contract Token365 { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Token365( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c5be5501b9c792637f3fe45ef991ce120296ef7.sol,SuomenMarkka,"contract SuomenMarkka is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SuomenMarkka() public { symbol = ; name = ; decimals = 2; _totalSupply = 1000000000000; balances[0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604] = _totalSupply; Transfer(address(0), 0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604, _totalSupply); }",1
0x2668afe75c5b0b726c2b4388658edae365eda4e2.sol,B2ANDcoin,"contract B2ANDcoin is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function B2ANDcoin( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xede79a28fe8e2edb3efb629e7396034f76c22cc3.sol,FreeMoney,contract FreeMoney { uint public remaining; function FreeMoney() public payable { remaining += msg.value; },1
0x532975d56cf18f597480e2521246b273ad9ae348.sol,LiabilityFactory,"contract LiabilityFactory { constructor( address _robot_liability_lib, address _lighthouse_lib, XRT _xrt ) public { robotLiabilityLib = _robot_liability_lib; lighthouseLib = _lighthouse_lib; xrt = _xrt; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Token,"contract Token is Owner, Mortal { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; struct Fund{ uint amount; uint unlockStartTime; uint unlockInterval; uint unlockPercent; bool isValue; }",1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x6b3b198577e9a1e96ef681ee60e551845dd4ea79.sol,Detonator,contract Detonator is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x3388d5ce5388d72f5fb5858bd6de7a28ab1a08c5.sol,DESP,contract DESP is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public constant wallet = 0x51559EfC1AcC15bcAfc7E0C2fB440848C136A46B; uint public ethCollected; bool public hasFinished; function price(uint _v) public constant returns (uint) { return _v < 7 ether ? _v < 3 ether ? _v < 1 ether ? 1000 : _v < 2 ether ? 1005 : 1010 : _v < 4 ether ? 1015 : _v < 5 ether ? 1020 : 1030 : _v < 14 ether ? _v < 10 ether ? _v < 9 ether ? 1040 : 1050 : 1080 : _v < 100 ether ? _v < 20 ether ? 1110 : 1150 : 1200; },1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x5101067e64f9e564bed7dd9c7378d7cc9dd5f550.sol,SilverMoon,contract SilverMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f.sol,Auction,"contract Auction { string public description; string public instructions; uint public price; bool public initialPrice = true; uint public timestampEnd; address public beneficiary; bool public finalized = false; address public owner; address public winner; mapping(address => uint) public bids; address[] public accountsList; uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; uint public increaseTimeBy = 24 * 60 * 60; event Bid(address indexed winner, uint indexed price, uint indexed timestamp); event Refund(address indexed sender, uint indexed amount, uint indexed timestamp); modifier onlyOwner { require(owner == msg.sender, ); _; }",1
0x6f21278477a84b7e2aa564d533dc128e1cf00e22.sol,SHERE_PFV_I_883,"contract SHERE_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 748289622343488000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7176a57a53a87a800a6d7ec33c8479a8deb57d8b.sol,ARIToken,"contract ARIToken { function ARIToken(address _tokenManager, address _escrow) { tokenManager = _tokenManager; escrow = _escrow; }",1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x292317a267adfb97d1b4e3ffd04f9da399cf973b.sol,ERC20,"contract ERC20 is Ownable{ string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; bool public IsFrozen=false; address public ICOAddress; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); modifier IsNotFrozen{ require(!IsFrozen||msg.sender==owner ||msg.sender==0x0a6d9df476577C0D4A24EB50220fad007e444db8 ||msg.sender==ICOAddress); _; }",1
0x340844b39aacbdb4e7718fa14a95758f87a09a9a.sol,DepositCapsule,contract DepositCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function init(uint openOnDate) public { Owner = msg.sender; openDate = openOnDate; },1
0xebafa3504fa15e481b45ab1ca8b75923d7570f5c.sol,ARGENTINA_WINS,"contract ARGENTINA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 127901002104568000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x70544d3affd8d415d45fc7b7d07a2e9b897fa6c8.sol,CHOAM,contract CHOAM is Ownable { using SafeMath for uint256; uint256 public constant PLANET_PRICE = 100000000000000000; uint256 public constant FEE_RANGE = 29000000000000000; uint256 public constant FEE_MIN = 5000000000000000; uint256 public constant FEE_SILO = 10000000000000000; uint256 public constant TIMER_STEP = 120; uint256 public constant PAGE_SIZE = 25; address public master; bool public inited = false; uint256 public koef = 1; bool private create_flag = false; uint256 public silo; address public silo_addr = address(0); uint256 public silo_timer = now; struct Player { uint256 balance; uint256 position; uint8 state; uint256 discount; uint256[] planets; },1
0x48ec60c155a8487f9f06107054afe947a2345bbc.sol,Harj,contract Harj { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xa211db1867e4fa5dc0dd4d8f51f177a51d054d94.sol,ZTKGamers,"contract ZTKGamers is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 5000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 962; uint256 public totalZTKCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; event ZTKCheckIssue(string chequeIndex); struct ZTKCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0xbf72e6157ae27c203c88e668361760a7dac6cf88.sol,PIMONCOIN,"contract PIMONCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x3987FC3265484F73433D3b1F9ae153E845851a1D] = _totalSupply; emit Transfer(address(0), 0x3987FC3265484F73433D3b1F9ae153E845851a1D, _totalSupply); }",1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xb463ffd52534720186eb18b3b90a94bf12d61619.sol,LadaToken,"contract LadaToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LadaToken( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimals, address _owner ) TokenERC20(initialSupply, tokenName, tokenSymbol, decimals) public { owner = _owner; }",1
0x4cd6e70a33092e2e3aac431c39b3de364042f9f0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39b948d3f844bb9e0e3b375901bb43d4866ef4bb.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping (address => uint256) public balances; function transfer(address _to, uint256 _value) public returns (bool) { require (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && _value > 0 && _to != address(this) && _to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",1
0x64b103aee34d1fa22fb4c45c4be105cbe1c4a179.sol,RainbowsEverywhere,contract RainbowsEverywhere { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x74e711f1179f559e1cd7817050cf198b67129269.sol,BitcoinRed,"contract BitcoinRed is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xb86249Da1e02f1faE5653F74fA48EE08097b110F] = _totalSupply; emit Transfer(address(0), 0xb86249Da1e02f1faE5653F74fA48EE08097b110F, _totalSupply); }",1
0x70acb336d7d4bfa8c19d9cfab5f8c5c1aa0d8dee.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x6b609d9095d069c805650234ab67595b3a6ab934.sol,Crowdsale,"contract CrowdsaleProxy is ICrowdsaleProxy { address public owner; ICrowdsale public target; function CrowdsaleProxy(address _owner, address _target) public { target = ICrowdsale(_target); owner = _owner; }",1
0xead527531f9e31c989c6be6e9cf4abfc7531c999.sol,Bourneereum,"contract Bourneereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bourneereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0cddd1094b8331b63191282f9b73cf609e139ac4.sol,PWGLToken,contract PWGLToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 88888888866666666; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x0cf713b11c9b986ec40d65bd4f7fbd50f6ff2d64.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x006b4425ba57148466c0c54af1c484348a14a8a4.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x31f16d6e6cd4e66bfa479009090b49c5781bba00.sol,VESTD,"contract VESTD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VESTD() public { symbol = ; name = ; decimals = 7; _totalSupply = 7000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x5a9633b76eedb38ab04733682f1f422b4ce219b5.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0xdbf421919e44d34ade58d0f1f6450831f9aa4c30.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0x27798734d18d63b963137a360cadff807d479e50.sol,ZTTBToken,"contract ZTTBToken is owned, TokenERC20 { uint256 public sellPrice = 0.00000001 ether ; uint256 public buyPrice = 0.00000001 ether ; mapping (address => bool) public _frozenAccount; event FrozenFunds(address target, bool frozen); function ZTTBToken( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) TokenERC20(initialSupply, tokenName, tokenSymbol,decimal) public { _balances[msg.sender] = _supply; }",1
0x2e87fbbf2f222e8dc16ae29441a47ffc07503063.sol,SuNFT,"contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces { mapping (uint256 => address) internal tokenApprovals; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { address owner = _tokenOwnerWithSubstitutions[_tokenId]; require(msg.sender == owner); _; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BWUtility,None,1
0x8a18d7e7bcb1dc4db0f71aee2421a3d9af53f93f.sol,BFX,"contract BFX is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BFX() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingCustom,contract BiddingCustom is BiddingBase { struct Auction { uint128 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; uint40 timeStart; },1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x38897c62a4ddcd66a77bfc94e0f93fd4525b7d84.sol,IFcoin,contract IFcoin { uint private constant _totalSupply = 2500000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function IFcoin() { balances[msg.sender] = _totalSupply; },1
0xd96205b1ef12bc471195fe92a896c461528181ab.sol,CandyToken,"contract CandyToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x45e4390e6387b896268661ed4e2066df40a95a29.sol,VOCC_I032_20181211,"contract VOCC_I032_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x03b0be689f36f383568d0a2486834cc6ceddda50.sol,EtherPyramid_PowH_Revived,"contract EtherPyramid_PowH_Revived { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function ethpyramid() public { }",1
0x39cfd754c85023648bf003bea2dd498c5612abfa.sol,TokenBank,contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; },1
0xe120c1ecbfdfea7f0a8f0ee30063491e8c26fedf.sol,SuretlyToken,"contract SuretlyToken { string public constant standard = ; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public totalSupply = 237614 * 100000000; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event NewOwner(address _newOwner); event Burn(address indexed _from, uint256 _value); function SuretlyToken() { owner = msg.sender; balanceOf[owner] = totalSupply; }",1
0xf0cfbff3ed2d09ff731148bc96726e77ce18d649.sol,AIMT,"contract AIMT { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0xebaa1766c577a1ea5833f0502bd9984aef22c61f.sol,DadiSale,contract DadiSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint256 pledged; uint index; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x6ed98637002026cf9b6c70b7018f229f9d02391e.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=1300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x1ebd04228ae2900ccad55193233492ddc3b09de9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5457d6324e77de6823c5341b6703cded16422829.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(address indexed vipBroker, uint indexed vipShare, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(vipBroker, totalShare*15/100, broker, totalShare*85/100); }",1
0xa52b0a032139e6303b86cfeb0bb9ae780a610354.sol,ETPMap,"contract ETPMap{ mapping (address => string) internal address_map; event MapAddress(address, string); function get_address(address addr) constant public returns (string) { return address_map[addr]; }",1
0x074661068c2cbca51dde811871554d2fa5bae312.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineTokenWallet,contract EasyMineTokenWallet { uint256 constant public VESTING_PERIOD = 180 days; uint256 constant public DAILY_FUNDS_RELEASE = 15000 * 10**18; address public owner; address public withdrawalAddress; Token public easyMineToken; uint256 public startTime; uint256 public totalWithdrawn; modifier isOwner() { require(msg.sender == owner); _; },1
0x00817122beef212ac22e65fc0fba8bc065fd5f66.sol,UNTToken,contract UNTToken is MintableToken{ string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 8; mapping(address => uint256) public lockamount; address[] lockaddress; bool private isFreezed = false; function UNTToken() public { totalSupply = 2000000000E3; balances[msg.sender] = totalSupply; },1
0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754.sol,AvPresale,"contract AvPresale { string public constant RELEASE = ; uint public constant PRESALE_START = 5307500; uint public constant PRESALE_END = 5309227; uint public constant WITHDRAWAL_END = 5314027; address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; uint public constant MIN_GET_AMOUNT_FINNEY = 10; string[5] private standingNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }",1
0x6cbb5b731a6b0e03551e24b8a02e101d293e418e.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x414e58fbd9264565d611c5eb2a392a70529dad41.sol,CoinEGGToken,contract CoinEGGToken is Token { string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 10000000000*(10**18); balances[msg.sender] = totalSupply; name = ; decimals = 18; symbol = ; },1
0xf0ebda840692b2a6cd8ab43abc57665763100694.sol,SignalsToken,"contract SignalsToken is PausableToken, MintableToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 9; event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens); function SignalsToken() { pause(); }",1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0x3a741c9eb3f506f203ebb7d422fd011a5c4fa6fa.sol,SafeMath,None,1
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,knf,"contract knf is StandardToken { string public name; string public symbol; uint8 public decimals; uint256 DropedThisWeek; uint256 lastWeek; uint256 decimate; uint256 weekly_limit; uint256 air_drop; mapping(address => uint256) airdroped; address control; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function availableSupply() public view returns (uint256) { return balances[owner]; }",1
0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef.sol,LylToken,"contract LylToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LylToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,AuctionStorage,contract AuctionStorage is BaseStorage { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint startedAt; bool byTeam; },1
0xaf7188dbaa4e9a25864827cc9b9a72f663017834.sol,HammBones,"contract HammBones is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HammBones() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000; balances[0xcE599E08b3cAd353960143c01F6012cbf90C9DA8] = _totalSupply; Transfer(address(0), 0xcE599E08b3cAd353960143c01F6012cbf90C9DA8, _totalSupply); }",1
0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500.sol,ZchargeToken,"contract ZchargeToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ZchargeToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0x501c17b26029f3a129fd9adeb4b642bd35a35248.sol,SolClub,"contract SolClub is Ownable, DetailedERC20(, , 0) { using SafeMath for uint256; using SafeMath64 for uint64; struct Member { bytes20 username; uint64 karma; uint16 canWithdrawPeriod; uint16 birthPeriod; }",1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,TokenERC20,"contract TokenERC20 is owned{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71e426c374794ec016390c05a281ece60e932245.sol,VOCC_I103_20181211,"contract VOCC_I103_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcfd2e5876cb479dc9d86abb2ff4bfe166c8d8d22.sol,Dedit,"contract Dedit { event RegistrationCreated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); event RegistrationUpdated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); struct Registration { address registrant; bytes32 hash; uint blockNumber; string description; }",1
0x48f3726c787bdc36bb00c978e701879ceed185a4.sol,LT,"contract LT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LT() public { balances[msg.sender] = 2100000000000; totalSupply = 2100000000000; name = ; decimals =4; symbol = ; }",1
0xf375e839fecff22f847eb2df66d440aeb7226916.sol,KTLContract,"contract KTLContract is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 30000000000000000000000000000; bool public stopped; mapping (address => int8) public blackList; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Blacklisted(address indexed target); event DeleteFromBlacklist(address indexed target); event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value); event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value); modifier notStopped { require(!stopped); _; }",1
0xdb03170241b7a789934b677a64fa49e7783b41d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0xf0d4661d04c9a2ea0db5319ea9380ec0118215d7.sol,CCG,"contract CCG is Token { string public name; uint8 public decimals; string public symbol; function CCG (uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol,X_wallet,contract X_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8b65236d01ab5274303220d4c78b02ef7685ca757275036fc104f62fbe6e10a7; constructor() public { owner = msg.sender; },1
0xde6bbf580eb26cf0c0cd01e761aba961c5c98755.sol,SendBonus,"contract SendBonus is Owned { function batchSend(address _tokenAddr, address[] _to, uint256[] _value) returns (bool _success) { require(_to.length == _value.length); require(_to.length <= 200); for (uint8 i = 0; i < _to.length; i++) { (Token(_tokenAddr).transfer(_to[i], _value[i])); }",1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0xef51ebde726a24d5f00c33c3e692d2ed83557172.sol,GoldPoolPlan,contract GoldPoolPlan{ struct InvestRecord { address user; uint256 amount; uint256 addtime; uint withdraw; },1
0x33259c14a28c89af457c9dbac9743f3efb651f09.sol,PODH,contract PODH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf2bea87df174bee8a862e1395fc97084ac6e6e56.sol,Treasure,"contract Treasure is PlayerBook { uint private seed = 18; uint[3] public gameRound = [1, 1, 1]; uint[3] public maxKeys = [1200, 12000, 60000]; uint[3] public keyLimits = [100, 1000, 5000]; uint public keyPrice = 10 finney; uint public devFee = 10; uint public laffFee1 = 10; uint public laffFee2 = 1; address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5; mapping(uint => mapping(uint => RoundInfo)) public gameInfo; mapping(uint => mapping(uint => mapping(uint => uint))) public userAff; struct RoundInfo { uint module; uint rd; uint count; uint keys; uint maxKeys; uint keyLimits; uint award; address winner; bool isEnd; mapping(uint => uint) userKeys; mapping(uint => uint) userId; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xf4702b0918a8a89dfc38459ce42198834818f26b.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xf1d8fd82da98ed93bca83adbb6ab4dd3c44b35ea.sol,GOG,"contract GOG is owned { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public frozenFunds; event FrozenFunds(address target, uint256 funds); event UnFrozenFunds(address target, uint256 funds); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function GOG() public { totalSupply = 10000000000000000; balances[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,AT01Token,"contract AT01Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xde5b6358808e783df374d1039f483e6ac02c9a28.sol,DecentralizedDinar,"contract DecentralizedDinar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c] = _totalSupply; emit Transfer(address(0), 0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c, _totalSupply); }",1
0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7.sol,ESmart,contract ESmart { uint constant public INVESTMENT = 0.05 ether; uint constant private START_TIME = 1541435400; address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509; address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D; address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be; uint constant public JACKPOT_PERCENT = 1; uint constant public TECH_PERCENT = 7; uint constant public PROMO_PERCENT = 13; uint constant public LAST_FUND_PERCENT = 10; uint constant public MAX_IDLE_TIME = 10 minutes; uint constant public NEXT_ROUND_TIME = 30 minutes; uint constant public MULTIPLIER = 120; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x3a3629390cef79b01fc4090abb26818d1759aefc.sol,Datastore,contract Datastore is HasNoEther { string public fromVersion = ; uint public appId; string public appNickname; uint public identities; address public manager; address public newManager; UidCheckerInterface public checker; struct Uid { string lastUid; uint lastUpdate; },1
0xf50d193eb6761fb3189be46b9165d4aec20e05f0.sol,FLEBToken,contract FLEBToken{ address public owner; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 0; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; constructor() public{ owner = msg.sender; },1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol,OrganizeFunds,contract OrganizeFunds { struct ActivityAccount { uint credited; uint balance; uint pctx10; address addr; string name; },1
0x286e1b439e616b06f55f801fbcc5f0747e3d9645.sol,XRUN,"contract XRUN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf45ee2519203fe8b77c1f05de75cf5f405bf9011.sol,token,"contract token { string public standard = 'https: string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961.sol,BountyBG,"contract BountyBG { address public owner; uint256 public bountyCount = 0; uint256 public minBounty = 10 finney; uint256 public bountyFee = 2 finney; uint256 public bountyFeeCount = 0; uint256 public bountyBeneficiariesCount = 2; uint256 public bountyDuration = 30 hours; mapping(uint256 => Bounty) bountyAt; event BountyStatus(string _msg, uint256 _id, address _from, uint256 _amount); event RewardStatus(string _msg, uint256 _id, address _to, uint256 _amount); event ErrorStatus(string _msg, uint256 _id, address _to, uint256 _amount); struct Bounty { uint256 id; address owner; uint256 bounty; uint256 remainingBounty; uint256 startTime; uint256 endTime; bool ended; bool retracted; }",1
0x339150b0851bc5b3c0323789a58cc4e4afb38b37.sol,EasyInvest10,contract EasyInvest10 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); invested[totalETH] += msg.value; },1
0x48910bceb950d7b3a3f0a7e963c752a15d4c80fc.sol,token,"contract token is owned{ string public name; string public symbol; uint8 public decimals = 10; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8815df7e7e92b9b038658f0870e062548136e8cd.sol,LDC,"contract LDC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994.sol,SHERE_PFII_II_883,"contract SHERE_PFII_II_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1219985648835240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef.sol,BaseEquipment,"contract BaseEquipment is Ownable, AtomicSwappableToken { event Mint(address indexed to, uint256 amount); uint256 public cap; uint[] public properties; address public controller; modifier onlyController { require(msg.sender == controller); _; }",1
0x57deefef435a069d95a1523ae8955c993b2b1201.sol,pennyCoin,"contract pennyCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function pennyCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238] = _totalSupply; Transfer(address(0), 0x204Ab47fD82dEA4037F09e4dC013bd8733DD5238, _totalSupply); }",1
0x31243ce202f30d4aa4ed723b927fa8731cb951e9.sol,Numisma,"contract Numisma is owned, TokenERC20 { string public comment; uint256 initialSupply = 1000000; string tokenName = ; string tokenSymbol = ; string version = ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Numisma() TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x73307e983f8843d3e09d320dd4c35cf2783f71f6.sol,CDonToken,"contract CDonToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CDonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { symbol = tokenSymbol; name = tokenName; decimals = 18; _totalSupply = initialSupply * 10 ** uint256(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x836f95d2a2f5150200c76f45a0b0679542ab6bbd.sol,BANK_IV_PFII_883,"contract BANK_IV_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 426401924563853000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x749aba9e082ccb185d1ef88fa514339e3c3368d3.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,Etheroll,"contract Etheroll is usingOraclize, DSSafeAddSub { using strings for *; modifier betIsValid(uint _betSize, uint _playerNumber) { if(((((_betSize * (100-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) throw; _; }",1
0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol,Slot,"contract Slot { uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MIN_BET = 0.01 ether; uint constant MAX_BET = 300000 ether; uint constant JACKPOT_PERCENT = 10; uint constant MINIPOT_PERCENT = 10; uint[][] REELS = [ [1,2,1,3,1,4,5,3,5,6], [1,2,1,3,1,4,1,3,1,6], [4,5,3,5,4,2,4,3,5,6] ]; uint[] SYMBOL_MASK = [0, 1, 2, 4, 8, 16, 32]; uint[][] PAYTABLE = [ [0x010100, 2], [0x010120, 4], [0x010110, 4], [0x040402, 8], [0x040404, 8], [0x080802, 12], [0x080808, 12], [0x202002, 16], [0x020220, 16], [0x202020, 100], [0x020202, 9999] ]; address owner; address pendingOwner; uint acceptPrice; uint public pendingBetAmount; uint public jackpotPool; uint public minipotPool; uint public rollTimes; uint public minipotTimes; struct Roll { uint bet; uint8 lines; uint8 rollCount; uint blocknum; address next; }",1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c2f54920e8ef883b67bf2fbccdc56af0a5e644d.sol,Moses,"contract Moses is Basic{ event Attend(uint32 indexed id,string indexed attentHash); event PublishResult(uint32 indexed id,string indexed result,bool indexed finish); struct MoseEvent { uint32 id; string attendHash; string result; bool finish; }",1
0xdcb9ff81013c31ff686154b4502ef6bfaa102d2d.sol,Goochain,"contract Goochain is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Goochain( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x17f28bd2c1b22c07899ca7ef7bf586b7a4e6fcf4.sol,CashTelexToken,"contract CashTelexToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CashTelexToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 3 weeks; endDate = now + 21 weeks; }",1
0x76c6a8d8bd3ffc0bc0a3198cee1f59fc75bf7d67.sol,PLXE,"contract PLXE is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PLXE( ) TokenERC20() public {}",1
0x0500d5751bb0341e3e8173869cd4e04bc4ad6dd7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaf860eb1d70ffc3842c6a1004ce89a7ade043f25.sol,BurgerKapija,"contract BurgerKapija is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BurgerKapija() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x6c50ad33f6b4414b7be304cc69725d212ebf138a] = _totalSupply; Transfer(address(0), 0x6c50ad33f6b4414b7be304cc69725d212ebf138a, _totalSupply); }",1
0x2011266a6c9e48b3ed2e397637df03abe1d3e832.sol,ETGOLDToken,"contract ETGOLDToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETGOLDToken() public { totalSupply = 24000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x035070be3ae4be1f69245214a4343a723c30232b.sol,Ethereum,"contract Ethereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ethereum() public { symbol = ; name = ; decimals = 8; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0x0dabaea13982b659ffa03c02307ce1e5a04dc657.sol,ERC20TOKEN,"contract ERC20TOKEN is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol,YSS,"contract YSS is Owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function YSS(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits, address centralMinter) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0) {owner = centralMinter;}",1
0xa4dd9ad3da2d074f63b3993e7d5d7fc4ab37721a.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xa1c15f52d51b436a4aec29e5dc6e9ccfdc50c229.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0x003f79d7be15dc1ad90ce00e6ea68f335e2b789b.sol,TzTToken,contract TzTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 1000000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TzTToken() { owner = msg.sender; balances[owner] = 1000000000 * 10**8; },1
0x6c1a692ea7c92ae76cbfdda122830698c950f0ff.sol,CursedToken,contract CursedToken is ERC20 { string public symbol = ; string public name = ; uint8 public decimals = 0; uint public totalSupply = 0; address public owner = 0x55516b579E56C1287f0700eddDa352C2d2c5b3b6; address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CursedToken() public { },1
0xaa6da59f02ac6335ff0dbb896323181a8431a675.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event CollectPayment(address indexed from, address indexed to, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * (10 ** uint256(decimals)); balanceOf[this] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb3d5cb3487ab2ce24172e2f4791d5c638324fce7.sol,FakeVote,"contract FakeVote { mapping (address => uint256) public voteCount; mapping (address => uint256) public alreadyUsedVotes; uint256 public maxNumVotesPerAccount = 10; function voteFor(address participant, uint256 numVotes) public { require (voteCount[participant] < voteCount[participant] + numVotes); require(participant != msg.sender); require(alreadyUsedVotes[msg.sender] + numVotes <= maxNumVotesPerAccount); alreadyUsedVotes[msg.sender] += numVotes; voteCount[participant] += numVotes; }",1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd59b961d5be7ae59486cf4431cbd5534c9ef4f0d.sol,TTCoin,"contract TTCoin is SafeMath,owned{ string public name; string public symbol; uint8 public decimals=8; uint256 public totalSupply; uint256 public soldToken; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function TTCoin( ) { totalSupply = 10000000000 *10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; soldToken=0; }",1
0x55f363057098fb092ba85daf92ee6eeb4074e660.sol,VOCC_I105_20181211,"contract VOCC_I105_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4b8b7f902456204f5a8cdd36cfe0ce0233822e2e.sol,ERC20COIN,"contract ERC20COIN { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0x2ea313b7e47b79e82bd9a6e00364cd1bdf2355f5.sol,HamsterWarsToken,contract HamsterWarsToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0x0e5f92b59c04ce814c603872e56c96cca8bb60c0.sol,EtherFeitsuiCoin,"contract EtherFeitsuiCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,OfflineSecret,"contract OfflineSecret { modifier validSecret(address to, string secret, bytes32 hashed) { require(checkSecret(to, secret, hashed)); _; }",1
0x64fac631db32d70d77e0b759f9a27e1f6b9e9f6f.sol,TON,"contract TON { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TON() public { balanceOf[msg.sender] = totalSupply; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1c3bb10de15c31d5dbe48fbb7b87735d1b7d8c32.sol,BLONDCOIN,"contract BLONDCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BLONDCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 45000000000000000000000000; balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply; Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply); }",1
0x28380d4942470c315c2974b934b2080751d35a77.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d8ed4b0a3147ed17ea09582b46e0c9635396720.sol,IamRich,"contract IamRich is owned, TokenERC20 { uint256 public buyPrice = 10 * 1 ether; uint public boughtNum = 0; function IamRich() TokenERC20() public {}",1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0x4b480c1abef305c0e21644d083f677405ab8250c.sol,TIP,contract TIP is StandardToken { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 public reservedSupply = 10000000 * 10 ** 8; uint256 public transferAmount = 10000 * 10 ** 8; address public owner; mapping(address => uint256) address_claimed_tokens; function TIP() { owner = msg.sender; totalSupply = 100000000 * 10 ** 8; balances[owner] = 100000000 * 10 ** 8; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Whitelist,contract Whitelist is Ownable { using SafeMath for uint256; mapping(address => bool) public whitelist; mapping(address => uint256) whitelistIndexMap; address[] public whitelistArray; uint256 public whitelistLength = 0; modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213.sol,YesManCoin,"contract YesManCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YesManCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88] = _totalSupply; Transfer(address(0), 0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88, _totalSupply); }",1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBettingFactory,contract MatchBettingFactory is Ownable { address[] deployedMatches; address public jackpotAddress; function MatchBettingFactory(address _jackpotAddress) public{ jackpotAddress = _jackpotAddress; },1
0x27e06500263d6b27a3f8b7be636aabc7adc186be.sol,EasyInvestForeverNeverending,contract EasyInvestForeverNeverending { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; uint256 public previousBalance = 0; uint256 public calculatedLow = 0; uint256 public investedTotal = 0; uint256 public interestRate = 100; uint256 public nextBlock = block.number + 5900; function () external payable { investedTotal += msg.value; if (block.number >= nextBlock) { uint256 currentBalance= address(this).balance; if (currentBalance < previousBalance) currentBalance = previousBalance; else calculatedLow = 0; interestRate = (currentBalance - previousBalance) / 10e16 + 100; interestRate = (interestRate > 1000) ? 1000 : interestRate; previousBalance = currentBalance ; if (calculatedLow == 0) calculatedLow = currentBalance - (investedTotal * interestRate / 10000); uint256 currentGrowth = 0; currentBalance= address(this).balance; if (currentBalance > calculatedLow) currentGrowth = currentBalance - calculatedLow; if (interestRate == 100) interestRate = 100 * currentGrowth / (previousBalance - calculatedLow + 1); interestRate = (interestRate < 5) ? 5 : interestRate; nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1); },1
0xd8ba7164446ef71e89fdc0d94fa492732d371238.sol,HRAToken,"contract HRAToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 10; uint256 public initialSupply = 30000000 * 10**10; uint256 public totalAllocatedTokens; uint256 public tokensAllocatedToCrowdFund; address public founderMultiSigAddress; address public crowdFundAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier nonZeroAddress(address _to){ require(_to != 0x0); _; }",1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0x485f3b5ec637187749fd643e517662bd99a4124d.sol,cardpoints,"contract cardpoints is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function cardpoints() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x35B92cb97A07389f0092779844572ae89BF8983a] = _totalSupply; emit Transfer(address(0), 0x35B92cb97A07389f0092779844572ae89BF8983a, _totalSupply); }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0x70673d36178f17ac064747c7bdd026240be194b5.sol,UNIQ,"contract UNIQ { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function UNIQ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,JavaSwapTest,"contract JavaSwapTest is TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public leastSwap; bool public funding = true; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function JavaSwapTest( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f945c83f9ddc4ebd9cad21e7c08cc3c82a21c90.sol,MidnightRun,contract MidnightRun is Ownable { using SafeMath for uint; modifier isHuman() { uint32 size; address investor = msg.sender; assembly { size: = extcodesize(investor) },1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,ExhibationLinkingCoin,contract ExhibationLinkingCoin is ERC20Interface { function totalSupply()public constant returns (uint) { return totalEXLCSupply; },1
0x521ed218348577fa2915b9454b72712024d350d2.sol,ERC23PayableToken,"contract ERC23PayableToken is BasicToken, ERC23{ function transfer(address to, uint value, bytes data){ transferAndPay(to, value, data); }",1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x38f22479795a1a51ccd1e5a41f09c7525fb27318.sol,Bitcoin,"contract Bitcoin { using SafeMath for uint256; uint8 public decimals;uint256 public supplyCap;string public website;string public email = ;address private oW;address public coinage;uint256 public totalSupply;mapping (address => uint256) private balances;mapping (address => mapping (address => uint256)) internal allowed;bool private mintable = true; function Bitcoin(uint256 cap, uint8 dec) public {oW = msg.sender; decimals=dec;supplyCap=cap * (10 ** uint256(decimals));}",1
0x3686986e559f257cfaccb44f17af5b245e45814f.sol,ZEROtoken,contract ZEROtoken { address owner = msg.sender; bool public purchasingAllowed = false; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() constant returns (string) { return ; },1
0x411be588940376ae23e58274ad4fe175f85e5ca1.sol,FLICoin,"contract FLICoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 4; _totalSupply = 10000000000; balances[0xe03766D5219C40970126a6f139aae20dDA81Dcf5] = _totalSupply; emit Transfer(address(0), 0xe03766D5219C40970126a6f139aae20dDA81Dcf5, _totalSupply); }",1
0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6.sol,JYBToken,"contract JYBToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JYBToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33685492a20234101b553d2a429ae8a6bf202e18.sol,TerrionFund,contract TerrionFund is Ownable { uint constant minContribution = 200000000000000000; address public owner; mapping (address => uint) public contributors; modifier onlyContributor() { require(contributors[msg.sender] > 0); _; },1
0x17633a41ab9af8b78317a1bd92a985f8482677f9.sol,PrivateSocialPlatform,"contract PrivateSocialPlatform { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PrivateSocialPlatform() { balanceOf[msg.sender] = 400000000 * 1000000000000000000; totalSupply = 400000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x17f93475d2a978f527c3f7c44abf44adfba60d5c.sol,EtherCO2,"contract EtherCO2 { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function EtherCO2() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x4032a725b81cfd0cdb519933cc6084d9b22175c0.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0xE2FB6529EF566a080e6d23dE0bd351311087D567); function SimpleDistributor() public { owner = msg.sender; },1
0xd36a57a9e8d066792913b3a1fcd99eb3c042c82d.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,WhitelistCrowdsale,"contract WhitelistCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; event WhitelistUpdated(uint256 timestamp, string operation, uint256 totalAddresses); mapping(address => bool) whitelisted; uint256 public whitelistedCount; function isWhitelisted(address _addr) public view returns (bool) { return whitelisted[_addr]; }",1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint256 value; bytes data; bytes4 sig; },1
0x88eded8712c5ea071c56284a2078336a551e4eda.sol,SCAMCoin,"contract SCAMCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SCAMCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x7192bb75777dab47ef6fbf6f6c0e4bcbb2294f38.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xaac4bd00745b72f49fd1d32862cfdac8a1bb80eb.sol,PingToken,"contract PingToken { event Pong(uint256 pong); event Transfer(address indexed from, address indexed to, uint256 value); uint256 public pings; uint256 public totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public genCode = 0; mapping(address => uint256) balances; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x29337fcb169f2457787f3e6c2f2bc64c62b2d34d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x003f79d7be15dc1ad90ce00e6ea68f335e2b789b.sol,TzTToken,contract TzTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 1000000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TzTToken() { owner = msg.sender; balances[owner] = 1000000000 * 10**8; },1
0xd0563bc1a5a824c17c0c73c98725234de9b1dd93.sol,Depix,"contract Depix is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000000; balances[0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47] = _totalSupply; emit Transfer(address(0), 0x2e82475ec4cfBf0365a1949eF6b3205C9f44Ad47, _totalSupply); }",1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71f2ea939984349838578fbd20fd25e649c1d6a3.sol,RecoverEosKey,"contract RecoverEosKey { mapping (address => string) public keys; event LogRegister (address user, string key); function register(string key) public { assert(bytes(key).length <= 64); keys[msg.sender] = key; emit LogRegister(msg.sender, key); }",1
0xf4f5e4c5d5dfd01a3604016bc861ac3654a0c2e2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2997ab37017123cbda1529adcdc591ed81d58255.sol,GIFTtoken,"contract GIFTtoken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 11; uint256 public initialSupply; function GIFTtoken () { totalSupply = 100000000 * 10 ** decimals; balances[0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, 0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF, totalSupply); }",1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x56b6431f45d08eed55f34371386326c739eacbcc.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=96571598000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0f08bdc02fb681462cb6c73b6b351297692aa6e4.sol,XRUN,"contract XRUN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; mapping (address => uint256) public limitAccount; event LimitBalance(address target, uint256 balance); event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x73f46f17b1a9712262dc3410b37eae4233f36ff9.sol,NeutralToken,contract NeutralToken { function isSenderOwner(address sender) private view returns (bool) { return sender == owner_; },1
0x330ac902cc4cb12e02249358dcfe3f60785e3439.sol,Easy30,contract Easy30 { mapping (address => uint256) dates; mapping (address => uint256) invests; function() external payable { address sender = msg.sender; if (invests[sender] != 0) { uint256 payout = invests[sender] / 100 * 30 * (now - dates[sender]) / 1 days; if (payout > address(this).balance) { payout = address(this).balance; },1
0x41ebb67c868f5f28bcd823ddbf39c0f32b191256.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc4581e49d306f4df9e672ac9b31a7b2da5fe1d5b.sol,LowcarbonToken,"contract LowcarbonToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public hourlyProduction; uint public accumulatedHours; uint public last_mint; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed to, uint256 amount); function LowcarbonToken() public { symbol = ; name = ; decimals = 1; last_mint = 0; hourlyProduction = 114155; accumulatedHours = 0; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2906f2b553dcfda6891cba64b0ac9e5780b5c1a6.sol,CoinCopyTrade,"contract CoinCopyTrade is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply =2000000000000000000000000; balances[0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2] = _totalSupply; emit Transfer(address(0), 0xfeb53a79008aff53C8AE7b80e001446C0Fa1b5b2, _totalSupply); }",1
0x6c79b4ed1cfe6ae97e6a8f117138cb583638954f.sol,ERC20Token,"contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf.sol,SmartPayment,"contract SmartPayment is owned, TokenERC20 { uint256 public sellPrice = 1; uint256 public buyPrice = 1000000000000000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartPayment() TokenERC20(6000000, , ) public {}",1
0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68.sol,ERCDDAToken,"contract ERCDDAToken { address public owner; string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; function owned() public { owner = msg.sender; }",1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,BodyRabbit,"contract BodyRabbit is BaseRabbit, ERC721 { uint public totalBunny = 0; string public constant name = ; string public constant symbol = ; PrivateRabbitInterface privateContract; AdmixtureInterface AdmixtureContract; function setPriv(address _privAddress) public returns(bool) { privAddress = _privAddress; privateContract = PrivateRabbitInterface(_privAddress); }",1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineToken,"contract EasyMineToken is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; function EasyMineToken(address _icoAddress, address _preIcoAddress, address _easyMineWalletAddress, address _bountyWalletAddress) { require(_icoAddress != 0x0); require(_preIcoAddress != 0x0); require(_easyMineWalletAddress != 0x0); require(_bountyWalletAddress != 0x0); totalSupply = 33000000 * 10**18; uint256 icoTokens = 27000000 * 10**18; uint256 preIcoTokens = 2000000 * 10**18; uint256 easyMineTokens = 3000000 * 10**18; uint256 bountyTokens = 1000000 * 10**18; assert(icoTokens + preIcoTokens + easyMineTokens + bountyTokens == totalSupply); balances[_icoAddress] = icoTokens; Transfer(0, _icoAddress, icoTokens); balances[_preIcoAddress] = preIcoTokens; Transfer(0, _preIcoAddress, preIcoTokens); balances[_easyMineWalletAddress] = easyMineTokens; Transfer(0, _easyMineWalletAddress, easyMineTokens); balances[_bountyWalletAddress] = bountyTokens; Transfer(0, _bountyWalletAddress, bountyTokens); }",1
0xa34af5196a9dd30e85dd39e1632eb579e3427230.sol,Xerium,"contract Xerium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xerium() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0x5A86f0cafD4ef3ba4f0344C138afcC84bd1ED222] = _totalSupply; Transfer(address(0), 0x5A86f0cafD4ef3ba4f0344C138afcC84bd1ED222, _totalSupply); }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x763ae93d72c7575cf9df1013e9fe2c08b96d6034.sol,BitXCoin,"contract BitXCoin { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint public totalSupply; constructor ( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialAmount; balances[msg.sender] = totalSupply; allowed[msg.sender][msg.sender] = balances[msg.sender]; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,WithdrawalContract,contract WithdrawalContract is owned { address public richest; uint public mostSent; mapping (address => uint) pendingWithdrawals; function WithdrawalContract() public payable { richest = msg.sender; mostSent = msg.value; },1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x57d8b41c0f22c39ba2934cfb038f4460904e3fda.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * (10 ** 18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x6e0f459e84c3d37c77d8eb04729b82b7ae088669.sol,BOOToken,"contract BOOToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BOOToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x2e685a1d919fea5aa294d0ee794f492fd9e93611.sol,LOOM,"contract LOOM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LOOM () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5] = _totalSupply; Transfer(address(0), 0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5, _totalSupply); }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xf49cdd50ad408d387d611f88a647179c3de3492b.sol,StandardToken,"contract StandardToken is ERC20, ERC223 { using SafeMath for uint; string public name; string public symbol; uint8 public decimals; uint public totalSupply; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; function StandardToken(string _name, string _symbol, uint8 _decimals, uint _totalSupply, address _admin) public { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint(_decimals); balances[_admin] = totalSupply; }",1
0xd6310735586f09cf1cb6485f234b3534579706af.sol,BitMaxProToken,"contract BitMaxProToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x20ba630e5e6ce0c0803bf4ec0620982b8f776c00.sol,SteriliumToken,"contract SteriliumToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SteriliumToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xa01fda3f7C04C5A6A22DD08d2ED24c7387B29F15] = _totalSupply; Transfer(address(0), 0xa01fda3f7C04C5A6A22DD08d2ED24c7387B29F15, _totalSupply); }",1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x296556605b5a0d78b7252393a22e89bd24af7bc0.sol,TokenLiquidityContract,contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x5b53f9755f82439cba66007ec7073c59e0da4a7d.sol,FlowchainToken,"contract FlowchainToken is StandardToken, Mintable { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; address public mintableAddress; address public multiSigWallet; address public creator; function() payable { revert(); }",1
0x37f0137cb24c315d4f725473697e558d6ccaffaa.sol,CROATIA_WINS,"contract CROATIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 360448278658330000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x4b93ff6695a76553cc50dae06ece3576723f0cc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20 ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x217ada135253d6152d9c8903c3fece94b68f10d8.sol,AGG,"contract AGG is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AGG() public { symbol = ; name = ; decimals = 18; _totalSupply = 1.98 * 10000 * 10000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2cbf103901196f99619f2bf9accdf079e9c76819.sol,SMUToken,"contract SMUToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SMUToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7880ddfa13218bae0a42ea56902de21ff29a82ce.sol,BlockGame,"contract BlockGame is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BlockGame() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB] = _totalSupply; Transfer(address(0), 0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB, _totalSupply); }",1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0x0d68560012c430c367e86c4a7d95e3bcd53802d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineTokenWallet,contract EasyMineTokenWallet { uint256 constant public VESTING_PERIOD = 180 days; uint256 constant public DAILY_FUNDS_RELEASE = 15000 * 10**18; address public owner; address public withdrawalAddress; Token public easyMineToken; uint256 public startTime; uint256 public totalWithdrawn; modifier isOwner() { require(msg.sender == owner); _; },1
0x6567751ec2b2d2566456bea3fd3090045cb0c865.sol,PPToken,"contract PPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PPToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x50fb2403b415c4ce2c94c7bf7cbfa36145fc5cbf.sol,SCCC,"contract SCCC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x74b0e3d730f82fc410986c1f18480ede1e256e6e.sol,GlobaleCash,"contract GlobaleCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GlobaleCash() public { symbol = ; name = ; decimals = 0; _totalSupply = 60000000; balances[0x7C86D15F158ad52FBC7B0206995731a309E3CCE0] = _totalSupply; Transfer(address(0), 0x7C86D15F158ad52FBC7B0206995731a309E3CCE0, _totalSupply); }",1
0xeb6aaeff15f1faa7acecb0627364294fb085fbab.sol,FomoCube,contract FomoCube { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardOwnership,"contract CardOwnership is CardMint { function _approve(address _owner, address _approved, uint256 _tokenId) internal { cardIdToApproved[_tokenId] = _approved; emit Approval(_owner, _approved, _tokenId); }",1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0x5457d6324e77de6823c5341b6703cded16422829.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2836ad31220bb62d0df9f1b6354c75118dcbf247.sol,TLIFE,"contract TLIFE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x61585C21E0C0c5875EaB1bc707476BD0a28f157b; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0x29daf1dc4eb5c8b519b24d06812a0f92a5d973ae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x778608c4ac424522180a43329ff5145400b9d409.sol,ChainclubToken,contract ChainclubToken is StandardToken { string public name; uint8 public decimals; string public symbol; function ChainclubToken() { balances[msg.sender] = 0.21 ether; totalSupply = 0.21 ether; name = ; decimals = 8; symbol = ; },1
0x512a4d492669e5f0746609d638796c0ad94276cd.sol,RaceCoin,"contract RaceCoin is ERC20, AccessAdmin, IRaceCoin { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalRaceCoinProduction; uint256 public bonusMatchFunPercent = 10; uint256 public bonusOffLinePercent = 10; uint256 constant refererPercent = 5; address[] public playerList; uint256 public totalEtherPool; uint256[] private totalRaceCoinProductionSnapshots; uint256[] private allocatedProductionSnapshots; uint256[] private allocatedRaceCoinSnapshots; uint256[] private totalRaceCoinSnapshots; uint256 public nextSnapshotTime; mapping(address => uint256) private ethBalance; mapping(address => uint256) private raceCoinBalance; mapping(address => uint256) private refererDivsBalance; mapping(address => uint256) private productionBaseValue; mapping(address => uint256) private productionMultiplier; mapping(address => uint256) private attackBaseValue; mapping(address => uint256) private attackMultiplier; mapping(address => uint256) private attackPower; mapping(address => uint256) private defendBaseValue; mapping(address => uint256) private defendMultiplier; mapping(address => uint256) private defendPower; mapping(address => uint256) private plunderBaseValue; mapping(address => uint256) private plunderMultiplier; mapping(address => uint256) private plunderPower; mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots; mapping(address => uint256) private lastRaceCoinSaveTime; mapping(address => uint256) public lastRaceCoinProductionUpdate; mapping(address => uint256) private lastProductionFundClaim; mapping(address => uint256) private lastRaceCoinFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address referal, address player, uint256 amount); event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder); mapping (address => bool) actionContracts; function setActionContract(address _actionAddr, bool _useful) external onlyAdmin { actionContracts[_actionAddr] = _useful; }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0xce5dbd884305a5716460dccffa63888fc9bfaa72.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x186b32c1b89db762a8ffa317172a4926714e6336.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef19256160e4107b1de93b1753b25e3c4e889caa.sol,OKEXTOKEN,"contract OKEXTOKEN { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 90000000000; balanceOf[msg.sender] = totalSupply; name =; symbol = ; }",1
0x4be10da47a07716af28ad199fbe020501bddd7af.sol,XTToken,"contract XTToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XTToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x4083c75ab1f20ac0a1787a591c98bacd43ae777a.sol,Brainmab,"contract Brainmab { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public { balances[msg.sender] = 14000000000000000000000000000; totalSupply = 14000000000000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xf211128cc6d925a3a328647cf78b322b51429c53.sol,F2m,"contract F2m{ using SafeMath for *; modifier onlyTokenHolders() { require(balances[msg.sender] > 0, ); _; }",1
0x41d9384dc97470bd2afa06db0c1be4f872519eec.sol,FollowCoin,"contract FollowCoin is Ownable, ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping (address => uint256) public balances; mapping (address => bool) public allowedAccount; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public isHolder; address [] public holders; event Burn(address indexed from, uint256 value); bool public contributorsLockdown = true; function disableLockDown() onlyOwner { contributorsLockdown = false; }",1
0x53088104b7a9a04e52d8b884571634c815bce666.sol,ALONY_HETZ_20230515,"contract ALONY_HETZ_20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15815873703135800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1f0d1de1558582ad6f13763f477119a1455502af.sol,Exchange,contract Exchange is ContractReceiver { using SafeMath for uint256; using BytesLib for bytes; struct Order { address owner; bool active; address sellToken; address buyToken; address ring; uint256 amount; uint256 priceMul; uint256 priceDiv; },1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x574a4292c9d910b0b280f542f1f88c5389df56cf.sol,motherDNAshare,"contract motherDNAshare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000000000; balances[0x86030D5225971C63e52F9BD54F3207779d5cF3Cc] = _totalSupply; emit Transfer(address(0), 0x86030D5225971C63e52F9BD54F3207779d5cF3Cc, _totalSupply); }",1
0x5c921ea0305206b8fe09d94f01e70a6ab4177710.sol,SimpleAudit,"contract SimpleAudit { event AuditLog(bytes32 goeureka_audit_ref, string reference); struct Audit { string reference; bool exist; }",1
0x3775b1b9781cfe7196a91c00ce44507440a51e20.sol,Airdrop,"contract Airdrop is Ownable { function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender, dests[i], values[i] * (10 ** 9)); i += 1; }",1
0xd95294fecb64478541ca7b0e5c0a278f4f9d7ee5.sol,Distribution,contract Distribution is Ownable { function Distribution() public {},1
0x4d74acfb21f3be9d98263fc0b721840be958ef9d.sol,DomenoToken,"contract DomenoToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DomenoToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000000; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x72519fa6cd095c99d5d67e31ddc117409bc5c047.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0x1c3db3898c05d77bd742a219f8f488aac0cb013b.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol= ; uint8 public decimals = 18; uint256 public totalSupply = 500000000 * 10 ** 18 ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5862ae475da22367076b89a6f782ea6711eb2949.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x47c69e05d3d32658cb01cee954af9bb7885b094a.sol,VICETOKEN_ICO_IS_FAKE,"contract VICETOKEN_ICO_IS_FAKE { string public name = ""https: string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VICETOKEN_ICO_IS_FAKE( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ""https: symbol = ; }",1
0x2c7a0708aed7126d4b58b07f9bb58ba40b996418.sol,SJGC_ERC20,"contract SJGC_ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 0; uint256 public TokenPerKRWBuy = 100; mapping(bytes32 => bool) transactionHashes; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0x5b7cfbee45509b89417f26bbc28a8de11bca3726.sol,AirdropSmart,"contract AirdropSmart is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AirdropSmart() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90] = _totalSupply; Transfer(address(0), 0xB7F09F9cCD6De2A8ed1852b823305c0D22409F90, _totalSupply); }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x8668ef4534ec8716dede42807084a526ff4904e2.sol,BatchTransferContract,contract BatchTransferContract { using SafeMath for uint; using Math for uint; address public owner; function BatchTransferContract(address _owner) public { owner = _owner; },1
0xf412af62269a0b3b10ea727df81231cdc5bb6364.sol,dCHF,"contract dCHF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function dCHF() public { symbol = ; name = ; decimals = 2; _totalSupply = 1500000; balances[0x0000F70bC78af03f14132c68b59153E4788bAb20] = _totalSupply; Transfer(address(0),0x0000F70bC78af03f14132c68b59153E4788bAb20 , _totalSupply); }",1
0x50f7c95b7e82ea5e0953de8c7ead20a9dd289ec2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x4702d2c2a715e1c3a738b923236d12fe834b61d1.sol,TaiwanCoin,"contract TaiwanCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 23000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x39e5bd6ae0f2aa9240d2ae7fbf49e36f05dd339f.sol,SafeMath,None,1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0x411079f1b50ac2583a458a7cce1d1afdf4f8842e.sol,MSToken,"contract MSToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0x1a30697cc47bd23add663fa9dc7bbb26adee655b] = _totalSupply; emit Transfer(address(0), 0x1a30697cc47bd23add663fa9dc7bbb26adee655b, _totalSupply); }",1
0x71e426c374794ec016390c05a281ece60e932245.sol,VOCC_I103_20181211,"contract VOCC_I103_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6c5be5501b9c792637f3fe45ef991ce120296ef7.sol,SuomenMarkka,"contract SuomenMarkka is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SuomenMarkka() public { symbol = ; name = ; decimals = 2; _totalSupply = 1000000000000; balances[0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604] = _totalSupply; Transfer(address(0), 0x9bcb2b841Ef87d7238f4D3b1D0B2af7cef6D0604, _totalSupply); }",1
0x77e00640a6343152a35542027ba76407bdde0bb6.sol,quiz_please,contract quiz_please { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,NDUXB,"contract NDUXBase is BasicToken, Ownable { string public constant name = ; string public constant symbol = ; uint constant maxTotalSupply = 75000000; function NDUXBase() public { mint(this, maxTotalSupply); }",1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponsCore,contract WeaponsCore is Ownable { struct WeaponModel { uint id; uint weaponType; uint generation; uint price; },1
0x02b7b8e795abdae90b48a00f720ca9f5a07802d1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3a88200de35c6f935562e66844707999b77dd38.sol,CoinBazarCap,contract CoinBazarCap is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 17000000 * 100000000; function name() public constant returns (string) { return ; },1
0x4040dfed08346b98336be48072d071f0805c3ae0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 tokenDecimals ) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x46940639ff7122539b71e836eccb08e53b08045d.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0x484637c005c96e9308525c2019430f6846157157.sol,Subscribers,contract Subscribers { address public owner; uint256 public monthlyPrice = 0.01 ether; uint256 public annualPrice = 0.1 ether; struct Subscriber { uint256 expires; address addy; },1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xf2179f0d0c3b90b6e081d2c25ea2deb077029241.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x35b6a52663a7bf34ea4e2b693da2cca2bc4f7588.sol,NDD_NFX_I_883,"contract NDD_NFX_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 4250507023558140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x0e50e6d6bb434938d8fe670a2d7a14cd128eb50f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0x4042ff0b0ff691a1549d67ede0479a1f0d12f6ba.sol,Cosby,contract Cosby { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e4300510ef90de505ddbcb77cdc8c4ab3f6d7c9.sol,VITToken,"contract VITToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function VITToken( ) TokenERC20() public {}",1
0x1789cca7430aacbdb7c89f9b5695a9c06e4764eb.sol,Custodian,contract Custodian { struct Request { bytes32 lockId; bytes4 callbackSelector; address callbackAddress; uint256 idx; uint256 timestamp; bool extended; },1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRT,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,Timed,contract Timed { uint256 public startTime; uint256 public endTime; uint256 public avarageBlockTime; function isInTime() constant returns (bool inTime) { return block.timestamp >= (startTime - avarageBlockTime) && !isTimeExpired(); },1
0xbd8b5ce4c64bdee0f33989e87bae71b3392924d2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x5487939f38ad535223a6f5441edd43fac291da31.sol,PeculiumOld,"contract PeculiumOld is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function PeculiumOld() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0xf32eba56b29cfeba67c10b18e1e1626f97c00a22.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed82730312babb41367e060911f798002ffa445f.sol,TheCryptoTech,"contract TheCryptoTech is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheCryptoTech() public { symbol = ; name = ; decimals = 18; _totalSupply = 950000000000000000000000000; balances[0x59e47c9984d391f4A6095f25d8fA2570e34D87CC] = _totalSupply; Transfer(address(0), 0x59e47c9984d391f4A6095f25d8fA2570e34D87CC, _totalSupply); }",1
0x0078bd770f55a3c6b8f3b3d2a0c21fcac8a92394.sol,SetLibrary,None,1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xed710216da4b1416a78768790ca9aa3633ca110f.sol,PLAY_AND_GAIN,"contract PLAY_AND_GAIN { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc7dd5fc5cd6488088b30e7e2fa302fc8b8a55ddf.sol,AT01Token,"contract AT01Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x856912680349a406f72e26aa994100b8ad409f87.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; function transfer(address to, uint value) public returns (bool) { require((to != 0x0) && (to != address(this))); if (balances[msg.sender] < value) revert(); balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); return true; }",1
0x57fae64171be173cacfdf533f290f824ca92347a.sol,BHPetolCoin,"contract BHPetolCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 5; _totalSupply = 100000000000000; balances[0x30FC7cbb3e0AFcfF52B230503F5ED4E49dD8cdf0] = _totalSupply; emit Transfer(address(0), 0x30FC7cbb3e0AFcfF52B230503F5ED4E49dD8cdf0, _totalSupply); }",1
0x412c003380e08921be3ee7ee5830d3a00dd7e589.sol,AeternumLibertarianFoundationToken,"contract AeternumLibertarianFoundationToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AeternumLibertarianFoundationToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2.sol,Poge,"contract Poge { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Poge( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x88c46a325254d19f12403643e12356c1a195c88b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken() TokenERC20() public {}",1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd0ffe3496101fd676b646ade429653d7df12edd2.sol,ContractEFT,contract ContractEFT is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = formatDecimals(500000000000); address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; },1
0x4be10da47a07716af28ad199fbe020501bddd7af.sol,XTToken,"contract XTToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 100*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XTToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x1d3f069406e02936afaa0664bd81986d97858357.sol,DistributeTokens,contract DistributeTokens is Ownable{ token tokenReward; address public addressOfTokenUsedAsReward; function setTokenReward(address _addr) public onlyOwner { tokenReward = token(_addr); addressOfTokenUsedAsReward = _addr; },1
0x0d3264ab9ee29bec9534f0f210ca8db3ac4794a8.sol,LeifengMedals,"contract LeifengMedals { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LeifengMedals( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x77d4447a3f042d3c88fae21b28d52b905d6c3dfc.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0xdd850d1d845a444a13e9516317a0a57075d9cf8e.sol,FOMOWINNER,"contract FOMOWINNER is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3.sol,HxroTokenContract,"contract HxroTokenContract is Owner { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public lockedFund; string public version; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _lockedFund) public { totalSupply = _initialSupply * 10 ** uint256(_decimals); lockedFund = _lockedFund * 10 ** uint256(_decimals); balanceOf[msg.sender] = totalSupply - lockedFund; decimals = _decimals; name = _tokenName; symbol = _tokenSymbol; version = ; }",1
0xc5392940c99a9e02c47feea448c2474fb768f65c.sol,XMX,"contract XMX { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XMX ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72519fa6cd095c99d5d67e31ddc117409bc5c047.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 0; },1
0x4488ed050cd13ccfe0b0fcf3d168216830142775.sol,NetkillerAdvancedTokenAirDrop,"contract NetkillerAdvancedTokenAirDrop { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false; bool public airdropStatus = false; uint256 public airdropTotalSupply; uint256 public airdropCurrentTotal; uint256 public airdropAmount; mapping(address => bool) public touched; event AirDrop(address indexed target, uint256 value); function NetkillerAdvancedTokenAirDrop( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; airdropAmount = 1 * 10 ** uint256(decimals); }",1
0x56b6431f45d08eed55f34371386326c739eacbcc.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=96571598000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,FlowerBase,contract FlowerBase is FlowerAdminAccess { struct Flower { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint16 cooldownIndex; uint16 generation; },1
0x6f60914be8e1aa413c981926e9edf3e5603d3f46.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0x856912680349a406f72e26aa994100b8ad409f87.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; function transfer(address to, uint value) public returns (bool) { require((to != 0x0) && (to != address(this))); if (balances[msg.sender] < value) revert(); balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); return true; }",1
0x87a05bacd70ed024a3abc5d56b902ec4cc4c9d6c.sol,EasyInvest,contract EasyInvest { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 4 / 100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0xf226b12c03514571c5a473b2627f5528da46d263.sol,ECRecovery,None,1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0x324d65aa829a9b976fe661b03a7d4cd0d66ff843.sol,BCE,"contract BCE { using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public supplyLeftAtOrigin = 21000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public constant RATE = 500; function BCE( address sendTo, uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = sendTo; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x837768a7231b3363fdddbf6dd89bde1c20dd4676.sol,wphcToken,"contract wphcToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function wphcToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0x6b683581e66524639cb9444000a7c8b5e10a1a07.sol,Eth5iov_2,"contract Eth5iov_2 { address public advertising; address public admin; address private owner; uint constant public statusFreeEth = 10 finney; uint constant public statusBasic = 50 finney; uint constant public statusVIP = 5 ether; uint constant public statusSVIP = 25 ether; uint constant public dailyPercent = 188; uint constant public dailyFreeMembers = 200; uint constant public denominator = 10000; uint public numerator = 100; uint public dayDepositLimit = 555 ether; uint public freeFund; uint public freeFundUses; uint public round = 0; address[] public addresses; mapping(address => Investor) public investors; bool public resTrigger = true; uint constant period = 5; uint dayDeposit; uint roundStartDate; uint daysFromRoundStart; uint deposit; uint creationDate; enum Status { TEST, BASIC, VIP, SVIP }",1
0x1d2196207512665ad3beb7c3641f7db409dc7beb.sol,BitcoinBLUE,"contract BitcoinBLUE { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitcoinBLUE( ) public { totalSupply = 2100000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1e0646940d1ec4494fe80ca13643e3abb76f5810.sol,GameSicBo,"contract GameSicBo is Base { uint public lastBlockNumber = 0; uint public gameID = 0; uint public gameBeginTime; uint public gameEndTime; uint public gameTime; uint256 public gameMaxBetAmount; uint256 public gameMinBetAmount; bool public gameOver = true; bytes32 public gameEncryptedText; uint public gameResult; string public gameRandon1; string public constant gameRandon2 = ; bool public betInfoIsLocked = false; uint public playNo = 1; uint public gameBeginPlayNo; uint public gameEndPlayNo; uint public nextRewardPlayNo; uint public currentRewardNum = 100; function GameSicBo(string _gameName,uint _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,address _DonQuixoteToken) public { require(_gameTime > 0); require(_gameMinBetAmount >= 0); require(_gameMaxBetAmount > 0); require(_gameMaxBetAmount >= _gameMinBetAmount); gameMinBetAmount = _gameMinBetAmount; gameMaxBetAmount = _gameMaxBetAmount; gameTime = _gameTime; require(_DonQuixoteToken != 0x0); DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken); owner = msg.sender; gameName = _gameName; }",1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xd6d62024d82b5bf4fe4a9e214991743d543f1673.sol,SafeMath,None,1
0xd7e000213f0ffa6e20e1c953bc49867f8d318bfa.sol,voult,contract voult { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4907b7baf408bca83a16ea4e780a9850c63722909d42337fb3a96414d88b6b76; constructor() public { owner = msg.sender; },1
0xf213d198b68b10654c63a9ed05a045e1d4a50f9f.sol,FootballerBase,"contract FootballerBase is FootballerAccessControl { using SafeMath for uint256; event Create(address owner, uint footballerId); event Transfer(address _from, address _to, uint256 tokenId); uint private randNonce = 0; struct footballer { uint price; uint defend; uint attack; uint quality; }",1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,WHOIS,"contract WHOIS is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WHOIS( ) TokenERC20(100000000, , ) public {}",1
0xa524828a504da3486b70c7b07eb0a7d3a157ae56.sol,WineSpiritCoin,"contract WineSpiritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WineSpiritCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x0A4Eeec02eFAAF3964E0655DFF97b4f809240f9c] = _totalSupply; Transfer(address(0), 0x0A4Eeec02eFAAF3964E0655DFF97b4f809240f9c, _totalSupply); }",1
0x47789aafa0045a316c9af4260ad4ab813fcc2f47.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardOwnership,"contract CardOwnership is CardMint { function _approve(address _owner, address _approved, uint256 _tokenId) internal { cardIdToApproved[_tokenId] = _approved; emit Approval(_owner, _approved, _tokenId); }",1
0x3365560754379382d568be87a70dbb0254bae642.sol,LionShare,"contract LionShare is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LionShare() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0] = _totalSupply; Transfer(address(0), 0x5b609F8f61df4E07a1DffdAE42CC2e9089c1ABd0, _totalSupply); }",1
0xf0b9dd890257c20bb2c733db38d5cd5c8df522cf.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e06db853b69f2d9cedbfaf8ae79e724622de6ae.sol,Crowdsale,"contract Crowdsale is owned { uint256 public totalSupply; string public priceOneTokenSokol = ; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public payable owned() { totalSupply = 11000000; balanceOf[this] = 10000000; balanceOf[owner] = totalSupply - balanceOf[this]; emit Transfer(this, owner, balanceOf[owner]); }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,ExchangeRate,"contract ExchangeRate is Ownable { event RateUpdated(uint timestamp, bytes32 symbol, uint rate); mapping(bytes32 => uint) public rates; function updateRate(string _symbol, uint _rate) public onlyOwner { rates[keccak256(_symbol)] = _rate; RateUpdated(now, keccak256(_symbol), _rate); }",1
0x6de3cc59152e19f108378984f45e20a34c9f6338.sol,EtherSpin,"contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; }",1
0x1cf6949f4b661018b3195f3ff98effe12f587263.sol,AtlantToken,"contract AtlantToken { string public name = ; string public symbol = ; uint8 public constant decimals = 8; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function AtlantToken() public { owner = msg.sender; balances[owner]=1000; }",1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0xc07c972ac722eb36f5911fdf89dfe978ef36988c.sol,SafeMath,None,1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0xf46f049967ed63b864a7f6cdf91d6dac9ea23b2c.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; uint256 amount = 0; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x471407f224b99bb3347de2609bc117dad367f889.sol,CappedToken,contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; },1
0xc5e1510dfb5942f0af172af9c3ef3eef46e945c2.sol,TMRToken,"contract TMRToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TMRToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 600000000000000000000000000; balances[0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01] = _totalSupply; Transfer(address(0), 0x6d4a039ea6634f45f449c232a2a43f7c5ee4bc01, _totalSupply); }",1
0x46570e37d496855b391573fd567599e567a73cb4.sol,VOCC_I043_20181211,"contract VOCC_I043_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x50f7c95b7e82ea5e0953de8c7ead20a9dd289ec2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27054b13b1b798b345b591a4d22e6562d47ea75a.sol,AirSwapToken,"contract AirSwapToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant totalSupply = 5000000000000; uint256 becomesTransferable = 1508249410; uint256 lockingPeriod = 604800; modifier onlyAfter(uint256 _time) { require(now >= _time); _; }",1
0x7199c3fbc0832e8798d2514eeaa88f0ce597698d.sol,Shareable,contract Shareable { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x561f26b8522d1b43559f3171ccebabd6d317af4e.sol,IGEChainERC20,"contract IGEChainERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IGEChainERC20() public { totalSupply =31415926500000000; balanceOf[msg.sender] = 31415926500000000; name = ; symbol = ; }",1
0x70dea95c5e56792a70d357f3e1b2f11e35c4c277.sol,VOCC_I077_20181211,"contract VOCC_I077_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6ceb458fac48cf87b420f23b0d890534655683e0.sol,ERC20,contract ERC20 { function totalSupply() constant returns (uint256 supply) {},1
0x6bb7a864a695ff718c9d8330c7d2ed9293949169.sol,ColorStarToken,"contract ColorStarToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf0d4661d04c9a2ea0db5319ea9380ec0118215d7.sol,CCG,"contract CCG is Token { string public name; uint8 public decimals; string public symbol; function CCG (uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xa5d6accc5695327f65cbf38da29198df53efdcf0.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkOwnership,"contract ArtworkOwnership is ArtworkBase, ArtworkUnique, ERC721 { string public constant NAME = ; string public constant SYMBOL = ; ERC721Metadata public erc721Metadata; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256()); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()) ^ bytes4(keccak256()); function approve( address _to, uint256 _tokenId ) external whenNotPaused { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); }",1
0x291a1b4ba9e936741d5cb185ad74fa9a32d048d8.sol,WithdrawalContract,contract WithdrawalContract is owned { address public richest; uint public mostSent; mapping (address => uint) pendingWithdrawals; function WithdrawalContract() public payable { richest = msg.sender; mostSent = msg.value; },1
0x5c6183d10a00cd747a6dbb5f658ad514383e9419.sol,NexxusToken,contract NexxusToken is StandardToken { function () {throw;},1
0xd5670cdb0d6e6d9eedfdbaceb97d5774466f0b23.sol,Owned,contract Owned { address public ceoAddress; address public cooAddress; address private newCeoAddress; address private newCooAddress; function Owned() public { ceoAddress = msg.sender; cooAddress = msg.sender; },1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0x75163374524bac8ca983bea408a0e3f22a1cb25b.sol,BannerDesk,"contract BannerDesk is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000000; balances[0x3b970B892c1113a567656b447f14A7195C85C487] = _totalSupply; emit Transfer(address(0), 0x3b970B892c1113a567656b447f14A7195C85C487, _totalSupply); }",1
0x44ad6729188261006a27b8b937e9f15b2b814f32.sol,Stockfinex,"contract Stockfinex is TokenContainer { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Stockfinex( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4d55ee29f3806c6feb424ba5948d660586bd51d3.sol,BB,"contract BB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x3452519f4711703e13ea0863487eb8401bd6ae57.sol,BulkSender,"contract BulkSender is Ownable { using SafeERC20 for ERC20Basic; function bulkTransfer(ERC20Basic token, address[] toAddresses, uint256[] values) public onlyOwner returns (bool) { require((toAddresses.length > 0) && (toAddresses.length == values.length)); for (uint i = 0; i < toAddresses.length; i++) { token.safeTransfer(toAddresses[i], values[i]); }",1
0xb60cfc056a3f201ce4f421655d5fcb535b8d7ca5.sol,SimpleBanners,contract SimpleBanners { struct BannerOwnerStruct { address owner; uint balance; uint bidAmountPerDay; bytes32 dataCID; uint timestampTaken; },1
0x6b609d9095d069c805650234ab67595b3a6ab934.sol,Crowdsale,"contract CrowdsaleProxy is ICrowdsaleProxy { address public owner; ICrowdsale public target; function CrowdsaleProxy(address _owner, address _target) public { target = ICrowdsale(_target); owner = _owner; }",1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0xb39b66a7273b83bca1f2f618672302485b391f92.sol,ANHUI_ANNUITY_DAO_33_c,"contract ANHUI_ANNUITY_DAO_33_c { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6d105976d1a93e1ce23b825b562519144a56d7a4.sol,StringDump,contract StringDump { event Event(string value); function emitEvent(string value) public { Event(value); },1
0x6c9ece80505a55c4fc373900994800340a5e2e14.sol,CGENToken,contract CGENToken is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint128 public availableSupply; struct vesting { uint createdAt; uint128 amount; uint8 releaseRate; uint32 releaseIntervalSeconds; uint8 nextReleasePeriod; bool completed; },1
0xc14c848a2a5945e1a415976fc059550ecbe7b034.sol,Line,contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public giftNumerator = 1; uint constant public denominator = 100; uint constant public ownerDenominator = 100; uint public jackpot = 0; address[] internal addresses; mapping(address => SpinRec) internal spinsByAddr; mapping(bytes32 => SpinRec) internal spinsByQuery; struct SpinRec { uint id; bytes32 queryId; uint bet; uint token; },1
0xdbe46c0e6526e9068da1626acfddff2386635045.sol,PumpToken,contract PumpToken { address owner = msg.sender; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalSupply = 0; function name() pure returns (string) { return ; },1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0x2bae8bf1d52cf870381c6c02f0256f1b68d7aa2e.sol,OBOK,contract OBOK { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0xda36819cfa6167ab5d7932aa8a7852b377a15ab9.sol,DOJC,"contract DOJC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DOJC( ) public { totalSupply = 500000000000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000000000; name = ; symbol = ; }",1
0x6b6d1a8858893c3e228f335726e1417a35832f76.sol,Carbon,contract Carbon { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 1000000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0xf09db3b0b2b9d0ae4a8f84676f2c86a899b1a490.sol,ReservedContract,"contract ReservedContract { address public richest; address public owner; uint public mostSent; uint256 tokenPrice = 1; ERC20 Paytoken; address public _reserve20 = 0xD73a0D08cCa496fC687E6c7F4C3D66234FEfda47; event PackageJoinedViaPAD(address buyer, uint amount); event PackageJoinedViaETH(address buyer, uint amount); mapping (address => uint) pendingWithdraws; modifier onlyAdmin() { require (msg.sender == owner); _; }",1
0x6b193e107a773967bd821bcf8218f3548cfa2503.sol,PossContract,"contract PossContract is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PossContract() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0xAbB082211930DA475879BF315AFaDDD55913C6a8] = _totalSupply; Transfer(address(0), 0xAbB082211930DA475879BF315AFaDDD55913C6a8, _totalSupply); }",1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0x778608c4ac424522180a43329ff5145400b9d409.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x693f915802b6f2bf47e97bf28ac118042278c9fa.sol,DynamicToken,"contract DynamicToken is TokenInterface { bool public isClosed; bool public isMaxSupplyLocked; bool public isLockedOpen; bool public isContractOwnerLocked; uint256 public maxSupply; address public upgradedContract; address public contractOwner; address[] public accounts; string[] public proofIds; mapping (address => bool) public accountExists; mapping (string => bool) proofIdExists; event TransferFrom(address indexed _from, address indexed _to, address indexed _spender, uint256 _amount); event Issue(address indexed _from, address indexed _to, uint256 _amount, string _proofId); event Burn(address indexed _burnFrom, uint256 _amount); event Close(address indexed _closedBy); event Upgrade(address indexed _upgradedContract); event LockOpen(address indexed _by); event LockContractOwner(address indexed _by); event TransferContractOwnership(address indexed _by, address indexed _to); event MaxSupply(address indexed _by, uint256 _newMaxSupply, bool _isMaxSupplyLocked); function DynamicToken() { contractOwner = msg.sender; maxSupply = 10**7; totalSupply = 0; isClosed = false; isMaxSupplyLocked = false; isLockedOpen = false; isContractOwnerLocked = false; }",1
0x01aec44dd1be1bf86f4fe4f768fc8fd46008b166.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd082e9e4f9b39bad6103c330292a7b219bf3b740.sol,BIBToken,"contract BIBToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BIBToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xec841073efd8e68ddffbd6cf440f2548684345ea.sol,GemCoin,"contract GemCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GemCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x1df6fC0743712B1Ee73e9C7A1A3eA82f07757721] = _totalSupply; Transfer(address(0), 0x1df6fC0743712B1Ee73e9C7A1A3eA82f07757721, _totalSupply); }",1
0x6c6b3fd123d575cbeb1670a1fcc9c8fd603357a3.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,PiToken,"contract PiToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PiToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 3141592653589793238 ** uint256(decimals); balanceOf[msg.sender] = totalSupply = 3141592653589793238; tokenName = ; tokenSymbol = ; }",1
0x1be34bec23ef52fca1b5bb9ce27da1277ca4eebd.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 4000000000 * 10 ** uint256(decimals); address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); address public dateTimeAddr = 0x1a6184CD4C5Bea62B0116de7962EE7315B7bcBce; DateTime dateTime = DateTime(dateTimeAddr); uint[] lockupTime = [dateTime.toTimestamp(2018,11,13),dateTime.toTimestamp(2019,1,13),dateTime.toTimestamp(2019,3,13),dateTime.toTimestamp(2019,5,13)]; uint8[] lockupPercent = [0,25,50,75]; constructor() public { balanceOf[msg.sender] = totalSupply; owner = msg.sender; }",1
0x17f28bd2c1b22c07899ca7ef7bf586b7a4e6fcf4.sol,CashTelexToken,"contract CashTelexToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CashTelexToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 3 weeks; endDate = now + 21 weeks; }",1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Lotthereum,"contract Lotthereum is Mortal, SafeMath { Game[] private games; mapping (address => uint) private balances; struct Game { uint id; uint pointer; uint maxNumberOfBets; uint minAmountByBet; uint prize; uint currentRound; Round[] rounds; }",1
0xa2b5ca48fc2f8517c5e6077046a17e57d346dab5.sol,CHEMCHINA_PFI_I_883,"contract CHEMCHINA_PFI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 561734866207499000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0xef19256160e4107b1de93b1753b25e3c4e889caa.sol,OKEXTOKEN,"contract OKEXTOKEN { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 90000000000; balanceOf[msg.sender] = totalSupply; name =; symbol = ; }",1
0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7051620d11042c4335069aaa4f10cd3b4290c681.sol,TCASH,contract TCASH is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 88000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TCASH() { owner = msg.sender; balances[owner] = 88000000 * 10**8; },1
0x27cc52118d2b150c40d35f39ddbc28835db0ff01.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc709c316555ae3002ccc1c0ff7bd2ba83b9cd067.sol,TUNISIA_WINS,"contract TUNISIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,TokenRecipient,"contract TokenRecipient { event ReceivedEther(address indexed sender, uint amount); event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData); function receiveApproval(address from, uint256 value, address token, bytes extraData) public { ERC20 t = ERC20(token); require(t.transferFrom(from, this, value)); ReceivedTokens(from, value, token, extraData); }",1
0x32cd77627ddb1dd8bda46e35c6e68aadfe916066.sol,RedlineFinancialLabCoin,"contract RedlineFinancialLabCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedlineFinancialLabCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x6c72582241de57e6fd501a99d85c650924039a50.sol,WHC,"contract WHC { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WHC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x213a22d873e02269ac45c094c0655a09eaa22c3a.sol,TokenERC20,"contract TokenERC20 { string public name= ; string public symbol= ; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ed98637002026cf9b6c70b7018f229f9d02391e.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=1300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,token,"contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }",1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0x8a18d7e7bcb1dc4db0f71aee2421a3d9af53f93f.sol,BFX,"contract BFX is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BFX() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x366efd14d20302ab592ffff7bfa4ccb244c19ad9.sol,LCoin,"contract LCoin { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; string public name; string public symbol; uint8 public decimals; constructor(uint _totalSupply,string tokenName,string tokenSymbol,uint8 decimalUnits) public{ balanceOf[msg.sender] = _totalSupply; totalSupply = _totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0xa48d3b79f43477224933e492e42f5cacf4091ecc.sol,AdvancedCOINSToken,"contract AdvancedCOINSToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x848bcb77c97d449312ece071cd999e5f0d30f849.sol,TokenMCT,"contract TokenMCT{ using SafeMath for uint; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMCT(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x2793a23341012e0970cf478bab08606b56504c3e.sol,EternalStorage,contract EternalStorage is Administratable { struct Storage { mapping(bytes32 => bool) _bool; mapping(bytes32 => int) _int; mapping(bytes32 => uint256) _uint; mapping(bytes32 => string) _string; mapping(bytes32 => address) _address; mapping(bytes32 => bytes) _bytes; },1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0x6b7734c5ecc51116b806e2ea6decbb3b97f4f92e.sol,CRBT223,"contract CRBT223 is ERC223Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRBT223() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x561dd423ebcaa801e04746fb411ef7404a389961.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4acd3b516ffc36ab6929b46b787b320c21f65b35f32f6cb0dbc4717a487841eb; constructor() public { owner = msg.sender; },1
0xe319847f14624ad62a99c7eb5e6d738f61fcf185.sol,EtherPaint,"contract EtherPaint { uint256 constant scaleFactor = 0x10000000000000000; int constant crr_n = 1; int constant crr_d = 2; int constant price_coeff = -0x296ABF784A358468C; mapping(address => uint256[16]) public tokenBalance; uint256[128][128] public colorPerCoordinate; uint256[16] public colorPerCanvas; event colorUpdate(uint8 posx, uint8 posy, uint8 colorid); event priceUpdate(uint8 colorid); event tokenUpdate(uint8 colorid, address who); event dividendUpdate(); event pushuint(uint256 s); mapping(address => int256[16]) public payouts; uint256[16] public totalSupply; uint256 public allTotalSupply; int256[16] totalPayouts; uint256[16] earningsPerToken; uint256[16] public contractBalance; address public owner; uint256 public ownerFee; function EtherPaint() public { owner = msg.sender; colorPerCanvas[0] = 128*128; pushuint(1 finney); }",1
0x1cb82f4228719a53a6f5fc98de74f12eebdc31ed.sol,Fusionchain,"contract FusionchainSafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); }",1
0x6b3add2227ac41403c93674185b32ff9e8bc3a43.sol,QianChengMeng,"contract QianChengMeng { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x292ee80f00e83faa51a793a87503024f36f3a1dc.sol,Futurescoin,"contract Futurescoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Futurescoin() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3] = _totalSupply; Transfer(address(0), 0xf5c7DF4262EAeaA6655785c43336E262ae81a1E3, _totalSupply); }",1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x51f4fcf219d79855341f749c0f1008c6066a2f1f.sol,EQU,"contract EQU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EQU( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39e743fee400a5d9b36f1167b70c10e8f06440e5.sol,TNCGroupToken,"contract TNCGroupToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x74b920485c31f07b2df06f326b465565af6f69e4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, uint8 initialDecimals, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; decimals = initialDecimals; name = tokenName; symbol = tokenSymbol; }",1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0xb4933b15b21924af2c18012c4da78b182f060107.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] > _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0xf0ebda840692b2a6cd8ab43abc57665763100694.sol,SignalsToken,"contract SignalsToken is PausableToken, MintableToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 9; event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens); function SignalsToken() { pause(); }",1
0x12ac8d8f0f48b7954bcda736af0576a12dc8c387.sol,OPL,"contract OPL { string public name; string public symbol; uint8 public decimals = 18; bool public adminVer = false; address public owner; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Emission(address indexed from, uint256 value); function OPL() public { totalSupply = 210000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; owner = msg.sender; }",1
0x85924fdcccb75c47c3d2155ae0a519018164cac0.sol,StandardToken,"contract StandardToken is TelomereCoin { function transfer(address _to, uint256 _value) returns (bool success) { require(allowTransfer); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x561f26b8522d1b43559f3171ccebabd6d317af4e.sol,IGEChainERC20,"contract IGEChainERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IGEChainERC20() public { totalSupply =31415926500000000; balanceOf[msg.sender] = 31415926500000000; name = ; symbol = ; }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x6b7734c5ecc51116b806e2ea6decbb3b97f4f92e.sol,CRBT223,"contract CRBT223 is ERC223Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRBT223() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xdb5c3c46e28b53a39c255aa39a411dd64e5fed9c.sol,NeosCredits,"contract NeosCredits is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NeosCredits() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xE581eFBa0B2a360Dc66443289a50660e9F44aC81] = _totalSupply; Transfer(address(0), 0xE581eFBa0B2a360Dc66443289a50660e9F44aC81, _totalSupply); }",1
0xb8c6107f66152fa908111e2963878ad04c89b125.sol,EENX,"contract EENX is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function EENX( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x91f5f7fa8c7030f4d1ce841142386ebed7589ced.sol,EVERBIT,"contract EVERBIT { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0xf2b87ce9c2ce65e786d6ffee0fdb9629ceff05f2.sol,DSCToken,"contract DSCToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function DSCToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0x2702ff94cb05717bfa47324872ab5c92b07a8982.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public maxSupply; function transfer(address _to, uint256 _value) public returns (bool) { if (balances[msg.sender] < _value) { revert(); }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,LeaderSystem,"contract LeaderSystem { using SafeMath for uint256; event NewLeader(uint256 _indexTable, address _addr, uint256 _index, uint256 _sum); event LeadersClear(uint256 _indexTable); uint8 public constant leadersCount = 7; mapping (uint8 => uint256) public leaderBonuses; struct LeadersTable { uint256 timestampEnd; uint256 duration; uint256 minSum; address[] leaders; mapping (address => uint256) users; }",1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0xec193241dc1ca3bbe3165de6d37a793585b4504e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,APP,"contract APP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function APP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xceedf087d386109ff18dd38b0684efb0355a13e8.sol,EthereumMobile,"contract EthereumMobile { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6ca26152df86c13f9830ec3701e8e96d51ee833f.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x71e617e6024c20ac20f1c3fa47d874b9e4d2c141.sol,RedCarpetToken,"contract RedCarpetToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedCarpetToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 1200000000000; balances[0x865957fedaef1eaab481e9d236ce45d432c06b60] = _totalSupply; Transfer(address(0), 0x865957fedaef1eaab481e9d236ce45d432c06b60, _totalSupply); }",1
0x40f5d52331674b60bc532f553c97feac5d60ab34.sol,CryptoMinerTokenPlat,contract CryptoMinerTokenPlat{ modifier onlyBagholders { require(myTokens() > 0); _; },1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0x703ab45e12a509e1a6430b0f1c9576c6b3075dd2.sol,Elythrium,"contract Elythrium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Elythrium() public { symbol = ; name = ; decimals = 2; _totalSupply = 10000000000; balances[0xe060ea1402e5713c5E140054B1e1c253137E4636] = _totalSupply; Transfer(address(0), 0xe060ea1402e5713c5E140054B1e1c253137E4636, _totalSupply); }",1
0xed0c3e1d538fda7370c22c4c3f3dc076ab51bd00.sol,wallet,contract wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc3a496b6657c6a3db45d162d99953a436d8c423ad460cc8819cea54acc2071e9; constructor() public { owner = msg.sender; },1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cc24b1feb9f45f907d16159ce82fc067a7e1c43.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4.sol,FansChainToken,"contract FansChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FansChainToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0x1c2389c0b8014be72e11849ec0aa790b03929e18.sol,FundingWallet,contract FundingWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x405b15a78a968607529aaa1f482e642883809496.sol,urunitairdropper,"contract urunitairdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x3a783e99e5a5618b8149e3380d14328139d97e31.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c44134ab77bd7b90907d2b9745c628caae077d6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xaaabd58b6d94b21859f9fc2b4e829f532283cf69.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x763ae93d72c7575cf9df1013e9fe2c08b96d6034.sol,BitXCoin,"contract BitXCoin { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint public totalSupply; constructor ( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialAmount; balances[msg.sender] = totalSupply; allowed[msg.sender][msg.sender] = balances[msg.sender]; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xd91e45416bfbbec6e2d1ae4ac83b788a21acf583.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x87b3a2c40e63ef9410da6c985a1501fe4972c4e4.sol,SPGForEver,contract SPGForEver { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => uint256) public lockOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 10000000000 * 10 ** decimals; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x91cdb5bb5969bfed2373e97378354052bbc606f2.sol,DRCToken,"contract DRCToken is BurnableToken, MintableToken, PausableToken, Claimable, Autonomy { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 0; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenAmount; event FrozenFunds(address indexed _target, bool _frozen); event FrozenFundsPartialy(address indexed _target, bool _frozen, uint256 _value); event BurnFrom(address from, address burner, uint256 value); function DRCToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xd5e1f90d918fd871fa0aba9aea54bb07e6382299.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c242bc9af8aa768a54222ed47bb756f1a1a757b.sol,LockableFreezableBurnablePausableERC20Token,contract LockableFreezableBurnablePausableERC20Token is FreezableBurnablePausableERC20Token { struct LockAtt { uint256 initLockAmount; uint256 lockAmount; uint256 startLockTime; uint256 cliff; uint256 interval; uint256 releaseCount; bool revocable; address revocAddress; },1
0x9222740a4351abda9d83f3c7165c556e802f920e.sol,StandardToken,"contract StandardToken is ERC20, SafeMath { event Transfer(address indexed from, address indexed to, uint indexed value, bytes data); event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length != size + 4) { revert(); }",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xc7cbd16654cf938e6c9cc3ade88ae9ee21c27edf.sol,CTSCToken,"contract CTSCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CTSCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1250000000000000000000000000; balances[0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f] = _totalSupply; Transfer(address(0), 0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f, _totalSupply); }",1
0xed0c3e1d538fda7370c22c4c3f3dc076ab51bd00.sol,wallet,contract wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc3a496b6657c6a3db45d162d99953a436d8c423ad460cc8819cea54acc2071e9; constructor() public { owner = msg.sender; },1
0x54923b4f2e4433294c70559cc94d1812793f0451.sol,Future1Exchange,contract Future1Exchange { address public archon; mapping (address => mapping(address => uint256)) public _token; constructor() public { archon = msg.sender; },1
0xda6bae24e98db8ec03151d5edcf9ade67e442b6d.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, StealthGridToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) StealthGridToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x77331db23993850d34372c94b804de2461625503.sol,SafeOpt,None,1
0x84cc06eddb26575a7f0afd7ec2e3e98d31321397.sol,DiamondDividendMain,contract DiamondDividendMain { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7677b0d1fa1b71e3dc17aae1c9fcf22b13a59a34.sol,WhoWins,contract WhoWins { mapping (address => uint256) public balance; mapping (address => uint256) public atBlock; address public house; constructor() public { house = msg.sender; },1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x5a9633b76eedb38ab04733682f1f422b4ce219b5.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0xcd7067332044bba6c7055677a14e25702e1f5af8.sol,PROSH,"contract PROSH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PROSH() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000000000000000000; balances[0x02DEA85397EF756307F9751693872d54d0B75A2c] = _totalSupply; Transfer(address(0), 0x02DEA85397EF756307F9751693872d54d0B75A2c, _totalSupply); }",1
0x78a06472d78bfef33270654319b6373d51cf0575.sol,EasyMineTokenWallet,contract EasyMineTokenWallet { uint256 constant public VESTING_PERIOD = 180 days; uint256 constant public DAILY_FUNDS_RELEASE = 15000 * 10**18; address public owner; address public withdrawalAddress; Token public easyMineToken; uint256 public startTime; uint256 public totalWithdrawn; modifier isOwner() { require(msg.sender == owner); _; },1
0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f.sol,HEART,"contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x17c94b2203cd76d1e28509cece13e35744b9555c.sol,ERC20MIST,"contract ERC20MIST { string public name=; string public symbol=; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ERC20MIST ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 8 ** uint256(decimals); balanceOf[msg.sender] = 2100000000000000; name = tokenName=; symbol = tokenSymbol=; }",1
0x00fee04ea211711aaeb18a562be88c140cff4c24.sol,OpayToken,"contract OpayToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x0f6029ebde2ecd9ab4d60dd5d0a297e9e59bf77a.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
0x34644911eeefd50877cca86562e673b94885048b.sol,RUSS_PFVI_III_883,"contract RUSS_PFVI_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1055519864651380000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x46b9ad944d1059450da1163511069c718f699d31.sol,CREDITS,"contract CREDITS is Ownable{ string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; uint public TotalHoldersAmount; bool public Frozen=true; bool public CanChange=true; address public Admin; address public AddressForReturn; address[] Accounts; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address => bool) public AccountIsFrozen; mapping(address => bool) public AccountIsNotFrozen; mapping(address => bool) public AccountIsNotFrozenForReturn; mapping(address => uint) public AccountIsFrozenByDate; mapping (address => bool) public isHolder; mapping (address => bool) public isArrAccountIsFrozen; mapping (address => bool) public isArrAccountIsNotFrozen; mapping (address => bool) public isArrAccountIsNotFrozenForReturn; mapping (address => bool) public isArrAccountIsFrozenByDate; address [] public Arrholders; address [] public ArrAccountIsFrozen; address [] public ArrAccountIsNotFrozen; address [] public ArrAccountIsNotFrozenForReturn; address [] public ArrAccountIsFrozenByDate; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event Burn(address indexed from, uint256 value); modifier IsNotFrozen{ require(((!Frozen&&AccountIsFrozen[msg.sender]!=true)||((Frozen)&&AccountIsNotFrozen[msg.sender]==true))&&now>AccountIsFrozenByDate[msg.sender]); _; }",1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0x4d0528598f916fd1d8dc80e5f54a8feedcfd4b18.sol,Atoshi,"contract Atoshi is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Atoshi( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2868f8e9425a7f5cfe989026b6cabb19a01d51d6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc6c3ae1e6ac193e5a71ec144dde1c93b4a3de47c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1eb35af86a3821b5cca3013b1bb942c796aef544.sol,LV,"contract LV { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0x865cae29127a556ae9a0ed9e5f573ea43f83f6fd.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5861e9618ec3fe9c8e1d4befb8dc5466a6a9fde1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0x2edd739976bf60e2b5a7a9fdb4a96e0dad4ca21e.sol,BethElCoin,"contract BethElCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xF417694bfAcd465b98681aa5cB2723FA6cd53ef1] = _totalSupply; emit Transfer(address(0),0xF417694bfAcd465b98681aa5cB2723FA6cd53ef1, _totalSupply); }",1
0x6eb1eee8dcb041e2d3b2130ce124c3005dc3d6a7.sol,PopeCoin,"contract PopeCoin is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PopeCoin( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0x00) { owner = centralMinter; }",1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,JavaSwapTest,"contract JavaSwapTest is TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public leastSwap; bool public funding = true; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function JavaSwapTest( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xda65eed883a48301d0ecf37465f135a7a0c9d978.sol,DavidCoin,"contract DavidCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DavidCoin() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x6bcfcc7035dbe589e9c0c91260772630ce92f25b.sol,TOMAToken,"contract TOMAToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TOMAToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdcc2a9c95518a1196896bd116334c1eb1b6785ad.sol,CGTToken,"contract CGTToken is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) internal allowed; function CGTToken() public { symbol = ; name = ; decimals = 2; _totalSupply = 10000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); }",1
0xbd04617f9bee584c0c45923a2d7971a64cea9297.sol,ADSToken,contract ADSToken { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1e27; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x58054e51c19fa796443043418be91032b99992a3.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { struct inr { address sender; uint value; bytes data; bytes4 sig; },1
0x33e127da2426822408b1d41344146de02ee48670.sol,PONTEM,"contract PONTEM { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply , string tokenName , string tokenSymbol) public { totalSupply = 250000000 * 10 ** uint256(18) ; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 580000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0xe1754d039c839192ee193d5cf8406fb24fcb421f.sol,ETHToken,"contract ETHToken is ERC20Interface { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant tokenCreationCap = 3000000* 10**18; uint256 public constant tokenCreationMin = 1* 10**18; mapping(address => mapping (address => uint256)) allowed; uint public fundingStart; uint public fundingEnd; bool public funding = true; address public master; uint256 totalTokens; uint256 soldAfterPowerHour; mapping (address => uint256) balances; mapping (address => uint) lastTransferred; mapping (address => uint256) balancesEther; address public migrationAgent; uint256 public totalMigrated; event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); uint totalParticipants; function ETHToken() { master = msg.sender; fundingStart = 1511654250; fundingEnd = 1511663901; }",1
0x656610729fc13e8283d96aa69cdf56c112222951.sol,JeopardyJack,contract JeopardyJack { bytes32 private answerHash; uint private isActive; Guess[] public Guesses; string public Riddle; string public Answer; struct Guess { address player; string guess; },1
0x20a2137530c4206100ec9d9b3a5dc8bdda8bc589.sol,IMEXToken,"contract IMEXToken is owned, TokenERC20 { uint256 _initialSupply=420000000; string _tokenName=; string _tokenSymbol=; address wallet1 = 0x3d41E1d1941957FB21c2d3503E59a69aa7990370; address wallet2 = 0xE5AA70C5f021992AceE6E85E6Dd187eE228f9690; address wallet3 = 0x55C7Cbb819C601cB6333a1398703EeD610cCcF40; uint256 public startTime; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function IMEXToken( ) TokenERC20(_initialSupply, _tokenName, _tokenSymbol) public { startTime = now; balanceOf[wallet1] = totalSupply.mul(1).div(100); balanceOf[wallet2] = totalSupply.mul(25).div(100); balanceOf[wallet3] = totalSupply.mul(74).div(100); }",1
0x515669d308f887fd83a471c7764f5d084886d34d.sol,MuxeToken,"contract MuxeToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public tokensBurnt; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Burn(uint tokens); function MuxeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); tokensBurnt = 0; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x4d0425e47ee2d16b94c036715dfcb52a0cebc4dc.sol,TAGZ5,"contract TAGZ5 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599] = _totalSupply; emit Transfer(address(0), 0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599, _totalSupply); }",1
0x009b40aab0ec2d4abd696db7b0cfce5c24eb9114.sol,CAMToken,"contract CAMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE] = _totalSupply; emit Transfer(address(0), 0x24808Ba8EEa4634d00b0CE9fF7033D6d93CEcFcE, _totalSupply); }",1
0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc.sol,DAAS,"contract DAAS { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAAS ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xe3dbf587330d9b8f127a3f38dabf9aa3c90d3187.sol,VCcoin,"contract VCcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VCcoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; balances[0x903862f79f24d564aef487b7b28306e71df2ab03] = _totalSupply; Transfer(address(0), 0x903862f79f24d564aef487b7b28306e71df2ab03, _totalSupply); }",1
0xaa5059814a9412bd161a53a6a69625906701f91d.sol,CCD_EUROSIBENERGO_20190326_2,"contract CCD_EUROSIBENERGO_20190326_2 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0x573db28be1fce18fb46fbc49d23204daf7e7589c.sol,SafeMath,None,1
0x91cdb5bb5969bfed2373e97378354052bbc606f2.sol,DRCToken,"contract DRCToken is BurnableToken, MintableToken, PausableToken, Claimable, Autonomy { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 0; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenAmount; event FrozenFunds(address indexed _target, bool _frozen); event FrozenFundsPartialy(address indexed _target, bool _frozen, uint256 _value); event BurnFrom(address from, address burner, uint256 value); function DRCToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0x8c211128f8d232935afd80543e442f894a4355b7.sol,SNcoin_Token,"contract SNcoin_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint private constant _totalSupply = 100000000 * 10**uint(decimals); mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; struct LimitedBalance { uint8 limitType; uint initial; }",1
0xde08a96e974bad18f64013d5b59b3c8e3f4621f8.sol,SimpleDistributor,contract SimpleDistributor { address public owner; Mintable public token = Mintable(0x552Ed8253f341fb770E8BAdff5A0E0Ee2fd57B43); function SimpleDistributor() public { owner = msg.sender; },1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0x2880163d22b8742a8736b21ae9f8b7f239a22243.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken() { balanceOf[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; symbol = ; decimals = 6; }",1
0xebb060f9d0029082a04f78d84b9fb9d3d26f9a93.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0xd35be56e4ed6818d09e6f95b9c744c4607fda453.sol,ProofOfBitConnect,contract ProofOfBitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc729c50c19d3b2f0049c9eec809b5cc175dbf489.sol,PDGToken,"contract PDGToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDGToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x704a1e04ca263c4af14fca6cd5cc371d247bd200.sol,ERC20Detailed,"contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; constructor(string name, string symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; }",1
0x83f06e75e448115d7f5e2038814766124c0db8ce.sol,ERC20Token,contract ERC20Token { function totalSupply() constant returns (uint supply) {},1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x65244ee745288952f347d82ba69690fa9a9843c0.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xf3dce610acbfbcbb4efc12c4c2e3be063128baad.sol,NumbersToken2,"contract NumbersToken2 { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function NumbersToken() public { }",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x3a042fb0439da1c7ca28e352fb48cdb2d8d90cff.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa52b0a032139e6303b86cfeb0bb9ae780a610354.sol,ETPMap,"contract ETPMap{ mapping (address => string) internal address_map; event MapAddress(address, string); function get_address(address addr) constant public returns (string) { return address_map[addr]; }",1
0x5bd7b9cd17cee4d2fae01d9695e83098cf409488.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71fd1b8263b40049269ee881c9cf842e6ca297e0.sol,JPCOIN,"contract JPCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function JPCOIN() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383] = _totalSupply; Transfer(address(0), 0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383, _totalSupply); }",1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0x6faff25ef78e39c518687b0dd19113f9b29ac562.sol,ETHedgeToken,contract ETHedgeToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x313c54eb9f08f1be0f18e8ad505135fa7041a52f.sol,CHEXToken,"contract CHEXToken is Token { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public startBlock; uint public endBlock; address public founder; address public owner; uint public totalSupply = 2000000000 * 10**decimals; uint public etherCap = 2500000 * 10**decimals; uint public totalTokens = 0; uint public presaleSupply = 0; uint public presaleEtherRaised = 0; event Buy(address indexed recipient, uint eth, uint chx); event Deliver(address indexed recipient, uint chx, string _for); uint public presaleAllocation = totalSupply / 2; uint public ecosystemAllocation = totalSupply / 4; uint public reservedAllocation = totalSupply / 4; bool public ecosystemAllocated = false; uint public constant MIN_ETHER = 10 finney; enum TokenSaleState { Initial, Presale, Live, Frozen }",1
0x51a1a60ae2310e34295a18b559cac9e4140303d7.sol,ItemList,None,1
0x25ff04031852660cbb733709890b9f92257ee731.sol,NotFomo3D,"contract NotFomo3D { address public owner; address public latestBidder; address public latestWinner; uint public endTime; uint public addTime; event Bid(address bidder, uint ending, uint adding, uint balance); function NotFomo3D() public { owner = msg.sender; latestBidder = msg.sender; latestWinner = msg.sender; addTime = (2 hours); endTime = 0; }",1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x693e3857aa48bb2902fd12f724dc095622e61afc.sol,DopeToken,"contract DopeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DopeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000; balances[0xe2f54E82B8E413537B95e739C2e80d99dE40C67B] = _totalSupply; Transfer(address(0), 0xe2f54E82B8E413537B95e739C2e80d99dE40C67B, _totalSupply); }",1
0x04950c94f4cbf9b3eb7b3ddd48e6aef176e3f73f.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x32f1ee166437b15b7716f51f2cbb53a57475bc76.sol,BLITZ_GAME,contract BLITZ_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0x2a790479cd47f686804fe570b903f3b6cf08599d.sol,ChainmonstersShop,contract ChainmonstersShop { using SafeMath for uint256; address public owner; bool started; uint256 public totalCoinsSold; address medianizer; uint256 shiftValue = 100; uint256 multiplier = 10000; struct Package { uint256 price; string packageReference; bool isActive; uint256 coinsAmount; },1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0x18cabd1e7db6c52406719cb72859ea2c2eea75d6.sol,GoGuides,"contract GoGuides { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GoGuides( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0x088674acdb4f6ac52fa46f8334955e34b00b0b36.sol,CCD_KOHLE_10_20190411,"contract CCD_KOHLE_10_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x654dddc32f6734a33b9cea0901c47f9a00336c1e.sol,VisperNetwork,contract VisperNetwork is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**18; function name() public constant returns (string) { return ; },1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ContractOfSale,"contract ContractOfSale is ElementTokenImpl { using SafeMath for uint256; event Sold (uint256 elementId, address oldOwner, address newOwner, uint256 price); uint256 private constant LIMIT_1 = 20 finney; uint256 private constant LIMIT_2 = 500 finney; uint256 private constant LIMIT_3 = 2000 finney; uint256 private constant LIMIT_4 = 5000 finney; function calculateNextPrice (uint256 _price) public pure returns (uint256 _nextPrice) { if (_price < LIMIT_1) { return _price.mul(2); }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x32fb35728c3d95ac9591708bfb91136577ab1dd2.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0xf2855df7f963531f689a8a3d2eb7bf4e0f532c01.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x068ae20c4938821442cefba1716e1f7a4696897b.sol,VOCC_I083_20181211,"contract VOCC_I083_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xecbed48098c4f25a16195c45ddf5fd736e28b14b.sol,UserfeedsClaimWithConfigurableTokenMultiTransfer,"contract UserfeedsClaimWithConfigurableTokenMultiTransfer is Destructible, WithClaim { function post(string data, address[] recipients, ERC20 token, uint[] values) public { emit Claim(data); transfer(recipients, token, values); }",1
0x6ba2d5e4384a69df6066e1cf6c395909254910fb.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,ECRecovery,None,1
0x6e06db853b69f2d9cedbfaf8ae79e724622de6ae.sol,Crowdsale,"contract Crowdsale is owned { uint256 public totalSupply; string public priceOneTokenSokol = ; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public payable owned() { totalSupply = 11000000; balanceOf[this] = 10000000; balanceOf[owner] = totalSupply - balanceOf[this]; emit Transfer(this, owner, balanceOf[owner]); }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0x2955e1a797f621dd865cf30e7406d973bf7bd769.sol,AuzToken,"contract AuzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 150000000000000000000000; balances[0x7eb3c74a4dD5a08459Ece27917db3C564A324F54] = _totalSupply; emit Transfer(address(0), 0x7eb3c74a4dD5a08459Ece27917db3C564A324F54, _totalSupply); }",1
0x3a931cabde9d3deeb9cfe50d8afb0b7be357cb16.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x4198958c0324d322c0d7118495a5327304fa624b.sol,FantomToken,"contract FantomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantomToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3175000000000000000000000000; balances[0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6] = _totalSupply; Transfer(address(0), 0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6, _totalSupply); }",1
0x6d764e5ba1da7f5affd9d4ac00e2dd8bf41cc2aa.sol,LIFECOIN,"contract LIFECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LIFECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000000; balances[0xD133cc957d41C0cd62ed6175155B2E54F951eA79] = _totalSupply; Transfer(address(0), 0xD133cc957d41C0cd62ed6175155B2E54F951eA79, _totalSupply); }",1
0x92972bbc89708127016046c150e3a223431a31e0.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x680ec9492d8372662dd439294bff2bd373e96309.sol,MyEtherHODL,"contract MyEtherHODL is Ownable { event Hodl(address indexed hodler, uint indexed amount, uint untilTime, uint duration); event Party(address indexed hodler, uint indexed amount, uint duration); event Fee(address indexed hodler, uint indexed amount, uint elapsed); address[] public hodlers; mapping(address => uint) public indexOfHodler; mapping (address => uint) public balanceOf; mapping (address => uint) public lockedUntil; mapping (address => uint) public lockedFor; function get1(uint index) public constant returns(address hodler1, uint balance1, uint lockedUntil1, uint lockedFor1) { hodler1 = hodlers[index]; balance1 = balanceOf[hodler1]; lockedUntil1 = lockedUntil[hodler1]; lockedFor1 = lockedFor[hodler1]; }",1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0552ae7f174e43479159f87a66417cca31eb54b.sol,VOCC_I054_20181211,"contract VOCC_I054_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x48f3726c787bdc36bb00c978e701879ceed185a4.sol,LT,"contract LT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LT() public { balances[msg.sender] = 2100000000000; totalSupply = 2100000000000; name = ; decimals =4; symbol = ; }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x7880ddfa13218bae0a42ea56902de21ff29a82ce.sol,BlockGame,"contract BlockGame is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BlockGame() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB] = _totalSupply; Transfer(address(0), 0x84c5fbD891205c1E4620CAaC0AD5F9CE9A3653bB, _totalSupply); }",1
0x55100b6e3e1cc3018881a4a68edf229a80bac944.sol,MintingERC20,"contract MintingERC20 is ERC20 { mapping (address => bool) public minters; uint256 public maxSupply; function MintingERC20( uint256 _initialSupply, uint256 _maxSupply, string _tokenName, uint8 _decimals, string _symbol, bool _transferAllSupplyToOwner, bool _locked ) ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked) { standard = ; minters[msg.sender] = true; maxSupply = _maxSupply; }",1
0x1c8f7f728844cd77bf83a7247febe460a7db284e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26.sol,Admin,"contract Admin is Variable, Modifiers, Event { function admin_tokenBurn(uint256 _value) public isOwner returns(bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit TokenBurn(msg.sender, _value); return true; }",1
0xd81fe2c11edd560c4d44fdd4f651f3608452beed.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); }",1
0x0e9eccf7ced35da0702c9e2d943654da80fc72dd.sol,HKDD,"contract HKDD is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x1d72347bfc99b65a61ecf464676994ef725e3294.sol,Token,"contract Token is StandardToken{ uint currUnlockStep; uint256 currUnlockSeq; mapping (uint => uint256[]) public freezeOf; mapping (uint => bool) public stepUnlockInfo; mapping (address => uint256) public freezeOfUser; uint256 internal constant INITIAL_SUPPLY = 1 * (10**8) * (10 **18); event Burn(address indexed burner, uint256 value); event Freeze(address indexed locker, uint256 value); event Unfreeze(address indexed unlocker, uint256 value); event TransferMulti(uint256 count, uint256 total); constructor() { owner = msg.sender; balanceOf[owner] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; }",1
0x178381837f84a7a636f57a3f2946cda512e5caab.sol,TreasureToken,contract TreasureToken { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0x85df7eac31157bbdef55f05b0e8f25d3a74f7f88.sol,ERC20,"contract ERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function ERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Bankrollable,contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; },1
0x3633c61be0dd1b1fd20a97e05c5ed880a204de33.sol,EtherTeam,"contract EtherTeam is Ownable,PyramidEvents{ using SafeMath for uint; address private wallet1; address private wallet2; uint public startAtBlockNumber; uint public curBubbleNumber= 1000; bool public gameOpened=false; uint public totalPlayers=0; mapping(address=>uint) playerRefCode; mapping(uint=>address) playerRefxAddr; mapping(uint=>uint) parentRefCode; mapping(uint=>uint) numOfBubblesL1; mapping(uint=>uint) numOfBubblesL2; mapping(uint=>uint) numOfBubblesL3; mapping(address=>uint) playerRewards; mapping(uint=>uint) referees; uint gameRound=1; mapping(uint=>address) roundxAddr; mapping(uint=>uint) roundxRefCode; constructor(address _addr1,address _addr2)public { wallet1=_addr1; wallet2=_addr2; startAtBlockNumber = block.number+633; }",1
0x54345d405d4f459c22954b1a233cd42bfd3a9262.sol,ERC23PayableToken,"contract ERC23PayableToken is BasicToken, ERC23{ function transfer(address to, uint value, bytes data){ transferAndPay(to, value, data); }",1
0x201e7cd92e03ea87c51d3e22974243ed7a26a1cb.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 7; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0xedf7eac72ff28dbcde6aa14322726a7d05739007.sol,EasyInvest20,contract EasyInvest20 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 20 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206.sol,LotteryAdmin,"contract LotteryAdmin { address public owner; address public admin; address public proposedOwner; address public ethereumLottery; uint public dailyAdminAllowance; uint public lastAllowancePaymentTimestamp; uint public nextProfile; event Deposit(address indexed _from, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6b6d1a8858893c3e228f335726e1417a35832f76.sol,Carbon,contract Carbon { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 1000000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardOwnership,"contract CardOwnership is CardMint { function _approve(address _owner, address _approved, uint256 _tokenId) internal { cardIdToApproved[_tokenId] = _approved; emit Approval(_owner, _approved, _tokenId); }",1
0x1fc4f3ed0415fd13748383a08069c549910cc655.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06.sol,TokenTWL,"contract TokenTWL { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenTWL( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x128a0cdaf3bb00e4b5357e02ff0682933beb407f.sol,ERC20Connect,"contract ERC20Connect is ERXInterface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Connect() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); unitsOneEthCanBuy = 5000; fundsWallet = msg.sender; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 300000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0x6d105976d1a93e1ce23b825b562519144a56d7a4.sol,StringDump,contract StringDump { event Event(string value); function emitEvent(string value) public { Event(value); },1
0x268f03c41d3f33a697eed9c7f0632053556fae9e.sol,BountyClaims,"contract BountyClaims is Ownable { using SafeMath for uint256; ERC20 public token; address public wallet; mapping(address => uint256) bountyTokens; event Claim( address indexed beneficiary, uint256 amount ); function BountyClaims( ERC20 _token, address _wallet) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; }",1
0x6c3f8dafc614075f627a8ff34cc605e1a1fa6d52.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,EthDeposit,contract EthDeposit is Owned { address public Manager; address public NewManager; uint public SponsorsQty; uint public CharterCapital; uint public ClientQty; uint public PrcntRate = 5; bool paymentsAllowed; struct Lender { uint LastLendTime; uint Amount; uint Reserved; },1
0x35e44051799bd7cea091c4fad2cba9b37e364c5b.sol,myPreICO,contract myPreICO is Ownable { uint public ETHRaised; uint public soft_cap = 1 ether; uint public hard_cap = 10 ether; address public owner = 0x0; uint public end_date; address[] public holders; mapping (address => uint) public holder_balance; function myICO() public { owner = msg.sender; end_date = now + 90 days; },1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x0188404de3811357ef0157f9b3aeeca7d32d3b68.sol,NISSAN_usd_31_883,"contract NISSAN_usd_31_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1143826793595050000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x693e3857aa48bb2902fd12f724dc095622e61afc.sol,DopeToken,"contract DopeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DopeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000; balances[0xe2f54E82B8E413537B95e739C2e80d99dE40C67B] = _totalSupply; Transfer(address(0), 0xe2f54E82B8E413537B95e739C2e80d99dE40C67B, _totalSupply); }",1
0x0d3d475f035705a662f5ab34e374e3c44bb52187.sol,Config,contract Config { uint256 public constant jvySupply = 333333333333333; uint256 public constant bonusSupply = 83333333333333; uint256 public constant saleSupply = 250000000000000; uint256 public constant hardCapUSD = 8000000; uint256 public constant preIcoBonus = 25; uint256 public constant minimalContributionAmount = 0.4 ether; function getStartPreIco() public view returns (uint256) { uint256 nowTime = block.timestamp; uint256 _preIcoStartTime = nowTime + 1 minutes; return _preIcoStartTime; },1
0x2054a15c6822a722378d13c4e4ea85365e46e50b.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xf3eb8b0600739111e41c14be93fcff15f104e6e6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x87d1ccf428832015d6108520d6d0909013753a62.sol,SafeMath,None,1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0xf3dce610acbfbcbb4efc12c4c2e3be063128baad.sol,NumbersToken2,"contract NumbersToken2 { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function NumbersToken() public { }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x29daf1dc4eb5c8b519b24d06812a0f92a5d973ae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2de9307ff85d1ca43fa8448de90038a9c719f459.sol,TravelChain,contract TravelChain { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 99000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0xed04927a3849fc9db3f3341a17b7d844a6c551a8.sol,CrowdInvestment,"contract CrowdInvestment { uint private restAmountToInvest; uint private maxGasPrice; address private creator; mapping(address => uint) private perUserInvestments; mapping(address => uint) private additionalCaps; uint private limitPerInvestor; function CrowdInvestment(uint totalCap, uint maxGasPriceParam, uint capForEverybody) public { restAmountToInvest = totalCap; creator = msg.sender; maxGasPrice = maxGasPriceParam; limitPerInvestor = capForEverybody; }",1
0x6560c60f55c165e6f819b3a52c13f9f1aa22b502.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x00b9034425e357bf61b4abeb22299ec4a62c725b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 110000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0x281043fa2101009dc85d98e0fcd538d299f6eb1c.sol,TKCC,"contract TKCC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKCC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4702d2c2a715e1c3a738b923236d12fe834b61d1.sol,TaiwanCoin,"contract TaiwanCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 23000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1af79fb7772ebafebcfd5cc79e67281a814ccb1d.sol,ISBToken,"contract ISBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ISBToken() public { symbol = ; name = ; decimals = 9; _totalSupply = 100000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0xf022c002e82faf509ba89698b529ae813b7a735d.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x54d3ad23846643b93098915001ab274ea19e5622.sol,Maths,None,1
0xc608f567bcf51b0d84edef669b9d7d47440b7bb7.sol,EthronTokenPonzi,"contract EthronTokenPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthronTokenPonzi() public { }",1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0x70e6718a025dfaa44159f1c9a9cc20f575f3cdf0.sol,Payreum,contract Payreum is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 500000000 * (10 ** uint256(decimals)); uint256 public PYRToEth; uint256 public ethInWei; address public devWallet; function Payreum () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; PYRToEth = 200000; devWallet = msg.sender; },1
0x3fe53debe8720a61a3e40f85da8611e810fe1fa0.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { totalSupply = 0 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xc8035ea3580d5dd63b7535c26687fe18f8284e2f.sol,Rapide,"contract Rapide { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Rapide( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0ef4bd1e9baa163d410b31d47bd4e9ebe7dfda1c.sol,EdxToken,contract EdxToken is ERC20 { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; struct VestInfo { uint256 vested; uint256 remain; },1
0xed787fc6835408bfc3ea8e24dfea1f4ea54be982.sol,Molecule,"contract Molecule { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Molecule( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x400c73395bbc01d9e757f02f267925e1de0779f8.sol,TokenDrop,contract TokenDrop { ERC20 token; function TokenDrop() { token = ERC20(0xec662B61C129fcF9fc6DD6F1A672021A539CE45d); },1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoinSale,"contract HngCoinSale is owned, HngCoin { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HngCoinSale( uint256 initialSupply, string tokenName, string tokenSymbol ) HngCoin(initialSupply, tokenName, tokenSymbol) public {}",1
0x6e3990c89bd13397f3c080500805863275cc85ec.sol,POSV,contract POSV { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf0f0ec744a717807a24322d0e2fecc6b73c2d752.sol,DragonKing,contract DragonKing is mortal { struct Character { uint8 characterType; uint128 value; address owner; uint64 purchaseTimestamp; },1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0xf21ed2a554d3fcc7b7c88f463b314a227caea7bf.sol,VALEO_301202,"contract VALEO_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11287331013060800000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b0d7b8357bb851de9f1953199c39c7bc4675796.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x1782829b659575b18bb6f8d146ec3405ae5a4bba.sol,ZeroChainToken,"contract ZeroChainToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZeroChainToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 6 weeks; }",1
0x48f3726c787bdc36bb00c978e701879ceed185a4.sol,LT,"contract LT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LT() public { balances[msg.sender] = 2100000000000; totalSupply = 2100000000000; name = ; decimals =4; symbol = ; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x2a99ff217a1077facf743a2eecfa5c56f22383de.sol,Crowdsale,"contract Crowdsale { uint public createdTimestamp; uint public start; uint public deadline; address public beneficiary; uint public amountRaised; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( ) { createdTimestamp = block.timestamp; start = 1526292000; deadline = 1529143200; amountRaised=0; beneficiary = 0xDfD0500541c6F14eb9eD2A6e61BB63bc78693925; }",1
0x70acb336d7d4bfa8c19d9cfab5f8c5c1aa0d8dee.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xdc8fd6abd32fd9d0dc74e6947aca082658adeb3d.sol,UMIproject,contract UMIproject { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; UMIBiggestInvestor public umiBiggestInvestor; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x6567751ec2b2d2566456bea3fd3090045cb0c865.sol,PPToken,"contract PPToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PPToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b60414447a58a9ac5e28fd695f1e23874103ef0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DDBBCOIN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = 8; balanceOf[msg.sender] = 2160000000000000; name = ; symbol = ; }",1
0x1d1c828239c3986fc6be89b6d54964b54fc9231f.sol,PORNCASH,"contract PORNCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PORNCASH() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29] = _totalSupply; Transfer(address(0), 0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29, _totalSupply); }",1
0x658d45e88e62ac0efcbdf5ddf222b1bb51015851.sol,QNC,"contract QNC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function QNC( ) public { totalSupply = 10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c8951c94b059900d05b10d592b44c78574196c5.sol,EtherCityToken,"contract EtherCityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.005 ether; uint256 private secondStepLimit = 0.055 ether; uint256 private thirdStepLimit = 0.5 ether; uint256 private fourthStepLimit = 10.0 ether; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0xbdae4cb65e1c68cd9cd41b73c93ae3d331acad5c.sol,Vote,"contract Vote is Ownable { event CandidateRegistered(uint candidateId, string candidateName, string candidateDescription); event VoteCast(uint candidateId); struct Candidate { uint candidateId; string candidateName; string candidateDescription; }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44df18f1936ea129d1f87e240f099b8bcc52b602.sol,Horger,"contract Horger { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xda908dcf358351d79e5051a7118c9318f67fcfc9.sol,Troo,"contract Troo is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Troo ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x01b90ee8249afdf628f738af4a2a8ffd7b8434ed.sol,DMC,"contract DMC { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xaa88e4e83055f144a9f265a217d5727c8b0df57a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x28bd55152293595c65652f175c1e8fa95d10be93.sol,NandoCoin,"contract NandoCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8.sol,UniCoin,"contract UniCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UniCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x658b3573f8222c2d792ff1199933a88680b12973.sol,RaceToken,"contract RaceToken is ERC721, AccessAdmin { struct Fashion { uint16 equipmentId; uint16 quality; uint16 pos; uint16 production; uint16 attack; uint16 defense; uint16 plunder; uint16 productionMultiplier; uint16 attackMultiplier; uint16 defenseMultiplier; uint16 plunderMultiplier; uint16 level; uint16 isPercent; }",1
0x516f49a1a2087d481b73abe69f50d6e663228cca.sol,CRYPTOZOLToken,"contract CRYPTOZOLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOZOLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000000000000000000000; balances[0x9254ab18462437F517De179806d83Aa5c9A27031] = _totalSupply; Transfer(address(0), 0x9254ab18462437F517De179806d83Aa5c9A27031, _totalSupply); }",1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2997ab37017123cbda1529adcdc591ed81d58255.sol,GIFTtoken,"contract GIFTtoken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 11; uint256 public initialSupply; function GIFTtoken () { totalSupply = 100000000 * 10 ** decimals; balances[0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, 0x2B58ff794923166197d42E4d79E4Fa7c5746EFbF, totalSupply); }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,TokenRK50Z,"contract TokenRK50Z is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = false; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRK50Z() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x87b3a2c40e63ef9410da6c985a1501fe4972c4e4.sol,SPGForEver,contract SPGForEver { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => uint256) public lockOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 10000000000 * 10 ** decimals; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x2fb23f5b0b18e947186c9cc848b86d550c81711c.sol,AndhraToken,"contract AndhraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AndhraToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0x3878c8700b65afcc237f0cf29dc7eae7fa236192] = _totalSupply; Transfer(address(0), 0x3878c8700b65afcc237f0cf29dc7eae7fa236192, _totalSupply); }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b31a898f7e711b323a6212eac4ae250e0d6624f.sol,EthLendToken,"contract EthLendToken { string public name = ; string public symbol = ; uint8 public constant decimals = 18; address public owner; uint256 public constant tokensPerEth = 1; uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether; uint256 public constant howManyEtherInWeiToKillContract = 500 ether; uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether; bool public funding = true; uint256 totalTokens = 1000; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Migrate(address indexed _from, address indexed _to, uint256 _value); event Refund(address indexed _from, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function QLinkToken() public { owner = msg.sender; balances[owner]=1000; }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xc7cbd16654cf938e6c9cc3ade88ae9ee21c27edf.sol,CTSCToken,"contract CTSCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CTSCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1250000000000000000000000000; balances[0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f] = _totalSupply; Transfer(address(0), 0x83d9675D2C603f3F3Be7CE0379b7e74FD75a923f, _totalSupply); }",1
0xefb0e0d88f674d4c79760f411cba2a10221de4f9.sol,SafeMath,None,1
0x51f4fcf219d79855341f749c0f1008c6066a2f1f.sol,EQU,"contract EQU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EQU( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b.sol,KpopItem,contract KpopItem is ERC721 { address public author; address public coauthor; address public manufacturer; string public constant NAME = ; string public constant SYMBOL = ; uint public GROWTH_BUMP = 0.4 ether; uint public MIN_STARTING_PRICE = 0.001 ether; uint public PRICE_INCREASE_SCALE = 120; uint public DIVIDEND = 3; address public KPOP_CELEB_CONTRACT_ADDRESS = 0x0; address public KPOP_ARENA_CONTRACT_ADDRESS = 0x0; struct Item { string name; },1
0xc66e78b1078ba0e65d311c92854dd446451b2ba6.sol,Xoom,"contract Xoom is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xoom() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b] = _totalSupply; Transfer(address(0), 0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b, _totalSupply); }",1
0x693e3857aa48bb2902fd12f724dc095622e61afc.sol,DopeToken,"contract DopeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DopeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000; balances[0xe2f54E82B8E413537B95e739C2e80d99dE40C67B] = _totalSupply; Transfer(address(0), 0xe2f54E82B8E413537B95e739C2e80d99dE40C67B, _totalSupply); }",1
0x04247b9b59091b349eb60e429fe7dbc99fdad34b.sol,FSC3,"contract FSC3 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function FSC3( ) TokenERC20() public {}",1
0x6ba0841cd866e2d914d38f4af0643b7a982b3b51.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1b413506fc42e2f04a4e8c57710f850b234d6653.sol,EpiphanyCoin,"contract EpiphanyCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EpiphanyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3452519f4711703e13ea0863487eb8401bd6ae57.sol,BulkSender,"contract BulkSender is Ownable { using SafeERC20 for ERC20Basic; function bulkTransfer(ERC20Basic token, address[] toAddresses, uint256[] values) public onlyOwner returns (bool) { require((toAddresses.length > 0) && (toAddresses.length == values.length)); for (uint i = 0; i < toAddresses.length; i++) { token.safeTransfer(toAddresses[i], values[i]); }",1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xe0090146f0eb3193a8a12380e3ec14732589e41f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41f2efdcd15eadf974d8f9bea14c2936823d095f.sol,CryptoPepeMarketToken,"contract CryptoPepeMarketToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => TopOwner) private topOwner; mapping (uint256 => address) public lastBuyer; mapping (uint256 => address) public itemIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public itemIndexToApproved; mapping (uint256 => uint256) private itemIndexToPrice; address public ceoAddress; address public cooAddress; struct TopOwner { address addr; uint256 price; }",1
0x84cc06eddb26575a7f0afd7ec2e3e98d31321397.sol,DiamondDividendMain,contract DiamondDividendMain { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b5d0fbbd75d4501e5cdc854c445fb0eabcb0afc.sol,EmrCrowdfund,"contract EmrCrowdfund is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function EmrCrowdfund( uint256 initialSupply, uint256 _tokenPrice, string tokenName, string tokenSymbol ) public { tokenPrice = _tokenPrice / 10 ** uint256(decimals); totalSupply = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; }",1
0x1af79fb7772ebafebcfd5cc79e67281a814ccb1d.sol,ISBToken,"contract ISBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ISBToken() public { symbol = ; name = ; decimals = 9; _totalSupply = 100000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x88eded8712c5ea071c56284a2078336a551e4eda.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe.sol,ENVELOPE,contract ENVELOPE { bytes32 public hashPass; bool closed = false; address sender; uint unlockTime; function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);},1
0x5209283a7ad07b579cb34183f4dc1da2aef422dc.sol,Crowdsale,"contract Crowdsale { address public beneficiary; uint public tokenBalance; uint public amountRaised; uint public deadline; uint dollar_exchange; uint test_factor; uint start_time; token public tokenReward; mapping(address => uint256) public balanceOf; event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale() { tokenBalance = 50000; beneficiary = 0x6519C9A1BF6d69a35C7C87435940B05e9915Ccb3; start_time = now; deadline = start_time + 30 * 1 days; dollar_exchange = 295; tokenReward = token(0x67682915bdfe37a04edcb8888c0f162181e9f400); }",1
0x0e9eccf7ced35da0702c9e2d943654da80fc72dd.sol,HKDD,"contract HKDD is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5caa790ee0586c78db45da6e37409315d1712f3e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7895a43ae537e8e1ac97006ea9235807eea04cfa.sol,YunMint,"contract YunMint is Operational, ReentrancyGuard, BurnableToken, StandardToken { using SafeMath for uint; using SafeMath for uint256; using DateTime for uint256; event Release(address operator, uint256 value, uint256 releaseTime); event Burn(address indexed burner, uint256 value); event Freeze(address indexed owner, uint256 value, uint256 releaseTime); event Unfreeze(address indexed owner, uint256 value, uint256 releaseTime); struct FrozenBalance {address owner; uint256 value; uint256 unFrozenTime;}",1
0x3fd8f39a962efda04956981c31ab89fab5fb8bc8.sol,Rotharium,"contract Rotharium is owned{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function Rotharium( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3763fc61bc1b54d97dfdbd1501a3ff476bd99c36.sol,MworldElectronicsportscoin,"contract MworldElectronicsportscoin { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x345943aae101bfc73aa32eaff2b9abe7d6790b71.sol,KeyPay,"contract KeyPay is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x1cae8c6ec705520b11f10f773b7010958363318e.sol,Hermes,contract Hermes { using MathForInterset for uint; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public DAY_VALUE = 0; uint public DAY_LIMIT = 200 ether; uint public DEPOSIT_AMOUNT; uint public PERCENT_FOR_MARKETING = 1500000000; address[] public ADDRESSES; mapping(address => Investor) public INVESTORS; address public ADMIN_ADDR; struct Investor { uint id; uint percentCount; uint deposit; uint date; address referrer; uint reinvestID; uint actualValue; uint stage; uint startReinvestDate; uint dayLimitValue; },1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0x56f366e4245e459078fd70cb21d20e6e27324c36.sol,PayItBack,"contract PayItBack { uint constant HOLD_TIME = 31 days; address public creator; uint public contributionTime = 0; uint public totalContributions = 0; bool public isDisabled = false; event Contribution(uint _amount, address _from); event OwnershipConfirmed(); event PaidOut(uint _amount); event Warning(string _message); event Disabled(); modifier ownerOnly() { require(msg.sender == creator, ); _; }",1
0xce7382bf7f277a2b661aaf71408ac65b287305a0.sol,Maccabi,"contract Maccabi is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Maccabi() { uint supply = 15200000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x5caa790ee0586c78db45da6e37409315d1712f3e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0305b4ccbfd603d92ca0d5eae752000273e26a60.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17fd666fa0784885fa1afec8ac624d9b7e72b752.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0x3375d3d9df8c67b3d7ebce220c3dda4be03dce31.sol,SantimentWhiteList,contract SantimentWhiteList { string constant public VERSION = ; function () { throw; },1
0x57463c652ed95146937e94f02201f127bf7e9836.sol,LeinosCoin,"contract LeinosCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x51e7359d008a85a021da36370d78b594079a67b1.sol,WorldRobot,"contract WorldRobot { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x75163374524bac8ca983bea408a0e3f22a1cb25b.sol,BannerDesk,"contract BannerDesk is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000000; balances[0x3b970B892c1113a567656b447f14A7195C85C487] = _totalSupply; emit Transfer(address(0), 0x3b970B892c1113a567656b447f14A7195C85C487, _totalSupply); }",1
0x7051620d11042c4335069aaa4f10cd3b4290c681.sol,TCASH,contract TCASH is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 88000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TCASH() { owner = msg.sender; balances[owner] = 88000000 * 10**8; },1
0x5c8f0deb9797f63117cdc2a802140b61928c64f9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x293f4f057a37f3b1806dbb362bddb242c0c39add.sol,MINNYCoin,"contract MINNYCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x214f96e84d3c0f2920bb90fec861be4925edf02b.sol,HorseyToken,"contract HorseyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor(string _symbol, string _name, uint8 _decimals, uint _totalSupply ) public { symbol = _symbol; name = _name; decimals = _decimals; totalSupply = _totalSupply * 10**uint(_decimals); balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); }",1
0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce.sol,Botcash,"contract Botcash is owned { uint256 totalSupply; string public name; string public symbol; uint8 public decimals; uint public minBalanceForAccounts; uint256 sellPrice; uint256 buyPrice; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public { if (centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x1dd7c1a2be393644bf56420aa64d53058a3c430a.sol,SodaCoin,"contract SodaCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76] = _totalSupply; emit Transfer(address(0), 0xC713b7c600Bb0e70c2d4b466b923Cab1E45e7c76, _totalSupply); }",1
0x73390087000b126be1ced616a9df4daff59d03c6.sol,CHEMCHINA_PFV_I_883,"contract CHEMCHINA_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 582396634707317000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xbf6008bd7ac150e50fbb4efe6aa6af5ae47362b9.sol,MultiSigWallet,"contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionHash); event Revocation(address sender, bytes32 transactionHash); event Submission(bytes32 transactionHash); event Execution(bytes32 transactionHash); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequiredUpdate(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; }",1
0x3a1237d38d0fb94513f85d61679cad7f38507242.sol,Mindexcoin,"contract Mindexcoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Mindexcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d9bbc5035f2b0f74fc3e0a8a023aa98f5749fa.sol,mango,"contract mango is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function mango() public { symbol = ; name = ; decimals = 18; emit Transfer(address(0),0xAc2682F1Bd5316875805058f4Ec6157ccdE04859, 100000); bonusEnds = now + 12 weeks; endDate = now + 20 weeks; }",1
0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0.sol,MyToken,"contract MyToken is owned { string public name = ; string public symbol = ; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x1cc2a863c070340f21f441648bbceed77656a137.sol,KeytonToken,"contract KeytonToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KeytonToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x6360E136A401D4373B3AB084F46Ea9550d088302] = _totalSupply; Transfer(address(0), 0x6360E136A401D4373B3AB084F46Ea9550d088302, _totalSupply); }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,WhiteList,"contract WhiteList is Ownable { mapping (address => uint8) internal list; event WhiteBacker(address indexed backer, bool allowed); function setWhiteBacker(address _target, bool _allowed) onlyOwner public { require(_target != 0x0); if(_allowed == true) { list[_target] = 1; }",1
0x002036ed3d00736787a31a19b1e28f7a86c72672.sol,DLP,"contract DLP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DLP() public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4bb0f20cf2e4cd470ed9537b1b69aa7a2c53707d.sol,_List_Glory_,contract _List_Glory_{ string public info_Name; string public info_Symbol; address public info_OwnerOfContract; string[] private listTINAmotley; uint256 private listTINAmotleyTotalSupply; mapping (uint => address) private listTINAmotleyIndexToAddress; mapping(address => uint256) private listTINAmotleyBalanceOf; struct forSaleInfo { bool isForSale; uint256 tokenIndex; address seller; uint256 minValue; address onlySellTo; },1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,pricerControl,"contract pricerControl is canFreeze { I_Pricer public pricer; address public future; uint256 public releaseTime; uint public PRICER_DELAY = 2; event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange); function setPricer(address newAddress) onlyOwner { releaseTime = now + PRICER_DELAY; future = newAddress; EventAddressChange(pricer, future, releaseTime); }",1
0x69ceaea78e28d62bc1ac68491d77f6a761edce01.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcfd2e5876cb479dc9d86abb2ff4bfe166c8d8d22.sol,Dedit,"contract Dedit { event RegistrationCreated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); event RegistrationUpdated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); struct Registration { address registrant; bytes32 hash; uint blockNumber; string description; }",1
0xed0f41abc9fdb3052ebd5391c80e1ee792ec4f42.sol,pricerControl,"contract pricerControl is canFreeze { I_Pricer public pricer; address public future; uint256 public releaseTime; uint public PRICER_DELAY = 2; event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange); function setPricer(address newAddress) onlyOwner { releaseTime = now + PRICER_DELAY; future = newAddress; EventAddressChange(pricer, future, releaseTime); }",1
0x0078bd770f55a3c6b8f3b3d2a0c21fcac8a92394.sol,SetLibrary,None,1
0xb47f7059e3706c0ccf270ba11f1747a137f9fd12.sol,Fund,"contract Fund{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function Fund() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0x1e172788434e2e2bdee70df0cf552d8da3fe7a65.sol,IVNT5Token,"contract IVNT5Token is ERC20Interface, Owned, SafeMath { string public symbol; string public name; address public ownerAddress; uint8 public decimals; uint public totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; constructor() public { symbol = ; name = ; decimals = 18; totalSupply = 969 * 10 ** 26; ownerAddress = 0xBe0B705D79dD99aA8512A16d0256fA5b864e6c59; balances[ownerAddress] = totalSupply; emit Transfer(address(0), ownerAddress, totalSupply); }",1
0x53c2159fa4690ccaa773086a137fb1cd17f65f35.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x69d94dc74dcdccbadec877454a40341ecac34a7c.sol,IRideToken,"contract IRideToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IRideToken() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x719e7f0dadfdea25b78595da944f44d15d7e6795.sol,Musk,"contract Musk is Token { string public name; uint8 public decimals; string public symbol; constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc709c316555ae3002ccc1c0ff7bd2ba83b9cd067.sol,TUNISIA_WINS,"contract TUNISIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2771ef07defb079c309542e11219d97b562ab6b0.sol,Avalanche,"contract Avalanche is AVL { string public constant name = ; uint8 public constant decimals = 4; string public constant symbol = ; string public constant version = ; event tokensCreated(uint total, uint price); event etherSent(uint total); event etherLeaked(uint total); uint public constant pieceprice = 1 ether / 256; uint public constant oneavl = 10000; uint public constant totalavl = 1000000 * oneavl; mapping (address => bytes1) addresslevels; mapping (address => uint) lastleak; function Avalanche() public { incirculation = 10000 * oneavl; balances[0xe277694b762249f62e2458054fd3bfbb0a52ebc9] = 10000 * oneavl; }",1
0x137099bdc97fa0c487612466333d2b28bf0c2aa4.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3aa343d578050e333676b560f6465fa181c02edf.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x40f4991411ac5377675c421e87378e10470134a3.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x48ee772b8c8927d8d32afc8961fbc177fb723637.sol,Contribution,"contract Contribution is SafeMath, Owned { uint256 public constant MIN_FUND = (0.01 ether); uint256 public constant CRAWDSALE_START_DAY = 1; uint256 public constant CRAWDSALE_END_DAY = 7; uint256 public dayCycle = 24 hours; uint256 public fundingStartTime = 0; address public ethFundDeposit = 0; address public investorDeposit = 0; bool public isFinalize = false; bool public isPause = false; mapping (uint => uint) public dailyTotals; mapping (uint => mapping (address => uint)) public userBuys; uint256 public totalContributedETH = 0; event LogBuy (uint window, address user, uint amount); event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle); event LogFinalize (uint finalizeTime); event LogPause (uint finalizeTime, bool pause); function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle) { require( now < _fundingStartTime ); require( _ethFundDeposit != address(0) ); fundingStartTime = _fundingStartTime; dayCycle = _dayCycle; ethFundDeposit = _ethFundDeposit; investorDeposit = _investorDeposit; LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle); }",1
0x6eedd095c335a7dae40db56832607093e1ae6311.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; emit Transfer(address(this), msg.sender, totalSupply); }",1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x1d8ebb2f0345874e9193388ef3a2f063eaa71edc.sol,QuadCoin,"contract QuadCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function QuadCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000000; balances[0x8E38343A2fFcC3dC60b623128E506E1DF5713b62] = _totalSupply; Transfer(address(0), 0x8E38343A2fFcC3dC60b623128E506E1DF5713b62, _totalSupply); }",1
0x6ab4c5563213ea49d3475d8b53f6fec918871d90.sol,DENMARK_WINS,"contract DENMARK_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x05d379b48a8622ae4018309e116420db4a38a225.sol,ELYTE,"contract ELYTE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ELYTE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x402288b27f39223d8a8131b53b35b9976d2c46d7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed023b117953fcfaa92150d3ebe3e987d19563ce.sol,ERC721DutchAuction,"contract ERC721DutchAuction is Ownable, Pausable { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0xa1b522e7985bbc9e543dfdc0c9752b140ee8447d.sol,OilChainGlobal,"contract OilChainGlobal { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xe3eec4b1a59dd6b42a98c2f7ad64b56fee15337d.sol,Ticket2Crypto,contract Ticket2Crypto { struct player_ent{ address player; address ref; },1
0x20b1c3faf91b57f0dcf016c4ce318c8504248c16.sol,BigchatToken,"contract BigchatToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BigchatToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,CompanyFundingAccount,contract CompanyFundingAccount { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0x35ae44bc4e3186ca732efa09a459cf93fa491a47.sol,XMLYToken,"contract XMLYToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) freezed; mapping(address => uint) freezeAmount; mapping(address => uint) unlockTime; function XMLYToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5B807E379170d42f3B099C01A5399a2e1e58963B] = _totalSupply; Transfer(address(0), 0x5B807E379170d42f3B099C01A5399a2e1e58963B, _totalSupply); }",1
0x6a00a6cd60733c483070aa5e7d835fa81fe5b10a.sol,BJUIO,"contract BJUIO { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; bool public send_allowed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x888934de736b7f5244f006a655f3bcd71ef0979d.sol,Oryx,"contract Oryx is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Oryx() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x439d5924500Aa4E2F0cD5A0d84fdd9c8Cb983418] = _totalSupply; Transfer(address(0), 0x439d5924500Aa4E2F0cD5A0d84fdd9c8Cb983418, _totalSupply); }",1
0x71880d9f448c995ec5a7c9d68f2b0e256ef510d2.sol,ValueTokenBase,"contract ValueTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ValueTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x28f01187b61d799f6d90a7c8c5325a9de95f025d.sol,Sender,contract Sender is admined { token public DEEM; function Sender (token _addressOfToken) public { DEEM = _addressOfToken; },1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x44b1cdc06c3afa610e125a3cbcc9b8cce7c366dc.sol,VOCC_I060_20181211,"contract VOCC_I060_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5b36ca95ed4145a608b9f474f81f3c345dc6599f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x64bfbfa5aedd9622f627e3ddeadb634eb96a6fed.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x52ccb8ebb0f55a592ce67dd49249f6cb0c64a129.sol,Globglogabgalab,"contract Globglogabgalab is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Globglogabgalab() public { symbol = ; name = ; decimals = 7; _totalSupply = 13370000000000000; balances[0x433a57803f841C5611e5370ad5CD97bf46e25cb6] = _totalSupply; Transfer(address(0), 0x433a57803f841C5611e5370ad5CD97bf46e25cb6, _totalSupply); }",1
0xf066a61ebcb0a11ec3921cf9fbcca4561877526f.sol,MasterNodeMining,"contract MasterNodeMining is Ownable{ using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maximumSupply = 10000000 * (10 ** uint256(decimals)); uint256 public constant icoSupply = 9000000 * (10 ** uint256(decimals)); uint256 public constant TokensPerEther = 1000; uint256 public constant icoEnd = 1522540800; uint256 public constant teamTokens = 1538352000; address public multisig = 0xF33014a0A4Cf06df687c02023C032e42a4719573; uint256 public totalSupply; function transfer(address _to, uint _value) public returns (bool success) { require( msg.data.length >= (2 * 32) + 4 ); require( _value > 0 ); require( balances[msg.sender] >= _value ); require( balances[_to] + _value > balances[_to] ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x28b07e3fe42cd85177bcbbad8e4b60e9e19aac0e.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x482f35aba9fb3dc1c4942dacb29b9a22cb648482.sol,NAST,"contract NAST { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NAST() public { totalSupply = 34550000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0xd359e3f53b5d4e11b8b11dc0772448f380accf3c.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0xb430244b442c228a59a0fd4450fa7eedd5fbf833.sol,VOC_ethchf_48013527701_20181215,"contract VOC_ethchf_48013527701_20181215 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 330000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x03200f18368a33906491df56b74cc97986fbdbce.sol,XueBiToken,"contract XueBiToken { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function XueBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37eba68380f5a549532f658244f82619ac733c03.sol,VOCC_I042_20181211,"contract VOCC_I042_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x4b4878af9474089783f9cef61edbe96614af79e6.sol,CCD_KOHLE_5_20190411,"contract CCD_KOHLE_5_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x71e8d74ff1c923e369d0e70dfb09866629c4dd35.sol,WorkCoin,"contract WorkCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WorkCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5838f878000fe44b6f6c677bbf839e12f097c147.sol,Q_GAME,contract Q_GAME { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>2 ether) { msg.sender.transfer(this.balance); },1
0xb3bbc0cc040413a3e68dcaa8f2b6eac2957c5ce0.sol,BitGuildToken,"contract BitGuildToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitGuildToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x53e3a7ec57132173ce615debb9a303fd2cd86789.sol,CityToken,"contract CityToken is ERC721 { event CityCreated(uint256 tokenId, string name, string country, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, string country); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.05 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; mapping (uint256 => address) public cityIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cityIndexToApproved; mapping (uint256 => uint256) private cityIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct City { string name; string country; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2a790479cd47f686804fe570b903f3b6cf08599d.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0x749dab228c71e650addba8c9875b842ad460a3c2.sol,KyberContributorWhitelist,contract KyberContributorWhitelist is Ownable { uint public slackUsersCap = 7; mapping(address=>uint) public addressCap; function KyberContributorWhitelist() {},1
0xbbf283a1386b1b5e258eec60f27f775972c68571.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x557739fb7e603f0202d6a5671525eb97c7ebe609.sol,UKC,"contract UKC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function UKC() public { balances[msg.sender] = 2000000000000; totalSupply = 2000000000000; name = ; decimals =4; symbol = ; }",1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0x544789c586ddaed07ffb23f41ca1334232cb1804.sol,A_TAXPHONE,"contract A_TAXPHONE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x0311dEdC05cfb1870f25de4CD80dCF9e6bF4F2e8; address internal constant partone = 0xC92Af66B0d64B2E63796Fd325f2c7ff5c70aB8B7; address internal constant parttwo = 0xbfd0Aea4b32030c985b467CF5bcc075364BD83e7; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62.sol,WncToken,"contract WncToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WncToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x28380d4942470c315c2974b934b2080751d35a77.sol,TurdCoin,"contract TurdCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TurdCoin() TokenERC20(1000000, , ) public {}",1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0x1c5599ea81f4946a2ff80dc7438a8e139ee8c746.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function transfer(address _to, uint256 _value) public returns (bool) { if (balances[msg.sender] < _value) { throw; }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0xf2940f868fcd1fbe8d1e1c02d2eaf68d8d7db338.sol,PlayerBook,contract PlayerBook { using SafeMath for uint256; address private admin = msg.sender; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => Player) public plyr_; mapping (uint256 => uint256) public refIDxpID_; struct Player { address addr; },1
0x7329e152d805dec79c67e45d4e04f3b6ce545b7c.sol,HmcDistributor,contract HmcDistributor { uint64 public constant lockDuration = 1 minutes; uint256 public constant bonus = 2*10*18; uint public constant minBlockNumber = 5000000; address public owner; address public hmcAddress; uint256 public joinCount = 0; uint256 public withdrawCount = 0; uint256 public distributorCount = 0; struct member { uint unlockTime; bool withdraw; },1
0x6b3a7e99e399df2efc5f48b55af120283ffc888d.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x483b2942b24681c258bc5b63cd0921e6c5ea997a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x377748ddc51b3075b84500a6ed95d260a102d85f.sol,TuneToken,"contract TuneToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TuneToken() public { totalSupply = 3e9 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a.sol,RocketCoin,"contract RocketCoin { string public constant symbol = ; string public constant name = ; uint public constant decimals = 18; uint public constant totalSupply = 10000000 * 10 ** decimals; address owner; bool airDropStatus = true; uint airDropAmount = 300 * 10 ** decimals; uint airDropGasPrice = 20 * 10 ** 9; mapping (address => bool) participants; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function RocketCoin() public { owner = msg.sender; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0x532975d56cf18f597480e2521246b273ad9ae348.sol,LiabilityFactory,"contract LiabilityFactory { constructor( address _robot_liability_lib, address _lighthouse_lib, XRT _xrt ) public { robotLiabilityLib = _robot_liability_lib; lighthouseLib = _lighthouse_lib; xrt = _xrt; }",1
0x65244ee745288952f347d82ba69690fa9a9843c0.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xc0d766017141dd4866738c1e704be6fedc97b904.sol,TreeToken,"contract TreeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TreeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x68A924EA85c96e74A05cf12465cB53702a560811] = _totalSupply; Transfer(address(0), 0x68A924EA85c96e74A05cf12465cB53702a560811, _totalSupply); }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0x0e6664cdb81ddf20d776b3bcb001797cee4030bc.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0xeee07485b432c56d38bb7e1a8f5d57322cb78f89.sol,TokenMyUnicoin,"contract TokenMyUnicoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMyUnicoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0.sol,CCOIN,"contract CCOIN is ERC20, Ownable { struct Escrow { address creator; address brand; address agreementContract; uint256 reward; }",1
0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c.sol,BitSteveCoin,"contract BitSteveCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitSteveCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x671C107a6Ab0846792d38F284678ac172ecf125d] = _totalSupply; Transfer(address(0), 0x671C107a6Ab0846792d38F284678ac172ecf125d, _totalSupply); }",1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0x05c848e3547bc3ccd977b84140fdc917bfff96a1.sol,BodyRabbit,"contract BodyRabbit is BaseRabbit, ERC721 { uint public totalBunny = 0; string public constant name = ; string public constant symbol = ; PrivateRabbitInterface privateContract; AdmixtureInterface AdmixtureContract; function setPriv(address _privAddress) public returns(bool) { privAddress = _privAddress; privateContract = PrivateRabbitInterface(_privAddress); }",1
0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af.sol,archercoin,"contract archercoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function archercoin() TokenERC20() public {}",1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x568a693e1094b1e51e8053b2fc642da7161603f5.sol,BitConnect,contract BitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x02b46985d243001b3de2ee0b68793016c9ca6843.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xed82730312babb41367e060911f798002ffa445f.sol,TheCryptoTech,"contract TheCryptoTech is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheCryptoTech() public { symbol = ; name = ; decimals = 18; _totalSupply = 950000000000000000000000000; balances[0x59e47c9984d391f4A6095f25d8fA2570e34D87CC] = _totalSupply; Transfer(address(0), 0x59e47c9984d391f4A6095f25d8fA2570e34D87CC, _totalSupply); }",1
0x36eafcf412718774440ed934a81f3e6f90cdd54c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x76c6a8d8bd3ffc0bc0a3198cee1f59fc75bf7d67.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 initialSupply=1000000000; string tokenName=; string tokenSymbol=; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x69d94dc74dcdccbadec877454a40341ecac34a7c.sol,IRideToken,"contract IRideToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IRideToken() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2858f2b0d94947962f93e4387d391467ebd72166.sol,FLEX,"contract FLEX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FLEX( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2.sol,Pie,contract Pie { address public Owner = msg.sender; function() public payable { },1
0xf25957c81fd208b01ce2f4696210d7d141a6c972.sol,DigiDollar,"contract DigiDollar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DigiDollar() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000000000; balances[0xD15346e09Fa6705E79bD13D25463C6da981A3164] = _totalSupply; Transfer(address(0), 0xD15346e09Fa6705E79bD13D25463C6da981A3164, _totalSupply); }",1
0x6b6130ed3d3e50db4e550638ab887c53287d41b7.sol,CSNTToken,"contract CSNTToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 1000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0xf084d5bc3e35e3d903260267ebd545c49c6013d0.sol,DimonCoin,contract DimonCoin { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 200; uint256 public blocksBeforeTargetShoot = 800; event death(address indexed player); event semiShot(address indexed player); event targetShot(address indexed player); constructor() public { },1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0xf226df00c91ec1fd05e89382edeb7b4b12f6dfab.sol,AZEEMCOIN,"contract AZEEMCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AZEEMCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6a33c2c807124eae26f6188877c15675d3889ca3.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5101067e64f9e564bed7dd9c7378d7cc9dd5f550.sol,SilverMoon,contract SilverMoon { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x516f02475acf19bad0352ce3759c42adaac0000f.sol,DateTime,contract DateTime { struct _DateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0x00c7221d5fbdaab1448675a156876efb885a6449.sol,DENMARK_WINS,"contract DENMARK_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1165947079929830000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x3ff283f4b333f0c046dea47938a413a2bae56bf5.sol,FantasySportsCoin,"contract FantasySportsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantasySportsCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0] = _totalSupply; Transfer(address(0), 0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0, _totalSupply); }",1
0xe0c3f2deaa356fea4b6a1355674a766cb5821589.sol,MineableToken,"contract MineableToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public supplyCap; mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; event Approval( address indexed owner, address indexed spender, uint value ); event Transfer( address indexed from, address indexed to, uint256 value ); event Burn( address indexed from, uint256 value ); function MineableToken() public { decimals = uint8(18); supplyCap = 833333333 * 10**uint256(decimals); name = ; symbol = ; }",1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e.sol,PylonToken,"contract PylonToken is owned { string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 3750000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); using SafeMath for uint256; address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535; uint256 public fundingGoal = 21230434782608700000000; uint256 public amountRaised; uint256 public deadline; uint256 public price = 6608695652173910; uint256 public totalTokensToSend = 3250000000000000000000000; uint256 public maxEtherInvestment = 826086956521739000000; uint256 public maxTokens = 297619047619048000000000; uint256 public bonusCap = 750000000000000000000000; uint256 public pylonSelled = 0; uint256 public startBlockBonus; uint256 public endBlockBonus1; uint256 public endBlockBonus2; uint256 public endBlockBonus3; uint256 public qnt10k = 6578947368421050000000; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address deposit, uint256 amountDeposited); event FundTransfer(address backer, uint256 amount, bool isContribution); event LogQuantity(uint256 _amount, string _message); uint256 public startBlock = getBlockNumber(); bool public paused = false; modifier contributionOpen() { require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline); _; }",1
0x9c731584b4422c9f7f7cfd6909b36a72b76ae115.sol,company_funding,contract company_funding { bytes32 keyHash; address owner; bytes32 wallet_id = 0xa9d3c58d3b8d0c6f91a1564bacea67ed012d43683d6978e5d90b5b1099662c51; constructor() public { owner = msg.sender; },1
0xaa840b1138d31cc4a5fcd9545ed03441ef2a1213.sol,DIVIUMx2,contract DIVIUMx2 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x33b44a1d150f3feaa40503ad20a75634adc39b18.sol,TimeCapsule,contract TimeCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function initCapsule(uint open) { Owner = msg.sender; openDate = open; },1
0x711a1836b306d2eac12129c0b97da8931ee80fe2.sol,Burner,"contract Burner { uint256 public totalBurned; function Purge() public { msg.sender.transfer(this.balance / 1000); assembly { mstore(0, 0x30ff) create(balance(address), 30, 2) pop }",1
0x6cb9c5abf310b42893adff0b1f38322eea109c98.sol,DelightToken,"contract DelightToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DelightToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 1500000000000000000; balances[0xbBFe11C614d8089C621E843eDac04F43F6767469] = _totalSupply; Transfer(address(0), 0xbBFe11C614d8089C621E843eDac04F43F6767469, _totalSupply); }",1
0x71fd1b8263b40049269ee881c9cf842e6ca297e0.sol,JPCOIN,"contract JPCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function JPCOIN() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383] = _totalSupply; Transfer(address(0), 0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383, _totalSupply); }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef51c9377feb29856e61625caf9390bd0b67ea18.sol,Bionic,"contract Bionic is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bionic() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xdD2A5B646bb936CbC279CBE462E31eab2C309452] = _totalSupply; Transfer(address(0), 0xdD2A5B646bb936CbC279CBE462E31eab2C309452, _totalSupply); }",1
0x8633e144f2d9b9b8bdd12ddb58e4bef1e163a0ce.sol,Yellow,"contract Yellow { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Yellow( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x279e152f96bdd4a0b3cb10b5fba0cfeea4a7429b.sol,SafeMath,None,1
0x2f50ab197f950e0c2184cf5d804f4141502cd987.sol,LoggedDividend,"contract LoggedDividend is Ownable, LoggedERC20 { struct Dividend { uint256 id; uint256 block; uint256 time; uint256 amount; uint256 claimedAmount; uint256 transferedBack; uint256 totalSupply; uint256 recycleTime; bool recycled; mapping (address => bool) claimed; }",1
0x70e6718a025dfaa44159f1c9a9cc20f575f3cdf0.sol,Payreum,contract Payreum is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 500000000 * (10 ** uint256(decimals)); uint256 public PYRToEth; uint256 public ethInWei; address public devWallet; function Payreum () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; PYRToEth = 200000; devWallet = msg.sender; },1
0xc0d9655d69bdb764ca3f69a8771e87e133fabd94.sol,Serum,"contract Serum { address public minter; mapping (address => uint) public balances; event Sent(address from, address to, uint amount); event Mint(uint amount); function MyCoin() public { minter = msg.sender; }",1
0xf07d979303c50a8632848cb154c6b30980218c07.sol,PXLProperty,contract PXLProperty is StandardToken { uint8 constant LEVEL_1_MODERATOR = 1; uint8 constant LEVEL_2_MODERATOR = 2; uint8 constant LEVEL_1_ADMIN = 3; uint8 constant LEVEL_2_ADMIN = 4; uint8 constant LEVEL_1_ROOT = 5; uint8 constant LEVEL_2_ROOT = 6; uint8 constant LEVEL_3_ROOT = 7; uint8 constant LEVEL_PROPERTY_DAPPS = 8; uint8 constant LEVEL_PIXEL_PROPERTY = 9; uint8 constant FLAG_NSFW = 1; uint8 constant FLAG_BAN = 2; address pixelPropertyContract; mapping (address => uint8) public regulators; mapping (uint16 => Property) public properties; mapping (address => uint256[2]) public ownerWebsite; mapping (address => uint256[2]) public ownerHoverText; struct Property { uint8 flag; bool isInPrivateMode; address owner; address lastUpdater; uint256[5] colors; uint256 salePrice; uint256 lastUpdate; uint256 becomePublic; uint256 earnUntil; },1
0x6ce17d826a1c50e97678810954943c83ebd10066.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1a94fdf6d0bf45d298557789550bb2d7e359ca2d.sol,CrossChainEntertainmentTokenE,"contract CrossChainEntertainmentTokenE { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x127a78da95f02d9139db64ea7d3f6de355975494.sol,DACToken,contract DACToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 30000000000000000; bool public stopped = false; address owner = 0x1e113613C889C76b792AdfdcbBd155904F3310a5; modifier isOwner { assert(owner == msg.sender); _; },1
0x4c49d776c1c314d16b82ecac7ed8f70433db757d.sol,caspianToken,"contract caspianToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function caspianToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply=10000000000000000000000000000; }",1
0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol,CryptoBetOn,contract CryptoBetOn { struct Gamer { address wallet; uint amount; },1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,Freedom,contract Freedom is ERC20Contract { using SafeMath for uint256; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowed; string public constant tokenName = ; string public constant tokenSymbol = ; uint256 public totalSupply = 1000000000e8; uint8 public decimals = 8; constructor () public { balanceOf[msg.sender] = totalSupply; totalSupply = totalSupply; decimals = decimals; },1
0x8be453b8a4a834638407b39b6dbc5e7bbf6c1ce2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2e1f0f6d76b60963b46ee9ddb6797696a0b64ee.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x856912680349a406f72e26aa994100b8ad409f87.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; function transfer(address to, uint value) public returns (bool) { require((to != 0x0) && (to != address(this))); if (balances[msg.sender] < value) revert(); balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); return true; }",1
0xef106bc813cb65695f5a2c01c1ba3403e7e583b4.sol,RUSS_PFXXXVII_I_883,"contract RUSS_PFXXXVII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 595075367869688000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x44ad6729188261006a27b8b937e9f15b2b814f32.sol,Stockfinex,"contract Stockfinex is TokenContainer { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Stockfinex( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x31a5f35f32756fe35d39bafe85607d93185b23f2.sol,GNNM,"contract GNNM { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GNNM( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1df6eadc2e1e9f4cbb2d94369210d8f1b790ee19.sol,PinnacleToken,contract PinnacleToken { uint private constant _totalSupply = 100000000000000000000000000; using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function PinnacleToken() { balances[msg.sender] = _totalSupply; },1
0xbf92c30ecebae64ae5ab0361f9010d7317be3c50.sol,GSEPTO,"contract GSEPTO { string public name = ; string public symbol = ; address private owner; uint256 public fundingGoal; uint256 public amountRaised; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _amount); event FundTransfer(address indexed _backer, uint256 _amount); event IncreaseFunding(uint256 indexed _increase, uint256 indexed _curFundingGoal); bool public crowdsaleOpened = true; function GSEPTO(uint256 _fundingGoal) public { owner = msg.sender; fundingGoal = _fundingGoal; balanceOf[owner] = fundingGoal; Transfer(0x0, owner, fundingGoal); }",1
0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6bb7a864a695ff718c9d8330c7d2ed9293949169.sol,ColorStarToken,"contract ColorStarToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd9c7adec23911489e443693efcd514be8da89eab.sol,ERC20,"contract ERC20 is owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 600000000 * 10 ** uint256(decimals); address public ICO_Contract; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); constructor () public { balanceOf[owner] = totalSupply; }",1
0x35ac7dcba25ba2192c87981bfcf024208070a25f.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address target, bytes data) external payable onlyOwner returns (bool) { return target.call.value(msg.value)(data); }",1
0xefff7c7d4270268e0d1d75f4f93f856836ac1ee8.sol,ballotBox,contract ballotBox { mapping(address => bool) public creators; struct ballot { uint8 choiceCount; uint256 voteCountBlock; },1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7.sol,AdvHajjToken,"contract AdvHajjToken is owned, HajjERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) HajjERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeb92266ba75dc3ff16a12e9ea4f1d20ca1560beb.sol,NHC,"contract NHC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NHC( ) public { totalSupply = 3141592653000000000000000000; balanceOf[msg.sender] = 3141592653000000000000000000; name = ; symbol = ; }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0x1db7f8171d82f9fc009f207cd80dd00a54b77560.sol,OllisCoin,"contract OllisCoin is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OllisCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0x737242fc5d432fc40f59bb1aa049436b6183f4f6.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; address[] public admins; uint public contributionMin; uint[] public contributionCaps; uint public feePct; uint constant public maxGasPrice = 50000000000; WhiteList public whitelistContract; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0xaa5059814a9412bd161a53a6a69625906701f91d.sol,CCD_EUROSIBENERGO_20190326_2,"contract CCD_EUROSIBENERGO_20190326_2 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0x58534c480ef96b6478940f9bbf6748da8f2ec935.sol,Funding,"contract Funding is ApplicationAsset { address public multiSigOutputAddress; ABIFundingInputGeneral public DirectInput; ABIFundingInputGeneral public MilestoneInput; enum FundingMethodIds { __IGNORED__, DIRECT_ONLY, MILESTONE_ONLY, DIRECT_AND_MILESTONE }",1
0x341492c5f449ca8accae37d73aed8fcd21995ef9.sol,WEIPAY,"contract WEIPAY { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c.sol,BitSteveCoin,"contract BitSteveCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitSteveCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x671C107a6Ab0846792d38F284678ac172ecf125d] = _totalSupply; Transfer(address(0), 0x671C107a6Ab0846792d38F284678ac172ecf125d, _totalSupply); }",1
0x6ef9032ce16082df9d9ddcd2657ffd795f5f0485.sol,SODIUMTOKEN,"contract SODIUMTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SODIUMTOKEN() public { symbol = ; name = ; decimals = 18; _totalSupply = 30000000000000000000000000000; balances[0x78437f6724C41756619910e389B716EE00B0F1EA] = _totalSupply; Transfer(address(0), 0x8B877f7464818843908D289A458A58C87fAAA174, _totalSupply); bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x55e7f93c7746877b1e6a1a1e789a8e37b03172cb.sol,CCD_EUROSIBENERGO_20190326_7,"contract CCD_EUROSIBENERGO_20190326_7 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x282ee54f8ecda53d6bb77df4a4134738375a0664.sol,XToken,"contract XToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03a2f2eb836fdd6ef462edc65bccd358ba1f2375.sol,BasicToken,"contract BasicToken is ERC20Basic, Ownable { using SafeMath for uint256; struct WalletData { uint256 tokensAmount; uint256 freezedAmount; bool canFreezeTokens; }",1
0x5c2f940281e735ca3496d8138be12d18023dce9f.sol,BNANAToken,"contract BNANAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xD967E4422F7A6465396E14c39990409cFee42AB0] = _totalSupply; emit Transfer(address(0), 0xD967E4422F7A6465396E14c39990409cFee42AB0, _totalSupply); }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0ba84690b9bdec4c3175557446dddf6384eec1d.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0xaa88e4e83055f144a9f265a217d5727c8b0df57a.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => uint) public lockAmount; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf091cf09c51811819db705710e9634b8bf18f164.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x69e1e36d795f72fe02638d749bffe2af2f64a20e.sol,GHK,"contract GHK{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function GHK() public { balances[msg.sender] = 3600000000000; totalSupply = 3600000000000; name = ; decimals =4; symbol = ; }",1
0x03ce85b4017119f23f023e1374736a8059c03c31.sol,CHEMCHINA_PFII_III_883,"contract CHEMCHINA_PFII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1233471162710430000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x92575d350284d64a1c74a0b6cb1dd16334d43e0d.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns(uint256) { return totalSupply_; },1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,OracleContractAdapter,contract OracleContractAdapter is Object { event OracleAdded(address _oracle); event OracleRemoved(address _oracle); mapping(address => bool) public oracles; modifier onlyOracle { if (oracles[msg.sender]) { _; },1
0xdcfae5ec906742f66e57e09ce098f5adb76ababa.sol,EthDeposit,contract EthDeposit is Owned { address public Manager; address public NewManager; uint public SponsorsQty; uint public CharterCapital; uint public ClientQty; uint public PrcntRate = 5; bool paymentsAllowed; struct Lender { uint LastLendTime; uint Amount; uint Reserved; },1
0xd8e6a6a27f31cb4ee8d7584b7a67e624e17a038a.sol,SafeMath,None,1
0xf1d8fd82da98ed93bca83adbb6ab4dd3c44b35ea.sol,GOG,"contract GOG is owned { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public frozenFunds; event FrozenFunds(address target, uint256 funds); event UnFrozenFunds(address target, uint256 funds); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function GOG() public { totalSupply = 10000000000000000; balances[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x27054b13b1b798b345b591a4d22e6562d47ea75a.sol,AirSwapToken,"contract AirSwapToken is StandardToken, Pausable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 4; uint256 public constant totalSupply = 5000000000000; uint256 becomesTransferable = 1508249410; uint256 lockingPeriod = 604800; modifier onlyAfter(uint256 _time) { require(now >= _time); _; }",1
0xc654928ecf5f984ef72c806ec9b6e2d213c90818.sol,EDGETVToken,"contract EDGETVToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x31fd65340a3d272e21fd6ac995f305cc1ad5f42a.sol,Gift_Box,contract Gift_Box { address prop = msg.sender; function()payable{},1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x55883c45ca6d60ae69e084acc1daece002dd11c7.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xbd791314f50c8854866ce4db764b3031d7a9a68e.sol,KycContract,contract KycContract is Owned { mapping (address => bool) verifiedAddresses; function isAddressVerified(address _address) public view returns (bool) { return verifiedAddresses[_address]; },1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0xde522a2778e4554707e6a8df36a4871ce9967bb5.sol,FML,"contract FML { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FML() public { totalSupply = 2100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0x212fa406fd28663ee6110d863a18e80960300e5c.sol,AnxToken,"contract AnxToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x963012c66676F1B4d8cbb491dd78AF3278789738] = _totalSupply; emit Transfer(address(0), 0x963012c66676F1B4d8cbb491dd78AF3278789738, _totalSupply); }",1
0xaf6dbf545cc245c00b425d02e545b6ecc1527f3d.sol,LSCKcoin,"contract LSCKcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LSCKcoin() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65] = _totalSupply; Transfer(address(0), 0x60f71Dd71aEa773657d75b2884e93c6bCbbADF65, _totalSupply); }",1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x41aef9b47f6e37de66e34ce073023b36f1823b2a.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public totalSupply = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = totalSupply.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amounteth, bool isContribution); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0x763d3a11796551b435c8d789086e922625461410.sol,TCASH,contract TCASH is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 88000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TCASH() { owner = msg.sender; balances[owner] = 88000000 * 10**8; },1
0xa3feedc649f1742f0f7aee3d1a4f9111757c87d6.sol,LicotestToken,"contract LicotestToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10*10**26; balances[0x266cC4b523078A71818700FaDA37eEFB885532fd] = _totalSupply; emit Transfer(address(0), 0x266cC4b523078A71818700FaDA37eEFB885532fd, _totalSupply); }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x52d208f3ff79985b5a50a55fd35334f924a9f643.sol,OSSCardToken,"contract OSSCardToken is ERC721 { event Birth(uint256 tokenId, string slug, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, string slug); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.0001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cardIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cardIndexToApproved; mapping (uint256 => uint256) private cardIndexToPrice; address public ceoAddress; address public cooAddress; struct Card { string slug; }",1
0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol,YSS,"contract YSS is Owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function YSS(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits, address centralMinter) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0) {owner = centralMinter;}",1
0x888a5c3f9f3744ff9189aa3af567e1fffc25a3ef.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,APP,"contract APP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function APP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x78dd22e93357d6f926fa0f7cb860c5e6e1bcf484.sol,LETSY,"contract LETSY is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x3aa9C81C14cE1799533C5e24b1e90c00344c5A9c] = _totalSupply; emit Transfer(address(0), 0x3aa9C81C14cE1799533C5e24b1e90c00344c5A9c, _totalSupply); }",1
0x51f171b6bc39456dd94a303537d995ea990e1146.sol,TTOH,"contract TTOH is owned, SafeMath { string public name; string public symbol; uint public decimals = 8; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public lockInfo; uint constant valueTotal = 10 * 10000 * 10000 * 10 ** 8; uint constant valueSale = valueTotal / 100 * 30; uint constant valueTeam = valueTotal / 100 * 70; uint public minEth = 0.1 ether; uint public maxEth = 1000 ether; uint256 public buyPrice = 5000; uint256 public sellPrice = 1; bool public buyTradeConfir = false; bool public sellTradeConfir = false; uint public saleQuantity = 0; uint public ethQuantity = 0; modifier validAddress(address _address) { assert(0x0 != _address); _; }",1
0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22.sol,STCToken,"contract STCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function STCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x71402645d25196842b0434a1805726b7c0eef426.sol,BlueChips,contract BlueChips { modifier onlyOwner(){ require(msg.sender == dev); _; },1
0x536ad2443ba256577876dbb4b89db10966513475.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 400000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x56aca8618b2b4240d609104f31c87183682065e0.sol,hkchain,"contract hkchain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function hkchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8f61d0889245c40a3555aa6386e17a5e4aafa18.sol,RCRchain,"contract RCRchain { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,SafeMath,None,1
0x6f2deef18421ba39065223b23ef38666b3052a46.sol,Marine,contract Marine is ERC20Standard { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant maxSupply = 1000000000 * (10 ** uint256(decimals)); uint256 public MRNToEth; uint256 public ethInWei; address public devWallet; function Marine () public { totalSupply = maxSupply; balances[msg.sender] = maxSupply; MRNToEth = 20000000; devWallet = msg.sender; },1
0xf22480ac062f109420595b522c095eaf60867e15.sol,I2Crowdsale,"contract I2Crowdsale is Ownable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; uint public usd = 550; uint public tokensPerDollar = 10; uint public bonus = 30; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function I2Crowdsale ( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers.mul(1 ether); deadline = now.add(durationInMinutes.mul(1 minutes)); price = 10**18 / tokensPerDollar / usd; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,TokenERC20,"contract TokenERC20 is owned{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c3a22fc1f2f3307a01f71d266e01a06d86fb0f1.sol,Hold,"contract Hold is Ownable { uint public deadline = 1546230000; uint public amountRaised; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function () payable public { uint amount = msg.value; amountRaised += amount; }",1
0x6f86aeae8dd4f56a566a0d462ec7c254a2213916.sol,MetronomeToken,"contract MetronomeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MetronomeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0xaf892edC9515Ba62151d44219eA2149A86B86F93] = _totalSupply; Transfer(address(0), 0xaf892edC9515Ba62151d44219eA2149A86B86F93, _totalSupply); }",1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Whitelist,contract Whitelist is Ownable { using SafeMath for uint256; mapping(address => bool) public whitelist; mapping(address => uint256) whitelistIndexMap; address[] public whitelistArray; uint256 public whitelistLength = 0; modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; },1
0x1c2389c0b8014be72e11849ec0aa790b03929e18.sol,FundingWallet,contract FundingWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x6f97b5c035939424037f00102068e610380ee25a.sol,NDD_KHC_I_883,"contract NDD_KHC_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1407435608253240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x70f53cb14a08700d0816f01bdae54b3f507f2ce2.sol,Contract50,contract Contract50 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] /50 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x51e7359d008a85a021da36370d78b594079a67b1.sol,WorldRobot,"contract WorldRobot { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x54f61b89a0bac15c88c6bddf41573ddc1ba5bf6d.sol,LEF,"contract LEF is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function LEF() public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x5059601b10af5faf69633692abe1d6a877d2be87.sol,CryptoyatToken,"contract CryptoyatToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 20000000000000000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x54139aa6fd3a986b83b684d1a928fc79e3f35850.sol,BubbleCoin,"contract BubbleCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function BubbleCoin() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x27cf5a8d216c923f95e63a12c5a0023aa6473763.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x40c37192f32be790e1ce15c219fe150c0bb6455f.sol,Pardi,"contract Pardi is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Pardi() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c] = _totalSupply; Transfer(address(0), 0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c, _totalSupply); }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,BountyTokenAllocation,contract BountyTokenAllocation is Ownable { uint256 public remainingBountyTokens; address[] public allocationAddressList; mapping (address => Types.StructBountyAllocation) public bountyOf; function BountyTokenAllocation(uint256 _remainingBountyTokens) Ownable() public { remainingBountyTokens = _remainingBountyTokens; },1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5c6183d10a00cd747a6dbb5f658ad514383e9419.sol,StandardToken,"contract StandardToken is Token { bool public disabled = false; function transfer(address _to, uint256 _value) returns (bool success) { if (disabled != true && balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb3bff5e980da2d46c29833b7a36a26df644ee4cf.sol,PotaosBucks,"contract PotaosBucks is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PotaosBucks() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x63f3e25496282318A356Cd50f7fAdD71E6A6aD25] = _totalSupply; Transfer(address(0), 0x63f3e25496282318A356Cd50f7fAdD71E6A6aD25, _totalSupply); }",1
0xde768b1249374e129d0a24afe4b07ab0ce8ec20f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0x05b075b00cd4779e53dd646759b3c1087b37986a.sol,TriLionToken,"contract TriLionToken { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TriLionToken() public { balances[msg.sender] = 1000000000000000000; _totalSupply = 1000000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,Multiowned,contract Multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x729e895e186b7fbd34485d496415bb2f42629b71.sol,RequestCore,"contract RequestCore is Administrable { using SafeMath for uint256; using SafeMathUint96 for uint96; using SafeMathInt for int256; using SafeMathUint8 for uint8; enum State { Created, Accepted, Canceled }",1
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0xd3aaf402a2fd26424e60f91a7783def8a444f880.sol,MobileTokenAlert,"contract MobileTokenAlert is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MobileTokenAlert() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0xa46166D89Fa0c759260953E5BF6142FAF1Df2094] = _totalSupply; Transfer(address(0), 0xa46166D89Fa0c759260953E5BF6142FAF1Df2094, _totalSupply); }",1
0x8af9e74991044827449946d334a478b6fe8f5740.sol,MUBEX,"contract MUBEX { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MUBEX() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x474b4642fa37528652e907a2a3ef7ded8fec8cc8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,Milestones,"contract Milestones is Ownable { enum State { PreIco, IcoOpen, IcoClosed, IcoSuccessful, IcoFailed, BankLicenseSuccessful, BankLicenseFailed }",1
0x490dbf7884b8e13c2161448b83dd2d8909db48ed.sol,Curate,"contract Curate is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Curate() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x604d0523bE64C34ffF0686f23b035EBe88B6AC52] = _totalSupply; Transfer(address(0), 0x604d0523bE64C34ffF0686f23b035EBe88B6AC52, _totalSupply); }",1
0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e.sol,Quiz,contract Quiz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1c934a503fe39721591b97b8c56f013bf78a8d19.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0ec03c088cbfffdd0c2ba8c1cfa35f655a9ce078.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x02aa481223f81b30ae9ccd4845ebfc3d4f4be068.sol,METS6,"contract METS6 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function METS6( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0x6e81a9ee3a1d4c2522de6e15e30ab551b3bdcbb6.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0x6c4de8424a6184c830234b996f7dba9720dc9306.sol,XKnockoutHamster,contract XKnockoutHamster { using SafeMath for uint256; struct EntityStruct { bool active; bool vip; uint listPointer; uint256 date; uint256 update; uint256 exit; uint256 profit; },1
0x5b53f9755f82439cba66007ec7073c59e0da4a7d.sol,FlowchainToken,"contract FlowchainToken is StandardToken, Mintable { string public name = ; string public symbol = ; uint8 public decimals = 18; string public version = ; address public mintableAddress; address public multiSigWallet; address public creator; function() payable { revert(); }",1
0x1c2f54920e8ef883b67bf2fbccdc56af0a5e644d.sol,Moses,"contract Moses is Basic{ event Attend(uint32 indexed id,string indexed attentHash); event PublishResult(uint32 indexed id,string indexed result,bool indexed finish); struct MoseEvent { uint32 id; string attendHash; string result; bool finish; }",1
0xeb14e8d94010d402fff3decaa712aa9cf4662a72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x1c98eea5fe5e15d77feeabc0dfcfad32314fd481.sol,EthConnectPonzi,"contract EthConnectPonzi { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function EthConnectPonzi() public { }",1
0x501a752f6cb44bd7c8e9ea0d97347d6c65a48ea5.sol,TalentCoin,"contract TalentCoin is ERC20, Ownable, Whitelist, Pausable{ using SafeMath for uint256; mapping (address => bool) admins; mapping( address => uint256 ) balances; mapping( address => mapping( address => uint256 ) ) approvals; mapping( address => uint256 ) ratemapping; mapping (address => uint) public investedAmountOf; address public owner; address public walletAddress; uint256 public supply; string public name; uint256 public decimals; string public symbol; uint256 public rate; uint public weiRaised; uint public soldTokens; uint public investorCount; function TalentCoin(address _walletAddress, uint256 _supply, string _name, uint256 _decimals, string _symbol, uint256 _rate ) public { require(_walletAddress != 0x0); balances[msg.sender] = _supply; ratemapping[msg.sender] = _rate; supply = _supply; name = _name; decimals = _decimals; symbol = _symbol; rate = _rate; owner = msg.sender; admins[msg.sender] = true; walletAddress = _walletAddress; }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x51fb3da8a67861361281ac56fe2ad8c3b4539ffa.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0xc7b62900c4860bc20f8561ee53d9a888b2ee411b.sol,BinanceGold,"contract BinanceGold { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 766575559732 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0x32e730afe4332bf98902ea59c3d003e81b5c7c69.sol,TokenERC20AC,"contract TokenERC20AC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20AC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x65719c47fd2a6c1eb9cf24be619291a0e9341ad5.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x2019763bd984cce011cd9b55b0e700abe42fa6c7.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0xf412af62269a0b3b10ea727df81231cdc5bb6364.sol,dCHF,"contract dCHF is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function dCHF() public { symbol = ; name = ; decimals = 2; _totalSupply = 1500000; balances[0x0000F70bC78af03f14132c68b59153E4788bAb20] = _totalSupply; Transfer(address(0),0x0000F70bC78af03f14132c68b59153E4788bAb20 , _totalSupply); }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,SampleStorage,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0x7078b01170768c6db7bd9f515305682e52664cd3.sol,TariInvestment,"contract TariInvestment is Ownable { address public investmentAddress = 0x33eFC5120D99a63bdF990013ECaBbd6c900803CE; address public majorPartnerAddress = 0x8f0592bDCeE38774d93bC1fd2c97ee6540385356; address public minorPartnerAddress = 0xC787C3f6F75D7195361b64318CE019f90507f806; mapping(address => uint) public balances; uint totalInvestment; uint availableRefunds; uint refundingDeadline; enum State{Open, Closed, Refunding}",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 1000000; },1
0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e.sol,TokenERC20,"contract TokenERC20 is owned{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d6a99e9e94923a9992a0593ea0298bf7542be67.sol,dapBetting,"contract dapBetting { enum eventStatus{ open, finished, closed }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,PaintingStorage,contract PaintingStorage is BaseStorage { struct Painting { uint parentId; uint originalId; uint createdAt; uint completedAt; uint8 generation; uint8 speedIndex; uint artistId; uint releasedAt; bool isFinal; },1
0x18035ee31125a9934de44b0105cd31691cce95d5.sol,BigBoobsToken,"contract BigBoobsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BigBoobsToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5] = _totalSupply; Transfer(address(0), 0xE3aF42CB6E90B1F1cD5B91a77Ce9f52F6E5A61d5, _totalSupply); }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x92f6096a93a6ebb6bc439831a7f30f1e6020f184.sol,ROPE,"contract ROPE{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; bool public transferrable = true; address public contract2Address; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROPE( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78.sol,TASOHATOKEN,"contract TASOHATOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TASOHATOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5192a95f79c83e1581574b90f75a28af79c871ff.sol,DiscountPercentCoin,"contract DiscountPercentCoin is Authorizable, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x286ae9778a87dc8d4eb4ac3d57b5b928d41abbff.sol,VOCC_I027_20181211,"contract VOCC_I027_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xbd91b8e4d0afb1b7fc19bca93a74a1c531bd125c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd52d09ce4c0118b227bd9496d973ed0bf98f8d5a.sol,SupplySchedule,contract SupplySchedule is Owned { using SafeMath for uint; using SafeDecimalMath for uint; struct ScheduleData { uint totalSupply; uint startPeriod; uint endPeriod; uint totalSupplyMinted; },1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x57db1c0f1c4c71919426c23e65be611fa9076b20.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6c9ece80505a55c4fc373900994800340a5e2e14.sol,CGENToken,contract CGENToken is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint128 public availableSupply; struct vesting { uint createdAt; uint128 amount; uint8 releaseRate; uint32 releaseIntervalSeconds; uint8 nextReleasePeriod; bool completed; },1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x72a3678da1e6683ebb58f006888903496d4e97ab.sol,ENC,contract ENC is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10 ** 14 / 2; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xed5c2ce8b29bd874374532e059b49e85b7e8fa5a.sol,GoldenMinerToken,contract GoldenMinerToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd9ff8cc0433c995f3a9711f1400329cd6a40387f.sol,EtherKnightGame,"contract EtherKnightGame { HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882); using SafeMath for uint256; using SafeMath128 for uint128; event OwnershipTransferred( address previousOwner, address nextOwner, uint256 timeStamp ); event HDXcontractChanged( address previous, address next, uint256 timeStamp ); event onWithdrawGains( address customerAddress, uint256 ethereumWithdrawn, uint256 timeStamp ); event onNewRound( uint256 gRND, uint32 turnRound, uint32 eventType, uint32 eventTarget, uint32[4] persoEnergy, uint32[4] persoDistance, uint32[4] powerUpSpeed, uint32[4] powerUpShield, uint256 blockNumberTimeout, uint256 treasureAmountFind, address customerAddress ); event onNewRace( uint256 gRND, uint8[4] persoType, uint256 blockNumber ); event onBuyShare( address customerAddress, uint256 gRND, uint32 perso, uint256 nbToken, uint32 actionType, uint32 actionValue ); event onMaintenance( bool mode, uint256 timeStamp ); event onRefund( address indexed customerAddress, uint256 eth, uint256 timeStamp ); event onCloseEntry( uint256 gRND ); event onChangeBlockTimeAverage( uint256 blocktimeavg ); modifier onlyOwner { require (msg.sender == owner ); _; }",1
0x0dc35ce59014aed7babc16ef0831580a2327e697.sol,PlatformTeamCoinVer01,"contract PlatformTeamCoinVer01 is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,LockRequestable,contract LockRequestable { uint256 public lockRequestCount; function LockRequestable() public { lockRequestCount = 0; },1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,CRYPTOSSTOKEN,"contract CRYPTOSSTOKEN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0e41c976f456ccb29c04e62ba70094d174f2b503.sol,NoahDividend,contract NoahDividend is Ownable { NoahToken public noahToken; function NoahDividend(address noahTokenAddress) public { noahToken = NoahToken(noahTokenAddress); },1
0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x275b69aa7c8c1d648a0557656bce1c286e69a29d.sol,SafeMath,None,1
0x286e1b439e616b06f55f801fbcc5f0747e3d9645.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x34734d66dadc3fe1c35b6555341f07e8d8524c29.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 588235295; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x1db7f8171d82f9fc009f207cd80dd00a54b77560.sol,OllisCoin,"contract OllisCoin is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OllisCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0x0f234c7992956af755c5cd9451a3f872314efa78.sol,ROHH,"contract ROHH is Ownable { string public name; string public symbol; uint8 public decimals = 17; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROHH( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x517be460e08a7ecce448f54b41658c0bfb0d8674.sol,StringYokes,None,1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0xeead74c98c573b43a1af116be7c4debb0a4fd4a8.sol,Line,"contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public denominator = 100; uint public jackpot = 0; event Jackpot(uint line, address addr, uint date, uint prize, uint left); event Win(uint line, address addr, uint date, uint prize, uint left); event JackpotIncreased(uint date, uint jackpot); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x4b480c1abef305c0e21644d083f677405ab8250c.sol,TIP,contract TIP is StandardToken { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 public reservedSupply = 10000000 * 10 ** 8; uint256 public transferAmount = 10000 * 10 ** 8; address public owner; mapping(address => uint256) address_claimed_tokens; function TIP() { owner = msg.sender; totalSupply = 100000000 * 10 ** 8; balances[owner] = 100000000 * 10 ** 8; },1
0x651a824c225e60c1901ec6018a685aa38d82f23c.sol,PimmelToken,"contract PimmelToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PimmelToken() { uint initialSupply = 28000000000000000000000000; balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = ; symbol = ; decimals = 18; }",1
0x1bafa500bd219a2afb8f2d0286cc9480c7bd95c2.sol,ERC20Token,"contract ERC20TokenInterface { function balanceOf(address _owner) public constant returns (uint256 value); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); }",1
0x413bdaae8e7218aea3a7ca544762d4f9f128a562.sol,NFC,"contract NFC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NFC() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0xbd677963d9bc990ee8fb7de06e1a63bf6850c2d1.sol,castrol,"contract castrol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function castrol() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 500000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd5ec2aa0dda1b4c3b36fff24cb06318821dcd126.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x7287bef78619e10c32a1eee82046fa3c4a29f17d.sol,CryptoPornSmartContract,"contract CryptoPornSmartContract is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; address public ceoAddress; address[4] public cooAddresses; struct Person { string name; uint256 sellingPrice; }",1
0x7704eaee68e4c0eb3ee47382391d0227a44bbac8.sol,SISKCoin,"contract SISKCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SISKCoin() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 52 weeks; }",1
0x2e685a1d919fea5aa294d0ee794f492fd9e93611.sol,LOOM,"contract LOOM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LOOM () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5] = _totalSupply; Transfer(address(0), 0x5DDf45770bf34F156F6920a1b2886EA35bCb20E5, _totalSupply); }",1
0x5304a4b788946f534088e9d8975ca8c1a3ded913.sol,Ozcar,"contract Ozcar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ozcar() public { symbol = ; name = ; decimals = 18; _totalSupply = 1250000000000000000000000000; balances[0xB9705a168AB4a92A78b1F3246fBb98cb5a4a8d6E] = _totalSupply; Transfer(address(0), 0xB9705a168AB4a92A78b1F3246fBb98cb5a4a8d6E, _totalSupply); }",1
0xf0eb75d7a2097a25796848c54e9eb862a93664ec.sol,TKTToken,"contract TKTToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TKTToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xefb0e0d88f674d4c79760f411cba2a10221de4f9.sol,SafeMath,None,1
0x6e7cf33736bafee311a73093741f93ab8cd6530c.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { symbol = ; name = ; decimals = 18; _totalSupply = 200 * (10**8) * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xc4a0ab20f1901c24740e06966cca9d5f2e5d5e79.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0x562f0c1d080be544b3095d02abcdb9786249a416.sol,SEAPORT_Portfolio_V_883,"contract SEAPORT_Portfolio_V_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 926816166179938000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc094367b4c79564b6c8b4218f84dea835b2c2dd0.sol,TikiMadness,contract TikiMadness { modifier onlyOwner() { require(msg.sender == contractOwner); _; },1
0xbde3e294e28709399b81d20689e351c7b1008773.sol,fcomToken,"contract fcomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function fcomToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x189b13941f6c1a221f47e5d0094cd206aded745e.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x0f234c7992956af755c5cd9451a3f872314efa78.sol,ROHH,"contract ROHH is Ownable { string public name; string public symbol; uint8 public decimals = 17; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROHH( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdfe36fefdf20a6cffd0a42ee789c93f446b3df95.sol,HelloToken,contract HelloToken { using SafeMath for uint256; string public constant name = ; uint8 public constant decimals = 18; string public constant symbol = ; struct Supplies { uint128 totalSupply; },1
0x58c37105311985775c43e8b27efabf441859dfc4.sol,DBXTTest,"contract DBXTTest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; endDate = now + 12 weeks; }",1
0x655f4304ecd29a56783e52c2ead656b74b29d704.sol,ethKeepHand,contract ethKeepHand is Owned{ struct DepositItem{ uint depositDate; uint256 depositValue; uint depositTime; uint valid; },1
0xe1291032766b81488dc565479503a103489f78d7.sol,x32323,"contract x32323 is owned{ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => bool) initialized; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x749f35ff65932e68267dd82f6cd85eea735d700e.sol,CCLToken,"contract CCLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 4000000000000000000000000000; balances[0xf835bF0285c99102eaedd684b4401272eF36aF65] = _totalSupply; Transfer(address(0), 0xf835bF0285c99102eaedd684b4401272eF36aF65, _totalSupply); }",1
0x45a353132143f475b355620ad9d7413d0222ea04.sol,APP,"contract APP is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function APP( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x5b614e4f17a1938da6248d116cc32f4f17c35f99.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Register (address user, string key); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 36000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3482665b52c01076ef4939a0089a9b62222fe824.sol,BtcSweetCoin,"contract BtcSweetCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xf1071b75AB3688bc9Be87D66892c2383d40a3EBd] = _totalSupply; emit Transfer(address(0), 0xf1071b75AB3688bc9Be87D66892c2383d40a3EBd, _totalSupply); }",1
0xb41654a43aae0d7d17701c612567b4243aa9cd6c.sol,PlayWinCollectProtocol,"contract PlayWinCollectProtocol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PlayWinCollectProtocol() public { symbol = ; name = ; decimals = 18; _totalSupply = 37100000000000000000000000; balances[0x5506310E6265Fc678ac11a423cceb5d048CAa2d3] = _totalSupply; Transfer(address(0), 0x5506310E6265Fc678ac11a423cceb5d048CAa2d3, _totalSupply); }",1
0xa5d1eb8bbb42b7f2ebbebf174b3966510243f30c.sol,TokenCreation,"contract TokenCreation is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public freezeOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor( string tokenSymbol, string tokenName, uint256 tokenSupply ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = 18; totalSupply = tokenSupply * (10 ** 18); balanceOf[0x94eE12284824C91dB533d4745cD02098d7284460] = SafeMath.safeDiv(totalSupply, 10); balanceOf[0xfaDB28B22b1b5579f877c78098948529175F81Eb] = SafeMath.safeSub(totalSupply, SafeMath.safeDiv(totalSupply, 10)); }",1
0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event AddSupply(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0xec2a74d48c0d5dc1e4ec2677d33d87def3244b49.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x536ad2443ba256577876dbb4b89db10966513475.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 400000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5192a95f79c83e1581574b90f75a28af79c871ff.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x1b9dcdcddd2d6ca699cad9505faa363e81145c6b.sol,BrinkToken,"contract BrinkToken is EIP20Interface { address owner = msg.sender; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint price; function BrinkToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2a98c6dcac6d759695b09cdf6b26cf4a13370a57.sol,DOGEToken,"contract DOGEToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DOGEToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8] = _totalSupply; Transfer(address(0), 0xdF74B93C1Fa5515E3D5199fce19b9DB57A98e8B8, _totalSupply); }",1
0x0e44c40162b29f5252db58a7f46b8cabe2c0867f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01805928b325078683818329526dab3f74865e10.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0xc541e02e7d66cb5cbd7d33d1874dcc3f028ad75c.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x009725f31c561a64c30c89e74adb995c570330ff.sol,CHCTokenERC20,"contract CHCTokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CHCTokenERC20() public { totalSupply =10000000000000000; balanceOf[msg.sender] = 10000000000000000; name = ; symbol = ; }",1
0xee6189995391e82bc48c8bed50285767c60d807f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7.sol,RewardsGiftToken,"contract RewardsGiftToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RewardsGiftToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa226aa0c9039808f72f3ef62205b7be58da12fef.sol,Etheradium,"contract Etheradium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Etheradium() public { symbol = ; name = ; decimals = 18; _totalSupply = 1500000000000000000000000000; balances[0xa35514a419D9807905778300b8F547C2b2E8C4AE] = _totalSupply; Transfer(address(0), 0xa35514a419D9807905778300b8F547C2b2E8C4AE, _totalSupply); }",1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c44134ab77bd7b90907d2b9745c628caae077d6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x32e730afe4332bf98902ea59c3d003e81b5c7c69.sol,TokenERC20AC,"contract TokenERC20AC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20AC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0x5085c5356129ee11bffb523e3166d7153ac13c75.sol,Casino,"contract Casino is Ownable, HouseAdmin { using SafeMath for uint; uint constant HOUSE_EDGE_PERCENT = 1; uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; uint constant BET_AMOUNT_MIN = 0.01 ether; uint constant BET_AMOUNT_MAX = 1000 ether; uint constant BET_EXPIRATION_BLOCKS = 250; uint constant MAX_MASKABLE_MODULO = 40; uint constant MAX_BET_MASK = 2 ** MAX_MASKABLE_MODULO; uint constant POPCOUNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001; uint constant POPCOUNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041; uint constant POPCOUNT_MODULO = 0x3F; uint public bankFund; struct Bet { uint8 modulo; uint64 choice; uint amount; uint winAmount; uint placeBlockNumber; bool isActive; address player; }",1
0x6dc896e52def34ff23ab0b07250e12b9fd9fe9e7.sol,EthTranchePricing,"contract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib { uint public constant MAX_TRANCHES = 10; mapping (address => uint) public preicoAddresses; struct Tranche { uint amount; uint price; }",1
0x41c0542f41251d6d81526ed2dbc8f0008b13fe48.sol,MultiEther,contract MultiEther { struct Deposit { address depositor; uint deposit; uint payout; },1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0x051f73eaf3f93b0b5440cc1381cb604f1457a6d1.sol,HOPE,"contract HOPE is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x88c1f00df493673f72aa0481187a0ff8c5ad0e14.sol,ByteConvert,None,1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,Contribution,contract Contribution is Ownable { using SafeMath for uint256; WPR public wpr; address public contributionWallet; address public teamHolder; address public communityHolder; address public futureHolder; address public exchanger; uint256 public totalCollected; uint256 public totalWeiCap; uint256 public totalWeiCollected; uint256 public presaleTokensIssued; uint256 public minimumPerTransaction = 0.01 ether; uint256 public numWhitelistedInvestors; mapping (address => bool) public canPurchase; mapping (address => uint256) public individualWeiCollected; uint256 public startTime; uint256 public endTime; uint256 public initializedTime; uint256 public finalizedTime; uint256 public initializedBlock; uint256 public finalizedBlock; bool public paused; modifier initialized() { require(initializedBlock != 0); _; },1
0x51754fb81c6f7605658f79cb2519625a0d296765.sol,LPCT,"contract LPCT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LPCT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3.sol,CoinifinexToken,"contract CoinifinexToken { uint256 constant public TOTAL_TOKEN = 10 ** 9; uint256 constant public TOKEN_FOR_ICO = 650 * 10 ** 6; uint256 constant public TOKEN_FOR_COMPANY = 200 * 10 ** 6; uint256 constant public TOKEN_FOR_BONUS = 50 * 10 ** 6; mapping (address => uint256) public tokenForTeam; mapping (address => uint256) public tokenForTeamGet; address[] public teamAddress; uint public startTime; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CoinifinexToken( ) public { totalSupply = TOTAL_TOKEN * 10 ** uint256(decimals); name = ; symbol = ; startTime = 1538265600; tokenForTeam[0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x040440286a443822211dDe0e7E9DA3F49aF2EBC7] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D] = 20 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xc456aC342f17E7003A03479e275fDA322dE38681] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24] = 300 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x88311485647e19510298d7Dbf0a346D5B808DF03] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F] = 500 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb] = 100 * 10 ** 3 * 10 ** uint256(decimals); tokenForTeam[0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe387125f1b24E59f7811d26fbb26bdA1c599b061] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xC5b644c5fDe01fce561496179a8Bb7886349bD75] = 1 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae] = 5 * 10 ** 6 * 10 ** uint256(decimals); tokenForTeam[0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF] = 5 * 10 ** 6 * 10 ** uint256(decimals); teamAddress.push(0x4B7786bD8eB1F738699290Bb83cA8E28fEDea4b0); teamAddress.push(0x040440286a443822211dDe0e7E9DA3F49aF2EBC7); teamAddress.push(0x4f7a5A2BafAd56562ac4Ccc85FE004BB84435F71); teamAddress.push(0x7E0D3AaaCB57b0Fd109D9F16e00a375ECa48b41D); teamAddress.push(0xc456aC342f17E7003A03479e275fDA322dE38681); teamAddress.push(0xB19d3c4c494B5a3d5d72E0e47076AefC1c643D24); teamAddress.push(0x88311485647e19510298d7Dbf0a346D5B808DF03); teamAddress.push(0x2f2754e403b58D8F21c4Ba501eff4c5f0dd95b7F); teamAddress.push(0x45cD08764e06c1563d4B13b85cCE7082Be0bA6D1); teamAddress.push(0xB08924a0D0AF93Fa29e5B0ba103A339704cdeFdb); teamAddress.push(0xa8bD7C22d37ea1887b425a9B0A3458A186bf6E77); teamAddress.push(0xe387125f1b24E59f7811d26fbb26bdA1c599b061); teamAddress.push(0xC5b644c5fDe01fce561496179a8Bb7886349bD75); teamAddress.push(0xe4dB43bcB8aecFf58C720F70414A9d36Fd7B9F78); teamAddress.push(0xf28edB52E808cd9DCe18A87fD94D373D6B9f65ae); teamAddress.push(0x87CE30ad0B66266b30c206a9e39A3FC0970db5eF); uint arrayLength = teamAddress.length; for (uint i=0; i<arrayLength; i++) { tokenForTeamGet[teamAddress[i]] = tokenForTeam[teamAddress[i]] * 1 / 10; balanceOf[teamAddress[i]] = tokenForTeamGet[teamAddress[i]]; tokenForTeam[teamAddress[i]] -= tokenForTeamGet[teamAddress[i]]; }",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x2add07c4d319a1211ed6362d8d0fbe5ef56b65f6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x723a277f1f41b528affa37c5a8ca52a3d4d02e6e.sol,BTL,"contract BTL{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BTL() public { balances[msg.sender] = 5180000000000; totalSupply = 5180000000000; name = ; decimals =4; symbol = ; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x27798734d18d63b963137a360cadff807d479e50.sol,ZTTBToken,"contract ZTTBToken is owned, TokenERC20 { uint256 public sellPrice = 0.00000001 ether ; uint256 public buyPrice = 0.00000001 ether ; mapping (address => bool) public _frozenAccount; event FrozenFunds(address target, bool frozen); function ZTTBToken( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) TokenERC20(initialSupply, tokenName, tokenSymbol,decimal) public { _balances[msg.sender] = _supply; }",1
0x0d15cfff56a4ae7a978955d660bd8e9e5d1d4d9f.sol,VT,"contract VT is owned { string public name; string public symbol; uint8 public decimals=18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Marketplace,contract Marketplace is Ownable { struct Ad { uint price; address exchanger; bool exists; bool active; },1
0x5c13a9ad2601eeec34672c655d2ca994a360c4a0.sol,GalacticX,"contract GalacticX is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function GalacticX( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x361cef27a967e3fa2d8fc117b3f2cfe2a09bbc02.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x65811ddbca75ea040b89777bd5747549b77d1097.sol,Spqmcoin,"contract Spqmcoin{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Spqmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2094890017bf0eca1a032eeeccb85b5810f5e52f.sol,VT,"contract VT is owned { string public name; string public symbol; uint8 public decimals=18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2.sol,Poge,"contract Poge { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Poge( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf09f3788743c18ecdc2cf238163bd0bbbc8a4fd8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x923108a439c4e8c2315c4f6521e5ce95b44e9b4c.sol,BTTSLib,None,1
0x281d30bf8b045e90578895619498ef5d6fd6584c.sol,OracleContractAdapter,contract OracleContractAdapter is Object { event OracleAdded(address _oracle); event OracleRemoved(address _oracle); mapping(address => bool) public oracles; modifier onlyOracle { if (oracles[msg.sender]) { _; },1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0xbe407e7f8687965412c31f259eb16f75c44fc80b.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; address ownerWallet; bool released = false; enum LockupType {NOLOCK, FOUNDATION, TEAM, CONSORTIUM, PARTNER, BLACK}",1
0x031f7f7749247e0913aace12002cf61f039cd7b1.sol,WWECoin,"contract WWECoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WWECoin() public { symbol = ; name = ; decimals = 5; _totalSupply = 5000000000000; balances[0x92c826CA75FA55a64a4688F14863Fe21c04eE02C] = _totalSupply; Transfer(address(0), 0x92c826CA75FA55a64a4688F14863Fe21c04eE02C, _totalSupply); }",1
0xeaa9ed293e094084defd04cbced34e3ed4244881.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa032e135d6509c7e13c43f07b567edf4071f5636.sol,CryptoExchangeCoin,"contract CryptoExchangeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 125000000000; balances[0x5A3022F4b72c720E616b1085296b2d133eb2f3F3] = _totalSupply; emit Transfer(address(0), 0x5A3022F4b72c720E616b1085296b2d133eb2f3F3, _totalSupply); }",1
0xebb060f9d0029082a04f78d84b9fb9d3d26f9a93.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x58054e51c19fa796443043418be91032b99992a3.sol,ERC223ReceivingContract,contract ERC223ReceivingContract { struct inr { address sender; uint value; bytes data; bytes4 sig; },1
0x868822b816bf0292a0c46d89a51b019113537325.sol,MOROCCO_WINS,"contract MOROCCO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b293d3e843d68da3400b3f39aa3e59274feeb73.sol,NIMFUNToken,"contract NIMFUNToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function NIMFUNToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xece73b9f0e0a3d7f33f79fd1d77cb344288b9966.sol,RVG,"contract RVG is owned, StdToken { string public name = ; string public symbol = ; string public website = ; uint public decimals = 18; uint256 public totalSupplied; uint256 public totalBurned; constructor(uint256 _totalSupply) public { supply = _totalSupply * (1 ether / 1 wei); totalBurned = 0; totalSupplied = 0; balances[address(this)] = supply; }",1
0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71.sol,ExceedIOToken,"contract ExceedIOToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ExceedIOToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = 1200000000000000000; name = tokenName; symbol = tokenSymbol; }",1
0x6d14421da39b403baab1cb0eac158ee658590798.sol,Agencies,"contract Agencies { mapping (address => string) private agencyOfOwner; mapping (string => address) private ownerOfAgency; event Set (string indexed _agency, address indexed _owner); event Unset (string indexed _agency, address indexed _owner); function Agencies () public { }",1
0x55c30ae7a9ad5861394e971327b6bf35d147119d.sol,ETD,contract ETD is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x33a104dcbed81961701900c06fd14587c908eaa3.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x6f3f21e65e618592f95d5f3a2e7e1b1425309ff2.sol,GILToken,"contract GILToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GILToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0xdd16c70aD270633edF69174b4269914De9434bf8] = _totalSupply; Transfer(address(0), 0xdd16c70aD270633edF69174b4269914De9434bf8, _totalSupply); }",1
0x268f39ebb4868a09fa654d4ffe1ab024bc937db2.sol,DNACoin,"contract DNACoin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant UNIT = 10 ** decimals; address public companyWallet; address public backendWallet; uint256 public maxSupply = 1000000 * UNIT; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyBackend() { require(msg.sender == backendWallet); _; }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c.sol,SafeMath,None,1
0x92ca7bec7a5acdea3c38ba9fca2ac4e2cf5a88ff.sol,BRC,"contract BRC is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply; uint256 public targetsecure = 50000e18; mapping (address => uint256) public balanceOf; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function totalSupply() public constant returns (uint) { return _totalSupply - balances[address(0)]; }",1
0xd6f79a8ba756cc7babdc04c6715d65af297ce50d.sol,SimpleEscrow,contract SimpleEscrow { uint public PERIOD = 21 days; uint public SAFE_PERIOD = 5 days; address public developerWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; address public customerWallet; uint public started; uint public orderLastDate; uint public safeLastDate; address public owner; function SimpleEscrow() public { owner = msg.sender; },1
0x290d7f8b8d7da1e92903405a74667c934ca8f086.sol,Wallet,"contract Wallet { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x2955e1a797f621dd865cf30e7406d973bf7bd769.sol,AuzToken,"contract AuzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 150000000000000000000000; balances[0x7eb3c74a4dD5a08459Ece27917db3C564A324F54] = _totalSupply; emit Transfer(address(0), 0x7eb3c74a4dD5a08459Ece27917db3C564A324F54, _totalSupply); }",1
0x5554e04e76533e1d14c52f05beef6c9d329e1e30.sol,Token,"contract Token { mapping (address => uint256) public balanceOf; mapping (uint256 => address) public addresses; mapping (address => bool) public addressExists; mapping (address => uint256) public addressIndex; mapping(address => mapping (address => uint256)) allowed; uint256 public numberOfAddress = 0; string public physicalString; string public cryptoString; bool public isSecured; string public name; string public symbol; uint256 public totalSupply; bool public canMintBurn; uint256 public txnTax; uint256 public holdingTax; uint256 public holdingTaxInterval; uint256 public lastHoldingTax; uint256 public holdingTaxDecimals = 2; bool public isPrivate; address public owner; function Token(string n, string a, uint256 totalSupplyToUse, bool isSecured, bool cMB, string physical, string crypto, uint256 txnTaxToUse, uint256 holdingTaxToUse, uint256 holdingTaxIntervalToUse, bool isPrivateToUse) { name = n; symbol = a; totalSupply = totalSupplyToUse; balanceOf[msg.sender] = totalSupplyToUse; isSecured = isSecured; physicalString = physical; cryptoString = crypto; canMintBurn = cMB; owner = msg.sender; txnTax = txnTaxToUse; holdingTax = holdingTaxToUse; holdingTaxInterval = holdingTaxIntervalToUse; if(holdingTaxInterval!=0) { lastHoldingTax = now; while(getHour(lastHoldingTax)!=21) { lastHoldingTax -= 1 hours; }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0x6e7a61fbe11873f4c7d0983c79683aad5c0788bd.sol,ERC20Receive,contract ERC20Receive { TKN internal fallback; struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xa5818774ffb1405d7684c92892c990ba6939828b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0.sol,TokenERC20,"contract TokenERC20 is SafeMath { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) private addressBalance; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function balanceOf (address _owner) constant returns (uint256 balance) { return addressBalance[_owner]; }",1
0x2771ef07defb079c309542e11219d97b562ab6b0.sol,AVL,"contract AVL is ERC20 { uint public incirculation; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; mapping (address => uint) goo; function transfer(address _to, uint _value) public returns (bool success) { uint gas = msg.gas; if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); refund(gas+1158); return true; }",1
0xd850942ef8811f2a866692a623011bde52a462c1.sol,SafeMath,None,1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x29daf1dc4eb5c8b519b24d06812a0f92a5d973ae.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,Storage,"contract Storage is SafeMath, StringMover { function Storage() public { controllerAddress = msg.sender; }",1
0x31ac1331eed69beefb33aa992989605beac875d2.sol,DeWeiSecurityServiceToken,"contract DeWeiSecurityServiceToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DeWeiSecurityServiceToken() public { owner = msg.sender; totalSupply = 10000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0xc3a684140448995f6abeb361c56110207da04d57.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function deposit(address account, uint amount) public { balances[account] += amount; Deposited(account, amount, balances[account], now); }",1
0x488771fdac168e3e313763aa2907ac5806dbc976.sol,StandardToken,contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; },1
0x521da4a05a7a4c1714fdb747bb1a91296352e89c.sol,SAMPLE,"contract SAMPLE is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; bool _stopTrade; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Burn(address indexed burner, uint256 value); constructor(address admin) Owned(admin) public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10**uint(decimals); _stopTrade = false; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xeecfa1f63f9cce7ae80a49d5341dcba2563d72e1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 7600000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x262e1acb79822bfd711f04aa80d08b629ecdb299.sol,StopLoss,"contract StopLoss is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StopLoss() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x0667F1b5000fca448C3E3FdebA796616797c4DC9] = _totalSupply; Transfer(address(0), 0x0667F1b5000fca448C3E3FdebA796616797c4DC9, _totalSupply); }",1
0x6c3d74c06f5b41ee0427504a4c9abb78db7e1ef6.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6f97b5c035939424037f00102068e610380ee25a.sol,NDD_KHC_I_883,"contract NDD_KHC_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1407435608253240000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardMint,"contract CardMint is CardBase { using AddressUtils for address; event TemplateMint(uint256 _templateId); event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); struct Template { uint256 generation; uint256 category; uint256 variation; string name; }",1
0x4803ead7b2996353373e82f501e1a23a2f892d19.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x556b7a8e1e842625844de6a08669cd20523ce131.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x286ae9778a87dc8d4eb4ac3d57b5b928d41abbff.sol,VOCC_I027_20181211,"contract VOCC_I027_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x18b70ebdbca93c0299c87b594676dfed54a1b88d.sol,Timecoin,"contract Timecoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Timecoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b527c8cc72ea4b8681e44754be6248b107c5229.sol,SmartHomeCoin,"contract SmartHomeCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartHomeCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0x34570cf88db31d4c518dee6057ff78e895dd80f1.sol,IDRTokenERC20,"contract IDRTokenERC20 { string public constant _myTokeName = ; string public constant _mySymbol = ; uint public constant _myinitialSupply = 100000000; uint8 public constant _myDecimal = 0; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IDRTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { decimals = _myDecimal; totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal)); balanceOf[msg.sender] = totalSupply; name = _myTokeName; symbol = _mySymbol; }",1
0xd9ff8cc0433c995f3a9711f1400329cd6a40387f.sol,EtherKnightGame,"contract EtherKnightGame { HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882); using SafeMath for uint256; using SafeMath128 for uint128; event OwnershipTransferred( address previousOwner, address nextOwner, uint256 timeStamp ); event HDXcontractChanged( address previous, address next, uint256 timeStamp ); event onWithdrawGains( address customerAddress, uint256 ethereumWithdrawn, uint256 timeStamp ); event onNewRound( uint256 gRND, uint32 turnRound, uint32 eventType, uint32 eventTarget, uint32[4] persoEnergy, uint32[4] persoDistance, uint32[4] powerUpSpeed, uint32[4] powerUpShield, uint256 blockNumberTimeout, uint256 treasureAmountFind, address customerAddress ); event onNewRace( uint256 gRND, uint8[4] persoType, uint256 blockNumber ); event onBuyShare( address customerAddress, uint256 gRND, uint32 perso, uint256 nbToken, uint32 actionType, uint32 actionValue ); event onMaintenance( bool mode, uint256 timeStamp ); event onRefund( address indexed customerAddress, uint256 eth, uint256 timeStamp ); event onCloseEntry( uint256 gRND ); event onChangeBlockTimeAverage( uint256 blocktimeavg ); modifier onlyOwner { require (msg.sender == owner ); _; }",1
0x2612bb62eaa42991d12be0892c27040d4143e037.sol,ToknTalkToken,"contract ToknTalkToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; address public mintSigner = msg.sender; string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint public totalSupply = 0; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public mintedBy; function transfer(address to, uint amount) external returns (bool) { require(to != address(this)); require(to != 0); uint balanceOfMsgSender = balanceOf[msg.sender]; require(balanceOfMsgSender >= amount); balanceOf[msg.sender] = balanceOfMsgSender - amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; }",1
0x345943aae101bfc73aa32eaff2b9abe7d6790b71.sol,KeyPay,"contract KeyPay is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0x1b05e6557768650c0df0c9377c32c621ac1ccf17.sol,NFTHouseGame,contract NFTHouseGame { struct Listing { uint startPrice; uint endPrice; uint startedAt; uint endsAt; bool isAvailable; },1
0x65719c47fd2a6c1eb9cf24be619291a0e9341ad5.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x56e0dc284a913f7c1198c83f7c69bfec36d31eed.sol,SafeMath,None,1
0x1f0d1de1558582ad6f13763f477119a1455502af.sol,Exchange,contract Exchange is ContractReceiver { using SafeMath for uint256; using BytesLib for bytes; struct Order { address owner; bool active; address sellToken; address buyToken; address ring; uint256 amount; uint256 priceMul; uint256 priceDiv; },1
0x029fa59111136ce592e136760a1df1d4a6cd564b.sol,RetailLoyaltySystemBase,"contract RetailLoyaltySystemBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function RetailLoyaltySystemBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonstersBase,"contract MonstersBase is MonsterAccessControl, MonstersData { event Transfer(address from, address to, uint256 tokenId); bool lockedMonsterCreator = false; MonsterAuction public monsterAuction; MonsterCreatorInterface public monsterCreator; function setMonsterCreatorAddress(address _address) external onlyAdmin { require(!lockedMonsterCreator); MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address); monsterCreator = candidateContract; lockedMonsterCreator = true; }",1
0x3a580a0d295d3f5a8137a91448b03f2bdc22aa2c.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0x0217495d71d7246205bc1b1039dad814d0c0c192.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0xc66c48132e4de2bd2ef922e75eb84c87c9ce7660.sol,Tank,contract Tank is owned { function () payable public {},1
0x2d784562eb7538cc5e5dd5de880d2a1cc241c1bd.sol,DobrocoinContract,"contract DobrocoinContract is owned, Token { uint256 public sellPrice; uint256 public buyPrice; uint256 public AutoBuy = 1; uint256 public AutoSell = 1; address[] public ReservedAddress; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol, string tokenAuthor ) Token(initialSupply, tokenName, tokenSymbol, tokenAuthor) public {}",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x5744155b0891e09b36d871daf35c04a0f0ef4b9c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf09db3b0b2b9d0ae4a8f84676f2c86a899b1a490.sol,ReservedContract,"contract ReservedContract { address public richest; address public owner; uint public mostSent; uint256 tokenPrice = 1; ERC20 Paytoken; address public _reserve20 = 0xD73a0D08cCa496fC687E6c7F4C3D66234FEfda47; event PackageJoinedViaPAD(address buyer, uint amount); event PackageJoinedViaETH(address buyer, uint amount); mapping (address => uint) pendingWithdraws; modifier onlyAdmin() { require (msg.sender == owner); _; }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,Log,contract Log { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x6da5380105a57abf2f42ef4afe01d4d888fc9282.sol,EthStar,"contract EthStar { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xbbf283a1386b1b5e258eec60f27f775972c68571.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c866ac6991bb7bd2c11ec3b8b6cc6b79fd78d75.sol,Ghcwchain,"contract Ghcwchain{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ghcwchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x730688f6396c8d109f1e19e9bfaa9ff50b69246c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x27223d03b1cbe352789c65024cbaf71ab5c90824.sol,BUTT,"contract BUTT { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function BUTT(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5.sol,eBitcoinCash,contract eBitcoinCash is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 21000000 * 10**18; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function eBitcoinCash() { owner = msg.sender; balances[owner] = 21000000 * 10**18; },1
0x6b5ae67ee604f10e6429d74533ac15a57fa14572.sol,LUCK,contract LUCK is Ownable{ address[] public bebdsds; tokenTransfer public bebTokenTransfer; function LUCK(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x6cbc27eb873af5eb177671f45dd02be0b9416fd1.sol,SSSToken,contract SSSToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 2100000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x189cfa1e719ec7728d04e861a6cea077b5fad634.sol,SafeMath,contract SafeMath { constructor() internal { },1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0x74028170d74751878228cda221fd0ac42a830921.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd8ba7164446ef71e89fdc0d94fa492732d371238.sol,HRAToken,"contract HRAToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 10; uint256 public initialSupply = 30000000 * 10**10; uint256 public totalAllocatedTokens; uint256 public tokensAllocatedToCrowdFund; address public founderMultiSigAddress; address public crowdFundAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier nonZeroAddress(address _to){ require(_to != 0x0); _; }",1
0x1b27c2c096ae7e408eef72731fa5ea7e753054de.sol,SUSIToken,"contract SUSIToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SUSIToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc5d3b25a2ca77316b637106a749cd5e92a8e4702.sol,COMMERCIALPOINTCHAINSYSTEM,"contract COMMERCIALPOINTCHAINSYSTEM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COMMERCIALPOINTCHAINSYSTEM() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64] = _totalSupply; Transfer(address(0), 0x0e51B1C46Da00b89760C530a1f468435DAA1Ff64, _totalSupply); }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x1d6b371b0d23d169e87db2fc14ab34f82d190988.sol,ChickenPark,contract ChickenPark is Owned{ using SafeMath for *; modifier notContract() { require (msg.sender == tx.origin); _; },1
0x188ff41cc7960dd51b3aa802fcb17ba17c41276d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf4f5e4c5d5dfd01a3604016bc861ac3654a0c2e2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0eaf3a45f6035565ee7fb61b242f562b77883fc4.sol,Help_the_Needy,contract Help_the_Needy { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x53ce47cbe7f2be0aecd086a70182a98c907d024d.sol,EasyMineIco,"contract EasyMineIco { event TokensSold(address indexed buyer, uint256 amount); event TokensReserved(uint256 amount); event IcoFinished(uint256 burned); struct PriceThreshold { uint256 tokenCount; uint256 price; uint256 tokensSold; }",1
0x6a0d52e162fa1994f25fef0cdc0a3c52efad3e6d.sol,CROWDWISDOM,"contract CROWDWISDOM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x84BF93D0ffadeaa3B3eb2400d5251c889eeA6326] = _totalSupply; emit Transfer(address(0), 0x84BF93D0ffadeaa3B3eb2400d5251c889eeA6326, _totalSupply); }",1
0x3fe53debe8720a61a3e40f85da8611e810fe1fa0.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { totalSupply = 0 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1d9562d5f3b53316e25952079227621adca9eb49.sol,Test,"contract Test{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Test( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; unitsOneEthCanBuy = 1000; }",1
0xd2d6158683aee4cc838067727209a0aaf4359de3.sol,AddressWhitelist,contract AddressWhitelist is Ownable { mapping (address => bool) public whitelisted; function AddressWhitelist() public { },1
0x2151288dfdbd547e071d8c6dc7fe3301235ae87c.sol,Bitcoin1,"contract Bitcoin1 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitcoin1() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0xff3b1d46351D3feb6d2B3703B7d990a706953222] = _totalSupply; Transfer(address(0), 0xff3b1d46351D3feb6d2B3703B7d990a706953222, _totalSupply); }",1
0x1d935f49c1574d4b109dd7f5ff660de3adeb5a0f.sol,COCOIN,"contract COCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5] = _totalSupply; emit Transfer(address(0), 0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5, _totalSupply); }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3cfb35afdbffea20892488ba7f1574adda81b9d.sol,Proof,contract Proof { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xf093b8cc623ca76d2743f47ac1da6eeda24b040a.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x268ec2ff9bb1c27b744f465ff25be9d578096c1e.sol,ASBTToken,"contract ASBTToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xeb0c680b2e42685bc836922d416dfd836704ab09.sol,ARWToken,"contract ARWToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ARWToken() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xde3ad37d806309761210c18704dc1a3faada4aa9.sol,DUBAI_Portfolio_Ib_883,"contract DUBAI_Portfolio_Ib_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 728002043355369000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x9c3b979e2d9cb9d851fc29869ab4bdb1851b4d48.sol,StartupAcceleratorCoin,"contract StartupAcceleratorCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 745122014000000000000000000; balances[0x06203D2308102af31cFdd0317601943285F74086] = _totalSupply; emit Transfer(address(0),0x06203D2308102af31cFdd0317601943285F74086, _totalSupply); }",1
0xaa70bc3e835e12d6902a8e4da77db4842e519c42.sol,DhaCoin,"contract DhaCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DhaCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x33e127da2426822408b1d41344146de02ee48670.sol,PONTEM,"contract PONTEM { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor (uint256 initialSupply , string tokenName , string tokenSymbol) public { totalSupply = 250000000 * 10 ** uint256(18) ; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x523dc2c35f1d6071b5cd72cf4d7b670193034824.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x18cabd1e7db6c52406719cb72859ea2c2eea75d6.sol,GoGuides,"contract GoGuides { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GoGuides( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdc8fd6abd32fd9d0dc74e6947aca082658adeb3d.sol,UMIproject,contract UMIproject { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; UMIBiggestInvestor public umiBiggestInvestor; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0xf2b87ce9c2ce65e786d6ffee0fdb9629ceff05f2.sol,DSCToken,"contract DSCToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function DSCToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0xcd6cb1b25006603382b9e9a832b8686ae240373b.sol,EtheramaCore,"contract EtheramaCore is EtheramaGasPriceLimit { uint256 constant public MAGNITUDE = 2**64; uint256 constant public MIN_TOKEN_DEAL_VAL = 0.1 ether; uint256 constant public MAX_TOKEN_DEAL_VAL = 1000000 ether; uint256 constant public MIN_ETH_DEAL_VAL = 0.001 ether; uint256 constant public MAX_ETH_DEAL_VAL = 200000 ether; uint256 public _bigPromoPercent = 5 ether; uint256 public _quickPromoPercent = 5 ether; uint256 public _devRewardPercent = 15 ether; uint256 public _tokenOwnerRewardPercent = 30 ether; uint256 public _shareRewardPercent = 25 ether; uint256 public _refBonusPercent = 20 ether; uint128 public _bigPromoBlockInterval = 9999; uint128 public _quickPromoBlockInterval = 100; uint256 public _promoMinPurchaseEth = 1 ether; uint256 public _minRefEthPurchase = 0.5 ether; uint256 public _totalIncomeFeePercent = 100 ether; uint256 public _currentBigPromoBonus; uint256 public _currentQuickPromoBonus; uint256 public _devReward; uint256 public _initBlockNum; mapping(address => bool) private _controllerContracts; mapping(uint256 => address) private _controllerIndexer; uint256 private _controllerContractCount; mapping(address => mapping(address => uint256)) private _userTokenLocalBalances; mapping(address => mapping(address => uint256)) private _rewardPayouts; mapping(address => mapping(address => uint256)) private _refBalances; mapping(address => mapping(address => uint256)) private _promoQuickBonuses; mapping(address => mapping(address => uint256)) private _promoBigBonuses; mapping(address => mapping(address => uint256)) private _userEthVolumeSaldos; mapping(address => uint256) private _bonusesPerShare; mapping(address => uint256) private _buyCounts; mapping(address => uint256) private _sellCounts; mapping(address => uint256) private _totalVolumeEth; mapping(address => uint256) private _totalVolumeToken; event onWithdrawUserBonus(address indexed userAddress, uint256 ethWithdrawn); modifier onlyController() { require(_controllerContracts[msg.sender]); _; }",1
0xa5b2fe34d84824c6699c3e8a4139a1efde989b18.sol,BLCToken,"contract BLCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b3f9f54e2a684ea28365af5f3dd6d714df4328b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1e867d04fbb7434093071237813df00b3df6ee77.sol,GridcubePlatformToken,"contract GridcubePlatformToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public _currentSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GridcubePlatformToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 12 weeks; _totalSupply = 30000000000000000000000000; address OwnerAdd = 0xb917cd85b61813ac1cd29ba0a8c37e0cd9f11162; uint256 CommunityTokens = 10000000000000000000000000; uint256 ProjectTokens = 10000000000000000000000000; uint256 HoldTokens = CommunityTokens + ProjectTokens; uint256 SaleTokens = safeSub(_totalSupply, HoldTokens); balances[OwnerAdd] = HoldTokens; Transfer(address(0), OwnerAdd, HoldTokens); _currentSupply = SaleTokens; }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,UGCoin,"contract UGCoin is Multiowned, StandardToken { event Freeze(address from, uint value); event Defreeze(address ownerAddr, address userAddr, uint256 amount); event ReturnToOwner(address ownerAddr, uint amount); event Destroy(address from, uint value); function UGCoin() public Multiowned(){ balances[msg.sender] = initialAmount; totalSupply = initialAmount; }",1
0xf2cee90309418353a57717eca26c4f8754f0d84e.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x6cdc55813f10ace2b056cb52338adc623a83ef22.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 9565658097 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,DateTime,contract DateTime { struct _DateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; },1
0x20f279245cf7d9006f21edcb8d9e291c6e7ecfae.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x1ef57424c7f38628a0e25177ff61a671fbe4b405.sol,BitWestToken,"contract BitWestToken { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitWestToken() { owner = 0xe6C37d321aB3E3669C67347F9cd525b769459FcA; name = ; symbol = ; decimals = 18; totalSupply = 2000000000000000000000000000; balanceOf[owner] = 2000000000000000000000000000; }",1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0xde5b6358808e783df374d1039f483e6ac02c9a28.sol,DecentralizedDinar,"contract DecentralizedDinar is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c] = _totalSupply; emit Transfer(address(0), 0x5f52Fa795e17647D1E635cCA8302bcdE00a4d66c, _totalSupply); }",1
0x21aec0a028d7adec228595b24439c7eb969edd5f.sol,Sudokoin,"contract Sudokoin { uint supply = 203462379904501283815424; uint public boards = 0; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 12; mapping (address => mapping (address => uint)) allowances; mapping (address => uint) balances; mapping (uint => bool) public claimedBoards; event Approval(address indexed _owner, address indexed _spender, uint _value); event BoardClaimed(uint _board, uint _no, address _by); event Burn(address indexed _from, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); function allowance(address _owner, address _spender) constant returns (uint remaining) { remaining = allowances[_owner][_spender]; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,CollectibleToken,contract CollectibleToken is ERC721YC { uint256 private constant STARTING_PRICE = 0.001 ether; uint256 private constant FIRST_STEP_LIMIT = 0.053613 ether; uint256 private constant SECOND_STEP_LIMIT = 0.564957 ether; uint private constant MASTER_TOKEN_ID = 0; function CollectibleToken() public { balances[msg.sender] = 10000000000000000000; totalSupply = 10000000000000000000; },1
0xeccab39acb2caf9adba72c1cb92fdc106b993e0b.sol,AzbitToken,"contract AzbitToken is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public releaseDate = 1546300800; uint256 public constant MIN_RELEASE_DATE = 1546300800; uint256 public constant MAX_RELEASE_DATE = 1559260800; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public whiteList; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41643089590c305b56521b06563954447019f5e6.sol,Panel,contract Panel is IERC20 { using SafeMath for uint256; string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 public constant tokensPerEther = 1000; uint256 public _totalSupply = 9999999000000000000000000; uint256 public totalContribution = 0; uint256 public bonusSupply = 0; bool public purchasingAllowed = false; uint8 public currentSaleDay = 1; uint8 public currentBonus = 100; string public startDate = ; address public owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0x1ca6a09e02480be25c10284372cd21fde7d35a79.sol,IterableMapping,None,1
0xa427451a26d3419d75cb79f835c4b2e898a93ba4.sol,LSYP,"contract LSYP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LSYP() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b] = _totalSupply; Transfer(address(0), 0xc360d4BA6C919bB9C500C49795cA5b4fc31c545b, _totalSupply); }",1
0x711256406c2e9072fbaee5b67d5a893f66a3e707.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); address public ELIX_ADDRESS; uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x01805928b325078683818329526dab3f74865e10.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x785585878feb8cf7cd1e3b9eca0635464c2dd0cb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x200f96afa416d6ad606e5f3953f287a7282b8551.sol,ShamCoin,"contract ShamCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShamCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaac4bd00745b72f49fd1d32862cfdac8a1bb80eb.sol,PingToken,"contract PingToken { event Pong(uint256 pong); event Transfer(address indexed from, address indexed to, uint256 value); uint256 public pings; uint256 public totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); uint256 public genCode = 0; mapping(address => uint256) balances; constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa032e135d6509c7e13c43f07b567edf4071f5636.sol,CryptoExchangeCoin,"contract CryptoExchangeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 125000000000; balances[0x5A3022F4b72c720E616b1085296b2d133eb2f3F3] = _totalSupply; emit Transfer(address(0), 0x5A3022F4b72c720E616b1085296b2d133eb2f3F3, _totalSupply); }",1
0x03ab35f764b00c4dec653cc6ceac35a3efcd3482.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1bdf56c9593590122fd8750555d8148da2b80be8.sol,ShareTokenSale,contract ShareTokenSale is Ownable { using SafeMath for uint256; ERC20 public token; address public receiverAddr; uint256 public totalSaleAmount; uint256 public totalWannaBuyAmount; uint256 public startTime; uint256 public endTime; uint256 public userWithdrawalStartTime; uint256 public clearStartTime; uint256 public withdrawn; uint256 public proportion = 1 ether; mapping(uint256 => uint256) public globalAmounts; struct Stage { uint256 rate; uint256 duration; uint256 startTime; },1
0xd29decbfd29766d8aba8215587f915162c5bd8d8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x340844b39aacbdb4e7718fa14a95758f87a09a9a.sol,DepositCapsule,contract DepositCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function init(uint openOnDate) public { Owner = msg.sender; openDate = openOnDate; },1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0x20ba630e5e6ce0c0803bf4ec0620982b8f776c00.sol,SteriliumToken,"contract SteriliumToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SteriliumToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xa01fda3f7C04C5A6A22DD08d2ED24c7387B29F15] = _totalSupply; Transfer(address(0), 0xa01fda3f7C04C5A6A22DD08d2ED24c7387B29F15, _totalSupply); }",1
0x1c9be00d799132986edcd2d099b9f28e5757677c.sol,_0xEtherToken,"contract _0xEtherToken is ERC20Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol = ; string public name = ; uint8 public decimals = 8; uint public _totalSupply = 10000000000000000; uint public maxSupplyForEra = 5000000000000000; uint public latestDifficultyPeriodStarted; uint public tokensMinted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget = _MAXIMUM_TARGET; bytes32 public challengeNumber; uint public rewardEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; mapping(bytes32 => bytes32) solutionForChallenge; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; address private owner; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xEtherToken() public { owner = msg.sender; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); }",1
0x26c0e6f69b18125f68ac55f439b1e10c2a2e5c03.sol,Owners,contract Owners { mapping (address => bool) public owners; uint public ownersCount; uint public minOwnersRequired = 2; event OwnerAdded(address indexed owner); event OwnerRemoved(address indexed owner); constructor(bool withDeployer) public { if (withDeployer) { ownersCount++; owners[msg.sender] = true; },1
0x2154f9d7da8bf221e102197195531c82cee1677e.sol,AIUToken,"contract AIUToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x41643089590c305b56521b06563954447019f5e6.sol,Panel,contract Panel is IERC20 { using SafeMath for uint256; string public symbol = ; string public name = ; uint8 public constant decimals = 18; uint256 public constant tokensPerEther = 1000; uint256 public _totalSupply = 9999999000000000000000000; uint256 public totalContribution = 0; uint256 public bonusSupply = 0; bool public purchasingAllowed = false; uint8 public currentSaleDay = 1; uint8 public currentBonus = 100; string public startDate = ; address public owner; modifier onlyOwner { require(msg.sender == owner); _; },1
0x5bfea7daa03d28585d5f5307b27bd5c2f0448fb5.sol,FaceTech,"contract FaceTech is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public usersCanUnfreeze; mapping (address => bool) public admin; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozen; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Frozen(address indexed addr, bool frozen); function FaceTech() public { uint256 initialSupply = 8500000000000000; balanceOf[msg.sender] = initialSupply ; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; usersCanUnfreeze=false; admin[msg.sender]=true; }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x74e711f1179f559e1cd7817050cf198b67129269.sol,BitcoinRed,"contract BitcoinRed is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xb86249Da1e02f1faE5653F74fA48EE08097b110F] = _totalSupply; emit Transfer(address(0), 0xb86249Da1e02f1faE5653F74fA48EE08097b110F, _totalSupply); }",1
0x40b5ccf92f9c980fbc6f2f0c0af7a4afff0f7c48.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { require(initialSupply > 100); totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0217495d71d7246205bc1b1039dad814d0c0c192.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x36cac7291719e907276d795c330dbc2fcf66df54.sol,DogCash,"contract DogCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor () public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3] = _totalSupply; emit Transfer(address(0), 0x0C09EA03E90dEE7F0527b5a4Ce51f2F516F93eF3, _totalSupply); }",1
0xd95294fecb64478541ca7b0e5c0a278f4f9d7ee5.sol,Distribution,contract Distribution is Ownable { function Distribution() public {},1
0x1d72e76e38c815b9f91661c340949e8673e897b3.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 20000000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x47078e95d238108b5ee30d4806025b5aab6dac83.sol,BraggerContract,contract BraggerContract { address public richest; string public displayString; uint public highestBalance; address owner; function BraggerContract() public payable { owner = msg.sender; highestBalance = 0; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0xa6239853ff98b88367f6fcb003790654395d322d.sol,ETH10,contract ETH10 { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 10/100 * (block.number - atBlock[msg.sender]) / 6000; address sender = msg.sender; sender.send(amount); },1
0x4221eb87b28de194e916f2b09274471fb0b01b1c.sol,SafeMath,None,1
0x47789aafa0045a316c9af4260ad4ab813fcc2f47.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8.sol,KEDU,"contract KEDU { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x561dd423ebcaa801e04746fb411ef7404a389961.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4acd3b516ffc36ab6929b46b787b320c21f65b35f32f6cb0dbc4717a487841eb; constructor() public { owner = msg.sender; },1
0x0d68560012c430c367e86c4a7d95e3bcd53802d5.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x34737a1ed7508ca6bda6747825c901831f3cd8c0.sol,Weko,"contract Weko { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public funds; address public director; bool public saleClosed; bool public directorLock; uint256 public claimAmount; uint256 public payAmount; uint256 public feeAmount; uint256 public epoch; uint256 public retentionMax; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public buried; mapping (address => uint256) public claimed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Bury(address indexed _target, uint256 _value); event Claim(address indexed _target, address indexed _payout, address indexed _fee); function Weko() public { director = msg.sender; name = ; symbol = ; decimals = 8; saleClosed = true; directorLock = false; funds = 0; totalSupply = 0; totalSupply += 20000000 * 10 ** uint256(decimals); balances[director] = totalSupply; claimAmount = 20 * 10 ** (uint256(decimals) - 1); payAmount = 10 * 10 ** (uint256(decimals) - 1); feeAmount = 10 * 10 ** (uint256(decimals) - 1); epoch = 31536000; retentionMax = 40 * 10 ** uint256(decimals); }",1
0x28e860cb89e705de876f858671cb757f650fdae2.sol,WEPAYCOIN,"contract WEPAYCOIN { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x778608c4ac424522180a43329ff5145400b9d409.sol,ChainclubToken,contract ChainclubToken is StandardToken { string public name; uint8 public decimals; string public symbol; function ChainclubToken() { balances[msg.sender] = 0.21 ether; totalSupply = 0.21 ether; name = ; decimals = 8; symbol = ; },1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0xef4bbb338e2d21ffcbde49ea2b94befe2bba05f1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdba934811a10d2cfe5f33736cc56c42e7b8fd067.sol,HAMDAN,"contract HAMDAN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HAMDAN() public { symbol = ; name = ; decimals = 18; _totalSupply = 999000000000000000000000000; balances[0x91A4A840B9C5e01fc2f735e0331f698D07d98aAE] = _totalSupply; Transfer(address(0), 0x91A4A840B9C5e01fc2f735e0331f698D07d98aAE, _totalSupply); }",1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0xf39e32606f59e5dbbeebe81eb8251f1c380fb5f4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xc56a477ceb26c50ecdf00863c2a0c8b4399c8828.sol,Bitparadise,"contract Bitparadise is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x9b89e4a13c186E22588941eaD7B3b706B474E885] = _totalSupply; emit Transfer(address(0), 0x9b89e4a13c186E22588941eaD7B3b706B474E885, _totalSupply); }",1
0x3775b1b9781cfe7196a91c00ce44507440a51e20.sol,Airdrop,"contract Airdrop is Ownable { function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender, dests[i], values[i] * (10 ** 9)); i += 1; }",1
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,ICOStartPromo,"contract ICOStartPromo { string public url = ""https: string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000 ether; address private owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x6f4f8b6f233eb5dbad46163010f35fed843125b7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1ad1f2d6f5dcb3beca60ebff0bfab6d04a095299cdb316f6975f52b3c8abb569; constructor() public { owner = msg.sender; },1
0x8be453b8a4a834638407b39b6dbc5e7bbf6c1ce2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71e617e6024c20ac20f1c3fa47d874b9e4d2c141.sol,RedCarpetToken,"contract RedCarpetToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedCarpetToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 1200000000000; balances[0x865957fedaef1eaab481e9d236ce45d432c06b60] = _totalSupply; Transfer(address(0), 0x865957fedaef1eaab481e9d236ce45d432c06b60, _totalSupply); }",1
0x4122bc6e97f92acf56421e6365f9c03b692c988e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4103fd474fc5b0784f847efe7d219c7cc6dd2b4e.sol,SafeMath,None,1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0x73f46f17b1a9712262dc3410b37eae4233f36ff9.sol,NeutralToken,contract NeutralToken { function isSenderOwner(address sender) private view returns (bool) { return sender == owner_; },1
0x36234385514de7eb14b2fb5125774e874a88f9ce.sol,titanToken,"contract titanToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function titanToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x40f4991411ac5377675c421e87378e10470134a3.sol,multiowned,contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x887834d3b8d450b6bab109c252df3da286d73ce4.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0x3618516f45cd3c913f81f9987af41077932bc40d.sol,Peculium,"contract Peculium is BurnableToken,Ownable { PeculiumOld public peculOld; address public peculOldAdress = 0x53148Bb4551707edF51a1e8d7A93698d18931225; using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; mapping(address => bool) public balancesCannotSell; event ChangedTokens(address changedTarget,uint256 amountToChanged); event FrozenFunds(address address_target, bool bool_canSell); function Peculium() public { totalSupply = MAX_SUPPLY_NBTOKEN; balances[address(this)] = totalSupply; peculOld = PeculiumOld(peculOldAdress); }",1
0x1c25075bc63ed919babab6cab573f45a47c591df.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1e6f116ca704277c97595316ac157eb6ed30290e.sol,BatchTransfer,contract BatchTransfer is Ownable { constructor () public Ownable(msg.sender) {},1
0xa5a15631eb0aa1d178cf2d2c6bec7732a80eab03.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 500000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf47186b5a4a57121f4eace51f50d47a7c0cd8740.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 value); event Burn(address indexed to, uint256 value); function mint(address addr, uint256 value) onlyOwner public returns (bool) { _totalSupply = _totalSupply.add(value); _balances[addr] = _balances[addr].add(value); emit Mint(addr, value); emit Transfer(address(0), addr, value); return true; }",1
0x795890e742865ef9e716a6de1b107e3c3e7a5748.sol,BitcoinXL,"contract BitcoinXL is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitcoinXL() public { symbol = ; name = ; decimals = 18; _totalSupply = 21000000000000000000000000000; balances[0xF57359488Cbd49a22Da864168f862CD6792C81CD] = _totalSupply; Transfer(address(0), 0xF57359488Cbd49a22Da864168f862CD6792C81CD, _totalSupply); }",1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x6f527e968bab723128ca2a20ccf70da757a3bcf8.sol,E25,contract E25 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c.sol,TJK,"contract TJK { uint256 public totalSupply; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function TJK(uint256 _totalSupply, string _symbol, string _name, uint8 _decimalUnits) public { decimals = _decimalUnits; symbol = _symbol; name = _name; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xeee07485b432c56d38bb7e1a8f5d57322cb78f89.sol,TokenMyUnicoin,"contract TokenMyUnicoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenMyUnicoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x04950c94f4cbf9b3eb7b3ddd48e6aef176e3f73f.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x00c7221d5fbdaab1448675a156876efb885a6449.sol,DENMARK_WINS,"contract DENMARK_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1165947079929830000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6d6db51e3e4838369676508ce25db64f4ca7e5e4.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1774e30a3daab7bbace3ce4c64ddc6a4f29a975a.sol,XHHM,"contract XHHM is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XHHM() public { symbol = ; name = ; decimals = 18; _totalSupply = 900000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc.sol,CoinwareToken,"contract CoinwareToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinwareToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 260000000000000000000000000; balances[0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F] = _totalSupply; Transfer(address(0), 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F , _totalSupply); }",1
0x35d28772130c325403b5ed3cc591368f3baa8250.sol,tokenTrust,"contract tokenTrust { event Hodl(address indexed hodler, uint indexed amount); event Party(address indexed hodler, uint indexed amount); mapping (address => uint) public hodlers; uint partyTime = 1521975140; function() payable { hodlers[msg.sender] += msg.value; Hodl(msg.sender, msg.value); }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x417866263b96ea8fb86e1f332018dda49820c85a.sol,ERC1003Token,contract ERC1003Token is ERC20 { ERC1003Caller private _caller = new ERC1003Caller(); address[] internal _sendersStack; function caller() public view returns(ERC1003Caller) { return _caller; },1
0x5cbf1b692d921f9eccaac6364ba463b8f549f266.sol,roga,"contract roga { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function roga( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa61b4f7843920e43611c48f182784777a1f77f12.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x554ffc77f4251a9fb3c0e3590a6a205f8d4e067d.sol,ZmineToken,"contract ZmineToken is StandardToken, Ownable { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 1000000000 ether; function ZmineToken() public { balances[owner] = totalSupply; }",1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0x286e1b439e616b06f55f801fbcc5f0747e3d9645.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x581bcfbd2323ceb119b03d7e98d3086ac52e02d6.sol,ERC20token,"contract ERC20token{ uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20token(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x52a5e1a56a124dce84e548ff96122246e46d599f.sol,MultiGamesToken,"contract MultiGamesToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MultiGamesToken( ) TokenERC20(10000000, , ) public {}",1
0x1abc429a9e0a6bb21cac418e876f2ba608556836.sol,EthereumPower,"contract EthereumPower { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 965756597440 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22.sol,STCToken,"contract STCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function STCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x74d13225bc488397212e63dc38b497f6aa7a7a69.sol,CoinStacks,"contract CoinStacks { address private admin; uint256 private constant BOTTOM_LAYER_BET = 0.005 ether; uint16 private constant INITIAL_UNLOCKED_COLUMNS = 10; uint256 private maintenanceFeePercent; uint private NUM_COINS_TO_HIT_JACKPOT = 30; uint private MIN_AVG_HEIGHT = 5; uint256 private constant JACKPOT_PRIZE = 2 * BOTTOM_LAYER_BET; mapping(uint32 => address) public coordinatesToAddresses; uint32[] public coinCoordinates; uint256 public reserveForJackpot; mapping(address => uint256) public balances; event coinPlacedEvent ( uint32 _coord, address indexed _coinOwner ); function CoinStacks() public { admin = msg.sender; maintenanceFeePercent = 1; reserveForJackpot = 0; coordinatesToAddresses[uint32(0)] = admin; coinCoordinates.push(uint32(0)); coinPlacedEvent(uint32(0),admin); }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0x5ba2948083538208fca28de380b93cffb3b75fe0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply = 500000000 * 10 ** uint256(decimals); address public owner; address public development = 0x23556CF8E8997f723d48Ab113DAbed619E7a9786; uint public startTime; uint public icoDays; uint public stopTime; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = totalSupply; balanceOf[msg.sender] = 150000000 * 10 ** uint256(decimals); balanceOf[this] = 350000000 * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; owner = msg.sender; }",1
0x72d2da71d6ea20c63a4f23b888ea70dc044f6800.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdafe38c5f5e40f7b11f28344154e78e57537bd66.sol,CREXToken,contract CREXToken is Ownable { uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant restrictedPercent = 35; address constant restrictedAddress = 0x237c494b5B0164593898Fb95703c532A5340f12E; uint256 constant mintFinishTime = 1551448800; uint256 constant transferAllowTime = 1552140000; uint256 public constant hardcap = 399000000 * 1 ether; bool public transferAllowed = false; bool public mintingFinished = false; modifier whenTransferAllowed() { require(transferAllowed || now > transferAllowTime); _; },1
0xda83c0a8587c705122434e8baa50db67ef049263.sol,ICORP,"contract ICORP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ICORP() public { symbol = ; name = ; decimals = 8; _totalSupply = 6700000000000000; balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply; Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply); }",1
0x65832facdc1eefbcfaf50f570228ba886f745681.sol,SmartToken,"contract SmartToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SmartToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xb7710726f14E238aAfb93aDc00A0A7B5755109c1] = _totalSupply; Transfer(address(0), 0xb7710726f14E238aAfb93aDc00A0A7B5755109c1, _totalSupply); }",1
0x03067b2a3208c15013edac9461c600236af3a9f0.sol,Moon3DToken,"contract Moon3DToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x10A319Fc5b48EAa393f711a75DfC77FC4373a095] = _totalSupply; emit Transfer(address(0), 0x10A319Fc5b48EAa393f711a75DfC77FC4373a095, _totalSupply); }",1
0x4c1547be2c6f77c514840041b5a53d32f69e2c64.sol,Escrow,"contract Escrow { event Deposit(uint tokens); address dai_0x_address = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; mapping ( address => uint256 ) public balances; function deposit(uint tokens) public returns (bool success){ balances[msg.sender]+= tokens; ERC20(dai_0x_address).transferFrom(msg.sender, address(this), tokens); emit Deposit(tokens); return true; }",1
0xee6be3671b9d6a129573d89fc72deb074e61d0ec.sol,GenesisToken,"contract GenesisToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GenesisToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 6 weeks; endDate = now + 24 weeks; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherBase,"contract AetherBase is AetherAccessControl { event Construct ( address indexed owner, uint256 propertyId, PropertyClass class, uint8 x, uint8 y, uint8 z, uint8 dx, uint8 dz, string data ); event Transfer( address indexed from, address indexed to, uint256 indexed tokenId ); enum PropertyClass { DISTRICT, BUILDING, UNIT }",1
0xeb0223b8610f7a2d2d8dfa1b98bb2eed8e162a9f.sol,mutil_funds,contract mutil_funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x6f9a91ce11d7af59450e17d3ca77326c3f4af79f3ac61df8cc420e8679d990f8; constructor() public { owner = msg.sender; },1
0x3f922acba2ee567a93933fa4392c2690e4706d42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5515c7c8420d203a30eea9cdbf166e84ab7900c7.sol,OriginalMyDocAuthenticity,contract OriginalMyDocAuthenticity { mapping (string => uint) private authenticity; function storeAuthenticity(string sha256) { if (checkAuthenticity(sha256) == 0) { authenticity[sha256] = now; },1
0x6f21278477a84b7e2aa564d533dc128e1cf00e22.sol,SHERE_PFV_I_883,"contract SHERE_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 748289622343488000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6be98275cb30e4d64ebe6be942cd87268dfea3a5.sol,BusinessAutomationUnion,"contract BusinessAutomationUnion is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BusinessAutomationUnion() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x735ba26f91e1275fa4b504649b19ef74739fe7e7.sol,TeikhosBounty,contract TeikhosBounty { SHA3_512 public sha3_512 = SHA3_512(0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222); struct Commit { uint timestamp; bytes signature; },1
0x92b12168afde3b068fdb201ff42c407be27d15ad.sol,Gravestone,"contract Gravestone { string public fullname; string public birth_date; string public death_date; string public epitaph; Worship[] public worships; uint public worship_count; constructor(string _fullname,string _birth_date,string _death_date,string _epitaph) public { fullname = _fullname; birth_date = _birth_date; death_date = _death_date; epitaph = _epitaph; }",1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e8b3bf967405f2b1feaeb3a09c76bc94a8f37a4.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; string private _name; string private _symbol; uint8 private _decimals; constructor() public { _totalSupply = 21000000000000000; _balances[msg.sender] = _totalSupply; _name = ; _symbol = ; _decimals = 8; },1
0xefbfc3f373c9cc5c0375403177d71bcc387d3597.sol,ETH_GIFT,contract ETH_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass)) { msg.sender.transfer(this.balance); },1
0xc518086f77b45498fabdaa93bdbea24393c7fed6.sol,SFCCToken,"contract SFCCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000 ether; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x474b4642fa37528652e907a2a3ef7ded8fec8cc8.sol,Cyberminer,"contract Cyberminer is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Cyberminer( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x180d669e995ae5fbb7bfb06107546de625cd4f97.sol,BallzToken,"contract BallzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BallzToken() public { symbol = ; name = ; decimals = 3; _totalSupply = 1000000000000; balances[0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc] = _totalSupply; Transfer(address(0), 0xb1b547686b6230b318f6a2b291bdc7fdf7d73ffc, _totalSupply); }",1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0x1d8ed4b0a3147ed17ea09582b46e0c9635396720.sol,IamRich,"contract IamRich is owned, TokenERC20 { uint256 public buyPrice = 10 * 1 ether; uint public boughtNum = 0; function IamRich() TokenERC20() public {}",1
0x06373e227fc3855b0f646db3ed4eebe0f58797f7.sol,EasyTravel,"contract EasyTravel { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EasyTravel( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03b0be689f36f383568d0a2486834cc6ceddda50.sol,EtherPyramid_PowH_Revived,"contract EtherPyramid_PowH_Revived { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function ethpyramid() public { }",1
0x190f064876450617ded5f66735b822c18ba26dd2.sol,SafeMath,None,1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x923108a439c4e8c2315c4f6521e5ce95b44e9b4c.sol,BTTSLib,None,1
0x2858f2b0d94947962f93e4387d391467ebd72166.sol,FLEX,"contract FLEX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FLEX( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0xec1bfc5a4a5655db224a6c591959865a837f53ba.sol,FandBToken,"contract FandBToken is Token(, , 0, 10000), ERC20, ERC223 { function FandBToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x70a128fe6c4f654f52fc799f250506bed550945e.sol,CpublicGold,"contract CpublicGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CpublicGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 6000000000000000000000000000; balances[0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3] = _totalSupply; emit Transfer(address(0), 0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3, _totalSupply); }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3689f372eb8ae130b1767664ad1c75528c815811.sol,EasyInvestPI,contract EasyInvestPI { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 314 / 10000 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x74c5ab4757fcdbf8732230ca154498ea0c538239.sol,TheIlluminati,contract TheIlluminati { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0x0ec0f229574b7491076d1104d378913e28e7ed2a.sol,StandardToken,"contract StandardToken { using SafeMath for uint256; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function totalSupply() public constant returns (uint256 supply) { return totalSupply; }",1
0x3689f372eb8ae130b1767664ad1c75528c815811.sol,EasyInvestPI,contract EasyInvestPI { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 314 / 10000 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0xdc142e66eae81e1a6e7c60df32b15d736f3dd74a.sol,Airdropper,"contract Airdropper is Ownable { address public tokenAddr = 0x0; uint256 public numOfTokens; ERC20 public token; function Airdropper(address _tokenAddr, uint256 _numOfTokens) public { tokenAddr = _tokenAddr; numOfTokens = _numOfTokens; token = ERC20(_tokenAddr); }",1
0xf4f5e4c5d5dfd01a3604016bc861ac3654a0c2e2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ce4642936028cf493c9bdd72e78130297cb77ea.sol,Ownable,"contract Ownable { address public owner; address public ownerCandidate; address[4] public admins; uint256 public ownershipTransferCounter; constructor(address _owner, address[4] _admins) public { owner = _owner; admins[0] = _admins[0]; admins[1] = _admins[1]; admins[2] = _admins[2]; admins[3] = _admins[3]; }",1
0x28f272fb35039753be682dc9a0f416c487c0bc89.sol,continuousBacking,"contract continuousBacking { event CreatedReward(uint256 index,uint256 numAvailable); event ClaimedReward(uint256 index,uint256 totalAmount,uint256 numUnitsDesired,uint256 hostCut,uint256 creatorCut,address backer); event ModifiedNumAvailable(uint256 index,uint256 newNumAvailable); uint256 public MAX_HOST_PERCENT; uint256 public HOST_CUT; uint256 public MAX_NUM_AVAIL; struct Reward { string title; address host; address creator; uint256 numTaken; uint256 numAvailable; uint256 spmPreventionAmt; }",1
0x0073db4d9d92c22e3683058dc92c0b6e5edc639e.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x72bd9e034a034796d77b080bb3d477333c651be4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x74b920485c31f07b2df06f326b465565af6f69e4.sol,DrakeCoin,"contract DrakeCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, uint8 initialDecimals, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, initialDecimals, tokenName, tokenSymbol) public {}",1
0x51344e5ca564d1b8f05bdb483305a3cafec3df78.sol,Token,contract Token is BurnableToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public constant initialSupply = 1000000000 * (10 ** uint256(decimals)); function Token () { totalSupply = initialSupply; balances[msg.sender] = initialSupply; allowedAddresses[owner] = true; },1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x4c902a3ff72dcf01bac6b9d0438565e649a87404.sol,EVOLUTION,contract EVOLUTION { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x04874548a2c233f57ba13c4d4cdee73c29811322.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf442c2f7f9f91bd482fac07ed599ece40ffcc283.sol,HeelToken,"contract HeelToken { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=23000000000*10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HeelToken() public { balanceOf[msg.sender] = totalSupply; }",1
0x0f690a76ad438222ce694d84b2902b0ee2270e69.sol,Secure,"contract Secure { enum Algorithm { sha, keccak }",1
0x6c0f03411ab250f0a080a4420190b821affd4602.sol,ERC721Token,"contract ERC721Token is ERC721Interface, ERC721Metadata, ERC721Enumerable, Owned { using SafeMath for uint; uint public ownerCount = 0; uint public deedCount = 0; mapping(address => uint) public balances; mapping(uint => address) public mIdOwner; mapping(uint => address) public mIdApproved; function balanceOf(address _owner) external view returns (uint balance) { balance = balances[_owner]; }",1
0x0dce40212e3c689ad502739e283d9c3ac79727bc.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf265534f967d29190c995314190aa2275f710af5.sol,MHT,"contract MHT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function MHT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x4d0425e47ee2d16b94c036715dfcb52a0cebc4dc.sol,TAGZ5,"contract TAGZ5 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599] = _totalSupply; emit Transfer(address(0), 0xED8204345a0Cf4639D2dB61a4877128FE5Cf7599, _totalSupply); }",1
0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9.sol,SignalsSociety,"contract SignalsSociety is Ownable, Memberships { event Deposited(address account, uint amount, uint balance, uint timestamp); event MembershipPaid(address account, Membership membership, uint timestamp); mapping (address => uint) public balances; function withdraw(address user) public { require(user == msg.sender); uint amount = balances[user]; balances[user] = 0; user.transfer(amount); }",1
0x338c6906ce36ec61b8a74364bb29ea6ca8cf12c9.sol,DepositTiken,"contract DepositTiken is Owned { using SafeMath for uint; uint public _money = 0; uint public _tokens = 0; uint public _sellprice = 10**18; uint public contractBalance; mapping (address => uint) balances; event SomeEvent(address indexed from, address indexed to, uint value, bytes32 status); constructor () public { uint s = 10**18; _sellprice = s.mul(95).div(100); }",1
0xef09dd7bc772d135778e58f0696132ce7610ab34.sol,Voting,"contract Voting{ address owner; event Voting(uint256 videoNum, uint256 totalVoting); event ChangeOwner(address owner); mapping (uint256=>uint256) totalVoting; constructor(){ owner = msg.sender; }",1
0x53844515fcd00fe3864167a648309dd11c5055fc.sol,IChain,"contract IChain is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 1000000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 800000000 ether; uint256 public totalRemaining; uint256 public tokenReward = INITIAL_SUPPLY.sub(totalDistributed); bool public fundingGoalReached = false; bool public crowdsaleClosed = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { totalSupply_ = INITIAL_SUPPLY; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; }",1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0404ecdc2f2db455a263507863073ec3d725f8ba.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1c3f48ae556893ef033e37d673f7a218454692fa.sol,SWEDEN_WINS,"contract SWEDEN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xcfd2e5876cb479dc9d86abb2ff4bfe166c8d8d22.sol,Dedit,"contract Dedit { event RegistrationCreated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); event RegistrationUpdated(address indexed registrant, bytes32 indexed hash, uint blockNumber, string description); struct Registration { address registrant; bytes32 hash; uint blockNumber; string description; }",1
0xf5580e174b658695680db92e6503949f6c52b454.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x58c37105311985775c43e8b27efabf441859dfc4.sol,DBXTTest,"contract DBXTTest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; endDate = now + 12 weeks; }",1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8633e144f2d9b9b8bdd12ddb58e4bef1e163a0ce.sol,Yellow,"contract Yellow { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Yellow( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3116c449b8980e50df1047886c6042300bef9b96.sol,CryptoColors,"contract CryptoColors is ERC721 { event Released(uint256 tokenId, string name, address owner); event ColorSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private constant PROMO_CREATION_LIMIT = 1000000; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; address public ceoAddress; uint256 public promoCreatedCount; struct Color{ uint8 R; uint8 G; uint8 B; string name; }",1
0x2958ff9b325135374605b4e6987140a53394c6a6.sol,WNCT,"contract WNCT { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WNCT() public { balances[msg.sender] = 100000000000000; totalSupply = 100000000000000; name = ; decimals =4; symbol = ; }",1
0x417ecbab65f29e462a58b6f0516c8e8d5254016b.sol,Airdrop,"contract Airdrop is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0x6ccf98a13ed658678bfe9a319d4454e5f170114d.sol,STVCOIN,"contract STVCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STVCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37afbfb4330d449ce7d231f2356f4f9297c32bc1.sol,DistributeETH,"contract DistributeETH is Ownable { function distribute(address[] _addrs, uint[] _bals) onlyOwner public{ for(uint i = 0; i < _addrs.length; ++i){ if(!_addrs[i].send(_bals[i])) throw; }",1
0xd903286ce14d55ce3eee7a39bcf683c21ed5356e.sol,TheGTokenTest,"contract TheGTokenTest is Token { string public name; uint8 public decimals; string public symbol; function TheGTokenTest(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x4bb936f3ec75fc9f7d6f5ea3ad9837383c23703c.sol,StattmToken,contract StattmToken is MintableToken { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping(address => bool) public isWhiteListed; function burn() public { uint256 _b = balanceOf(msg.sender); balances[msg.sender] = 0; totalSupply_ = totalSupply_ - _b; },1
0x4c246f6e5fb1302c4f244ca3acabc2c09cfd46ad.sol,LCT,"contract LCT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LCT () public { symbol = ; name = ; decimals = 6; _totalSupply = 1000000000000000; balances[0x0A022c3844A055dB6458ef5103A764a71B526222] = _totalSupply; Transfer(address(0), 0x0A022c3844A055dB6458ef5103A764a71B526222, _totalSupply); }",1
0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0xee6465f5df390676c02ebe15cdad07d63e4b1ad6.sol,EthereumMoon,"contract EthereumMoon { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EthereumMoon() public { totalSupply = 500000000000000; balanceOf[msg.sender] = 500000000000000; name = ; symbol = ; decimals = 8; }",1
0x6fcaf59b5a6790752c78e2ab8cf7fe599f3dcd45.sol,NDD_001_T22,"contract NDD_001_T22 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x39f968b4b8b367ce20f5aefc852591f7eada4b3e.sol,Administration,"contract Administration is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Administration() public { symbol = ; name = ; decimals = 18; _totalSupply = 210000000000000000000000000; balances[0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c] = _totalSupply; Transfer(address(0), 0xFe905C1CC0395240317F4e5A6ff22823f9B1DD3c, _totalSupply); }",1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x40ae4acd08e65714b093bf2495fd7941aedfa231.sol,multiowned,contract multiowned { struct MultiOwnedOperationPendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf37c4a962e70d813a4d9825942141cd9bc5169fd.sol,ChangeableRateCrowdsale,contract ChangeableRateCrowdsale is ClaimableCrowdsale { struct RateBoundary { uint256 amount; uint256 rate; },1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Marketplace,contract Marketplace is Ownable { struct Ad { uint price; address exchanger; bool exists; bool active; },1
0xc709c316555ae3002ccc1c0ff7bd2ba83b9cd067.sol,TUNISIA_WINS,"contract TUNISIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5243941086287310000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd0b4fda55a2390e2dae76f1e6f263a7ee18dbdbb.sol,TVTToken,contract TVTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 160000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TVTToken() { owner = msg.sender; balances[owner] = 160000000 * 10**8; },1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837.sol,JawazToken,"contract JawazToken { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JawazToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,Token,"contract Token is Owner, Mortal { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; struct Fund{ uint amount; uint unlockStartTime; uint unlockInterval; uint unlockPercent; bool isValue; }",1
0x28380d4942470c315c2974b934b2080751d35a77.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9251efccb139465204e3d6e3269a73b212f24a5f.sol,Pob,contract Pob{ using SafeMath for *; struct BetItem{ uint256 id; uint256 betCount; },1
0xaa5059814a9412bd161a53a6a69625906701f91d.sol,CCD_EUROSIBENERGO_20190326_2,"contract CCD_EUROSIBENERGO_20190326_2 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x86f91249a10f9872acc96cc352f9a914531a38e5.sol,CrowdsaleRC,"contract CrowdsaleRC { uint public createdTimestamp; uint public start; uint public deadline; address public owner; address public beneficiary; uint public amountRaised; uint public maxAmount; mapping(address => uint256) public balanceOf; mapping (address => bool) public whitelist; event FundTransfer(address backer, uint amount, bool isContribution); function CrowdsaleRC () public { createdTimestamp = block.timestamp; start = 1529316000; deadline = 1532080800; amountRaised = 0; beneficiary = 0xD27eAD21C9564f122c8f84cD98a505efDf547665; owner = msg.sender; maxAmount = 2000 ether; }",1
0xed2192afa8c062dfd6883759380b7f2d1dc6c0c0.sol,Owned,contract Owned { modifier onlyOwner() { require(msg.sender == owner); _; },1
0xf3c8ed6c721774c022c530e813a369dfe78a6e85.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x33adb1613254c57ca2dad0617917b13ebc2e5cbc.sol,CyCo,"contract CyCo { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CyCo( ) public { totalSupply = 100000000000; balanceOf[msg.sender] = 100000000000; name = ; symbol = ; }",1
0x6f4f8b6f233eb5dbad46163010f35fed843125b7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1ad1f2d6f5dcb3beca60ebff0bfab6d04a095299cdb316f6975f52b3c8abb569; constructor() public { owner = msg.sender; },1
0x0f08bdc02fb681462cb6c73b6b351297692aa6e4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0344800bd3ffa687e4d780357961b28995a5f46.sol,QUIZ_GAME,contract QUIZ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x2cf618c19041d9db330d8222b860a624021f30fb.sol,CRBTTokenLive,"contract CRBTTokenLive is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRBTTokenLive() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x65484ce6201436ef85d09f8aa89a251f5e52ad8c.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b353a668f90025337e7f1fcd4202c41f50a22df.sol,LEToken,"contract LEToken is StandardToken, Owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 3*10**28; function LEToken(address beneficiary) public { totalSupply_ = INITIAL_SUPPLY; balances[beneficiary] = INITIAL_SUPPLY; }",1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0x4cd161743a3378aa4169cb5844ea422985342c05.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xf09db3b0b2b9d0ae4a8f84676f2c86a899b1a490.sol,ReservedContract,"contract ReservedContract { address public richest; address public owner; uint public mostSent; uint256 tokenPrice = 1; ERC20 Paytoken; address public _reserve20 = 0xD73a0D08cCa496fC687E6c7F4C3D66234FEfda47; event PackageJoinedViaPAD(address buyer, uint amount); event PackageJoinedViaETH(address buyer, uint amount); mapping (address => uint) pendingWithdraws; modifier onlyAdmin() { require (msg.sender == owner); _; }",1
0x366efd14d20302ab592ffff7bfa4ccb244c19ad9.sol,LCoin,"contract LCoin { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; string public name; string public symbol; uint8 public decimals; constructor(uint _totalSupply,string tokenName,string tokenSymbol,uint8 decimalUnits) public{ balanceOf[msg.sender] = _totalSupply; totalSupply = _totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xd0fa079f298c120946695d5c65a15c14355943b7.sol,PODD,contract PODD { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x6e06db853b69f2d9cedbfaf8ae79e724622de6ae.sol,Crowdsale,"contract Crowdsale is owned { uint256 public totalSupply; string public priceOneTokenSokol = ; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public payable owned() { totalSupply = 11000000; balanceOf[this] = 10000000; balanceOf[owner] = totalSupply - balanceOf[this]; emit Transfer(this, owner, balanceOf[owner]); }",1
0xef106bc813cb65695f5a2c01c1ba3403e7e583b4.sol,RUSS_PFXXXVII_I_883,"contract RUSS_PFXXXVII_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 595075367869688000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdcedcc689487b3c767e37cd2f198d40566294b20.sol,TianqibaoTokenERC20,"contract TianqibaoTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TianqibaoTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd5e0b57757b3555d33a6e93694e6dcc2a3897a63.sol,ERC_20_2,"contract ERC_20_2 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public lockAll = false; address public creator; address public owner; address internal newOwner = 0x0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event TransferExtra(address indexed _from, address indexed _to, uint256 _value, bytes _extraData); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); event Offer(uint256 _supplyTM); event OwnerChanged(address _oldOwner, address _newOwner); event FreezeAddress(address indexed _target, bool _frozen); constructor(uint256 initialSupplyHM, string tokenName, string tokenSymbol, uint8 tokenDecimals) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; totalSupply = initialSupplyHM * 10000 * 10000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; owner = msg.sender; creator = msg.sender; }",1
0x32cff49cd98e8af9dd2ba3ac370949fb06f6a412.sol,HTToken,"contract HTToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function HTToken( ) TokenERC20() public {}",1
0x063115687340eddf0468cfabea4f3770930c119d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x41dcc20e5fc42e21087afb0864683101be5a95ff.sol,Farmcoin,"contract Farmcoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Farmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc429e7b63dc30b51f5a7e4be23fd5eb4baf8a1c3.sol,Bitibu,"contract Bitibu is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitibu( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0xc83355ef25a104938275b46cffd94bf9917d0691.sol,FUTR,"contract FUTR { uint256 constant MAX_UINT256 = 2**256 - 1; uint256 MAX_SUBMITTED = 500067157619455000000000; uint256 _totalSupply = 0; uint256[] levels = [ 8771929824561400000000, 19895525330179400000000, 37350070784724800000000, 64114776667077800000000, 98400490952792100000000, 148400490952792000000000, 218400490952792000000000, 308400490952792000000000, 415067157619459000000000, 500067157619455000000000 ]; uint256[] ratios = [ 114, 89, 55, 34, 21, 13, 8, 5, 3, 2 ]; uint256 _submitted = 0; uint256 public tier = 0; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event Mined(address indexed _miner, uint _value); event WaitStarted(uint256 endTime); event SwapStarted(uint256 endTime); event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time); event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time); string public name = ; uint8 public decimals = 18; string public symbol = ; bool public swap = false; bool public wait = false; bool public extended = false; uint256 public endTime; uint256 swapTime; uint256 swapEndTime; uint256 endTimeExtended; uint256 swapTimeExtended; uint256 swapEndTimeExtended; uint256 public payRate = 0; uint256 submittedFeesPaid = 0; uint256 penalty = 0; uint256 reservedFees = 0; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () external payable { require(msg.sender != address(0) && tier != 10 && swap == false && wait == false); uint256 issued = mint(msg.sender, msg.value); Mined(msg.sender, issued); Transfer(this, msg.sender, issued); }",1
0x31a5f35f32756fe35d39bafe85607d93185b23f2.sol,GNNM,"contract GNNM { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GNNM( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe36df5bb57e80629cfc28a31e5f794071c085eca.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2200000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x4b4878af9474089783f9cef61edbe96614af79e6.sol,CCD_KOHLE_5_20190411,"contract CCD_KOHLE_5_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xbfc70f2151b471794422fd06480933192f3da674.sol,SIE_DE_301202,"contract SIE_DE_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10972781423493000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0x87a05bacd70ed024a3abc5d56b902ec4cc4c9d6c.sol,EasyInvest,contract EasyInvest { mapping (address => uint256) invested; mapping (address => uint256) atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 4 / 100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 0; },1
0x4c2085edeefa307e73a10e3e7224886e6b6a0586.sol,BREDToken,"contract BREDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D] = _totalSupply; emit Transfer(address(0), 0x75D0fC568BCFe82C5901f4ddA9e2b39f4041641D, _totalSupply); }",1
0x6fc1ee575e9023aea1c45b4dfc9acf603ea9f63f.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x2077db08d450d842189b94dea8e3eb95980a8b61.sol,SafePromo,"contract SafePromo { address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); function SafePromo() public { owner = msg.sender; }",1
0x5aa4769f204f0b9e8d9c852377bf90fbe5bf2aeb.sol,MultiX250max03eth,contract MultiX250max03eth { address constant private PROMO = 0x74E6B17a922C741c4dA0b71796eFB0edDDda398a; uint constant public PROMO_PERCENT = 10; uint constant public MULTIPLIER = 250; struct Deposit { address depositor; uint128 deposit; uint128 expect; },1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0x1afafc35b364595f06e89a0429c5762452eb7ffd.sol,BasicToken,"contract BasicToken is ERC20Basic, Pausable { using SafeMath for uint256; mapping(address => uint256) freeBalances; mapping(address => uint256) frozenBalances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; }",1
0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7.sol,RewardsGiftToken,"contract RewardsGiftToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RewardsGiftToken() public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf3fb69ef211c6d1e838a5c2223ef54fed4f24090.sol,SafeMath,None,1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0xee9908222b061ab6aa632b6c4f45d21c5aa6f08c.sol,Dogecointoken,contract Dogecointoken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000000000000000000000000; function name() public constant returns (string) { return ; },1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0x05bb30a1f820add4772b44a808ee9024ce82b34c.sol,VIRTToken,"contract VIRTToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VIRTToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xd46ddc98c63f9705ca6689e7036dc3ce981fb335.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool public initialTranches = false; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping(address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0x1b60504beb425f7cfc8dd14f29924cf596ffaf0b.sol,SafeMath,None,1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x6aeb95f06cda84ca345c2de0f3b7f96923a44f4c.sol,SafeMath,None,1
0x6ed680055bd5a04c194c954f71019ee90145001c.sol,Game,contract Game is FixedSupplyToken { HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); struct Village { address owner; uint defending; uint lastcollect; uint beginnerprotection; },1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf0f9569413d99964ec01bd900126e90c70edda6a.sol,Rollercoaster,contract Rollercoaster { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xe1005f9a9278d48b4917f7702d0d2c8800acc04e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3638c9e50437f00ae53a649697f288ba68888cc1.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7000 * 10 ** uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xeb6aaeff15f1faa7acecb0627364294fb085fbab.sol,FomoCube,contract FomoCube { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x554045a5359aa240807ed5445bfbb5fc60ee21aa.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x2eac4037a8df73f7ddde34b8153c16ded607ff8b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,Storage,contract Storage { address public owner; uint256 public storedAmount; function Storage() public { owner = msg.sender; },1
0xa4ec44afee34feffbae5ce4218d3c06ebd70455e.sol,Superbowl52,contract Superbowl52 { using SafeMath for uint; uint public constant GAME_START_TIME = 1517787000; bool public resultConfirmed = false; address public owner; mapping(address => betting) public bets; uint public totalBets; uint public philadelphiaBets; uint public newEnglandBets; uint public result; uint public betters; bool public votingOpen; bool public withdrawalOpen; uint public threshold; uint public winningPot; mapping(address => uint) public wins; BallotSB52 public ballot; struct betting { uint philadelphiaBets; uint newEnglandBets; bool claimed; },1
0x4bb71389943242be7e08b61c00175a8f0e8cabb4.sol,TwoAfrica,"contract TwoAfrica is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TwoAfrica( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0x721da477f68c71788a262d58853fe6977d86535e.sol,EtheremonPayment,"contract EtheremonPayment is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public STAT_COUNT = 6; uint8 constant public STAT_MAX = 32; uint8 constant public GEN0_NO = 24; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0x28f2c01a3d86ee4faf037147f0aeb49c2eab47ce.sol,DESH,"contract DESH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000; balances[0x2cF5dc0700bc0dccCF305AD2CFc28717e8299207] = _totalSupply; emit Transfer(address(0), 0x2cF5dc0700bc0dccCF305AD2CFc28717e8299207, _totalSupply); }",1
0x8bbb3375d2401da181711032f658c52252b03275.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x02df890024de6658a5a323c9ea33e8cd492bd3906a19c9977574634af4215a98; constructor() public { owner = msg.sender; },1
0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7.sol,YouAreRichToken,"contract YouAreRichToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YouAreRichToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0xf13297aebfe157c4412e59363351779e60ec6b86.sol,GRAM,"contract GRAM is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 12000000000000000; balances[0xEdf54a2ED7337410B8e367B4023C76134b3e801a] = _totalSupply; emit Transfer(address(0), 0xEdf54a2ED7337410B8e367B4023C76134b3e801a, _totalSupply); }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6b7290527ab68d72158cecaef27b0db6238b6fc5.sol,ConunToken,"contract ConunToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ConunToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6da5380105a57abf2f42ef4afe01d4d888fc9282.sol,EthStar,"contract EthStar { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x6d6db51e3e4838369676508ce25db64f4ca7e5e4.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7051620d11042c4335069aaa4f10cd3b4290c681.sol,TCASH,contract TCASH is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 88000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TCASH() { owner = msg.sender; balances[owner] = 88000000 * 10**8; },1
0x5a8dee1f2c6894b96422a536620e389da1f84641.sol,PO24,contract PO24 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,AdviserTimeLock,"contract AdviserTimeLock is Ownable{ SignalsToken token; uint256 withdrawn; uint start; event TokensWithdrawn(address owner, uint amount); function AdviserTimeLock(address _token, address _owner) public{ token = SignalsToken(_token); owner = _owner; start = now; }",1
0x2986402f1e6c4f01acc938e21f78d34fdad30878.sol,BesideVote,"contract BesideVote{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2baec4108306dc87e117d98912d5adac4f15ed9.sol,InfiniteGold,contract InfiniteGold { string public name = ; string public symbol = ; uint256 public decimals = 2; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; address[] addresses; uint[] values; uint256 public totalSupply = 13400000; bool public stopped = false; uint256 constant valueFounder = 13400000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol,TokenBank,contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; },1
0x049a5bf874f241d94232137ef728a9c7dd0d7550.sol,DataTradingToken,"contract DataTradingToken is Ownable, ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 private _unmintedTokens = 360000000*uint(10)**decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0x2d9498d0fd6f40760d53a847eb64eaf51c9b8e74.sol,BasicMathLib,None,1
0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d.sol,TextMessage,"contract TextMessage is owned { uint cost; bool public enabled; event UpdateCost(uint newCost); event UpdateEnabled(string newStatus); event NewText(string number, string message); function TextMessage() { cost = 380000000000000; enabled = true; }",1
0x1d4cb77889e1b418afff5b5190c6d40653af990c.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x91e1dcfbfe7b6be8ac836d08fb493b085ebbb3ef.sol,CoinLottoToken,"contract CoinLottoToken is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function CoinLottoToken (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39fad5cdc35e46bb64598519e00c9419ce121c9d.sol,Bulletin,contract Bulletin { string public message = ; address public owner; function Bulletin(){ owner = msg.sender; },1
0xf4e3a095e2cad145793ec0f9fb5500e260514065.sol,FRANCE_WINS,"contract FRANCE_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 92352243954837600000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x089b85fa15f72c1088cbbef23a49db80b91dd521.sol,BlockEstateToken,"contract BlockEstateToken { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function BlockEstateToken() public { balances[msg.sender] = 10000000000000000; _totalSupply = 10000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x179d2b800fa10cca26f8901707120dbae20641cc.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5c6183d10a00cd747a6dbb5f658ad514383e9419.sol,StandardToken,"contract StandardToken is Token { bool public disabled = false; function transfer(address _to, uint256 _value) returns (bool success) { if (disabled != true && balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xa48bb4d1baff077e9c45dab5d70db59537e8ab79.sol,Queue,contract Queue { address constant private PROMO1 = 0x0569E1777f2a7247D27375DB1c6c2AF9CE9a9C15; address constant private PROMO2 = 0xF892380E9880Ad0843bB9600D060BA744365EaDf; address constant private PROMO3 = 0x35aAF2c74F173173d28d1A7ce9d255f639ac1625; address constant private PRIZE = 0xa93E50526B63760ccB5fAD6F5107FA70d36ABC8b; uint constant public PROMO_PERCENT = 2; uint constant public BONUS_PERCENT = 3; struct Deposit { address depositor; uint deposit; uint payout; },1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x054d5ffadd9aa805544b774681b9fbdec72ca57c.sol,BANK_II_PFII_883,"contract BANK_II_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 427084638464841000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xe0b38482164468a11558606e98d9985e57814cd9.sol,LocalToken,"contract LocalToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; uint256 public totalEthers; uint256 public constant CAP = 2 ether; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LocalToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now; endDate = now + 30 minutes; }",1
0x56c26d3e5051bc0bae8d740304c8dcc16d5e1166.sol,SteabitToken,"contract SteabitToken is owned, TOKENERC20 { function SteabitToken () TOKENERC20( 40000000000 * 1 ** uint256(decimals), , ) public { }",1
0xd0a024e4b057024f941051dc19220a3bab4b5d45.sol,RelexLife,"contract RelexLife { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0x32a44d9d49a05f9049cd7f8eb0e3d19c90dd2421.sol,DragonDistributions,contract DragonDistributions { address public dragon; uint256 public clock; address public prime; address public film; address public northadvisor; address public southadvisor; uint public filmamount; bool public filmpaid; mapping ( address => uint256 ) public balanceOf; mapping ( address => bool ) public distributionOne; mapping ( address => bool ) public distributionTwo; mapping ( address => bool ) public distributionThree; mapping ( address => bool ) public advisors; uint256 public awardAmount = 45000000000000; uint256 public awardAmountPrime = 100000000000000; function DragonDistributions () { dragon = 0x814F67fA286f7572B041D041b1D99b432c9155Ee; prime = 0x243098c1e16973c7e3e969c289c5b87808e359c1; film = 0xdFCf69C8FeD25F5150Db719BAd4EfAb64F628d31; northadvisor = 0x74Fc8fA4F99b6c19C250E4Fc6952051a95F6060D; southadvisor = 0xCC3c6A89B5b8a054f21bCEff58B6429447cd8e5E; clock = now; filmamount = 2500000000000; balanceOf[ film ] = awardAmount + filmamount; balanceOf[ northadvisor ] = awardAmount; balanceOf[ southadvisor ] = awardAmount; balanceOf[ prime ] = awardAmountPrime; advisors [ film ] = true; advisors [ northadvisor ] = true; advisors [ southadvisor ] = true; filmpaid = false; },1
0x365a3335866ac0b5f7002608eae1043d526f44d7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x0c72ab6f7fa937e637f4741ab8e61500ab33c24e71bd88c81eb458dde498338b; constructor() public { owner = msg.sender; },1
0xf4ada683181837c150cd0c33881dd874230eb5ae.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x268f39ebb4868a09fa654d4ffe1ab024bc937db2.sol,DNACoin,"contract DNACoin is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant UNIT = 10 ** decimals; address public companyWallet; address public backendWallet; uint256 public maxSupply = 1000000 * UNIT; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyBackend() { require(msg.sender == backendWallet); _; }",1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xa322e495e36c18cc888e445fc09fba88e5ce164e.sol,NEBC,"contract NEBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NEBC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x71a982a028c9d4b0566041a78df12b810462e155.sol,TFcoin,"contract TFcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TFcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x549ace5ff0c3a1881682fa06813c06884f7ee2e0.sol,EarlyTokenSale,"contract EarlyTokenSale is MintableSale { using SafeMath for uint256; uint256 public fundingGoal; uint256 public tokensPerEther; uint public deadline; address public multiSigWallet; uint256 public amountRaised; Token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; address public creator; address public addressOfTokenUsedAsReward; bool public isFunding = false; mapping (address => uint256) public accredited; event FundTransfer(address backer, uint amount); function EarlyTokenSale( address _addressOfTokenUsedAsReward ) payable { creator = msg.sender; multiSigWallet = 0x9581973c54fce63d0f5c4c706020028af20ff723; addressOfTokenUsedAsReward = _addressOfTokenUsedAsReward; tokenReward = Token(addressOfTokenUsedAsReward); setupAccreditedAddress(0xec7210E3db72651Ca21DA35309A20561a6F374dd, 1000); }",1
0x3606bac9d236835210beb1a332431dd9fd5484da.sol,CTNCToken,contract CTNCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 3016000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0x6b18b3808fd9c4401af4839b6aa2971aae7a8aad.sol,ODEEPToken,"contract ODEEPToken is StandardToken , BurnableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public Bounties_Wallet = 0x70F48becd584115E8FF298eA72D5EFE199526655; address public Team_Wallet = 0xd3186A1e1ECe80F2E1811904bfBF876e6ea27A41; address public OEM_Wallet = 0x4fD0e4E8EFDf55D2C1B41d504A2977a9f8453714; address public LA_wallet = 0xA0AaFDbDD5bE0d5f1A5f980331DEf9b5e106e587; address public tokenWallet = 0x81cb9078e3c19842B201e2cCFC4B0f111d693D47; uint256 public constant INITIAL_SUPPLY = 100000000 ether; uint256 tokenRate = 560; function ODEEPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[Bounties_Wallet] = INITIAL_SUPPLY.mul(5).div(100) ; balances[Team_Wallet] = INITIAL_SUPPLY.mul(8).div(100); balances[OEM_Wallet] = INITIAL_SUPPLY.mul(10).div(100) ; balances[LA_wallet] = INITIAL_SUPPLY.mul(8).div(100) ; balances[tokenWallet] = INITIAL_SUPPLY.mul(69).div(100); endDate = _endDate; emit Transfer(0x0, Bounties_Wallet, balances[Bounties_Wallet]); emit Transfer(0x0, Team_Wallet, balances[Team_Wallet]); emit Transfer(0x0, OEM_Wallet, balances[OEM_Wallet]); emit Transfer(0x0, LA_wallet, balances[LA_wallet]); emit Transfer(0x0, tokenWallet, balances[tokenWallet]); }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0x5815182a0e30aa0ecad298c34cd905e6a854e406.sol,SemixToken,"contract SemixToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SemixToken() public { totalSupply = 10000000 * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5274a2293dbe075a82d41e873bb927403a9dce46.sol,EthCapsule,contract EthCapsule is Ownable { struct Depositor { uint numCapsules; mapping (uint => Capsule) capsules; },1
0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 10000000000; uint256 public buyPrice = 1; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public {}",1
0x712742829b3181b45facca605c699d4479855c30.sol,StrongHands,"contract StrongHands is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StrongHands() public { symbol = ; name = ; decimals = 18; _totalSupply = 18984246847200000000000000000000; balances[0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9] = _totalSupply; Transfer(address(0), 0x2d57365a7ab22425f09D49bB0baFB0426EB8dDF9, _totalSupply); }",1
0x485f3b5ec637187749fd643e517662bd99a4124d.sol,cardpoints,"contract cardpoints is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function cardpoints() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x35B92cb97A07389f0092779844572ae89BF8983a] = _totalSupply; emit Transfer(address(0), 0x35B92cb97A07389f0092779844572ae89BF8983a, _totalSupply); }",1
0x06faa4d8157ba45baf2da5e7d02384225948d54f.sol,EasyInvest25,contract EasyInvest25 { address owner; function EasyInvest25 () { owner = msg.sender; },1
0xd8ee3a6b246674a7c6ca07ed9d8b4500d1d80371.sol,MemeRecorder,contract MemeRecorder { address[] public memeContracts; constructor() public {},1
0x743bba828949fce4557bad9a52db488ce6fdff8d.sol,ZHSH,"contract ZHSH{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ZHSH() public { balances[msg.sender] = 1300000000000; totalSupply = 1300000000000; name = ; decimals =4; symbol = ; }",1
0x8700e5453718244cac9a5257aa82abc9d7bb13af.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x749aba9e082ccb185d1ef88fa514339e3c3368d3.sol,NokuConsumptionPlan,"contract NokuConsumptionPlan is NokuPricingPlan, Ownable { using SafeMath for uint256; event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner); event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee); event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index); struct NokuService { uint serviceFee; uint index; }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0x409e1820aba80fd6bc0f7573528f56cd3ccbfafb.sol,Linamyd,contract Linamyd { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xc668715818831645cdf0eee3a9b84590fa979e65.sol,BGAToken,"contract BGAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 600000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol,ZiberToken,"contract ZiberToken { mapping (address => uint256) public balances; mapping (address => bool) public checked_in; uint256 public bounty; bool public bought_tokens; uint256 public time_bought; bool public kill_switch; string public name; string public symbol; uint8 public decimals; uint256 ZBR_per_eth = 17440; uint256 ZBR_total_reserve = 100000000; uint256 ZBR_dev_reserved = 10000000; uint256 ZBR_for_selling = 80000000; uint256 ZBR_for_bounty= 10000000; uint256 ETH_to_end = 50000 ether; uint registredTo; uint256 loadedRefund; uint256 _supply; string _name; string _symbol; uint8 _decimals; DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50); address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function ZiberToken() { _supply = 10000000000; balanceOf[msg.sender] = _supply; name = ; symbol = ; decimals = 2; }",1
0x6be5744e45292144d6814ffbedcb6aad1bb287e4.sol,CikkaCoin,"contract CikkaCoin is owned { string public name; string public symbol; uint8 public decimals=5; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CikkaCoin() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xee522a9bbe2507546aec572cea7be0f250cba0cb.sol,CentaToken,"contract CentaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CentaToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82] = _totalSupply; Transfer(address(0), 0xFa064973Ad2EF28Ce8e3a306c36CB57cBb9A1d82, _totalSupply); }",1
0x383bf1fd04d0901bbd674a580e0a621fcbb4799b.sol,CryptoDoggies,"contract CryptoDoggies is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, bytes5 dna, uint256 price, address owner); event TokenSold( uint256 indexed tokenId, string name, bytes5 dna, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner ); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) private tokenIdToApproved; struct Doggy { string name; bytes5 dna; }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc.sol,CPLToken,"contract CPLToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPLToken() public { symbol = ; name = ; decimals = 12; _totalSupply = 2000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0x733dcf585e82c3daf788ee44e3faf8c1e7868729.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0x5c8546a7b86ba30202c09a84f5a72644a2a4f7ba.sol,MyDeposit,contract MyDeposit is Ownable { address public Owner; mapping (address => uint) public deposits; uint public openDate; function initalize(uint _openDate) payable public { Owner = msg.sender; openDate = _openDate; deposit(); },1
0x6c0f03411ab250f0a080a4420190b821affd4602.sol,ERC721Token,"contract ERC721Token is ERC721Interface, ERC721Metadata, ERC721Enumerable, Owned { using SafeMath for uint; uint public ownerCount = 0; uint public deedCount = 0; mapping(address => uint) public balances; mapping(uint => address) public mIdOwner; mapping(uint => address) public mIdApproved; function balanceOf(address _owner) external view returns (uint balance) { balance = balances[_owner]; }",1
0x03ce85b4017119f23f023e1374736a8059c03c31.sol,CHEMCHINA_PFII_III_883,"contract CHEMCHINA_PFII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1233471162710430000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x51036b0029e95ecbce4784df0a87987d1092ec7d.sol,StandardToken,contract StandardToken is Token { modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; },1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8.sol,UniCoin,"contract UniCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UniCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5.sol,MatchBettingFactory,contract MatchBettingFactory is Ownable { address[] deployedMatches; address public jackpotAddress; function MatchBettingFactory(address _jackpotAddress) public{ jackpotAddress = _jackpotAddress; },1
0x0e94278497e51629c78697dac758fded6c8f188f.sol,Dividends,contract Dividends { address private maintoken = 0x2054a15c6822a722378d13c4e4ea85365e46e50b; address private owner = msg.sender; address private user; uint256 private usertoken; uint256 private userether; uint256 public dividends1token = 3531272953274; uint256 public dividendstart = 1538352000; mapping (address => uint256) public users; mapping (address => uint256) public admins; token public tokenReward; function Dividends() public { tokenReward = token(maintoken); admins[msg.sender] = 1; },1
0xef19256160e4107b1de93b1753b25e3c4e889caa.sol,OKEXTOKEN,"contract OKEXTOKEN { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 90000000000; balanceOf[msg.sender] = totalSupply; name =; symbol = ; }",1
0x2b684e8905a850a91f5eea913a19dae3926a6703.sol,BWUtility,None,1
0xf5068761511594c82328102f4fde4650ed9ea6c4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x30d5f039375a1c6977b32225ad8c9a409d5dd31f.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0x7241d179d92e86237bb460f8a19fae369a8846a3.sol,CGCToken,"contract CGCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function CGCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xa5b46ff9a887180c8fb2d97146398ddfc5fef1cd.sol,SafeMath,None,1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xc7df14a8289efe7a2d3399387302fdf86e7adc4e.sol,IXToken,contract IXToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x2a99ff217a1077facf743a2eecfa5c56f22383de.sol,Crowdsale,"contract Crowdsale { uint public createdTimestamp; uint public start; uint public deadline; address public beneficiary; uint public amountRaised; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( ) { createdTimestamp = block.timestamp; start = 1526292000; deadline = 1529143200; amountRaised=0; beneficiary = 0xDfD0500541c6F14eb9eD2A6e61BB63bc78693925; }",1
0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xe1dbbce4570b815b6ce3434bb3097dc9f453c565.sol,MobiusRED,"contract MobiusRED is DSMath, DSAuth { string public ipfsHash; string public ipfsHashType = ; MobiusRedToken public token; bool public upgraded; address public nextVersion; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_FRACTION = WAD / 20; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 65 * 10**16; uint public constant REFERRAL_FRACTION = 1 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant AIRDROP_FRACTION = WAD / 100; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public constant STARTING_SHARE_PRICE = 1 finney; uint public constant PRICE_INCREASE_PERIOD = 1 hours; uint public constant HARD_DEADLINE_DURATION = 10 days; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public jackpotSeed; uint public devBalance; uint public raisedICO; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xdd850d1d845a444a13e9516317a0a57075d9cf8e.sol,FOMOWINNER,"contract FOMOWINNER is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; bool public send_allowed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0ec03c088cbfffdd0c2ba8c1cfa35f655a9ce078.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1c866ac6991bb7bd2c11ec3b8b6cc6b79fd78d75.sol,Ghcwchain,"contract Ghcwchain{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ghcwchain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0f08bdc02fb681462cb6c73b6b351297692aa6e4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x261d650a521103428c6827a11fc0cbce96d74dbc.sol,SnailThrone,"contract SnailThrone { using SafeMath for uint; event WithdrewEarnings (address indexed player, uint ethreward); event ClaimedDivs (address indexed player, uint ethreward); event BoughtSnail (address indexed player, uint ethspent, uint snail); event SoldSnail (address indexed player, uint ethreward, uint snail); event HatchedSnail (address indexed player, uint ethspent, uint snail); event FedFrogking (address indexed player, uint ethreward, uint egg); event Ascended (address indexed player, uint ethreward, uint indexed round); event BecamePharaoh (address indexed player, uint indexed round); event NewDivs (uint ethreward); uint256 public GOD_TIMER_START = 86400; uint256 public PHARAOH_REQ_START = 40; uint256 public GOD_TIMER_INTERVAL = 12; uint256 public GOD_TIMER_BOOST = 480; uint256 public TIME_TO_HATCH_1SNAIL = 1080000; uint256 public TOKEN_PRICE_FLOOR = 0.00002 ether; uint256 public TOKEN_PRICE_MULT = 0.00000000001 ether; uint256 public TOKEN_MAX_BUY = 4 ether; uint256 public SNAIL_REQ_REF = 300; bool public gameStarted = false; address public gameOwner; uint256 public godRound = 0; uint256 public godPot = 0; uint256 public godTimer = 0; address public pharaoh; uint256 public lastClaim; uint256 public pharaohReq = PHARAOH_REQ_START; uint256 public maxSnail = 0; uint256 public frogPot = 0; uint256 public snailPot = 0; uint256 public divsPerSnail = 0; mapping (address => uint256) public hatcherySnail; mapping (address => uint256) public lastHatch; mapping (address => uint256) public playerEarnings; mapping (address => uint256) public claimedDivs; constructor() public { gameOwner = msg.sender; }",1
0x03b6609aaceccec42ef526a35b1bd5d728874ea4.sol,PDATAToken,"contract PDATAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PDATAToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x7125df83a5d3945728036d3c5e48e2c9e38d1607.sol,Smartolution,contract Smartolution { struct User { uint value; uint index; uint atBlock; },1
0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d.sol,HomesCoin,"contract HomesCoin is ERC20Interface { string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint price; address owner; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000 * 10**uint(decimals); owner = msg.sender; balances[owner] = _totalSupply; price=100; emit Transfer(owner, address(0), _totalSupply); }",1
0x88b51fb1efb62c8931c125a31c72eb0cdd66a809.sol,VOCC_I100_20181211,"contract VOCC_I100_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x8b6c0dbc499eaf97f54b54fe0019a4c676db534a.sol,BYT,contract BYT is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; constructor() public { totalSupply = 100 * (10**8) * (10**8); balances[msg.sender] = totalSupply; name = ; decimals = 8; symbol = ; },1
0x64e99085fca7f908e1de0db94dae7449b90e97a5.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x6bc2adef424c32cf1e15789f010ea16a753587ac.sol,LEBRON,"contract LEBRON is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function LEBRON() public { symbol = ; name = ; decimals = 18; _totalSupply = 230000000000000000000000000; balances[0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87] = _totalSupply; Transfer(address(0), 0x432a39e0884a0bAA16e2b304b344E47f8CCe8B87, _totalSupply); }",1
0x3595279a9f0658eb2649976f155111bae1ae9de6.sol,GGE,"contract GGE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GGE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x03e5279e6a8acf5e81d70aaaf7791f497ff5aad9.sol,VUULRToken,contract VUULRTokenConfig { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS); uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR; },1
0x262f4bb83b7a1a611d2abea14c9d336320b538c7.sol,ArtisTurbaCrowdsale,contract ArtisTurbaCrowdsale is Owned{ using SafeMath for uint256; using SafeMath for uint; struct ContributorData{ bool isActive; bool isTokenDistributed; uint contributionAmount; uint tokensAmount; },1
0x1c76457f18230dc1c83d3376ca663ca7312f86d8.sol,ETR,"contract ETR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETR() public { symbol = ; name = ; decimals = 18; _totalSupply = 400000000000000000000000000; balances[msg.sender] = _totalSupply; bonusEnds = now + 0.1 weeks; endDate = now + 500 weeks; }",1
0x18dfd8c468ed83397c0e1cadae01e1e65e86d275.sol,PacioToken,"contract PacioToken is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 12; uint public tokensIssued; uint public tokensAvailable; uint public contributors; uint public founderTokensAllocated; uint public founderTokensVested; uint public foundationTokensAllocated; uint public foundationTokensVested; bool public icoCompleteB; address private pFounderToksA; address private pFoundationToksA; event LogIssue(address indexed Dst, uint Picos); event LogSaleCapReached(uint TokensIssued); event LogIcoCompleted(); event LogBurn(address Src, uint Picos); event LogDestroy(uint Picos); function Initialise(address vNewOwnerA) { require(totalSupply == 0); super.ChangeOwner(vNewOwnerA); founderTokensAllocated = 10**20; foundationTokensAllocated = 10**20; totalSupply = 10**21; iTokensOwnedM[ownerA] = 10**21; tokensAvailable = 8*(10**20); Transfer(0x0, ownerA, 10**21); }",1
0xd1f95941d9a69e875f7f51f04e5f214f8114e730.sol,Exzie,"contract Exzie is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Exzie() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000; balances[0xd81fe1115652d04d6b7c48f5e2ed5a615297852d] = _totalSupply; Transfer(address(0), 0xd81fe1115652d04d6b7c48f5e2ed5a615297852d, _totalSupply); }",1
0x261bb5e1c53248860f4bc405abaae3e0bfc12874.sol,LockBalance,"contract LockBalance is Ownable { enum eLockType {None, Individual, GroupA, GroupB, GroupC, GroupD}",1
0x27d99a6d64e8fd38a47fb87df2d80867d6c1592c.sol,MagicKeys,"contract MagicKeys is AtomicSwappableToken, Ownable { string public name; string public symbol; uint8 public decimals; constructor ( string _name, string _symbol ) public { name = _name; symbol = _symbol; decimals = 18; }",1
0xbd11eae443ef0e96c1cc565db5c0b51f6c829c0b.sol,AENToken,"contract AENToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 350000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d2c05109a1309c6de0d3b7f06f397c9c41b8fae.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 50*10**(18+8); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x41f8d4d01ba8505111794e3fa3deb3ed8cbaa8ee.sol,TokenERC20,contract TokenERC20 { address public owner; uint256 public feesA = 10; address public addressA = 0x82914CFc37c46fbbb830150cF2330B80DAADa2D5; function founder() private { owner = msg.sender; },1
0xe9e3f9cfc1a64dfca53614a0182cfad56c10624f.sol,SuNFT,"contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, SupportsInterface { mapping (uint256 => address) internal tokenApprovals; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { address owner = _tokenOwnerWithSubstitutions[_tokenId]; require(msg.sender == owner); _; }",1
0x87cdabc87128476d84462eb9c5a67a7acfa7889e.sol,MilestoneCrowdsale,contract MilestoneCrowdsale is TimedCrowdsale { using SafeMath for uint256; uint256 public constant MAX_MILESTONE = 10; struct Milestone { uint256 index; uint256 startTime; uint256 tokensSold; uint256 cap; uint256 rate; },1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b7734c5ecc51116b806e2ea6decbb3b97f4f92e.sol,CRBT223,"contract CRBT223 is ERC223Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRBT223() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x126bba3aa97d9f6e98f56705f29ab02f7660b445.sol,EducationTokens,"contract EducationTokens is owned{ using SafeMath for uint256; bool private transferFlag; string public name; uint256 public decimals; string public symbol; string public version; uint256 public totalSupply; uint256 public deployTime; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; mapping(address => uint256) private userLockedTokens; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Lock(address userAddress, uint256 amount); event Unlock(address userAddress,uint256 amount); event SetFlag(bool flag); constructor() public { transferFlag = true; name = ; decimals = 4; symbol = ; version = ; totalSupply = 2100000000 * 10 ** decimals; owner = msg.sender; deployTime = block.timestamp; balances[msg.sender] = totalSupply; }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x1eb35af86a3821b5cca3013b1bb942c796aef544.sol,LV,"contract LV { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01b90ee8249afdf628f738af4a2a8ffd7b8434ed.sol,DMC,"contract DMC { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2b6cb3e260fedcaa522f5b6d3c02b8716345d26d.sol,tokenDemo,"contract tokenDemo is owned{ string public name; string public symbol; uint8 public decimals=18; uint public totalSupply; uint public sellPrice=0.01 ether; uint public buyPrice=0.01 ether; mapping(address => uint) public balanceOf; mapping(address => bool) public frozenAccount; function tokenDemo( uint initialSupply, string _name, string _symbol, address centralMinter ) payable { if(centralMinter !=0){ owner=centralMinter; }",1
0xf3837fa9e62691a4eec8fd7d65ef8678d92eecf0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2702ff94cb05717bfa47324872ab5c92b07a8982.sol,StandardToken,"contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public maxSupply; function transfer(address _to, uint256 _value) public returns (bool) { if (balances[msg.sender] < _value) { revert(); }",1
0x292e8030f21039cdbbfb797d547f57e0a031075a.sol,TmrChainERC20,"contract TmrChainERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TmrChainERC20() public { totalSupply =1000000000000000; balanceOf[msg.sender] = 1000000000000000; name = ; symbol = ; }",1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x585a5601e2d95e988dc51a12759c0ca8309f4483.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xe14f29c22f47d1ca8dda796a6718c6bd0be0b3cf.sol,Vault,"contract Vault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0x70673d36178f17ac064747c7bdd026240be194b5.sol,UNIQ,"contract UNIQ { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function UNIQ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0xef02c45c5913629dd12e7a9446455049775eec32.sol,RuletkaIo,"contract RuletkaIo { event partyOver(uint256 roomId, address victim, address[] winners); event newPlayer(uint256 roomId, address player); event fullRoom(uint256 roomId); event roomRefunded(uint256 _roomId, address[] refundedPlayers); address CTO; address CEO; Room[] private allRooms; function () public payable {}",1
0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1.sol,MyNewBank,contract MyNewBank is owned { address public owner; mapping (address=>uint) public deposits; function init() { owner=msg.sender; },1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x2e7c2e45eb417a76132b7c1fd0be00875be8a00d.sol,TimeChip,contract TimeChip { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4839e3de8737769e0f93f176d157dca5e48b7662.sol,CPCToken,"contract CPCToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CPCToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xb435a693f4d453a72a3a094ed3f8e4cb721f66c2.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; uint256 amount = 0; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x47789aafa0045a316c9af4260ad4ab813fcc2f47.sol,WNToken,"contract WNToken is owned, TokenERC20 { using SafeMath for uint256; uint256 buyPrice = 4400; uint8 tranflag = 0; event mylog(uint code); function() external payable{ uint256 weiAmount = uint256(msg.value); owner.transfer(msg.value); uint256 msgvalue2 = buyPrice.mul(weiAmount); uint256 msgvalue3 = msgvalue2.div(10000000000); require(balanceOf[owner] >= msgvalue3); balanceOf[owner] -= msgvalue3; balanceOf[msg.sender] += msgvalue3; Transfer(owner, msg.sender, msgvalue3); }",1
0x74b0e3d730f82fc410986c1f18480ede1e256e6e.sol,GlobaleCash,"contract GlobaleCash is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GlobaleCash() public { symbol = ; name = ; decimals = 0; _totalSupply = 60000000; balances[0x7C86D15F158ad52FBC7B0206995731a309E3CCE0] = _totalSupply; Transfer(address(0), 0x7C86D15F158ad52FBC7B0206995731a309E3CCE0, _totalSupply); }",1
0x6cbd17dcb8331e61baf3d2c7355a27ff9deff619.sol,Crowdsale,"contract Crowdsale is ICrowdsale, Owned { enum Stages { Deploying, Deployed, InProgress, Ended }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ContractOfSale,"contract ContractOfSale is ElementTokenImpl { using SafeMath for uint256; event Sold (uint256 elementId, address oldOwner, address newOwner, uint256 price); uint256 private constant LIMIT_1 = 20 finney; uint256 private constant LIMIT_2 = 500 finney; uint256 private constant LIMIT_3 = 2000 finney; uint256 private constant LIMIT_4 = 5000 finney; function calculateNextPrice (uint256 _price) public pure returns (uint256 _nextPrice) { if (_price < LIMIT_1) { return _price.mul(2); }",1
0x18f1117186ea252e54a2fdd200f6fa48f9e5e979.sol,LegionToken,"contract LegionToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LegionToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2.sol,CryptoBeauty,"contract CryptoBeauty is AccessControl, ERC721 { event Creation(uint256 tokenId, string name, address owner); event Purchase(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, uint256 charityId); event PriceChange(uint256 tokenId, uint256 price); event Charity(uint256 charityId, address charity); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.005 ether; uint256 private increaseLimit1 = 0.5 ether; uint256 private increaseLimit2 = 50.0 ether; uint256 private increaseLimit3 = 100.0 ether; bool charityEnabled; struct Beauty { string name; uint256 price; uint256 maxPrice; }",1
0x71e426c374794ec016390c05a281ece60e932245.sol,VOCC_I103_20181211,"contract VOCC_I103_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6a6c47401f8c40e3bc7982bcd1d2df33a9e633cb.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x2b6cb3e260fedcaa522f5b6d3c02b8716345d26d.sol,tokenDemo,"contract tokenDemo is owned{ string public name; string public symbol; uint8 public decimals=18; uint public totalSupply; uint public sellPrice=0.01 ether; uint public buyPrice=0.01 ether; mapping(address => uint) public balanceOf; mapping(address => bool) public frozenAccount; function tokenDemo( uint initialSupply, string _name, string _symbol, address centralMinter ) payable { if(centralMinter !=0){ owner=centralMinter; }",1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,BountyTokenAllocation,contract BountyTokenAllocation is Ownable { uint256 public remainingBountyTokens; address[] public allocationAddressList; mapping (address => Types.StructBountyAllocation) public bountyOf; function BountyTokenAllocation(uint256 _remainingBountyTokens) Ownable() public { remainingBountyTokens = _remainingBountyTokens; },1
0xdabd08643935a02fdf49cd6264f8d4de8e1feb69.sol,DAX,"contract DAX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DAX( ) public { totalSupply = 200000000000000000000000000; balanceOf[msg.sender] = 200000000000000000000000000; name = ; symbol = ; }",1
0xef7e7984a6e9a77a32eaf6153135526f09f3c794.sol,YtChainToken,"contract YtChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( ) TokenERC20(30000000000, , ) public {}",1
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x54a9ed327f2614316914c3f3a782a77d0aa47aee.sol,CONNECT,"contract CONNECT{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CONNECT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17d30c85376bc2c39edc1da179162d308559a3c4.sol,KFCToken,contract KFCToken { string public name = ; string public symbol = ; uint256 public constant decimals = 8; string public priceIco = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant supplyNumber = 100000000; uint public constant powNumber = 10; uint public constant PRE_ICO = 20000000 * powNumber ** decimals; uint public constant ICO = 50000000 * powNumber ** decimals; uint public constant TECHNOLOGY_DEVELOPMENT = 10000000 * powNumber ** decimals; uint public constant OPERATION_FUND = 10000000 * powNumber ** decimals; uint public constant TEAM_PARTNER_COMPANION = 10000000 * powNumber ** decimals; uint public constant TOKEN_SUPPLY_TOTAL = supplyNumber * powNumber ** decimals; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 500000000; uint256 public buyPrice = 2000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x5314dd28de3f215647b64ccb3701e6098a80d080.sol,CaData,"contract CaData is ADM312, ERC721 { function CaData() public { COO = msg.sender; CTO = msg.sender; CFO = msg.sender; createCustomAtom(0,0,4,0,0,0,0); }",1
0x2de9307ff85d1ca43fa8448de90038a9c719f459.sol,TravelChain,contract TravelChain { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 99000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0xbd677963d9bc990ee8fb7de06e1a63bf6850c2d1.sol,castrol,"contract castrol is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function castrol() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000000000000000000000; bonusEnds = now + 2 weeks; endDate = now + 10 weeks; }",1
0x4d66945d0b739574634b59190af51b4fe27858cc.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x51754fb81c6f7605658f79cb2519625a0d296765.sol,LPCT,"contract LPCT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function LPCT() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x5c0915cc83755fdfbd07a73e0d92476080468212.sol,YuanTian,"contract YuanTian { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xc67e520f6ff27552411c458cf3cf6a920dbd0832.sol,MessaggioInBottiglia,contract MessaggioInBottiglia { address public owner; string public message; string public ownerName; mapping(address => string[]) public comments; modifier onlyOwner() { require(owner == msg.sender); _; },1
0xda36819cfa6167ab5d7932aa8a7852b377a15ab9.sol,DOJC,"contract DOJC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DOJC( ) public { totalSupply = 500000000000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000000000; name = ; symbol = ; }",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrGame,"contract ZethrGame { using SafeMath for uint; using SafeMath for uint56; event Result (address player, uint amountWagered, int amountOffset); event Wager (address player, uint amount, bytes data); address[] pendingBetsQueue; uint queueHead = 0; uint queueTail = 0; mapping(address => BetBase) bets; struct BetBase { uint56 tokenValue; uint48 blockNumber; uint8 tier; }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x729e895e186b7fbd34485d496415bb2f42629b71.sol,RequestCore,"contract RequestCore is Administrable { using SafeMath for uint256; using SafeMathUint96 for uint96; using SafeMathInt for int256; using SafeMathUint8 for uint8; enum State { Created, Accepted, Canceled }",1
0xafaeb51b058999a84354f5e45b44a1649519bcff.sol,MMCoin,"contract MMCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MMCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0d1c63e12fde9e5cada3e272576183aba9cfeda2.sol,ZenswapNetworkToken,"contract ZenswapNetworkToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 20000000000000000000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x70dea95c5e56792a70d357f3e1b2f11e35c4c277.sol,VOCC_I077_20181211,"contract VOCC_I077_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x7199c3fbc0832e8798d2514eeaa88f0ce597698d.sol,Shareable,contract Shareable { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0x47df2f172d2f387a602a85adff876a8ef535cf62.sol,TicketsCoin,"contract TicketsCoin { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 7665755597320 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0x00ea6f91b00e080e816f1bb2fad71b0fe1528983.sol,VCOIN,"contract VCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07] = _totalSupply; Transfer(address(0), 0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07, _totalSupply); }",1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,TOURISTOKEN,"contract TOURISTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 777777777000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0d2dea6d6d6780860431e7c8b0cce6db4ca49a41.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x30169203b76ff6a1879983efe66a65c31fa7758e.sol,EternalMultiplier,contract EternalMultiplier { struct Deposit { address depositor; uint deposit; uint payout; },1
0xeec58a6a1584145106693c24115b7efebf9de896.sol,BlockchainTechnologyFundingToken,"contract BlockchainTechnologyFundingToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x2a89115A6160987088CDA53b72f9751005A91EfE] = _totalSupply; emit Transfer(address(0), 0x2a89115A6160987088CDA53b72f9751005A91EfE, _totalSupply); }",1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf4991089fdc65a9e23771adef47544742a0096c4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf45a3bbe486779250961c9f2da73651deb90406a.sol,Distribute,"contract Distribute is Owned { mapping (address => uint) public tokensOwed; ERC20Basic token; event AmountSet(address contributor, uint amount); event AmountSent(address contributor, uint amount); function Distribute(address _token) public { token = ERC20Basic(_token); }",1
0xaa91a17611945c53a31c1e13969b908d59eab66e.sol,DADCoin,"contract DADCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DADCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF] = _totalSupply; Transfer(address(0), 0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF, _totalSupply); }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,PresaleToken,"contract PresaleToken is PausableToken, MintableToken { string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 9; event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens); function PresaleToken() public { pause(); }",1
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,TheGame,contract TheGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xc6567b2be42c208bc6875b9ae6b07d0618738c39.sol,DrunkCoin,contract DrunkCoin is IERC20 { using SafeMath for uint256; uint public _totalSupply = 0; address public owner; string public symbol; string public name; uint8 public decimals; uint256 public rate; uint256 public etherRaised; uint256 public drunkness; bool public icoRunning; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function () public payable { require(icoRunning); require(msg.value > 0); etherRaised += msg.value; uint256 tokens = msg.value.mul(rate); if(drunkness < 50 * 1 ether) { if(drunkness < 20 * 1 ether) { drunkness += msg.value * 20; if(drunkness > 20 * 1 ether) drunkness = 20 * 1 ether; },1
0xf45a3bbe486779250961c9f2da73651deb90406a.sol,Distribute,"contract Distribute is Owned { mapping (address => uint) public tokensOwed; ERC20Basic token; event AmountSet(address contributor, uint amount); event AmountSent(address contributor, uint amount); function Distribute(address _token) public { token = ERC20Basic(_token); }",1
0x2f7823aaf1ad1df0d5716e8f18e1764579f4abe6.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); }",1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x4083c75ab1f20ac0a1787a591c98bacd43ae777a.sol,Brainmab,"contract Brainmab { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public { balances[msg.sender] = 14000000000000000000000000000; totalSupply = 14000000000000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x127cae460d6e8d039f1371f54548190efe73e756.sol,ShiftCashExtraBonus,"contract ShiftCashExtraBonus { string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShiftCashExtraBonus() public { totalSupply = 1000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x338c6906ce36ec61b8a74364bb29ea6ca8cf12c9.sol,DepositTiken,"contract DepositTiken is Owned { using SafeMath for uint; uint public _money = 0; uint public _tokens = 0; uint public _sellprice = 10**18; uint public contractBalance; mapping (address => uint) balances; event SomeEvent(address indexed from, address indexed to, uint value, bytes32 status); constructor () public { uint s = 10**18; _sellprice = s.mul(95).div(100); }",1
0x1c3bb10de15c31d5dbe48fbb7b87735d1b7d8c32.sol,BLONDCOIN,"contract BLONDCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BLONDCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 45000000000000000000000000; balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply; Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply); }",1
0xd04a63eea250ce2b330d4ed46338d7cfa6999040.sol,TYCOONCoin,"contract TYCOONCoin { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TYCOONCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 219172838 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,Storage,"contract Storage is SafeMath, StringMover { function Storage() public { controllerAddress = msg.sender; }",1
0x87af260d1f637661dcecb6e4efcb4f74963c9539.sol,VINCI_301201,"contract VINCI_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 11063890721038700000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x490dbf7884b8e13c2161448b83dd2d8909db48ed.sol,Curate,"contract Curate is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Curate() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x604d0523bE64C34ffF0686f23b035EBe88B6AC52] = _totalSupply; Transfer(address(0), 0x604d0523bE64C34ffF0686f23b035EBe88B6AC52, _totalSupply); }",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1d3f069406e02936afaa0664bd81986d97858357.sol,DistributeTokens,contract DistributeTokens is Ownable{ token tokenReward; address public addressOfTokenUsedAsReward; function setTokenReward(address _addr) public onlyOwner { tokenReward = token(_addr); addressOfTokenUsedAsReward = _addr; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0x6f5ac8fda08c00c38380777f00e265d4951b6f59.sol,QUIZ,contract QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x374a27ebb608a9021fb907f8f57a3ad2156190ed.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { name = ; symbol = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGameTrophy,"contract TheEthGameTrophy { string public name; string public description; string public message; address public creator; address public owner; address public winner; uint public rank; bool private isAwarded = false; event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner); event Transfer (address indexed _from, address indexed _to); constructor () public { name = ; description = ; rank = 1; creator = msg.sender; }",1
0x736fcb9221bc56a76116981d010d17a320d7ca73.sol,zHQPreSale,"contract zHQPreSale is Crowdsale, Ownable { uint256 public numberOfPurchasers = 0; mapping(address => uint256) bought; uint256 public zHQNumber = 0; bool public goldLevelBonusIsUsed = false; address dev; address public owner; function zHQPreSale() Crowdsale(1506837600, 1606837600, 300) public { owner = msg.sender; dev = msg.sender; }",1
0xf2940f868fcd1fbe8d1e1c02d2eaf68d8d7db338.sol,PlayerBook,contract PlayerBook { using SafeMath for uint256; address private admin = msg.sender; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (uint256 => Player) public plyr_; mapping (uint256 => uint256) public refIDxpID_; struct Player { address addr; },1
0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f.sol,Creditcoin,contract CreditcoinBase is Owned { uint8 public constant decimals = 18; uint256 internal constant FRAC_IN1UNIT = 10 ** uint256(decimals); uint256 public constant creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT; uint256 public constant initialSupplyInFrac = creditcoinLimitInFrac * 30 / 100; },1
0xf07d979303c50a8632848cb154c6b30980218c07.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xcddbea34e7602f17fb661f4d2e59fe561f11e753.sol,TronGold,"contract TronGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TronGold() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 8 weeks; }",1
0x733dcf585e82c3daf788ee44e3faf8c1e7868729.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17e4cc902015958839e693f179f49c75696381ce.sol,DimonCoin,contract DimonCoin is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2e87fbbf2f222e8dc16ae29441a47ffc07503063.sol,SuNFT,"contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces { mapping (uint256 => address) internal tokenApprovals; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { address owner = _tokenOwnerWithSubstitutions[_tokenId]; require(msg.sender == owner); _; }",1
0x5044ac8da9601edf970dcc91a10c5f41c5c548c0.sol,UPower,contract UPower { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x180d14c826e4b74cf1a5c786189fe9888ebad1cc.sol,AsinerumShareToken,"contract AsinerumShareToken { string public name = ; string public symbol = ; uint8 public decimals = 15; uint64 public totalTokens = 172000000; uint64 public priceTokenToCoin = 5000; uint256 public totalSupply; address public ownerWallet; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function AsinerumShareToken() public { totalSupply = totalTokens * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; ownerWallet = msg.sender; }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0x1edcb0dcc0ee685bbea86f5a31a776029f02c7d3.sol,TokenDistribute,contract TokenDistribute is OwnerHelper { uint public E18 = 10 ** 18; constructor() public { },1
0xd806f2945baf1243ce1cbfedaa81d65a75655a9c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d1c828239c3986fc6be89b6d54964b54fc9231f.sol,PORNCASH,"contract PORNCASH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PORNCASH() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29] = _totalSupply; Transfer(address(0), 0xB13256a6bE0789Fc64aa78cAa883c90bB0334d29, _totalSupply); }",1
0xf20a773b3d9f2a1f080fbae1156a5e9768ceb615.sol,BabyCoin,"contract BabyCoin is Ownable { using SafeMath for uint256; string public name; string public symbol; uint32 public decimals = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public airdropNum = 2 ether; uint256 public airdropSupply = 2000; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function BabyCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2d9498d0fd6f40760d53a847eb64eaf51c9b8e74.sol,BasicMathLib,None,1
0xdcac1e6732cb951282e1cfc18b26adb5d1f995e2.sol,TrueGoldCoinToken,"contract TrueGoldCoinToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function TrueGoldCoinToken( ) TokenERC20(100090000, , ) public {}",1
0x2af0c33dd87bc66b8bf8f53c4f599186d0ec7d8f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xa322e495e36c18cc888e445fc09fba88e5ce164e.sol,NEBC,"contract NEBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NEBC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x405d44c9ed3d2d80e375b2360ed0713b71c6b811.sol,Criplos,"contract Criplos { event Transfer(address indexed from, address indexed to, uint tokens); using SafeMath for uint; using ToAddress for bytes; string constant public symbol = ; string constant public name = ; uint8 constant public decimals = 18; address owner; address public advance; address[] recordAccts; uint public priceTokens; uint public minMining; uint public minRemining; uint public minWithdraw; uint public minTransfer; uint totalTokens_; uint totalMining_; uint totalMiners_; uint techBuff_; struct Record { uint balance; uint volume; uint level; address master; }",1
0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c.sol,QUIZ_GAME,"contract QUIZ_GAME { string public Question; bytes32 responseHash; address questionSender; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); Question = _question; questionSender = msg.sender; }",1
0x70f823ed7643fd7a26fdf8753827d31c16374fde.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xf2cee90309418353a57717eca26c4f8754f0d84e.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xefc1b11ad4b183ad859ef220a9c498cb04716a31.sol,Counter,"contract Counter { event Won(address winner, uint amount); uint public i; address public owner; function Counter() public { owner = msg.sender; }",1
0x002036ed3d00736787a31a19b1e28f7a86c72672.sol,DLP,"contract DLP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DLP() public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5b6696ed1e4e74c2a73a3f27186ab315f4fa55d8.sol,TkoWhitelist,"contract TkoWhitelist is Ownable{ using SafeMath for uint256; address public admin; mapping(address => uint256) internal totalIndividualWeiAmount; mapping(address => bool) internal whitelist; event AdminChanged(address indexed previousAdmin, address indexed newAdmin); function TkoWhitelist (address _admin) public { require(_admin != address(0)); admin = _admin; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1f5cfb9a00b86bf9982970382bdb900b7744a559.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6f8e8e44e02963f11d494be759afbe24cf55cd39.sol,DemocracyVote,"contract DemocracyVote { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 99000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); function DemocracyVote() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xde6c7366c50663712de30919b2cb9af2dd1a5378.sol,MDL,contract MDL is ERC20 { function name() public constant returns (string) { return ; },1
0x31a6ba952064f3895e29a5a7f0731287368ab89e.sol,NutrioCoin,contract NutrioCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 50000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x1b9dcdcddd2d6ca699cad9505faa363e81145c6b.sol,BrinkToken,"contract BrinkToken is EIP20Interface { address owner = msg.sender; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint price; function BrinkToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xeccab39acb2caf9adba72c1cb92fdc106b993e0b.sol,AzbitToken,"contract AzbitToken is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public releaseDate = 1546300800; uint256 public constant MIN_RELEASE_DATE = 1546300800; uint256 public constant MAX_RELEASE_DATE = 1559260800; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public whiteList; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x256591374c0fb9b2782b754f6e072aa833e62278.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=3100000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x41dcc20e5fc42e21087afb0864683101be5a95ff.sol,Farmcoin,"contract Farmcoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Farmcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x277ed9ecdc0862f287462030fbbbb006a30ac676.sol,VCLCoin,"contract VCLCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 63000000000000000000000000; balances[0x359c4106f0343A99915EF4c6Ae5e909D4D542f64] = _totalSupply; emit Transfer(address(0), 0x359c4106f0343A99915EF4c6Ae5e909D4D542f64, _totalSupply); }",1
0x5b614e4f17a1938da6248d116cc32f4f17c35f99.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Register (address user, string key); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0x0305b4ccbfd603d92ca0d5eae752000273e26a60.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3688587725ed6dda84bcd25aeeb04997415da50a.sol,BFreeContract,"contract BFreeContract is ERC20Interface, owned{ string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; uint256 public _totalSupply = 2240000; uint256 public icoMin = 300000; uint256 public preIcoLimit = 600000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 preICOprice; uint256 ICOprice; uint256 public currentTokenPrice; uint256 public sellPrice; bool public preIcoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; bool icoExitIsPossible; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function BFreeContract() { preIcoIsRunning = true; minimalGoalReached = false; icoExitIsPossible = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 0.024340770791075100 * 1 ether; preICOprice = 0.024340770791075100 * 1 ether; ICOprice = 0.040567951318458400 * 1 ether; sellPrice = 0; updatePrices(); }",1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0x922c650a44d6b2f9ab761792f8cf60bd944fdcce.sol,DPC,"contract DPC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function DPC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxyCache,contract DSProxyCache { mapping(bytes32 => address) cache; function read(bytes _code) public view returns (address) { bytes32 hash = keccak256(_code); return cache[hash]; },1
0x2c3f2451143e8cec0341b064fcb8fe137ce5d6dd.sol,Maths,None,1
0x3fcf5261c035c26fd2644955968bc940f1b1dc78.sol,EdwinCToken,"contract EdwinCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { initialSupply = 21000000000; totalSupply = 21000000000; balanceOf[msg.sender] = totalSupply; tokenName = ; tokenSymbol = ; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x27d16a670bec2e2db9e0ca367aaee6758d2cb3c7.sol,QCSSToken,"contract QCSSToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x64bfbfa5aedd9622f627e3ddeadb634eb96a6fed.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x44a6bae1dba4d2b91ff7b0b54506fd0e1f9c44de.sol,TunTokenERC20,"contract TunTokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=1000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TunTokenERC20() public { balanceOf[msg.sender] = totalSupply; }",1
0x2ac6c3e75ea7bd845c8f84cb5180e1e9e9f1dfea.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xf24c63438ae11cb3facb84006f4cfa75458126ed.sol,EtherDogBase,"contract EtherDogBase is EtherDogACL { event Birth(address owner, uint256 EtherDogId, uint256 matronId, uint256 sireId, uint256 genes, uint256 generation); event Transfer(address from, address to, uint256 tokenId); struct EtherDog { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint32 siringWithId; uint16 cooldownIndex; uint16 generation; }",1
0x088674acdb4f6ac52fa46f8334955e34b00b0b36.sol,CCD_KOHLE_10_20190411,"contract CCD_KOHLE_10_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x03067b2a3208c15013edac9461c600236af3a9f0.sol,Moon3DToken,"contract Moon3DToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x10A319Fc5b48EAa393f711a75DfC77FC4373a095] = _totalSupply; emit Transfer(address(0), 0x10A319Fc5b48EAa393f711a75DfC77FC4373a095, _totalSupply); }",1
0x1c65557b72804569bcd25ce53575a9c712e2eff5.sol,Play2LivePromo,"contract Play2LivePromo { address public owner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply = 0; uint256 promoValue = 777 * 1e18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; event Transfer(address _from, address _to, uint256 amount); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xd3006f35c0286f5485971f935b87f84e72e8e43f.sol,Token,"contract Token is Owner, Mortal { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; struct Fund{ uint amount; uint unlockStartTime; uint unlockInterval; uint unlockPercent; bool isValue; }",1
0x41c23bf53117806ce77ca65003d435c4d944f519.sol,Contractus,contract Contractus { mapping (address => uint256) public balances; mapping (address => uint256) public timestamp; mapping (address => uint256) public receiveFunds; uint256 internal totalFunds; address support; address marketing; constructor() public { support = msg.sender; marketing = 0x53B83d7be0D19b9935363Af1911b7702Cc73805e; },1
0x4d0528598f916fd1d8dc80e5f54a8feedcfd4b18.sol,Atoshi,"contract Atoshi is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Atoshi( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x27798734d18d63b963137a360cadff807d479e50.sol,TokenERC20,"contract TokenERC20 is ERC20Basic{ string public name; string public symbol; uint8 public decimals = 4; uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _allowance; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimal ) public { _supply = initialSupply * 10 ** uint256(decimal); _balances[msg.sender] = _supply; name = tokenName; symbol = tokenSymbol; decimals = decimal; }",1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e.sol,AG,"contract AG is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 160000000000000000; balances[0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A] = _totalSupply; emit Transfer(address(0), 0xe4eD75a0A590848eE440a473bCBe4aE6a20D424A, _totalSupply); }",1
0x7998b7fcf30d4aed870635155cc62aa55be96f9a.sol,generic_holder,contract generic_holder { address owner; modifier onlyowner { if (owner == msg.sender) _; },1
0xf67451dc8421f0e0afeb52faa8101034ed081ed9.sol,Gambit,"contract Gambit is Token, Owned { string public constant name = ; uint8 public constant decimals = 8; string public constant symbol = ; string public constant version = ; uint256 internal _totalBurnt = 0; function Gambit() { _totalSupply = 260000000000000; balances[owner] = _totalSupply; }",1
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol,YSS,"contract YSS is Owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function YSS(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits, address centralMinter) public { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; if (centralMinter != 0) {owner = centralMinter;}",1
0xb3ccb987036d9e93ea895aa78378e137f72a5e84.sol,ROSCcoin,"contract ROSCcoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ROSCcoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x33685492a20234101b553d2a429ae8a6bf202e18.sol,TerrionFund,contract TerrionFund is Ownable { uint constant minContribution = 200000000000000000; address public owner; mapping (address => uint) public contributors; modifier onlyContributor() { require(contributors[msg.sender] > 0); _; },1
0x52a5e1a56a124dce84e548ff96122246e46d599f.sol,MultiGamesToken,"contract MultiGamesToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MultiGamesToken( ) TokenERC20(10000000, , ) public {}",1
0x41c0542f41251d6d81526ed2dbc8f0008b13fe48.sol,MultiEther,contract MultiEther { struct Deposit { address depositor; uint deposit; uint payout; },1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xdbd45e4d9a8b05790a2a0e0d1a661fd4e21f3da5.sol,IoTonToken,"contract IoTonToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function IoTonToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1bafa500bd219a2afb8f2d0286cc9480c7bd95c2.sol,ERC20Token,"contract ERC20TokenInterface { function balanceOf(address _owner) public constant returns (uint256 value); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); }",1
0x33a56a411b6908b06dc2497eb3dfac1d96db22f2.sol,FECT,"contract FECT is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FECT() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x462adf63904054f21e2b9f217d639446536b5743.sol,HOT,"contract HOT { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public tokenSupply = 177619433541; address public creator; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); function HOT() public { totalSupply = tokenSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; }",1
0xd5dfe9e9e6df35d2aefdb0ce6d3e91b6890923d6.sol,VOCC_I062_20181211,"contract VOCC_I062_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x34734d66dadc3fe1c35b6555341f07e8d8524c29.sol,EncryptedToken,"contract EncryptedToken is owned, TokenERC20 { uint256 INITIAL_SUPPLY = 588235295; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function EncryptedToken() TokenERC20(INITIAL_SUPPLY, , ) payable public { }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x00499c8444cff1c09566a1d5c8b6ea801af9688f.sol,Token,"contract Token { string public symbol = ; string public name = ; uint8 public constant decimals = 18; string public constant ICOFactoryVersion = ; uint256 _totalSupply = 0; uint256 _oneEtherEqualsInWei = 0; uint256 _maxICOpublicSupply = 0; uint256 _ownerICOsupply = 0; uint256 _currentICOpublicSupply = 0; uint256 _blockICOdatetime = 0; address _ICOfundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool isICOrunning = false; bool ICOstarted = false; uint256 ICOoverTimestamp = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) public { owner = adr; }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x4d4377ef856e89cbf76f8e994ab3065445d82f4f.sol,GenbbyToken,"contract GenbbyToken is UpgradableToken { string public contactInformation; string public name = ; string public symbol = ; uint256 public constant decimals = 18; uint256 public constant factor = 10 ** decimals; event UpgradeTokenInformation(string newName, string newSymbol); function GenbbyToken() public { hard_cap = (10 ** 9) * factor; contactInformation = 'https: }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xf2ad62fb35bad00b30e3af1d920de48d29613993.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6bc4375083d3ad563de91cad8438f629841448a5.sol,CryptogeneidToken,"contract CryptogeneidToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CryptogeneidToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xc6EE88b4746850cD70bDb5b2C299966862fc880F] = _totalSupply; Transfer(address(0), 0xc6EE88b4746850cD70bDb5b2C299966862fc880F, _totalSupply); }",1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x03b0be689f36f383568d0a2486834cc6ceddda50.sol,EtherPyramid_PowH_Revived,"contract EtherPyramid_PowH_Revived { uint256 constant PRECISION = 0x10000000000000000; int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function ethpyramid() public { }",1
0x6c44134ab77bd7b90907d2b9745c628caae077d6.sol,BTC,"contract BTC is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BTC( ) TokenERC20() public {}",1
0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897.sol,Angelglorycoin,"contract Angelglorycoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string Angelglorycoin, string AGC ) public { totalSupply = 1000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeb6aaeff15f1faa7acecb0627364294fb085fbab.sol,FomoCube,contract FomoCube { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x534546c490a4ed2a9d0c3555447bb9b4b01bcb9e.sol,Yotro,"contract Yotro is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Yotro() public { symbol = ; name = ; decimals = 17; _totalSupply = 999900000000000000000000; balances[0x3b539c1846f767bF6746AE18E6E949a4398F59E1] = _totalSupply; Transfer(address(0), 0x3b539c1846f767bF6746AE18E6E949a4398F59E1, _totalSupply); }",1
0x17987e621eb8c09f62bc10c90204238cc8cbbe94.sol,coc,"contract coc { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x504d917d0e941550e9f89df195b969e7430118ee.sol,SRDToken,"contract SRDToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRDToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0f598112679b78e17a4a9febc83703710d33489c.sol,MoneroGold,contract MoneroGold { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 21000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x0188404de3811357ef0157f9b3aeeca7d32d3b68.sol,NISSAN_usd_31_883,"contract NISSAN_usd_31_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1143826793595050000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xd1928831616d0cd498a204a81516b05531aea9c8.sol,Century,contract Century is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 21000000 * 10**8; function name() public constant returns (string) { return ; },1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x1c3f48ae556893ef033e37d673f7a218454692fa.sol,SWEDEN_WINS,"contract SWEDEN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb.sol,OXO,contract OXO is Token { string public name; string public symbol; uint32 internal rate; uint32 internal consume; uint256 internal totalConsume; uint256 internal bigJackpot; uint256 internal smallJackpot; uint256 public consumeRule; address internal owner; modifier onlyOwner(){ require (msg.sender==owner); _; },1
0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55.sol,OrganicumOrders,contract OrganicumOrders { struct order { uint256 balance; uint256 tokens; },1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,Multiowned,contract Multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; },1
0xf336496011891a6f905cde1242285e9953c94d0b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0x68fcc99a8cf6dee27dcbbf5ce8ab15f24c706da4.sol,SafeMath,None,1
0x1af79fb7772ebafebcfd5cc79e67281a814ccb1d.sol,ISBToken,"contract ISBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ISBToken() public { symbol = ; name = ; decimals = 9; _totalSupply = 100000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0x0d514c490640d6276b5bb5adc52d1453cf11c5a0.sol,Token,contract Token is StandardToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; address public mintableAddress; function Token(address sale_address) { balances[msg.sender] = 0; totalSupply = 0; name = name; decimals = decimals; symbol = symbol; mintableAddress = sale_address; allowTransfer = true; createTokens(); },1
0xd90cd0492bbb7405a8bba2e49556dbd74ef3b00c.sol,BEC700,"contract BEC700 is ERC20Interface, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BEC700() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC] = _totalSupply; Transfer(address(0), 0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC, _totalSupply); }",1
0xeef8102a0d46d508f171d7323bceffc592835f13.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address=>uint256) public indexes; mapping(uint256=>address) public addresses; uint256 public lastIndex = 0; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); if(_value > 0){ if(balances[msg.sender] == 0){ addresses[indexes[msg.sender]] = addresses[lastIndex]; indexes[addresses[lastIndex]] = indexes[msg.sender]; indexes[msg.sender] = 0; delete addresses[lastIndex]; lastIndex--; }",1
0x272658b351c357e4f5dea20ad45f3761b44134c2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1899924f87138cd0607e27c516a84bc839faa1a4.sol,TokenCreator,"contract TokenCreator { event TokenCreated(address indexed owner, address token); function createToken (string _name, string _symbol, uint8 _decimals) public { emit TokenCreated(msg.sender, new MyToken(_name, _symbol, _decimals, msg.sender)); }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4.sol,MetToken,"contract MetToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 1000 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x71fd1b8263b40049269ee881c9cf842e6ca297e0.sol,JPCOIN,"contract JPCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function JPCOIN() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383] = _totalSupply; Transfer(address(0), 0xa17536ae64eb311cfdD9DB8bDf1c1997C691c383, _totalSupply); }",1
0x5caae332dd0a17827052de681f6f2155e00394f0.sol,SafeMath,None,1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf024628c7bf1ffec7ca184026cd0764ac11ba22f.sol,ClickGemTokenERC20,"contract ClickGemTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ClickGemTokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6.sol,SLUTZToken,"contract SLUTZToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SLUTZToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 25000000000000000; balances[0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1] = _totalSupply; Transfer(address(25000000000000000), 0x2a590BE07c6178c1A743C1ddD94ECA1cAfc97FA1, _totalSupply); }",1
0xc14c848a2a5945e1a415976fc059550ecbe7b034.sol,Line,contract Line { address private owner; uint constant public jackpotNumerator = 50; uint constant public winNumerator = 5; uint constant public giftNumerator = 1; uint constant public denominator = 100; uint constant public ownerDenominator = 100; uint public jackpot = 0; address[] internal addresses; mapping(address => SpinRec) internal spinsByAddr; mapping(bytes32 => SpinRec) internal spinsByQuery; struct SpinRec { uint id; bytes32 queryId; uint bet; uint token; },1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5815182a0e30aa0ecad298c34cd905e6a854e406.sol,SemixToken,"contract SemixToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SemixToken() public { totalSupply = 10000000 * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xec2a74d48c0d5dc1e4ec2677d33d87def3244b49.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4198958c0324d322c0d7118495a5327304fa624b.sol,FantomToken,"contract FantomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantomToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3175000000000000000000000000; balances[0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6] = _totalSupply; Transfer(address(0), 0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6, _totalSupply); }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xdc51e521608ab84ef884232c8b1ed1dd6e48834f.sol,IPFC,"contract IPFC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function IPFC ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5592a2704ba651f8af4cb6f330415f9877483ad2.sol,NamiTrade,"contract NamiTrade{ using SafeMath for uint256; uint public minNac = 0; uint public minWithdraw = 10 * 10**18; uint public maxWithdraw = 1000000 * 10**18; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; }",1
0x70e531091d82e183f7246012d1566c3fe1315625.sol,SendToMany,contract SendToMany { address owner; address[] public recipients; function SendToMany() public { owner = msg.sender; },1
0x6b8c8bec2d3e3e583eabbb29913cc6b929cdfacc.sol,LxtBonusDistribution,"contract LxtBonusDistribution is Owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); enum AllocationType { WHITE_LISTING, BOUNTY, AIRDROP, REFERRAL }",1
0x1aced77b121ed465a95fb5471e3d409fd2d4ede6.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x4b8b085091c51f5f16d8e4a873eabfa6508ddaaa.sol,BCIA,"contract BCIA { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BCIA() { balanceOf[msg.sender] = 200000000 * 1000000000000000000; totalSupply = 200000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0x5bfea7daa03d28585d5f5307b27bd5c2f0448fb5.sol,FaceTech,"contract FaceTech is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public usersCanUnfreeze; mapping (address => bool) public admin; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozen; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Frozen(address indexed addr, bool frozen); function FaceTech() public { uint256 initialSupply = 8500000000000000; balanceOf[msg.sender] = initialSupply ; totalSupply = initialSupply; name = ; symbol = ; decimals = 8; usersCanUnfreeze=false; admin[msg.sender]=true; }",1
0x4198958c0324d322c0d7118495a5327304fa624b.sol,FantomToken,"contract FantomToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantomToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3175000000000000000000000000; balances[0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6] = _totalSupply; Transfer(address(0), 0x77fFE7227F78237c59D43EDdEC6cC259e1556bF6, _totalSupply); }",1
0x7176a57a53a87a800a6d7ec33c8479a8deb57d8b.sol,ARIToken,"contract ARIToken { function ARIToken(address _tokenManager, address _escrow) { tokenManager = _tokenManager; escrow = _escrow; }",1
0x1c66bb904ceaa80aa224193728d459b109115ec2.sol,TBC,"contract TBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() { totalSupply = 5000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,ERC20OptionsConverter,"contract ERC20OptionsConverter is BaseOptionsConverter, TimeSource, Math { address esopAddress; uint32 exercisePeriodDeadline; mapping(address => uint) internal balances; uint public totalSupply; uint32 public optionsConversionDeadline; event Transfer(address indexed from, address indexed to, uint value); modifier converting() { if (currentTime() >= exercisePeriodDeadline) throw; _; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x778608c4ac424522180a43329ff5145400b9d409.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x70ab487ec48b4b9571d346348da0f10737d48a54.sol,PredictionHandshake,contract PredictionHandshake { struct Market { address creator; uint fee; bytes32 source; uint closingTime; uint reportTime; uint disputeTime; uint state; uint outcome; uint totalMatchedStake; uint totalOpenStake; uint disputeMatchedStake; bool resolved; mapping(uint => uint) outcomeMatchedStake; mapping(address => mapping(uint => Order)) open; mapping(address => mapping(uint => Order)) matched; mapping(address => bool) disputed; },1
0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8.sol,UniCoin,"contract UniCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UniCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0xcddbea34e7602f17fb661f4d2e59fe561f11e753.sol,TronGold,"contract TronGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TronGold() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 8 weeks; }",1
0xec71870d02ba5c392ec8f64837e314b28afa4222.sol,BillionRewardsToken,contract BillionRewardsToken is owned { string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint constant ONETOKEN = 10 ** uint(decimals); uint constant MILLION = 1000000; uint public totalSupply; uint public Devs_Supply; uint public Bounty_Supply; bool public Dev_TokenReleased = false; uint public Token_ExchangeValue; bool public Accept_Payment; bool public Token_Unlocked; uint public Eth_Collected; uint public Sold_Token; uint public Burnt_Token; address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28; constructor() public { Accept_Payment = true; Token_Unlocked = true; Token_ExchangeValue = 1999995 * ONETOKEN; totalSupply = 550000 * MILLION * ONETOKEN; Devs_Supply = 10000 * MILLION * ONETOKEN; Bounty_Supply = 40000 * MILLION * ONETOKEN; totalSupply -= Devs_Supply + Bounty_Supply; balanceOf[msg.sender] = totalSupply; },1
0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a.sol,RocketCoin,"contract RocketCoin { string public constant symbol = ; string public constant name = ; uint public constant decimals = 18; uint public constant totalSupply = 10000000 * 10 ** decimals; address owner; bool airDropStatus = true; uint airDropAmount = 300 * 10 ** decimals; uint airDropGasPrice = 20 * 10 ** 9; mapping (address => bool) participants; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function RocketCoin() public { owner = msg.sender; balances[owner] = totalSupply; Transfer(address(0), owner, totalSupply); }",1
0x4cc34f17a47943a037e3a432ca1399daa0ca0bb7.sol,YouAreRichToken,"contract YouAreRichToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YouAreRichToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x0dfb14c2db6c9824d3210ed7e2689e1a51a8e954.sol,PriceGet,contract PriceGet { using SafeMath for uint; Oasis market; address public marketAddress; address public dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; mapping( address => uint256 ) public locked; mapping( address => uint256 ) public tokenBalance; constructor(address addr) public { marketAddress = addr; market = Oasis(marketAddress); },1
0xa177916265c6f647c8e0bfbed396aec1596d6af8.sol,AOS,contract AOS is ERC20Interface { uint256 public constant decimals = 5; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 500000000000000; address public owner; mapping(address => uint256) private balances; mapping(address => mapping (address => uint256)) private allowed; mapping(address => bool) private approvedInvestorList; mapping(address => uint256) private deposit; uint256 public totalTokenSold = 0; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); },1
0x6c79b4ed1cfe6ae97e6a8f117138cb583638954f.sol,ERC20Token,"contract ERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor ( string _tokenName, string _tokenSymbol, uint8 _decimals, uint256 _totalSupply) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xea8c9db193996bbc3f6a9afbdbea2b3b62c11253.sol,RAcoinToken,"contract RAcoinToken is Ownable, ERC20Interface { string public constant symbol = ; string public constant name = ; uint private _totalSupply; uint public constant decimals = 18; uint private unmintedTokens = 20000000000*uint(10)**decimals; event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value); struct LockupRecord { uint amount; uint unlockTime; }",1
0x8432a5a61cf1cc5ca5bc5ab919d0665427fb513c.sol,IcoToken,"contract IcoToken is SafeMath, StandardToken, Pausable { string public name; string public symbol; uint256 public decimals; string public version; address public icoContract; constructor( string _name, string _symbol, uint256 _decimals, string _version ) public { name = _name; symbol = _symbol; decimals = _decimals; version = _version; }",1
0x4103fd474fc5b0784f847efe7d219c7cc6dd2b4e.sol,SafeMath,None,1
0x91e1dcfbfe7b6be8ac836d08fb493b085ebbb3ef.sol,CoinLottoToken,"contract CoinLottoToken is ERC20Interface,Ownable { using SafeMath for uint256; uint256 public totalSupply; mapping(address => uint256) tokenBalances; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; address ownerWallet; mapping (address => mapping (address => uint256)) allowed; event Debug(string message, address addr, uint256 number); function CoinLottoToken (address wallet) public { owner = msg.sender; ownerWallet=wallet; totalSupply = INITIAL_SUPPLY * 10 ** 18; tokenBalances[wallet] = INITIAL_SUPPLY * 10 ** 18; }",1
0x4afea0f1252335e5e6be870139de87725e16560b.sol,NatminToken,"contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken { using SafeMath for uint256; string _name = ; string _symbol = ; string _standard = ; uint256 _decimals = 18; uint256 _totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; constructor(uint256 _supply) public { require(_supply != 0); _totalSupply = _supply * (10 ** 18); balances[contractOwner] = _totalSupply; }",1
0x70a128fe6c4f654f52fc799f250506bed550945e.sol,CpublicGold,"contract CpublicGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CpublicGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 6000000000000000000000000000; balances[0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3] = _totalSupply; emit Transfer(address(0), 0xA031d2564caf3327d5688cA559dDcF8e6f75C6C3, _totalSupply); }",1
0x52fe31c97e5c29ea63cbcfb045e1171427bb9248.sol,NewRich,"contract NewRich is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewRich() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a] = _totalSupply; Transfer(address(0), 0x08652C395d8E23fe7e9f436e882DF7C418dB2f3a, _totalSupply); }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x6d6db51e3e4838369676508ce25db64f4ca7e5e4.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x28df3fcb53b5efd091d816749d500c2e7c88d369.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x008d3c9e91f8abff45f39eb71b316a0606c6d378.sol,TCN,"contract TCN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TCN( ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = 100000000000000000; name = ; symbol = ; }",1
0x2151288dfdbd547e071d8c6dc7fe3301235ae87c.sol,Bitcoin1,"contract Bitcoin1 is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitcoin1() public { symbol = ; name = ; decimals = 8; _totalSupply = 2100000000000000; balances[0xff3b1d46351D3feb6d2B3703B7d990a706953222] = _totalSupply; Transfer(address(0), 0xff3b1d46351D3feb6d2B3703B7d990a706953222, _totalSupply); }",1
0xe0a8a9b7c821d9bbd66b826129d4cf1b219ebb3a.sol,CryptoRides,"contract CryptoRides is ERC721 { event Created(uint256 tokenId, string name, bytes7 plateNumber, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, bytes7 plateNumber); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public tokenIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; mapping (uint256 => uint256) private tokenIdToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Ride { string name; bytes7 plateNumber; }",1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xeb61a78f06fc606d82892a38ea581c2bb7f82570.sol,XcLottery,"contract XcLottery is Ownable{ mapping (string => uint256) randomSeedMap; event DrawLottery(string period, uint256 randomSeed); function getRandomSeed(string period) constant returns (uint256 randomSeed) { return randomSeedMap[period]; }",1
0x1f58af89d12d4a60647f99a9fc71dd0367b56df4.sol,BurnupGameBase,"contract BurnupGameBase is BurnupGameAccessControl { using SafeMath for uint256; event NextGame(uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage); event Start(uint256 indexed gameIndex, address indexed starter, uint256 timestamp, uint256 prizePool, uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage); event End(uint256 indexed gameIndex, address indexed winner, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 prize); event Buyout(uint256 indexed gameIndex, address indexed player, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 timeoutTimestamp, uint256 newPrice, uint256 newPrizePool); event SpiceUpPrizePool(uint256 indexed gameIndex, address indexed spicer, uint256 spiceAdded, string message, uint256 newPrizePool); struct GameSettings { uint256 rows; uint256 cols; uint256 activityTimer; uint256 unclaimedTilePrice; uint256 buyoutReferralBonusPercentage; uint256 buyoutPrizePoolPercentage; uint256 buyoutDividendPercentage; uint256 buyoutFeePercentage; }",1
0x01805928b325078683818329526dab3f74865e10.sol,usingOraclize,contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; },1
0x039b5649a59967e3e936d7471f9c3700100ee1ab.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x35bfd2cfe27ef7af2029d584b9b6c2ca27d9b3c7.sol,EasyEthProfit,contract EasyEthProfit{ mapping (address => uint256) invested; mapping (address => uint256) dateInvest; uint constant public FEE = 4; uint constant public ADMIN_FEE = 10; address private adminAddr; constructor() public{ adminAddr = msg.sender; },1
0x287d2215c5f73fb53badc102f4ae0ca37b1d3d22.sol,Bitzex,contract Bitzex is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function Bitzex() { balances[msg.sender] = 20762827198238982674857634; totalSupply = 20762827198238982674857634; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000000; fundsWallet = msg.sender; },1
0x549ace5ff0c3a1881682fa06813c06884f7ee2e0.sol,EarlyTokenSale,"contract EarlyTokenSale is MintableSale { using SafeMath for uint256; uint256 public fundingGoal; uint256 public tokensPerEther; uint public deadline; address public multiSigWallet; uint256 public amountRaised; Token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; address public creator; address public addressOfTokenUsedAsReward; bool public isFunding = false; mapping (address => uint256) public accredited; event FundTransfer(address backer, uint amount); function EarlyTokenSale( address _addressOfTokenUsedAsReward ) payable { creator = msg.sender; multiSigWallet = 0x9581973c54fce63d0f5c4c706020028af20ff723; addressOfTokenUsedAsReward = _addressOfTokenUsedAsReward; tokenReward = Token(addressOfTokenUsedAsReward); setupAccreditedAddress(0xec7210E3db72651Ca21DA35309A20561a6F374dd, 1000); }",1
0x46570e37d496855b391573fd567599e567a73cb4.sol,VOCC_I043_20181211,"contract VOCC_I043_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0xc5392940c99a9e02c47feea448c2474fb768f65c.sol,XMX,"contract XMX { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XMX ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4d74acfb21f3be9d98263fc0b721840be958ef9d.sol,DomenoToken,"contract DomenoToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DomenoToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000000; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xd86f790b2bfca7b224165662ae5bb21663a999a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, GCRTokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x57e03e646642c81f29c947ee35ff0bf430d4ac14.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; uint256 public initialSupply = 38000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbe4411737170e852ea275d235145ceab77e0fe73.sol,VouchCoin,"contract VouchCoin is Ownable, ERC20Interface { using SafeMath for uint; uint public _totalSupply = 10000000000000000; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; string public standard = ; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; event Burn(address indexed _from, uint _value); function VouchCoin() public { balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xd3cdc4e75750dc1e59f8342200742b6b29490e70.sol,Decurian,"contract Decurian is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decurian() public { symbol = ; name = ; decimals = 3; _totalSupply = 50000000000; balances[0x9eEcF14e12905AA6613D247034D3e71370a61530] = _totalSupply; Transfer(address(0), 0x9eEcF14e12905AA6613D247034D3e71370a61530, _totalSupply); }",1
0x6b78d47bfd2b391f2f34f31a128487e6768ab4f6.sol,eduCash,"contract eduCash { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function eduCash( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0ba84690b9bdec4c3175557446dddf6384eec1d.sol,ERC721,"contract ERC721Abstract { function implementsERC721() public pure returns (bool); function balanceOf(address _owner) public view returns (uint256 balance); function ownerOf(uint256 _tokenId) public view returns (address owner); function approve(address _to, uint256 _tokenId) public; function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); }",1
0x200f96afa416d6ad606e5f3953f287a7282b8551.sol,ShamCoin,"contract ShamCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ShamCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x37ceaf9e7748c707934edea028812c7fdaf93866.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xed17658ad6b3fe87c7dc7323d0e77c4116a23626.sol,Deploy,"contract Deploy is Ownable, Arbitrage { function transfer(address _to, uint256 _value) { require(balances[msg.sender] > _value); require(balances[_to] + _value > balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,InsuranceFund,contract InsuranceFund { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 withdrawals; bool insured; },1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x536ad2443ba256577876dbb4b89db10966513475.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { totalSupply = 400000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3a03afa73623b99eedaa6180a869dd5bde17a601.sol,CheapLambos,contract CheapLambos { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; address owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7.sol,COINVR,"contract COINVR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function COINVR() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x88F22c8632efFA4beF663A658a0a26F2ba418175] = _totalSupply; Transfer(address(0), 0x88F22c8632efFA4beF663A658a0a26F2ba418175, _totalSupply); }",1
0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb.sol,token,"contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }",1
0xc599523f90dc823b9c9dbb3859e22774b46bf6ba.sol,DumbCoin,contract DumbCoin { address public owner; bool public purchasingAllowed = true; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalContribution = 0; uint256 public totalTokensIssued = 0; uint256 public totalBonusTokensIssued = 0; function name() public constant returns (string) { return ; },1
0x365a3335866ac0b5f7002608eae1043d526f44d7.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x0c72ab6f7fa937e637f4741ab8e61500ab33c24e71bd88c81eb458dde498338b; constructor() public { owner = msg.sender; },1
0xf3e6264475f63d771ca562a5176fb9a9b79acd67.sol,Celer,"contract Celer is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Celer() public { symbol = ; name = ; decimals = 8; _totalSupply = 90000000000000000; balances[0x19532C1A9588ec51fc0EB54467E08233636b1a91] = _totalSupply; emit Transfer(address(0), 0x19532C1A9588ec51fc0EB54467E08233636b1a91, _totalSupply); }",1
0xdcaa6f95fcdd339b80631fed7eb213d653c21b12.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x47789aafa0045a316c9af4260ad4ab813fcc2f47.sol,WNToken,"contract WNToken is owned, TokenERC20 { using SafeMath for uint256; uint256 buyPrice = 4400; uint8 tranflag = 0; event mylog(uint code); function() external payable{ uint256 weiAmount = uint256(msg.value); owner.transfer(msg.value); uint256 msgvalue2 = buyPrice.mul(weiAmount); uint256 msgvalue3 = msgvalue2.div(10000000000); require(balanceOf[owner] >= msgvalue3); balanceOf[owner] -= msgvalue3; balanceOf[msg.sender] += msgvalue3; Transfer(owner, msg.sender, msgvalue3); }",1
0xef6ad5b5e389b3676ca1c666d88821d4d5cad2ae.sol,SafeDeposit,"contract SafeDeposit is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.5 ether; deposit(); }",1
0xeca0415f309789ade195a51988d760b6d51f5de9.sol,GreenMed,"contract GreenMed is ERC20Interface { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _totalSupply = 100000000000000000000000000; address public owner; uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) { throw; }",1
0xf3837fa9e62691a4eec8fd7d65ef8678d92eecf0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,RobincoinERC20,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 80000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0x874c3471d459f4107abaeb915cdba6c562cfba3d.sol,Gorgona,contract Gorgona { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; GorgonaKiller public gorgonaKiller; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc56a477ceb26c50ecdf00863c2a0c8b4399c8828.sol,Bitparadise,"contract Bitparadise is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x9b89e4a13c186E22588941eaD7B3b706B474E885] = _totalSupply; emit Transfer(address(0), 0x9b89e4a13c186E22588941eaD7B3b706B474E885, _totalSupply); }",1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x5cbf1b692d921f9eccaac6364ba463b8f549f266.sol,roga,"contract roga { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function roga( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x373604ee6f3bce3b7126bb38f54ce6fd5ec59803.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x29946bc47b8e8a64562816bd6c62e9aa023dfb92.sol,GHANIANCIDIDIGITALTETHER,"contract GHANIANCIDIDIGITALTETHER { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 2000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x763d3a11796551b435c8d789086e922625461410.sol,TCASH,contract TCASH is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 88000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TCASH() { owner = msg.sender; balances[owner] = 88000000 * 10**8; },1
0x02eebe04031cb7dd33ca76c8947059c8f8549ff1.sol,VOCC_I108_20181211,"contract VOCC_I108_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1e4300510ef90de505ddbcb77cdc8c4ab3f6d7c9.sol,VITToken,"contract VITToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function VITToken( ) TokenERC20() public {}",1
0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86.sol,IDCSale,"contract IDCSale is Pausable { using SafeMath for uint256; IDCToken private token; address public beneficiary; enum Stage { Angel, Private, Crowd, Finalized, Failed }",1
0x40c37192f32be790e1ce15c219fe150c0bb6455f.sol,Pardi,"contract Pardi is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Pardi() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c] = _totalSupply; Transfer(address(0), 0xA3D9064C16Bd7ce12D47F5054eE14C81aa12128c, _totalSupply); }",1
0x409e1820aba80fd6bc0f7573528f56cd3ccbfafb.sol,Linamyd,contract Linamyd { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0747af71e2034bc2d2fcad388a264f5ccdff505c.sol,BlockVentureCoin,"contract BlockVentureCoin is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function BlockVentureCoin() { uint supply = 10000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; }",1
0x0e9a0fe317da6c0ca0e1600704fea16211dc2c06.sol,BeardCoin,"contract BeardCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000; balances[0xf005910014c962378B2f179dc0034452Ad3Dc812] = _totalSupply; emit Transfer(address(0), 0xf005910014c962378B2f179dc0034452Ad3Dc812, _totalSupply); }",1
0x532a68a4f2cf7f381dbe151bc64771396eca9398.sol,HUBTToken,"contract HUBTToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HUBTToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000; balances[0x18f46174B90DB82300073c0319B86F7b1E3DDCb3] = _totalSupply; Transfer(address(0), 0x18f46174B90DB82300073c0319B86F7b1E3DDCb3, _totalSupply); }",1
0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51.sol,EtherColor,"contract EtherColor is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.05 ether; uint256 private secondStepLimit = 0.5 ether; mapping (uint256 => address) public colorIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public colorIndexToApproved; mapping (uint256 => uint256) private colorIndexToPrice; mapping (uint256 => uint256) private colorIndexToPreviousPrice; mapping (uint256 => address[5]) private colorIndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Color { string name; }",1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1cd74dd56b0929f1505c6e1f9bdf57fb31d60631.sol,BugisContract,"contract BugisContract { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 600000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BugisContract( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x2976ac3d0bb67c6307a73df852c61c14cdda9863.sol,BitcoinNeo,"contract BitcoinNeo is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitcoinNeo() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000; balances[0x794dcb20e4b48fb1e476d7d5202164d4ce260dff] = _totalSupply; Transfer(address(0), 0x794dcb20e4b48fb1e476d7d5202164d4ce260dff, _totalSupply); }",1
0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc.sol,ERC20,"contract ERC20Template { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef.sol,LylToken,"contract LylToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LylToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x87b3a2c40e63ef9410da6c985a1501fe4972c4e4.sol,SPGForEver,contract SPGForEver { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => uint256) public lockOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 10000000000 * 10 ** decimals; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0xc4581e49d306f4df9e672ac9b31a7b2da5fe1d5b.sol,LowcarbonToken,"contract LowcarbonToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public hourlyProduction; uint public accumulatedHours; uint public last_mint; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed to, uint256 amount); function LowcarbonToken() public { symbol = ; name = ; decimals = 1; last_mint = 0; hourlyProduction = 114155; accumulatedHours = 0; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x518049c81352636b34d82f0a3fad8cfe3571f35a.sol,TICKET,"contract TICKET { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TICKET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4c6e23e5d9dc901991128b3ced739bb0167d7474.sol,Sgethereum,"contract Sgethereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Sgethereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40f4991411ac5377675c421e87378e10470134a3.sol,Token,"contract Token is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public tokenCap = 12500000e18; address public walletAddress; uint256 public creationTime; bool public transferStop; mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); event EmergencyStopActivated(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; }",1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0x0ce4c6fd22c23ccb31d8e6f98ab79a6b6313c634.sol,CAC_2400_20200917,"contract CAC_2400_20200917 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x28b213902cd539e09992f4cbea374952cba5eeed.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { tokenName = ; tokenSymbol = ; initialSupply = 1000000000 * 10 ** uint256(decimals); totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb435a693f4d453a72a3a094ed3f8e4cb721f66c2.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; uint256 amount = 0; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x39e568276531f17da3c76d54400cfd8300201652.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; uint256 private icoLockUntil = 1543593540; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xb47f7059e3706c0ccf270ba11f1747a137f9fd12.sol,Fund,"contract Fund{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function Fund() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol,TokenBank,contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; },1
0x4c49d776c1c314d16b82ecac7ed8f70433db757d.sol,caspianToken,"contract caspianToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function caspianToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; _totalSupply=10000000000000000000000000000; }",1
0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561.sol,SafeMath,None,1
0x013bf75820343cccc2cffda666bf4d5f7891e35c.sol,NEWTOKEN,"contract NEWTOKEN{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=100000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function newtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x714d13c3bebfbf1097db48141471e78f9035dca5.sol,ETD,"contract ETD{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ETD() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0x0eaf3a45f6035565ee7fb61b242f562b77883fc4.sol,Help_the_Needy,contract Help_the_Needy { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x2c1180e2818069e5a9f911e636fb8f3db5106a9f.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; },1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,UltimateCoin,"contract UltimateCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UltimateCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf091cf09c51811819db705710e9634b8bf18f164.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0x0e16923571c50a48b4f9b3b8319606ef8d6106ae.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x597f180157564555ffd96235806415573a02ecb0e9af129d1ddc24e53fe00c96; constructor() public { owner = msg.sender; },1
0xa3c3134b360d8ccf17c4cd8709204e31a7365aa6.sol,FortuneGodToken,contract FortuneGodToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 10000000000*10**18; function FortuneGodToken (address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = 1000*10**18; balances[_owner] = INITIAL_SUPPLY.sub(1000*10**18); },1
0x6b8c8bec2d3e3e583eabbb29913cc6b929cdfacc.sol,LxtBonusDistribution,"contract LxtBonusDistribution is Owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); enum AllocationType { WHITE_LISTING, BOUNTY, AIRDROP, REFERRAL }",1
0xf0902adc8ebe58c4874f371066fd339519ae1d32.sol,SHERE_PFIII_III_883,"contract SHERE_PFIII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1864492808887740000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1.sol,CNet5G,"contract CNet5G { string public name = ; uint256 public decimals = 2; uint256 public totalSupply; string public symbol = ; event Mint(address indexed owner,uint amount); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function CNet5G() public { owner = 0x5103bA50f2324c6A80c73867d93B173d94cB11c6; balances[0x5103bA50f2324c6A80c73867d93B173d94cB11c6] = 300000000 * 10**decimals; totalSupply =300000000 * 10**decimals; }",1
0xdfb9e87ff81cb089484ef8150a21be80f6cdd401.sol,CRYPTOPOKER,"contract CRYPTOPOKER { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 10000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 10000000000* (10 ** uint256(decimals)); name = ; symbol = ; }",1
0xd389c08bb987dd7daeb31f51fce1b5b73710b38e.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0x313df3fac623a824c8e64b4c47cf62fe0b75809e.sol,Whitelist,contract Whitelist is Ownable { mapping(address => bool) whitelist; uint256 public whitelistLength = 0; address public backendAddress; function addWallet(address _wallet) public onlyPrivilegedAddresses { require(_wallet != address(0)); require(!isWhitelisted(_wallet)); whitelist[_wallet] = true; whitelistLength++; },1
0xdf329603bd378021698f9833cd5205b52f9e370e.sol,Ethershift,"contract Ethershift is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ethershift() public { symbol = ; name = ; decimals = 18; _totalSupply = 15000000000000000000000000; balances[0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302] = _totalSupply; Transfer(address(0), 0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302, _totalSupply); }",1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,contract WhaleGiveaway1 { address public Owner = msg.sender; uint constant public minEligibility = 0.999001 ether; function() public payable { },1
0x64b103aee34d1fa22fb4c45c4be105cbe1c4a179.sol,RainbowsEverywhere,contract RainbowsEverywhere { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x340085ed7d6c18dcf4c8b661fba6bd95916c8644.sol,BoostPax,"contract BoostPax { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 100000000 * 10 ** uint256(18); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x413bdaae8e7218aea3a7ca544762d4f9f128a562.sol,NFC,"contract NFC{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function NFC() public { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = ; decimals =4; symbol = ; }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,AuctionStorage,contract AuctionStorage is BaseStorage { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint startedAt; bool byTeam; },1
0xa26d5253ab96e04afe51b4c1614b29b11889d3b1.sol,Ico,contract Ico is BasicToken { address owner; uint256 public teamNum; mapping(address => bool) team; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 private constant tokenPrecision = 10e17; uint256 public constant hardCap = 32000 * tokenPrecision; uint256 public tokensFrozen = 0; uint256 public tokenValue = 1 * tokenPrecision; struct DividendSnapshot { uint256 totalSupply; uint256 dividendsIssued; uint256 managementDividends; },1
0x707bd951c676c5f7a957df363d6ce1b2af4b636d.sol,ANOToken,"contract ANOToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 21000000000 * 10**18; uint256 public tokensAllocatedToCrowdFund; uint256 public totalAllocatedTokens; address public crowdFundAddress; address public founderMultiSigAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier onlyCrowdFundAddress() { require(msg.sender == crowdFundAddress); _; }",1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x40d6ab35c171cddc7fc81187e8a20d6711717ef0.sol,ProofOfBible,contract ProofOfBible { modifier onlyBagholders { require(myTokens() > 0); _; },1
0xb3bbc0cc040413a3e68dcaa8f2b6eac2957c5ce0.sol,BitGuildToken,"contract BitGuildToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitGuildToken() public { balanceOf[msg.sender] = totalSupply; }",1
0xeefb40cd8224c2986f391b62b206c7a018885517.sol,touristoken,"contract touristoken { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 7000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xb3bff5e980da2d46c29833b7a36a26df644ee4cf.sol,PotaosBucks,"contract PotaosBucks is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PotaosBucks() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x63f3e25496282318A356Cd50f7fAdD71E6A6aD25] = _totalSupply; Transfer(address(0), 0x63f3e25496282318A356Cd50f7fAdD71E6A6aD25, _totalSupply); }",1
0xd806f2945baf1243ce1cbfedaa81d65a75655a9c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4cd6e70a33092e2e3aac431c39b3de364042f9f0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,AdviserTimeLock,"contract AdviserTimeLock is Ownable{ SignalsToken token; uint256 withdrawn; uint start; event TokensWithdrawn(address owner, uint amount); function AdviserTimeLock(address _token, address _owner) public{ token = SignalsToken(_token); owner = _owner; start = now; }",1
0xaaba7639c12dba5c518cc753d22c064568dcef54.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0x7c607c86247c8a80376115a924daeeac2e32b47f64217a1d977d0f836c934389; constructor() public { owner = msg.sender; },1
0x31ac1331eed69beefb33aa992989605beac875d2.sol,DeWeiSecurityServiceToken,"contract DeWeiSecurityServiceToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public decimals = 18; string public tokenName; string public tokenSymbol; uint minBalanceForAccounts ; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DeWeiSecurityServiceToken() public { owner = msg.sender; totalSupply = 10000000000000000000000000000; balanceOf[owner]=totalSupply; tokenName=; tokenSymbol=; }",1
0x6c2fa6691b237c9e453926d8d484d4c5ab635db5.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x0dcc6e4f98e734048689a63b824e89b8a58ed591.sol,MDGame,contract MDGame is Owned { using SafeMath for *; struct turnInfos{ string question; string option1name; string option2name; uint endTime; uint option1; uint option2; uint pool; bool feeTake; },1
0xa19118ddbabbf3d538db6a46578f3260e26b89b9.sol,Vault,contract Vault { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x6b6130ed3d3e50db4e550638ab887c53287d41b7.sol,CSNTToken,"contract CSNTToken is StandardToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 1000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x0d1c63e12fde9e5cada3e272576183aba9cfeda2.sol,ZenswapNetworkToken,"contract ZenswapNetworkToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 20000000000000000000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xa212156581b12d6b4f953da0f898af9fb62db72f.sol,MSERToken,"contract MSERToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply,string tokenName,string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c00afe8618feb85095b2c4c3c27441b22db2d12.sol,CNKTToken,"contract CNKTToken is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); function CNKTToken(uint256 initialSupply, string tokenName, string tokenSymbol) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[owner] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1b016ac4de0996b1f59eab9c54a083af496c811d.sol,ScandinavianEKrona,"contract ScandinavianEKrona is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ScandinavianEKrona() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08220b045BDC3d08ed341C0E5afF6D245f6eEBad] = _totalSupply; Transfer(address(0), 0x08220b045BDC3d08ed341C0E5afF6D245f6eEBad, _totalSupply); }",1
0xf35470b6182cbd9a0f0c01d8f491b18445707c7d.sol,ERC827Caller,"contract ERC827Caller { function makeCall(address _target, bytes _data) external payable returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,TOURISTOKEN,"contract TOURISTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 777777777000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xbfba5d637ccb3015ee97cbb27128dc4bebe2bd46.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x7123027d76a5135e66b3a365efaba2b55de18a62.sol,CrypteloERC20,"contract CrypteloERC20 { string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; uint256 public totalSupplyICO; uint256 public totalSupplyPrivateSale; uint256 public totalSupplyTeamTokens; uint256 public totalSupplyExpansionTokens; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Supply(uint256 supply); function CrypteloERC20() public { name = ; symbol = ; decimals = 8; totalSupply = 500000000; totalSupplyICO = 150000000; totalSupplyPrivateSale = 100000000; totalSupplyTeamTokens = 125000000; totalSupplyExpansionTokens = 125000000; address privateW = 0xb3d9c613a4B680A5Ffd28E08258dBd7BA77102A2; address ICOW = 0xF2b3Fc7196D5Ec9bD9111AF5B6D79c9FE26d729F; address companyW = 0xeC23f509E328100C08646389a3b6C45e9290AA42; address expansionW = 0xf799aa9cA15D6137eDAEb204016378112064ECa3; balanceOf[ICOW] = totalSupplyICO * ( 10 ** decimals); balanceOf[privateW] = totalSupplyPrivateSale * ( 10 ** decimals); balanceOf[companyW] = totalSupplyTeamTokens * ( 10 ** decimals); balanceOf[expansionW] = totalSupplyExpansionTokens * ( 10 ** decimals); Supply(totalSupplyICO * ( 10 ** decimals)); }",1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,UGCoin,"contract UGCoin is Multiowned, StandardToken { event Freeze(address from, uint value); event Defreeze(address ownerAddr, address userAddr, uint256 amount); event ReturnToOwner(address ownerAddr, uint amount); event Destroy(address from, uint value); function UGCoin() public Multiowned(){ balances[msg.sender] = initialAmount; totalSupply = initialAmount; }",1
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol,X_wallet,contract X_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8b65236d01ab5274303220d4c78b02ef7685ca757275036fc104f62fbe6e10a7; constructor() public { owner = msg.sender; },1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc518086f77b45498fabdaa93bdbea24393c7fed6.sol,SFCCToken,"contract SFCCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 5000000000 ether; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); }",1
0x38c83b225eb17d44f33f8bb3bdc23d86733838db.sol,try_to_play,contract try_to_play { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xd403cc1e2da3aa7d954e0ad34bef2df2b9a9f238.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0xc654928ecf5f984ef72c806ec9b6e2d213c90818.sol,EDGETVToken,"contract EDGETVToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5276761e4c476f63d5d61f030c3ae53c55fd97cf.sol,DCEP,"contract DCEP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DCEP() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0x868f77e4758776afa2cc2e46ce972e2043ca8e00.sol,YumeGorilla,"contract YumeGorilla { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint public constant totalSupply = 87700000000 * 10 ** decimals; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(0, msg.sender, totalSupply); }",1
0xed26cf773ac74d213668ccfda7de0831a6a5bb96.sol,eIDR,"contract eIDR { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c.sol,onlinewallet,contract onlinewallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf97a7fd2d234ba5f73a38afebd0c6a9db67f7fa4d82fdc062a01244beebafd92; constructor() public { owner = msg.sender; },1
0x37cd86aeb760322a47ee3fb7e27aa6823dc5d973.sol,StarOfDavid,"contract StarOfDavid { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000*10**uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function StarOfDavid() public { balanceOf[msg.sender] = totalSupply; }",1
0x6f4e647f553397dc999382ad3a9c5336c5de27aa.sol,YouCollectBase,"contract YouCollectBase is Owned { using SafeMath for uint256; string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint256 public totalSupply; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function name() public pure returns (string) { return NAME; }",1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,Robincoin,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x419b8ed155180a8c9c64145e76dad49c0a4efb97.sol,ApproveAndCallToken,"contract ApproveAndCallToken is StandardToken { function approveAndCall(address _spender, uint _value, bytes _data) public returns (bool) { TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _data); return true; }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd44dbf7e6aa11b3a9e16890f57eb6a6dc74ee94d.sol,token,"contract token { string public standard = ; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[this] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0xb41e96d68e9016f03480d98663caf02ba15958cc.sol,Silvereum,"contract Silvereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Silvereum() public { symbol = ; name = ; decimals = 7; _totalSupply = 230000000000000000; balances[0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D] = _totalSupply; Transfer(address(0), 0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D, _totalSupply); }",1
0xc317e1a103b5ba8161614c4e69f2bc49165841b3.sol,REALIDVerification,"contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; }",1
0x1d2196207512665ad3beb7c3641f7db409dc7beb.sol,BitcoinBLUE,"contract BitcoinBLUE { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BitcoinBLUE( ) public { totalSupply = 2100000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213.sol,YesManCoin,"contract YesManCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YesManCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88] = _totalSupply; Transfer(address(0), 0x7070Be2B116654C2b67b4e4Edb115F24a2f20E88, _totalSupply); }",1
0x2976ac3d0bb67c6307a73df852c61c14cdda9863.sol,BitcoinNeo,"contract BitcoinNeo is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BitcoinNeo() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000; balances[0x794dcb20e4b48fb1e476d7d5202164d4ce260dff] = _totalSupply; Transfer(address(0), 0x794dcb20e4b48fb1e476d7d5202164d4ce260dff, _totalSupply); }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x3a8a6d2bc23fb68a245250ad34019a65cf057418.sol,DiscountPercentToken,"contract DiscountPercentToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DiscountPercentToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x185480332ee00c4a23422df11e022172dc10d5a9.sol,NausiCoin,"contract NausiCoin is Erc20Token, owned { string public name; string public symbol; uint public decimals; uint _totalSupply; mapping(address => uint) _balanceOf; mapping(address => mapping(address => uint)) _allowance; event Burn(address indexed from, uint amount); event Mint(address indexed from, uint amount); constructor(string tokenName, string tokenSymbol, uint tokenDecimals, uint tokenTotalSupply) public { name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; _totalSupply = tokenTotalSupply * 10**uint(decimals); _balanceOf[msg.sender] = _totalSupply; }",1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,LinkedList,contract LinkedList { struct Element { uint previous; uint next; address data; },1
0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7.sol,GodsOfOlympus,contract GodsOfOlympus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,ECRecovery,None,1
0x1e8dfb1d2a82903807e94e5977dc75d85c7659a0.sol,BeBitcoin,"contract BeBitcoin is ERC20Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BeBitcoin ( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x54e3cd83c6b8f9ba0bab9397e9b7c8a882bcaa1d.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd54920cedf704b87342fa26d5773efabf9037a77.sol,CryptoStars,contract CryptoStars { address owner; string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public initialPrice; uint256 public transferPrice; uint256 public MaxStarIndexAvailable; uint256 public MinStarIndexAvailable; uint public nextStarIndexToAssign = 0; uint public starsRemainingToAssign = 0; uint public numberOfStarsToReserve; uint public numberOfStarsReserved = 0; mapping (uint => address) public starIndexToAddress; mapping (uint => string) public starIndexToSTRZName; mapping (uint => string) public starIndexToSTRZMasterName; mapping (address => uint256) public balanceOf; struct Offer { bool isForSale; uint starIndex; address seller; uint minValue; address onlySellTo; },1
0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74.sol,GIGA,contract GIGA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x70dea95c5e56792a70d357f3e1b2f11e35c4c277.sol,VOCC_I077_20181211,"contract VOCC_I077_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xa3076afebed9558e3c09e7bbb913f611a1547619.sol,Thanatos,"contract Thanatos is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Thanatos() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0x4634B71d85be147421BBF39404f4ABB13303F935] = _totalSupply; Transfer(address(0), 0x4634B71d85be147421BBF39404f4ABB13303F935, _totalSupply); }",1
0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc.sol,Multiplexer,"contract Multiplexer { function sendEth(address[] _to, uint256[] _value) payable returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 255); uint256 beforeValue = msg.value; uint256 afterValue = 0; for (uint8 i = 0; i < _to.length; i++) { afterValue = afterValue + _value[i]; assert(_to[i].send(_value[i])); }",1
0x4c4bcb4ffa0d7eab9287d1df294c8391e3b8096f.sol,PDVBO,"contract PDVBO { bytes32 public name; bytes6 public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDVBO( ) public { totalSupply = 1000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x749f35ff65932e68267dd82f6cd85eea735d700e.sol,CCLToken,"contract CCLToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCLToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 4000000000000000000000000000; balances[0xf835bF0285c99102eaedd684b4401272eF36aF65] = _totalSupply; Transfer(address(0), 0xf835bF0285c99102eaedd684b4401272eF36aF65, _totalSupply); }",1
0xdb7c83df286f5d9c44aec3d128dad6fee05dc6d1.sol,CARDToken,"contract CARDToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CARDToken() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 500000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdeec3ec3d942a50f77d9e4d6912a008a2bede2b3.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd0b4fda55a2390e2dae76f1e6f263a7ee18dbdbb.sol,TVTToken,contract TVTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 160000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TVTToken() { owner = msg.sender; balances[owner] = 160000000 * 10**8; },1
0xeaa9ed293e094084defd04cbced34e3ed4244881.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0249a616e4559f560aa30fa0e79d634603161b3a.sol,medcarednaio,"contract medcarednaio is ERC20Interface, Ownable{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 10000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0x562858eaa3c5af1ae79e33c225aff4e1562f8cce.sol,AntzToken,"contract AntzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public totalSupply; uint public unitsPerTransaction; uint public tokensDistributed; uint public numDistributions; uint public numDistributionsRemaining; address public fundsWallet; address public developersWallet; uint public developersCut; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AntzToken() public { fundsWallet = 0; balances[fundsWallet] = 25000000000000000000000000; totalSupply = 25000000000000000000000000; name = ; decimals = 18; symbol = ; unitsPerTransaction = 500000000000000000000; developersWallet = 0x78061eE39Cd5eDFe1D935168234a3BEEeF9d4b5a; developersCut = safeDiv(totalSupply,10); balances[developersWallet] = safeAdd(balances[developersWallet], developersCut); Transfer(fundsWallet, developersWallet, developersCut); tokensDistributed = developersCut; numDistributionsRemaining = (totalSupply - tokensDistributed) / unitsPerTransaction; numDistributions = 1; }",1
0xf15f61643eea73be40ad9b72c09ed381fac7a256.sol,FishbankBoosters,contract FishbankBoosters is Ownable { struct Booster { address owner; uint32 duration; uint8 boosterType; uint24 raiseValue; uint8 strength; uint32 amount; },1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,WhitelistCrowdsale,"contract WhitelistCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; event WhitelistUpdated(uint256 timestamp, string operation, uint256 totalAddresses); mapping(address => bool) whitelisted; uint256 public whitelistedCount; function isWhitelisted(address _addr) public view returns (bool) { return whitelisted[_addr]; }",1
0x4bf3e4d2378a1256cbe1cd1c2a8bc9857b811282.sol,Databits,"contract Databits is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 5000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Databits(){ balanceOf[msg.sender] = totalSupply; }",1
0x881f21d3e2d2d4f48d815f41bea8dbdcf0e24e50.sol,DepositVault,"contract DepositVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event TransferOwnership(address indexed from, address indexed to); address Owner; function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }",1
0x18835a9009a2a1a1dc1dce33ba7e417f9cee1154.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf375e839fecff22f847eb2df66d440aeb7226916.sol,KTLContract,"contract KTLContract is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 30000000000000000000000000000; bool public stopped; mapping (address => int8) public blackList; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Blacklisted(address indexed target); event DeleteFromBlacklist(address indexed target); event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value); event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value); modifier notStopped { require(!stopped); _; }",1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0xa48813e7aca6ff2e60916e0c6e4433d2d0fb03bf.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb417fa71a03a9badbf962589f2478353fd5693e2.sol,CoinDisplayNetwork,"contract CoinDisplayNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinDisplayNetwork() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd76618b352D0bFC8014Fc44BF31Bd0F947331660] = _totalSupply; Transfer(address(0), 0xd76618b352D0bFC8014Fc44BF31Bd0F947331660, _totalSupply); }",1
0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8.sol,SmartBlockchainPro,contract SmartBlockchainPro { mapping (address => uint256) invested; mapping (address => uint256) atBlock; address public marketingAddr = 0x43bF9E5f8962079B483892ac460dE3675a3Ef802; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 1 / 100 * (block.number - atBlock[msg.sender]) / 5900; address sender = msg.sender; sender.send(amount); },1
0x03200f18368a33906491df56b74cc97986fbdbce.sol,XueBiToken,"contract XueBiToken { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Burn(address indexed from, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function XueBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5890ef4e676cd051e59a348b46e0b3e73601f34d.sol,HIW,"contract HIW { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HIW() { owner = 0x878479357C54d993be99bD332b2649A146da41C0; name = ; symbol = ; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[owner] = 10000000000000000000000000000; }",1
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0x20a35ada16321d18ba2e72bd5fe81bc23515dbd9.sol,ProofOfVerifiedContract,contract ProofOfVerifiedContract { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0.sol,MyToken,"contract MyToken is owned { string public name = ; string public symbol = ; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xc0c45cbb1dce225cf620c36807a1cdecb85feda5.sol,ETHMONEY,"contract ETHMONEY is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETHMONEY() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x295e65915bf0a884dcb225d0b60f95f25626e221.sol,AbyssToken,"contract AbyssToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AbyssToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6] = _totalSupply; Transfer(address(0), 0x5dDD9bb4d5640cE37c76dDac8B3bbD35D84416A6, _totalSupply); }",1
0xf208f8cdf637e49b5e6219fa76b014d49287894f.sol,Gainz,contract Gainz { address owner; constructor () public { owner = msg.sender; },1
0x5544138f866b9a76c7c020719a094c530bac72fe.sol,LuckGameToken,"contract LuckGameToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0x1efa4d569ed37107ffbb94c15d25a32b594bc553.sol,FEMCoin,"contract FEMCoin { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 10000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,SampleStorage,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0x6ce17d826a1c50e97678810954943c83ebd10066.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xbe4411737170e852ea275d235145ceab77e0fe73.sol,VouchCoin,"contract VouchCoin is Ownable, ERC20Interface { using SafeMath for uint; uint public _totalSupply = 10000000000000000; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; string public standard = ; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowances; event Burn(address indexed _from, uint _value); function VouchCoin() public { balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x48de9c6454d9da324d7908a6472ca4fb77a3e4fd.sol,LC,"contract LC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3a6e5f1c1b0de5d2b46babd21c7844c96f5180aa.sol,SniperBillion,contract SniperBillion is modularBillion { using SafeMath for *; using Array256Lib for uint256[]; address constant private comReward_ = 0x8Aa94D530cC572aF0C730147E1ab76875F25f71C; address constant private comMarket_ = 0x6c14CAAc549d7411faE4e201105B4D33afb8a3db; address constant private comICO_ = 0xbAdb636C5C3665a969159a6b993F811D9F263639; address constant private donateAccount_ = 0x1bB064708eBf4763BeB495877E99Dfeb75198942; RubyFundForwarderInterface constant private Ruby_Fund = RubyFundForwarderInterface(0x7D653E0Ecb4DAF3166a49525Df04147a7180B051); SniperBookInterface constant private SniperBook = SniperBookInterface(0xc294FA45F713B09d865A088543765800F47514eD); string constant public name = ; string constant public symbol = ; uint256 constant private icoEndTime_ = 24 hours; uint256 constant private maxNumber_ = 100000000; uint256 public totalSum_; uint256 public rID_; uint256 public icoAmount_; bool private isDrawed_ = false; uint256 lastSID_; uint256[] private globalArr_; uint256[] private icoSidArr_; uint256[] private luckyPotBingoArr_; uint256[] private airdropPotBingoArr_; mapping (address => uint256) public sIDxAddr_; mapping (bytes32 => uint256) public sIDxName_; mapping (uint256 => uint256) public sidXnum_; mapping (uint256 => SPBdatasets.Sniper) public spr_; mapping (uint256 => SPBdatasets.Round) public round_; mapping (uint256 => mapping (bytes32 => bool)) public sprNames_; constructor() public { },1
0x6f3b2f2100875409c5c011bc3bb97ea6e0f671db.sol,ToknTalkToken,"contract ToknTalkToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; address public mintSigner = msg.sender; string public constant name = ""https: string public constant symbol = ; uint public constant decimals = 0; uint public totalSupply = 0; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public mintedBy; function transfer(address to, uint amount) external returns (bool) { require(to != address(this)); require(to != 0); uint balanceOfMsgSender = balanceOf[msg.sender]; require(balanceOfMsgSender >= amount); balanceOf[msg.sender] = balanceOfMsgSender - amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; }",1
0x0f598112679b78e17a4a9febc83703710d33489c.sol,MoneroGold,contract MoneroGold { string public name = ; string public symbol = ; uint256 public decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 21000000 * (10**decimals); address public owner; modifier isOwner { assert(owner == msg.sender); _; },1
0x0d2dea6d6d6780860431e7c8b0cce6db4ca49a41.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e850bf8607a37e84a489008eeb94fb19331b061.sol,FastEth,contract FastEth { address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35; address constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03; address constant private CASHBACK = 0x33cA4CbC4b171c32C16c92AFf9feE487937475F8; address constant private PRIZE = 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653; uint constant public PERCENT = 4; uint constant public BONUS_PERCENT = 5; uint constant StartEpoc = 1541354370; struct Deposit { address depositor; uint deposit; uint payout; },1
0x5a8dee1f2c6894b96422a536620e389da1f84641.sol,PO24,contract PO24 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x1db55af386e67e3ed55426cd3b84c8441720ebae.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf2baec4108306dc87e117d98912d5adac4f15ed9.sol,InfiniteGold,contract InfiniteGold { string public name = ; string public symbol = ; uint256 public decimals = 2; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; address[] addresses; uint[] values; uint256 public totalSupply = 13400000; bool public stopped = false; uint256 constant valueFounder = 13400000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xcd6f276334fd457d79fc04bca5f52393347c47a7.sol,ChessClubLiveChessCoin,"contract ChessClubLiveChessCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ChessClubLiveChessCoin() public { symbol = ; name = ; decimals = 64; _totalSupply = 640000000000000000000000000000000000000000000000000000000000000000; balances[0x04Ede35B1D51c0e814833887b2DdBB5D553070b6] = _totalSupply; Transfer(address(0), 0x04Ede35B1D51c0e814833887b2DdBB5D553070b6, _totalSupply); }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdfc5dce1a27e6110107817a352ebe4dd9dc6b157.sol,BeerCash,"contract BeerCash { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BeerCash( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf07d979303c50a8632848cb154c6b30980218c07.sol,PXLProperty,contract PXLProperty is StandardToken { uint8 constant LEVEL_1_MODERATOR = 1; uint8 constant LEVEL_2_MODERATOR = 2; uint8 constant LEVEL_1_ADMIN = 3; uint8 constant LEVEL_2_ADMIN = 4; uint8 constant LEVEL_1_ROOT = 5; uint8 constant LEVEL_2_ROOT = 6; uint8 constant LEVEL_3_ROOT = 7; uint8 constant LEVEL_PROPERTY_DAPPS = 8; uint8 constant LEVEL_PIXEL_PROPERTY = 9; uint8 constant FLAG_NSFW = 1; uint8 constant FLAG_BAN = 2; address pixelPropertyContract; mapping (address => uint8) public regulators; mapping (uint16 => Property) public properties; mapping (address => uint256[2]) public ownerWebsite; mapping (address => uint256[2]) public ownerHoverText; struct Property { uint8 flag; bool isInPrivateMode; address owner; address lastUpdater; uint256[5] colors; uint256 salePrice; uint256 lastUpdate; uint256 becomePublic; uint256 earnUntil; },1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5c88e93b5feae72f0fbe787c7f1b96ce3f29ee6a.sol,BWW_ERC20,"contract BWW_ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000000; uint256 public TokenPerKRWBuy = 4; mapping(bytes32 => bool) transactionHashes; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0x2cbf103901196f99619f2bf9accdf079e9c76819.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, SMUToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) SMUToken(initialSupply, tokenName, tokenSymbol) public {}",1
0xa13034912eca36ddb8a0b62bc86251006d8296d6.sol,LightAirdrop,contract LightAirdrop is OwnableContract{ function LightAirdrop() public { },1
0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f.sol,token123,contract token123 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token123() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x483b2942b24681c258bc5b63cd0921e6c5ea997a.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ed98637002026cf9b6c70b7018f229f9d02391e.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=1300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x74b920485c31f07b2df06f326b465565af6f69e4.sol,DrakeCoin,"contract DrakeCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, uint8 initialDecimals, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, initialDecimals, tokenName, tokenSymbol) public {}",1
0x347d11b17022f0f636dda2492f980cc60117d3f7.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() internal { balanceOf[msg.sender] = totalSupply; }",1
0x4d48ee87ab535833fdd79c7d1c4aac3c7c304b13.sol,Pomda,contract Pomda { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x92f6096a93a6ebb6bc439831a7f30f1e6020f184.sol,ROPE,"contract ROPE{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; bool public transferrable = true; address public contract2Address; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROPE( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xe1e83a85c9db1bbd7cfab3e6bffaf255c5013adb.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address _target, bytes _data) external payable onlyOwner returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x46a0fb6c0f540e825889f4b82005afef43d2cd71.sol,ArchiveCreation,contract ArchiveCreation { struct Archive { string projectNameToken; },1
0x8370b2d10956b9fa1db7faf14bac188a367fe7df.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x32a44d9d49a05f9049cd7f8eb0e3d19c90dd2421.sol,DragonDistributions,contract DragonDistributions { address public dragon; uint256 public clock; address public prime; address public film; address public northadvisor; address public southadvisor; uint public filmamount; bool public filmpaid; mapping ( address => uint256 ) public balanceOf; mapping ( address => bool ) public distributionOne; mapping ( address => bool ) public distributionTwo; mapping ( address => bool ) public distributionThree; mapping ( address => bool ) public advisors; uint256 public awardAmount = 45000000000000; uint256 public awardAmountPrime = 100000000000000; function DragonDistributions () { dragon = 0x814F67fA286f7572B041D041b1D99b432c9155Ee; prime = 0x243098c1e16973c7e3e969c289c5b87808e359c1; film = 0xdFCf69C8FeD25F5150Db719BAd4EfAb64F628d31; northadvisor = 0x74Fc8fA4F99b6c19C250E4Fc6952051a95F6060D; southadvisor = 0xCC3c6A89B5b8a054f21bCEff58B6429447cd8e5E; clock = now; filmamount = 2500000000000; balanceOf[ film ] = awardAmount + filmamount; balanceOf[ northadvisor ] = awardAmount; balanceOf[ southadvisor ] = awardAmount; balanceOf[ prime ] = awardAmountPrime; advisors [ film ] = true; advisors [ northadvisor ] = true; advisors [ southadvisor ] = true; filmpaid = false; },1
0xb8c6107f66152fa908111e2963878ad04c89b125.sol,EENX,"contract EENX is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function EENX( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0xc01b78e62a4d1fdce58d364193ee1218832919fd.sol,SatoshiTeamToken,"contract SatoshiTeamToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 21000000 * 1 ether; address mainAdd = address (this); function SatoshiTeamToken() { totalSupply = INITIAL_SUPPLY; balances[mainAdd] = INITIAL_SUPPLY; }",1
0x25e0c624f3f8239ac3932699dc6c2551facbf714.sol,CryptoMinerTokenFork,contract CryptoMinerTokenFork { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x2a287b4ebe1efb6b37ad1ed3141f0db1a1c51c99.sol,STS,"contract STS is Token { string public name; uint8 public decimals; string public symbol; function STS(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xf438e3a0c1bb9dc0ef6da672c97a282236d3f233.sol,HyperToken,"contract HyperToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HyperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x106B0Ab1922d0a8a44454d743A68EF936cc2F563] = _totalSupply; Transfer(address(0), 0x106B0Ab1922d0a8a44454d743A68EF936cc2F563, _totalSupply); }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x556241b90b4c55457a31e27eb612bdc11815d989.sol,NemixToken,"contract NemixToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NemixToken() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xeccab39acb2caf9adba72c1cb92fdc106b993e0b.sol,AzbitToken,"contract AzbitToken is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public releaseDate = 1546300800; uint256 public constant MIN_RELEASE_DATE = 1546300800; uint256 public constant MAX_RELEASE_DATE = 1559260800; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public whiteList; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37ceaf9e7748c707934edea028812c7fdaf93866.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x8c211128f8d232935afd80543e442f894a4355b7.sol,SNcoin_Token,"contract SNcoin_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint private constant _totalSupply = 100000000 * 10**uint(decimals); mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; struct LimitedBalance { uint8 limitType; uint initial; }",1
0x184b8e35fea87e75498705ea96f2326db8ee2470.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; constructor(address _tokenAddress) public { tokenInstance = Token(_tokenAddress); },1
0x7998b7fcf30d4aed870635155cc62aa55be96f9a.sol,generic_holder,contract generic_holder { address owner; modifier onlyowner { if (owner == msg.sender) _; },1
0x5b1d807e3202de4608a59ee93f98ef75c716236c.sol,Investors,"contract Investors is Ownable { address[] public investors; mapping (address => uint) public investorPercentages; function addInvestors(address[] _investors, uint[] _investorPercentages) onlyOwner public { for (uint i = 0; i < _investors.length; i++) { investors.push(_investors[i]); investorPercentages[_investors[i]] = _investorPercentages[i]; }",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,CraigHester,"contract CraigHester is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; deposit(); }",1
0xf18b97b312ef48c5d2b5c21c739d499b7c65cf96.sol,TBEToken,"contract TBEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TBEToken() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x52d208f3ff79985b5a50a55fd35334f924a9f643.sol,OSSCardToken,"contract OSSCardToken is ERC721 { event Birth(uint256 tokenId, string slug, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address owner, string slug); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.0001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public cardIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public cardIndexToApproved; mapping (uint256 => uint256) private cardIndexToPrice; address public ceoAddress; address public cooAddress; struct Card { string slug; }",1
0x361cef27a967e3fa2d8fc117b3f2cfe2a09bbc02.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol,WhaleGiveaway1,contract WhaleGiveaway1 { address public Owner = msg.sender; uint constant public minEligibility = 0.999001 ether; function() public payable { },1
0x0db8d8b76bc361bacbb72e2c491e06085a97ab31.sol,iQeon,"contract iQeon is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function iQeon( ) public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6c3be406174349cfa4501654313d97e6a31072e1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x286e1b439e616b06f55f801fbcc5f0747e3d9645.sol,XRUN,"contract XRUN is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xdf329603bd378021698f9833cd5205b52f9e370e.sol,Ethershift,"contract Ethershift is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Ethershift() public { symbol = ; name = ; decimals = 18; _totalSupply = 15000000000000000000000000; balances[0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302] = _totalSupply; Transfer(address(0), 0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302, _totalSupply); }",1
0xef68e7c694f40c8202821edf525de3782458639f.sol,LoopringToken,"contract LoopringToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 16, 14, 12, 10, 8, 6, 4, 2, 0 ]; uint public constant NUM_OF_PHASE = 10; uint16 public constant BLOCKS_PER_PHASE = 15250; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 50000 ether; uint256 public constant HARD_CAP = 120000 ether; uint public constant MAX_UNSOLD_RATIO = 675; uint256 public constant BASE_RATE = 5000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0xce5dbd884305a5716460dccffa63888fc9bfaa72.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x868822b816bf0292a0c46d89a51b019113537325.sol,MOROCCO_WINS,"contract MOROCCO_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x553b4546d26f383d4f4a056b7f50dadff07fb252.sol,Timed,contract Timed { uint256 public startTime; uint256 public endTime; uint256 public avarageBlockTime; function isInTime() constant returns (bool inTime) { return block.timestamp >= (startTime - avarageBlockTime) && !isTimeExpired(); },1
0x263c618480dbe35c300d8d5ecda19bbb986acaed.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xafaeb51b058999a84354f5e45b44a1649519bcff.sol,MMCoin,"contract MMCoin is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MMCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x6c21aa45fdf7175f2d87a07726e7f198b952866c.sol,StandardToken,"contract StandardToken is Token { using SafeMath for uint; function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x757df3c3cad364da4bbe0795f1fea5cb7e91774e.sol,Robincoin,"contract RobincoinERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function RobincoinERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x69e1e36d795f72fe02638d749bffe2af2f64a20e.sol,GHK,"contract GHK{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function GHK() public { balances[msg.sender] = 3600000000000; totalSupply = 3600000000000; name = ; decimals =4; symbol = ; }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0x64bfbfa5aedd9622f627e3ddeadb634eb96a6fed.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5.sol,LexitToken,"contract LexitToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LexitToken() TokenERC20() public { }",1
0xa4ef5964f146d2526c51fc40caa244e45edce136.sol,ELECTRONICPLATINUM,contract ELECTRONICPLATINUM is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; function ELECTRONICPLATINUM( ) { balances[msg.sender] = 2000000000000000; totalSupply = 2000000000000000; name = ; decimals = 8; symbol = ; },1
0x33286518eff61b810b9796cf847d84be65160147.sol,XCAToken,"contract XCAToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function XCAToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaa70bc3e835e12d6902a8e4da77db4842e519c42.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5.sol,LexitToken,"contract LexitToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LexitToken() TokenERC20() public { }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5b36ca95ed4145a608b9f474f81f3c345dc6599f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5b60ad56ec892e83ee61c61022c341b9b0ef7168.sol,Firechain,"contract Firechain { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Firechain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,SupplySchedule,contract SupplySchedule is Owned { using SafeMath for uint; using SafeDecimalMath for uint; struct ScheduleData { uint totalSupply; uint startPeriod; uint endPeriod; uint totalSupplyMinted; },1
0xf1a3dc9de80f17a22b43acecaae62f5480063111.sol,FreezableToken,"contract FreezableToken is StandardToken { mapping (address => uint64) internal roots; mapping (bytes32 => uint64) internal chains; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function getFreezingSummaryOf(address _addr) public constant returns (uint tokenAmount, uint freezingCount) { uint count; uint total; uint64 release = roots[_addr]; while (release != 0) { count ++; total += balanceOf(address(keccak256(toKey(_addr, release)))); release = chains[toKey(_addr, release)]; }",1
0x544a1abc3c932847fd1049ee55e0d0e1eeb3dc80.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc5fdada86ba48ae58214a1d6bac3c0207862ffd0302738847798a4843e4cc242; constructor() public { owner = msg.sender; },1
0x2958ff9b325135374605b4e6987140a53394c6a6.sol,WNCT,"contract WNCT { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WNCT() public { balances[msg.sender] = 100000000000000; totalSupply = 100000000000000; name = ; decimals =4; symbol = ; }",1
0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8.sol,CHAD,"contract CHAD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CHAD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x8F210dbB8FADa47bc090d7923E935267BF53160D] = _totalSupply; Transfer(address(0), 0x8F210dbB8FADa47bc090d7923E935267BF53160D, _totalSupply); }",1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0x0404ecdc2f2db455a263507863073ec3d725f8ba.sol,token,"contract token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,Reputation,contract Reputation { address owner; mapping(address => bool) whitelist; mapping(address => int) ratings; constructor () public { owner = msg.sender; },1
0xf336496011891a6f905cde1242285e9953c94d0b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72c17126e2ff24b5d76a75ed4b3f031c70b05eac.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0xc094d10e8c0f5f507bb986f01b0c44a83cbf8440.sol,Crowdsale,"contract Crowdsale is Ownable, RateSetter { using SafeMath for uint256; ERC20 public token; CCWhitelist public whitelist; uint256 public startTimePre; uint256 public endTimePre; uint256 public startTimeIco; uint256 public endTimeIco; address public wallet; uint32 public ethEurRate; uint32 public btcEthRate; uint256 public tokensSoldPre; uint256 public tokensSoldIco; uint256 public weiRaised; uint256 public eurRaised; uint256 public contributions; uint256 public preCap; uint8 public preDiscountPercentage; uint256 public icoPhaseAmount1; uint256 public icoPhaseAmount2; uint256 public icoPhaseAmount3; uint256 public icoPhaseAmount4; uint8 public icoPhaseDiscountPercentage1; uint8 public icoPhaseDiscountPercentage2; uint8 public icoPhaseDiscountPercentage3; uint8 public icoPhaseDiscountPercentage4; uint32 public HARD_CAP_EUR = 19170000; uint32 public SOFT_CAP_EUR = 2000000; uint256 public HARD_CAP_IN_TOKENS = 810 * 10**24; mapping (address => uint) public contributors; function Crowdsale(uint256 _startTimePre, uint256 _endTimePre, uint256 _startTimeIco, uint256 _endTimeIco, uint32 _ethEurRate, uint32 _btcEthRate, address _wallet, address _tokenAddress, address _whitelistAddress) { require(_startTimePre >= now); require(_endTimePre >= _startTimePre); require(_startTimeIco >= _endTimePre); require(_endTimeIco >= _startTimeIco); require(_ethEurRate > 0 && _btcEthRate > 0); require(_wallet != address(0)); require(_tokenAddress != address(0)); require(_whitelistAddress != address(0)); startTimePre = _startTimePre; endTimePre = _endTimePre; startTimeIco = _startTimeIco; endTimeIco = _endTimeIco; ethEurRate = _ethEurRate; btcEthRate = _btcEthRate; wallet = _wallet; token = ERC20(_tokenAddress); whitelist = CCWhitelist(_whitelistAddress); preCap = 90 * 10**24; preDiscountPercentage = 50; icoPhaseAmount1 = 135 * 10**24; icoPhaseAmount2 = 450 * 10**24; icoPhaseAmount3 = 135 * 10**24; icoPhaseAmount4 = 90 * 10**24; icoPhaseDiscountPercentage1 = 40; icoPhaseDiscountPercentage2 = 30; icoPhaseDiscountPercentage3 = 20; icoPhaseDiscountPercentage4 = 0; }",1
0x41dc0d29ea75f603ad725b6b26fba39a477ac796.sol,AXNETToken,"contract AXNETToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AXNETToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 3000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f.sol,Hourglass,contract Hourglass { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x2898ca01df2dc4062e8b269806de4996295a1f5c.sol,BlockBase,"contract BlockBase{ event Transfer(address from, address to, uint256 tokenId); event Birth(address owner, uint256 blockId, uint256 width, uint256 height, string position, uint16 genes); struct Block { uint256 width; uint256 heigth; string position; uint16 generation; }",1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcd7067332044bba6c7055677a14e25702e1f5af8.sol,PROSH,"contract PROSH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PROSH() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000000000000000000; balances[0x02DEA85397EF756307F9751693872d54d0B75A2c] = _totalSupply; Transfer(address(0), 0x02DEA85397EF756307F9751693872d54d0B75A2c, _totalSupply); }",1
0xd0bd12a8d5ebca1e2fa46da59f1993ec51c3d75c.sol,BKToken,"contract BKToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 3*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BKToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xf242930a8ca9e9dce8ce1e4be1bc7fe49ed41283.sol,Erc20_RacL,"contract Erc20_RacL is Owned { uint public totalSupply; string public name; string public symbol; uint8 public decimals = 18; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowence; event Transfer(address indexed _from, address indexed _to, uint tokens); event Approval(address indexed _tokenOwner, address indexed _spender, uint tokens); event Burn (address indexed from, uint256 value); constructor(string tokenName, string tokenSymbol, uint initialSupply) public { totalSupply = initialSupply*10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5438b0938fb88a979032f45b87d2d1aeffe5cc28.sol,Gifto,contract Gifto is ERC20Interface { uint public constant decimals = 5; string public constant symbol = ; string public constant name = ; bool public _selling = false; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; address public owner; mapping(address => uint256) balances; mapping(address => bool) approvedInvestorList; mapping(address => uint256) deposit; address[] buyers; uint _icoPercent = 10; uint public _icoSupply = _totalSupply * _icoPercent / 100; uint public _minimumBuy = 10 ** 17; uint public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xf49cdd50ad408d387d611f88a647179c3de3492b.sol,StandardToken,"contract StandardToken is ERC20, ERC223 { using SafeMath for uint; string public name; string public symbol; uint8 public decimals; uint public totalSupply; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; function StandardToken(string _name, string _symbol, uint8 _decimals, uint _totalSupply, address _admin) public { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply * 10 ** uint(_decimals); balances[_admin] = totalSupply; }",1
0x58002a6b6e659a16de9f02f529b10536e307b0d9.sol,CHFT,"contract CHFT is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x5375bD481a1442694893eDA7d47FcEb04e8776fD] = _totalSupply; emit Transfer(address(0), 0x5375bD481a1442694893eDA7d47FcEb04e8776fD, _totalSupply); }",1
0x27ba530d3d4bfd98a31eb7c9512e1ce502c990b6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f561670d669a91607f53cbe114226f5c7e8d99d.sol,EstateParticipationUnit,"contract EstateParticipationUnit { using SafeMath for uint256; enum VoteType { NONE, ALLOW_TRANSFER, CHANGE_ADMIN_WALLET, CHANGE_BUY_SELL_LIMITS, CHANGE_BUY_SELL_PRICE, SEND_WEI_FROM_EXCHANGE, SEND_WEI_FROM_PAYMENT, TRANSFER_EXCHANGE_WEI_TO_PAYMENT, START_PAYMENT }",1
0x8432a5a61cf1cc5ca5bc5ab919d0665427fb513c.sol,IcoToken,"contract IcoToken is SafeMath, StandardToken, Pausable { string public name; string public symbol; uint256 public decimals; string public version; address public icoContract; constructor( string _name, string _symbol, uint256 _decimals, string _version ) public { name = _name; symbol = _symbol; decimals = _decimals; version = _version; }",1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0x8a63a921b5d678b4a27dc81e44321923e297b4cf.sol,Doves,"contract Doves is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Doves() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDf4943c61042919Bd45312d033Bd697A1E0A6397] = _totalSupply; Transfer(address(0), 0xDf4943c61042919Bd45312d033Bd697A1E0A6397, _totalSupply); }",1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x544a1abc3c932847fd1049ee55e0d0e1eeb3dc80.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc5fdada86ba48ae58214a1d6bac3c0207862ffd0302738847798a4843e4cc242; constructor() public { owner = msg.sender; },1
0x29670620d09563868de0c0597d416ff3a23b8606.sol,ChinaInvestmentToken,"contract ChinaInvestmentToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function ChinaInvestmentToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2029fdb81d226e0e45a620c47314b3ab1f78bf46.sol,XToken,contract XToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6.sol,PlayerBook,contract PlayerBook { using NameFilter for string; using SafeMath for uint256; address private admin = msg.sender; uint256 public registrationFee_ = 10 finney; mapping(uint256 => PlayerBookReceiverInterface) public games_; mapping(address => bytes32) public gameNames_; mapping(address => uint256) public gameIDs_; uint256 public gID_; uint256 public pID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Player) public plyr_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; struct Player { address addr; bytes32 name; uint256 laff; uint256 names; },1
0x8c3cd81e8987e44b8d8702ed6d5791b346d0e1e5.sol,CryptoMemes,"contract CryptoMemes is ERC721 { event Transfer(address from, address to, uint256 tokenId); event Created(address owner, uint256 tokenId, string url, uint256 hash, uint256 createdAt); event UrlUpdated(address owner, uint256 tokenId, string url); modifier onlyOwnerOf(uint256 tokenId) { require(memeIndexToOwner[tokenId] == msg.sender); _; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,ProperProposal,"contract ProperProposal is ProposalInterface, TokenRescue { struct Argument { address source; uint8 position; uint256 count; }",1
0x70673d36178f17ac064747c7bdd026240be194b5.sol,UNIQ,"contract UNIQ { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function UNIQ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed29ff5874fa64dcf47ed7dacb770857a5d164fb.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function initVault() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0xa25d9e3c177a45265349d4bd37b23ec2669dea5b.sol,BMVCoin,"contract BMVCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BMVCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0f09c5922a47b0b9100c1d56ada4bf7a9f3a72d4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x405d44c9ed3d2d80e375b2360ed0713b71c6b811.sol,Criplos,"contract Criplos { event Transfer(address indexed from, address indexed to, uint tokens); using SafeMath for uint; using ToAddress for bytes; string constant public symbol = ; string constant public name = ; uint8 constant public decimals = 18; address owner; address public advance; address[] recordAccts; uint public priceTokens; uint public minMining; uint public minRemining; uint public minWithdraw; uint public minTransfer; uint totalTokens_; uint totalMining_; uint totalMiners_; uint techBuff_; struct Record { uint balance; uint volume; uint level; address master; }",1
0x189b9c623570b30e178289740b9cdb5589094424.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x6cd3cbfa29ebb63e84132ad7b1a10407aba30acd.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x267398927b5886df921b235afe9dbbe47fbcc37d.sol,NobarToken,"contract NobarToken { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NobarToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x72ba699f0f3c29d0f886c264ec7350533a32b3d5.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xbc9e2998e284540e21b28e5c2358be7291059e97.sol,OSECOIN,"contract OSECOINToken { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xbcdbb16c645816842b6ae7ebea8baa4b35203e73.sol,NetkillerCashier,contract NetkillerCashier{ address public owner; uint public amount; uint public amounteth; modifier onlyOwner { require(msg.sender == owner); _; },1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,WhitelistCrowdsale,"contract WhitelistCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; event WhitelistUpdated(uint256 timestamp, string operation, uint256 totalAddresses); mapping(address => bool) whitelisted; uint256 public whitelistedCount; function isWhitelisted(address _addr) public view returns (bool) { return whitelisted[_addr]; }",1
0x12b470a5c9055d312e1af0259b65976dce608e5d.sol,Lighthouse,"contract Lighthouse { address public auth = msg.sender; Searcher seeker; uint value; uint maxAge; modifier onlyAuth { require(auth == msg.sender, ); _; }",1
0xbc9e2998e284540e21b28e5c2358be7291059e97.sol,OSECOIN,"contract OSECOINToken { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x40f4991411ac5377675c421e87378e10470134a3.sol,Token,"contract Token is ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public tokenCap = 12500000e18; address public walletAddress; uint256 public creationTime; bool public transferStop; mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); event EmergencyStopActivated(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; }",1
0x6dc2b0014e1974d7606de09b87969f34bd336252.sol,VOCC_I023_20181211,"contract VOCC_I023_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5335ef421f90bac4605908bc3a0f493a4e9119e8.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0cfda67b0067f1a99deb1cb80e0273a3f26d317c.sol,SafeMath,None,1
0x4803ead7b2996353373e82f501e1a23a2f892d19.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa580853c469fa5edaaf59acc69ef0cacde325af5.sol,WtaERC20,"contract WtaERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x704079e823e42a936bbaac5163434c2515473836.sol,CONUNDRUM,"contract CONUNDRUM { string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; }",1
0x5cb888182fbffdb62c08fb4b5a343914f00fdfee.sol,MoneybrainBips,"contract MoneybrainBips is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x3a783e99e5a5618b8149e3380d14328139d97e31.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xed2192afa8c062dfd6883759380b7f2d1dc6c0c0.sol,WedIndex,contract WedIndex is Owned { string public wedaddress; string public partnernames; uint public indexdate; uint public weddingdate; uint public displaymultisig; IndexArray[] public indexarray; struct IndexArray { uint indexdate; string wedaddress; string partnernames; uint weddingdate; uint displaymultisig; },1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x92e55c6ee3171779174cebb27211120b730c155c.sol,SantimentWhiteList,contract SantimentWhiteList { string constant public VERSION = ; function () { throw; },1
0x18cabd1e7db6c52406719cb72859ea2c2eea75d6.sol,GoGuides,"contract GoGuides { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GoGuides( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0xc0d766017141dd4866738c1e704be6fedc97b904.sol,TreeToken,"contract TreeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TreeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x68A924EA85c96e74A05cf12465cB53702a560811] = _totalSupply; Transfer(address(0), 0x68A924EA85c96e74A05cf12465cB53702a560811, _totalSupply); }",1
0x326ce88b27c196d0387f5df7ae085c1203185cb4.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,LogFile,contract LogFile { struct Message { address Sender; string Data; uint Val; uint Time; },1
0x88c46a325254d19f12403643e12356c1a195c88b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2736d225f85740f42d17987100dc8d58e9e16252.sol,ServerRegistry,"contract ServerRegistry { event LogServerRegistered(string url, uint props, address owner, uint deposit); event LogServerUnregisterRequested(string url, address owner, address caller); event LogServerUnregisterCanceled(string url, address owner); event LogServerConvicted(string url, address owner); event LogServerRemoved(string url, address owner); struct In3Server { string url; address owner; uint deposit; uint props; uint128 unregisterTime; uint128 unregisterDeposit; address unregisterCaller; }",1
0x466c44812835f57b736ef9f63582b8a6693a14d0.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x1caecd601911d84941fddc74f94a871e15d24299.sol,JAPAN_WINS,"contract JAPAN_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 3499836512134110000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x00a8671dee8a84262945bb163036265901293789.sol,COSTA_RICA_WINS,"contract COSTA_RICA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 5206357752953970000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28bd55152293595c65652f175c1e8fa95d10be93.sol,NandoCoin,"contract NandoCoin { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( string tokenName, string tokenSymbol ) public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,RDFDM,"contract RDFDM { event FiatCollectedEvent(uint indexed charity, uint usd, string ref); event FiatToEthEvent(uint indexed charity, uint usd, uint eth); event EthToFiatEvent(uint indexed charity, uint eth, uint usd); event FiatDeliveredEvent(uint indexed charity, uint usd, string ref); event EthDonationEvent(uint indexed charity, uint eth); event CharityAddedEvent(uint indexed charity, string name, uint8 currency); event CharityModifiedEvent(uint indexed charity, string name, uint8 currency); uint constant CURRENCY_USD = 0x01; uint constant CURRENCY_EURO = 0x02; uint constant CURRENCY_NIS = 0x03; uint constant CURRENCY_YUAN = 0x04; struct Charity { uint fiatBalanceIn; uint fiatBalanceOut; uint fiatCollected; uint fiatDelivered; uint ethDonated; uint ethCredited; uint ethBalance; uint fiatToEthPriceAccEth; uint fiatToEthPriceAccFiat; uint ethToFiatPriceAccEth; uint ethToFiatPriceAccFiat; uint8 currency; string name; }",1
0xd83a825384a252f57b1ef7d617518f2099ac8eb5.sol,BteApplication,"contract BteApplication is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BteApplication() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000; balances[0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82] = _totalSupply; Transfer(address(0), 0xe0a7c0B6d307DD7a3123aa39f927417dda9b2b82, _totalSupply); }",1
0x421a0ee46dbfee7f65076c7e0c32fa86918bf62d.sol,BBX,"contract BBX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BBX( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x322909bb3aa921f101d829c0edf57493468d9bd4.sol,Guestbook,contract Guestbook { struct Entry{ address owner; string alias; uint timestamp; uint donation; string message; },1
0xd294fb1b8b1169dc634017f60d9ca36a5701bd7d.sol,TokenBCCO,"contract TokenBCCO { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenBCCO( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xce038523e278b6c1344d9e4f735f6064ad7a6032.sol,TokenSwap,"contract TokenSwap is Ownable { HumanStandardToken public ndc; HumanStandardToken public tpt; address public neverdieSigner; uint256 public minSwapAmount = 40; event Swap( address indexed to, address indexed PTaddress, uint256 rate, uint256 amount, uint256 ptAmount ); event BuyNDC( address indexed to, uint256 NDCprice, uint256 value, uint256 amount ); event BuyTPT( address indexed to, uint256 TPTprice, uint256 value, uint256 amount ); function TokenSwap(address _teleportContractAddress, address _neverdieContractAddress, address _signer) public { tpt = HumanStandardToken(_teleportContractAddress); ndc = HumanStandardToken(_neverdieContractAddress); neverdieSigner = _signer; }",1
0x28f379afad653336d200eec34be7558be455fa5d.sol,AIWEBToken,"contract AIWEBToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AIWEBToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 1 weeks; _totalSupply = 100000000000 * 10**uint(decimals); balances[0x669fcb22f157dba043118e3a452b860d74208562] = _totalSupply; Transfer(address(0), 0x669fcb22f157dba043118e3a452b860d74208562, _totalSupply); }",1
0xd083713e4d9bc1e4c923795f9f6ce2a97646c116.sol,ItemList,None,1
0xdf1b1b23f34de198a6881880b345419b59ca38d0.sol,ANY,"contract ANY is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ANY() public { symbol = ; name = ; decimals = 8; bonusEnds = now + 13 weeks; endDate = now + 49 weeks; }",1
0x5c0f734916b17c38674ed5867eda22f8314672ec.sol,ethernity,contract ethernity { address pr = 0xB85B67e48cD9edF95A6e95134Ee461e89E7B0928; address ths = this; mapping (address => uint) balance; mapping (address => uint) paytime; mapping (address => uint) prtime; function() external payable { if((block.number-prtime[pr]) >= 5900){ pr.transfer(ths.balance/100); prtime[pr] = block.number; },1
0x217ada135253d6152d9c8903c3fece94b68f10d8.sol,AGG,"contract AGG is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AGG() public { symbol = ; name = ; decimals = 18; _totalSupply = 1.98 * 10000 * 10000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x4b43d8a35257f42a2d0d4d774409208efc31b406.sol,Project512Foundation,"contract Project512Foundation { string public name = ; string public symbol = ; uint8 public decimals = 2; uint256 public initialSupply = 125000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Project512Foundation () public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0xc79d1b9d77dcf62add2f90c827e87e29d5934d37.sol,SevenTreasureGold,"contract SevenTreasureGold { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x480b94c1c794299157765988746cd97bea20a9b9.sol,TasnimCoin,"contract TasnimCoin { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x91f5f7fa8c7030f4d1ce841142386ebed7589ced.sol,EVERBIT,"contract EVERBIT { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a.sol,qui_qz,contract qui_qz { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x2c7d9a0416d00ff65bd851e8fc3badb1607db582.sol,ForintBudapest,contract ForintBudapest is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function ForintBudapest() { balances[msg.sender] = 99999999999999999999999999999; totalSupply = 99999999999999999999999999999; name = ; decimals = 2; symbol = ; unitsOneEthCanBuy = 10; fundsWallet = msg.sender; },1
0x34ddcc255d2f3f2e2d85a2a11e314670e73b24d4.sol,lottrygame,"contract lottrygame{ uint256 public people; uint numbers; uint256 public tickamount = 100; uint256 public winnergetETH1 = 0.05 ether; uint256 public winnergetETH2 = 0.03 ether; uint256 public winnergetETH3 = 0.02 ether; uint public gamecount = 0; uint public inputsbt = 100; uint black=1; uint red=2; uint yellow=3; address[] public tickplayers; address public owner; address tokenAddress = 0x503F9794d6A6bB0Df8FBb19a2b3e2Aeab35339Ad; address poolwallet; bool public tickgamelock = true; bool public full = true; event tickwinner(uint,address,address,address,uint,uint,uint); event ticksell(uint gettick,uint paytick); modifier ownerOnly() { require(msg.sender == owner); _; }",1
0x57c555591b18cff058e6fabfc57a6b7c7f37c8e8.sol,Ballot,contract Ballot { struct Voter { uint weight; bytes32 voterName; uint proposalId; },1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2094890017bf0eca1a032eeeccb85b5810f5e52f.sol,VT,"contract VT is owned { string public name; string public symbol; uint8 public decimals=18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd403cc1e2da3aa7d954e0ad34bef2df2b9a9f238.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x4200942093f5c8c2ce865e17b3fdec9148de8c49.sol,YunbeiToken,"contract YunbeiToken is owned, TokenERC20 { uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function YunbeiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0d15cfff56a4ae7a978955d660bd8e9e5d1d4d9f.sol,VT,"contract VT is owned { string public name; string public symbol; uint8 public decimals=18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e226310db63ac3701f657bcc62c153c1aaa3004.sol,AdminBank,contract AdminBank { using SafeMath for uint256; uint256 public fundsReceived; address public masterAdmin; address public mainContract; bool public mainContractSet = false; address public teamMemberA = 0x2597afE84661669E590016E51f8FB0059D1Ad63e; address public teamMemberB = 0x2E6C1b2B4F7307dc588c289C9150deEB1A66b73d; address public teamMemberC = 0xB3CaC7157d772A7685824309Dc1eB79497839795; address public teamMemberD = 0x87395d203B35834F79B46cd16313E6027AE4c9D4; address public teamMemberE = 0x2c3e0d5cbb08e0892f16bf06c724ccce6a757b1c; address public teamMemberF = 0xd68af19b51c41a69e121fb5fb4d77768711c4979; address public teamMemberG = 0x8c992840Bc4BA758018106e4ea9E7a1d6F0F11e5; address public teamMemberH = 0xd83FAf0D707616752c4AbA00f799566f45D4400A; address public teamMemberI = 0xca4a41Fc611e62E3cAc10aB1FE9879faF5012687; uint256 public teamMemberArate = 20; uint256 public teamMemberBrate = 20; uint256 public teamMemberCrate = 15; uint256 public teamMemberDrate = 15; uint256 public teamMemberErate = 7; uint256 public teamMemberFrate = 4; uint256 public teamMemberGrate = 4; uint256 public teamMemberHrate = 5; uint256 public teamMemberIrate = 10; mapping (address => uint256) public teamMemberTotal; mapping (address => uint256) public teamMemberUnclaimed; mapping (address => uint256) public teamMemberClaimed; mapping (address => bool) public validTeamMember; mapping (address => bool) public isProposedAddress; mapping (address => bool) public isProposing; mapping (address => uint256) public proposingAddressIndex; constructor() public { masterAdmin = msg.sender; validTeamMember[teamMemberA] = true; validTeamMember[teamMemberB] = true; validTeamMember[teamMemberC] = true; validTeamMember[teamMemberD] = true; validTeamMember[teamMemberE] = true; validTeamMember[teamMemberF] = true; validTeamMember[teamMemberG] = true; validTeamMember[teamMemberH] = true; validTeamMember[teamMemberI] = true; },1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0x1e26b3d07e57f453cae30f7ddd2f945f5bf3ef33.sol,ClearCoin,contract ClearCoin is IERC20 { uint public constant _totalSupply = 100000000000000000; string public constant symbol =; string public constant name = ; uint8 public constant decimals = 8; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function ClearCoin() { balances[msg.sender] = _totalSupply; },1
0xf37c4a962e70d813a4d9825942141cd9bc5169fd.sol,ChangeableRateCrowdsale,contract ChangeableRateCrowdsale is ClaimableCrowdsale { struct RateBoundary { uint256 amount; uint256 rate; },1
0x4868d191a23428fa9aca36a3d0f1421f33d12226.sol,JavaSwapTest,"contract JavaSwapTest is TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint256 public leastSwap; bool public funding = true; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function JavaSwapTest( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x2cf618c19041d9db330d8222b860a624021f30fb.sol,CRBTTokenLive,"contract CRBTTokenLive is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRBTTokenLive() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7.sol,AirDrop,contract AirDrop is Ownable { Token public tokenInstance; function AirDrop(address _tokenAddress){ tokenInstance = Token(_tokenAddress); },1
0x72a73495b769682d7b09a9641fa1a95e308fbe08.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x51257ce076e3b4a2c4de2763e442ea2bf2c61e2c.sol,jiangguilong1,"contract jiangguilong1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function jiangguilong1(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf0da1186a4977226b9135d0613ee72e229ec3f4d.sol,CreamtoeCoin,"contract CreamtoeCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CreamtoeCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 700000000 * 10**uint(decimals); startDate = 52 weeks; bonusEnds = startDate + 26 weeks; endDate = bonusEnds + 26 weeks; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0x0e74d6d1937a5855904403954dfa7e2ce8e712d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6aa27b3a8aab51745b7eaf53e61aba833b0f9400.sol,PCC,"contract PCC is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PCC() public { symbol = ; name = ; decimals = 8; _totalSupply = 5200000000000000; balances[0x67322D8A8f72B8417f16397667d8F6ce996A6982] = _totalSupply; Transfer(address(0), 0x67322D8A8f72B8417f16397667d8F6ce996A6982, _totalSupply); }",1
0x331655585e8893961f8e8e427f5f8dedf6e7f0af.sol,SDT_token,"contract SDT_token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SDTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4bf3e4d2378a1256cbe1cd1c2a8bc9857b811282.sol,Databits,"contract Databits is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 5000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Databits(){ balanceOf[msg.sender] = totalSupply; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x0dee19332fb83fb343a9fbb722b5395b8e7c9d8d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3617081dd9294a785780a4fcde3dcb8f0a2c69e8.sol,MofasAirdrop,"contract MofasAirdrop is Ownable { function multisend(address[] to, uint256[] value) onlyOwner returns (uint256) { address tokenAddr = 0x1d18f44256A27862d886E27191d55AB4029172C1; uint256 i = 0; while (i < to.length) { ERC20(tokenAddr).transfer(to[i], value[i] * ( 10 ** 18 )); i++; }",1
0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59.sol,TwentyDollars,contract TwentyDollars { struct Bid { address owner; uint256 amount; },1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x26497b895c43b84bc9d5c33702dce87c1358a502.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x659635905891a08f23d2cc7e000bc452ea5ee074.sol,CCTCOIN,"contract CCTCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( ) public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x6fa3217293bb88ec6accecc368881c33df1248f5.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xa29d3d850d169eca564e71a02c13b7d76bc0eff4.sol,Scorpio,"contract Scorpio { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Scorpio( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 40000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 4000000000000000; name = ; symbol = ; }",1
0x3a6e5f1c1b0de5d2b46babd21c7844c96f5180aa.sol,SniperBillion,contract SniperBillion is modularBillion { using SafeMath for *; using Array256Lib for uint256[]; address constant private comReward_ = 0x8Aa94D530cC572aF0C730147E1ab76875F25f71C; address constant private comMarket_ = 0x6c14CAAc549d7411faE4e201105B4D33afb8a3db; address constant private comICO_ = 0xbAdb636C5C3665a969159a6b993F811D9F263639; address constant private donateAccount_ = 0x1bB064708eBf4763BeB495877E99Dfeb75198942; RubyFundForwarderInterface constant private Ruby_Fund = RubyFundForwarderInterface(0x7D653E0Ecb4DAF3166a49525Df04147a7180B051); SniperBookInterface constant private SniperBook = SniperBookInterface(0xc294FA45F713B09d865A088543765800F47514eD); string constant public name = ; string constant public symbol = ; uint256 constant private icoEndTime_ = 24 hours; uint256 constant private maxNumber_ = 100000000; uint256 public totalSum_; uint256 public rID_; uint256 public icoAmount_; bool private isDrawed_ = false; uint256 lastSID_; uint256[] private globalArr_; uint256[] private icoSidArr_; uint256[] private luckyPotBingoArr_; uint256[] private airdropPotBingoArr_; mapping (address => uint256) public sIDxAddr_; mapping (bytes32 => uint256) public sIDxName_; mapping (uint256 => uint256) public sidXnum_; mapping (uint256 => SPBdatasets.Sniper) public spr_; mapping (uint256 => SPBdatasets.Round) public round_; mapping (uint256 => mapping (bytes32 => bool)) public sprNames_; constructor() public { },1
0xc429e7b63dc30b51f5a7e4be23fd5eb4baf8a1c3.sol,Bitibu,"contract Bitibu is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function Bitibu( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4d50c99294daa84d8de9b2a5b9b6a6d9a8d88aa3.sol,SERBIA_WINS,"contract SERBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xc66e78b1078ba0e65d311c92854dd446451b2ba6.sol,Xoom,"contract Xoom is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Xoom() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b] = _totalSupply; Transfer(address(0), 0x6d89FE3B635049A4846D8Af0c16b80bCDbcC553b, _totalSupply); }",1
0x02b6700c0282a687d66f3e09723bed55f23d5b83.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 99000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; decimals = 0; }",1
0x6b609d9095d069c805650234ab67595b3a6ab934.sol,Crowdsale,"contract CrowdsaleProxy is ICrowdsaleProxy { address public owner; ICrowdsale public target; function CrowdsaleProxy(address _owner, address _target) public { target = ICrowdsale(_target); owner = _owner; }",1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0x9233ad76758f642483e903b9ad45ed9b0b1d4ef2.sol,Boxicoin,"contract Boxicoin { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Boxicoin() { balanceOf[msg.sender] = 10000000000; totalSupply = 10000000000; name = ; symbol = ; decimals = 2; }",1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68.sol,eKRW,"contract eKRW { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6e45155b50ffdb802872830613b745b156922b20.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 50000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c66bb904ceaa80aa224193728d459b109115ec2.sol,TBC,"contract TBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() { totalSupply = 5000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x333f37329c6d2346001501f235d33bf68ec1cf5e.sol,BloquidIssuer,contract BloquidIssuer is Ambi2EnabledFull { AssetProxy public assetProxy; function setupAssetProxy(AssetProxy _assetProxy) onlyRole() returns(bool) { if ((address(assetProxy) != 0x0) || (address(_assetProxy) == 0x0)) { return false; },1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0x25dab234f1a0368656846412fa0c33a978315c07.sol,CryptoGoldStandardCoin,"contract CryptoGoldStandardCoin is MintableToken, BurnableToken { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 9; uint public INITIAL_SUPPLY = 100000000000; uint public sellPrice = 0; uint public buyPrice = 2**256-1; uint public priceExpirationBlockNumber = 0; function setPrices(uint newSellPrice, uint newBuyPrice, uint newPriceExpirationBlockNumber) onlyOwner public{ require(newPriceExpirationBlockNumber > block.number); require(newSellPrice < newBuyPrice); sellPrice = newSellPrice; buyPrice = newBuyPrice; priceExpirationBlockNumber = newPriceExpirationBlockNumber; }",1
0xf5580e174b658695680db92e6503949f6c52b454.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1b413506fc42e2f04a4e8c57710f850b234d6653.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5175731f308e27855337b902e667c5f36f8ce3d3.sol,MyNewToken,"contract MyNewToken is Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function MyNewToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = 100000; totalSupply = 100000; name = ; decimals = 0; symbol = ; }",1
0xed0c3e1d538fda7370c22c4c3f3dc076ab51bd00.sol,wallet,contract wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc3a496b6657c6a3db45d162d99953a436d8c423ad460cc8819cea54acc2071e9; constructor() public { owner = msg.sender; },1
0xc2149ced2e1e6fc976c24391059b09fbe970cafe.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xeb0223b8610f7a2d2d8dfa1b98bb2eed8e162a9f.sol,mutil_funds,contract mutil_funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x6f9a91ce11d7af59450e17d3ca77326c3f4af79f3ac61df8cc420e8679d990f8; constructor() public { owner = msg.sender; },1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf1d8fd82da98ed93bca83adbb6ab4dd3c44b35ea.sol,GOG,"contract GOG is owned { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public frozenFunds; event FrozenFunds(address target, uint256 funds); event UnFrozenFunds(address target, uint256 funds); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function GOG() public { totalSupply = 10000000000000000; balances[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x266be180f1bdda078b677c5d1c050268929f0da3.sol,CASINO_301201,"contract CASINO_301201 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10990099143654100000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xef6da6e6e72e3381a1f97ea520d2844582d85edb.sol,WinEthFree,contract WinEthFree{ struct Investor { uint waveNum; uint investment; uint payableInterest; uint paidInterest; uint payTime; },1
0xdd850d1d845a444a13e9516317a0a57075d9cf8e.sol,FOMOWINNER,"contract FOMOWINNER is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x264dc2dedcdcbb897561a57cba5085ca416fb7b4.sol,QunQunToken,contract QunQunTokenIssue { address public tokenContractAddress; uint16 public lastRate = 950; uint256 public lastBlockNumber; uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public inflateCount = 0; bool public isFirstYear = true; function QunQunTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0x6fc1ee575e9023aea1c45b4dfc9acf603ea9f63f.sol,MultiFundsWallet,contract MultiFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x37e1160184f7dd29f00b78c050bf13224780b0b0.sol,YCCToken,"contract YCCToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function YCCToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x48ec60c155a8487f9f06107054afe947a2345bbc.sol,Harj,contract Harj { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6c91c0104677d08cded353b1459b68415f278c38.sol,FastEth,contract FastEth { address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35; address constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03; address constant private CASHBACK = 0x33cA4CbC4b171c32C16c92AFf9feE487937475F8; address constant private PRIZE = 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653; uint constant public PERCENT = 4; uint constant public BONUS_PERCENT = 5; uint constant StartEpoc = 1541329170; struct Deposit { address depositor; uint deposit; uint payout; },1
0x4b5cd619741838cb3442831c3f268a78b7df859a.sol,CryptoPeopleName,contract CryptoPeopleName { address owner; mapping(address => string) private nameOfAddress; function CryptoPeopleName() public{ owner = msg.sender; },1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2898ca01df2dc4062e8b269806de4996295a1f5c.sol,BlockBase,"contract BlockBase{ event Transfer(address from, address to, uint256 tokenId); event Birth(address owner, uint256 blockId, uint256 width, uint256 height, string position, uint16 genes); struct Block { uint256 width; uint256 heigth; string position; uint16 generation; }",1
0xaa91a17611945c53a31c1e13969b908d59eab66e.sol,DADCoin,"contract DADCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DADCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF] = _totalSupply; Transfer(address(0), 0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF, _totalSupply); }",1
0x793bf5b5d34151b276ac212bfaddb915e3a47126.sol,JTCCtoken,"contract JTCCtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function JTCCtoken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5a086708501251d2c948d767a88379f0b8d8c300.sol,WeduToken,contract WeduToken is ERC20Interface { string private TOKEN_NAME; string private TOKEN_SYMBOL; uint8 private DECIMAL; uint private WEDU_UNIT; address owner; mapping(address => bool) internal blackList; uint private totalSupplyValue; struct BalanceType { uint locked; uint unlocked; },1
0x41451e8e7fd5b9a4f8176ccf1a0db2b68abc77fb.sol,FART,contract FART { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xcf91ddfd551c8eee7dc88372acd8c49a0d8726a3.sol,Alecrypto,"contract Alecrypto is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Alecrypto() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252] = _totalSupply; Transfer(address(0), 0x86F35b8BFcd841e8CC6719cCC1B4eeFeF1B3F252, _totalSupply); }",1
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,OpenAddressLottery,contract OpenAddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; },1
0x4c6e23e5d9dc901991128b3ced739bb0167d7474.sol,Sgethereum,"contract Sgethereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Sgethereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2858f2b0d94947962f93e4387d391467ebd72166.sol,FLEX,"contract FLEX { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function FLEX( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0x8700e5453718244cac9a5257aa82abc9d7bb13af.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x292317a267adfb97d1b4e3ffd04f9da399cf973b.sol,ERC20,"contract ERC20 is Ownable{ string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; bool public IsFrozen=false; address public ICOAddress; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); modifier IsNotFrozen{ require(!IsFrozen||msg.sender==owner ||msg.sender==0x0a6d9df476577C0D4A24EB50220fad007e444db8 ||msg.sender==ICOAddress); _; }",1
0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol,MultiplicatorX3,contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{},1
0x219218f117dc9348b358b8471c55a073e5e0da0b.sol,GRX,contract GRX is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x715641fd955890299863a73c906209b71a8a4ce9.sol,WhiteList,contract WhiteList { mapping (address => bool) public whiteList; address public owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; },1
0x33a0924b74b8ec4bc654a5dfd6603a7c27ab0af4.sol,MWorld,"contract MWorld is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MWorld() public { symbol = ; name = ; decimals = 8; _totalSupply = 200000000000000000; balances[0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2] = _totalSupply; Transfer(address(0), 0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2, _totalSupply); }",1
0x0d8f67a5792c156d0244f380a66655b9f4255586.sol,Carrot,"contract Carrot { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Carrot( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0f2d4c5c9dc5d1f7f9260e3d57ed2bbad742eba1.sol,DIR,"contract DIR is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DIR() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000*10**18; balances[0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00] = _totalSupply; Transfer(address(0), 0x743Fd6d924Ae32ccdDb377F11D43129CDD0d0D00, _totalSupply); }",1
0xf4a7c09a885a31755dd4cd1ce816d257fbe30dcf.sol,BBTDonate,contract BBTDonate { address public owner; bool public isClosed; uint256 public totalReceive; uint256 public remain; mapping (address => uint256) public record; mapping (address => bool) public isAdmin; modifier onlyAdmin { require(msg.sender == owner || isAdmin[msg.sender]); _; },1
0x558c62533def5e9d77a7e555490c0e2889eacf3a.sol,UTokenContract,"contract UTokenContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public UTExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public{ require (crowdsaleIsOpen == true); require(msg.value != 0); mintUTToken(msg.sender, (msg.value * UTExchangeRate * 10**decimals) / etherChange); }",1
0xbdae4cb65e1c68cd9cd41b73c93ae3d331acad5c.sol,Vote,"contract Vote is Ownable { event CandidateRegistered(uint candidateId, string candidateName, string candidateDescription); event VoteCast(uint candidateId); struct Candidate { uint candidateId; string candidateName; string candidateDescription; }",1
0x05abd85cc4424cbb7029b9a078f2c58793fd3e14.sol,WyoMesh,contract WyoMesh { struct Device { string name; bool permissioned; },1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0x6ed98637002026cf9b6c70b7018f229f9d02391e.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=1300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xeb0223b8610f7a2d2d8dfa1b98bb2eed8e162a9f.sol,mutil_funds,contract mutil_funds { bytes32 keyHash; address owner; bytes32 wallet_id = 0x6f9a91ce11d7af59450e17d3ca77326c3f4af79f3ac61df8cc420e8679d990f8; constructor() public { owner = msg.sender; },1
0xeaf503fd64d0cf9278f29775b78c6f31001ffebc.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
0xc4ff0412050fafbd9e697b1931a23ea41f4cb26f.sol,token1234,contract token1234 is owned{ using SafeMath for uint256; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 _initialSupply = 1000000 * 10 ** uint256(decimals); uint256 _totalSupply; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; constructor() token1234() public { owner = msg.sender; _totalSupply = _initialSupply; balances[owner] = _totalSupply; },1
0x5caae332dd0a17827052de681f6f2155e00394f0.sol,SafeMath,None,1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0xc0c45cbb1dce225cf620c36807a1cdecb85feda5.sol,ETHMONEY,"contract ETHMONEY is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ETHMONEY() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x5833dbb0749887174b254ba4a5df747ff523a905.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c46b734d5a94b10929ac4e88f22cc56145bc65c.sol,AMOT__20230515,"contract AMOT__20230515 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 15538797795124200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb.sol,NOUR,"contract NOUR { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1dcaef208411119ed3d2527d1a2e724f0e3a07cc.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x5c976e71bb27538bddb0ed399be1722c6745bcb6.sol,ProofOfKennyCoin,contract ProofOfKennyCoin { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4839e3de8737769e0f93f176d157dca5e48b7662.sol,CPCToken,"contract CPCToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CPCToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0x55ae5792903b179915e10065e26610435832a3f7.sol,CofounditICO,"contract CofounditICO is owned{ uint256 public startBlock; uint256 public endBlock; uint256 public minEthToRaise; uint256 public maxEthToRaise; uint256 public totalEthRaised; address public multisigAddress; uint256 public icoSupply; uint256 public strategicReserveSupply; uint256 public cashilaTokenSupply; uint256 public iconomiTokenSupply; uint256 public coreTeamTokenSupply; ICofounditToken cofounditTokenContract; mapping (address => bool) presaleContributorAllowance; uint256 nextFreeParticipantIndex; mapping (uint => address) participantIndex; mapping (address => uint256) participantContribution; uint256 usedIcoSupply; uint256 usedStrategicReserveSupply; uint256 usedCashilaTokenSupply; uint256 usedIconomiTokenSupply; uint256 usedCoreTeamTokenSupply; bool icoHasStarted; bool minTresholdReached; bool icoHasSucessfulyEnded; uint256 lastEthReturnIndex; mapping (address => bool) hasClaimedEthWhenFail; uint256 lastCfiIssuanceIndex; string icoStartedMessage = ; string icoMinTresholdReachedMessage = ; string icoEndedSuccessfulyMessage = ; string icoEndedSuccessfulyWithCapMessage = ; string icoFailedMessage = ; event ICOStarted(uint256 _blockNumber, string _message); event ICOMinTresholdReached(uint256 _blockNumber, string _message); event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message); event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message); event ErrorSendingETH(address _from, uint256 _amount); function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) { startBlock = _startBlock; endBlock = _endBlock; minEthToRaise = 4525 * 10**18; maxEthToRaise = 56565 * 10**18; multisigAddress = _multisigAddress; icoSupply = 125000000 * 10**18; strategicReserveSupply = 125000000 * 10**18; cashilaTokenSupply = 100000000 * 10**18; iconomiTokenSupply = 50000000 * 10**18; coreTeamTokenSupply = 100000000 * 10**18; }",1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x036a98e540599dae4a9778335ffabe6ca01ca705.sol,cwallet,contract cwallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x41691d0d4fa9d63aa73129998c6d22eda519ff3623f1881c379406b1650e4823; constructor() public { owner = msg.sender; },1
0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol,SanityPools,contract SanityPools is Controller { mapping (uint256 => mapping (address => uint256)) balances; Pool[100] pools; uint256 index_active = 0; uint256 public week_in_blocs = 39529; modifier validIndex(uint256 _index){ require(_index <= index_active); _; },1
0x5aba53f2ab792de10479cb51b809956c39a910b8.sol,SHERE_PFIV_III_883,"contract SHERE_PFIV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1827925061033140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6b3f9f54e2a684ea28365af5f3dd6d714df4328b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6fa8cd6a1a35542ba289437fe69e8f21ca1fa614.sol,SAN,"contract SAN is Owned, ERC20 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 15; address CROWDSALE_MINTER = 0xDa2Cf810c5718135247628689D84F94c61B41d6A; address public SUBSCRIPTION_MODULE = 0x00000000; address public beneficiary; uint public PLATFORM_FEE_PER_10000 = 1; uint public totalOnDeposit; uint public totalInCirculation; function SAN() { beneficiary = owner = msg.sender; }",1
0x25caf15e1cc43e7bfa9853a68de463bfb0d27021.sol,IndividualLockableToken,"contract IndividualLockableToken is PausableToken{ using SafeMath for uint256; event LockTimeSetted(address indexed holder, uint256 old_release_time, uint256 new_release_time); event Locked(address indexed holder, uint256 locked_balance_change, uint256 total_locked_balance, uint256 release_time); struct lockState { uint256 locked_balance; uint256 release_time; }",1
0x4b4878af9474089783f9cef61edbe96614af79e6.sol,CCD_KOHLE_5_20190411,"contract CCD_KOHLE_5_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x033d46d15ad9b5653cbe61be97371023acb11f94.sol,OChain,"contract OChain { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OChain() { balanceOf[msg.sender] = 100000000 * 1000000000000000000; totalSupply = 100000000 * 1000000000000000000; name = ; symbol = ; decimals = 18; }",1
0xdba3c9f9a427d2bdb7e260353dce57a94cd8ddd8.sol,Zorro02Token,"contract Zorro02Token is ERC20Token { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; string public constant GITHUB_LINK = 'htp: address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; }",1
0x37ceaf9e7748c707934edea028812c7fdaf93866.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x291a043f014d12dc852b02ff752e5b70132bc328.sol,CryptoCopyCrowdsale,"contract CryptoCopyCrowdsale { using SafeMath for uint256; address public creator; address public buyBackFund; address public bountyPool; address public advisoryPool; uint256 public minAcceptedEthAmount = 100 finney; uint256 public maxTotalSupply = 1000000 * 10**8; uint256 public tokensForInvestors = 900000 * 10**8; uint256 public tokensForBounty = 50000 * 10**8; uint256 public tokensForAdvisory = 50000 * 10**8; uint256 public totalTokenIssued; uint256 public bonusFirstTwoDaysPeriod = 2 days; uint256 public bonusFirstWeekPeriod = 9 days; uint256 public bonusSecondWeekPeriod = 16 days; uint256 public bonusThirdWeekPeriod = 23 days; uint256 public bonusFourthWeekPeriod = 30 days; uint256 public bonusFirstTwoDays = 20; uint256 public bonusFirstWeek = 15; uint256 public bonusSecondWeek = 10; uint256 public bonusThirdWeek = 5; uint256 public bonusFourthWeek = 5; uint256 public bonusSubscription = 5; uint256 public bonusOver3ETH = 10; uint256 public bonusOver10ETH = 20; uint256 public bonusOver30ETH = 30; uint256 public bonusOver100ETH = 40; mapping (address => uint256) balancesETH; mapping (address => uint256) balancesETHWithBonuses; mapping (address => uint256) balancesETHForSubscriptionBonus; mapping (address => uint256) tokenBalances; uint256 public totalInvested; uint256 public totalInvestedWithBonuses; uint256 public hardCap = 100000 ether; uint256 public softCap = 175 ether; enum Stages { Countdown, Ico, Ended }",1
0x6d54549975e0fef50cd954491a6abee84c6f4e61.sol,QuizTest,contract QuizTest { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x721da477f68c71788a262d58853fe6977d86535e.sol,EtheremonPayment,"contract EtheremonPayment is EtheremonEnum, BasicAccessControl, SafeMath { uint8 constant public STAT_COUNT = 6; uint8 constant public STAT_MAX = 32; uint8 constant public GEN0_NO = 24; struct MonsterClassAcc { uint32 classId; uint256 price; uint256 returnPrice; uint32 total; bool catchable; }",1
0xe31ced3343f21e5cad5d31163bba5899ee01d813.sol,ERC20_CRYPTOMILLION_CPMN,"contract ERC20_CRYPTOMILLION_CPMN { string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function CreateTokenERC20(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; }",1
0x27d99a6d64e8fd38a47fb87df2d80867d6c1592c.sol,MagicKeys,"contract MagicKeys is AtomicSwappableToken, Ownable { string public name; string public symbol; uint8 public decimals; constructor ( string _name, string _symbol ) public { name = _name; symbol = _symbol; decimals = 18; }",1
0x1b016ac4de0996b1f59eab9c54a083af496c811d.sol,ScandinavianEKrona,"contract ScandinavianEKrona is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ScandinavianEKrona() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x08220b045BDC3d08ed341C0E5afF6D245f6eEBad] = _totalSupply; Transfer(address(0), 0x08220b045BDC3d08ed341C0E5afF6D245f6eEBad, _totalSupply); }",1
0xb3b476df77086b227d480c99b69b08a77631f2cf.sol,ICOSyndicate,"contract ICOSyndicate { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; uint256 public eth_cap = 30000 ether; address public developer = 0x91d97da49d3cD71B475F46d719241BD8bb6Af18f; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) public { require(msg.sender == developer); require(sale == 0x0); sale = _sale; token = ERC20(_token); }",1
0x6f3f21e65e618592f95d5f3a2e7e1b1425309ff2.sol,GILToken,"contract GILToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GILToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0xdd16c70aD270633edF69174b4269914De9434bf8] = _totalSupply; Transfer(address(0), 0xdd16c70aD270633edF69174b4269914De9434bf8, _totalSupply); }",1
0xf2ad62fb35bad00b30e3af1d920de48d29613993.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x02c60d28be3338014fef3fdf50a3218b946c0609.sol,EasyInvest3,contract EasyInvest3 { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x35ac7dcba25ba2192c87981bfcf024208070a25f.sol,ERC1003Caller,"contract ERC1003Caller is Ownable { function makeCall(address target, bytes data) external payable onlyOwner returns (bool) { return target.call.value(msg.value)(data); }",1
0xf310d06a54eda5d5ae204b0aa9b5e207972d80b9.sol,MicoinToken,"contract MicoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MicoinToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x8516b43a9b547e4692433340ca9f0a13b5d25d7f.sol,TheInternetCoin,contract TheInternetCoin { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200*10**24; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0xb45d7bc4cebcab98ad09babdf8c818b2292b672c.sol,HODLCoin,"contract HODLCoin is StandardToken { using SafeMath for *; event Deposit(address indexed account, uint etherValue, uint tokenValue); event Withdrawal(address indexed account, uint etherValue, uint tokenValue); string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint8 constant DEPOSIT_FEE = 2; uint8 constant MULTIPLIER = 100; function value(uint amount) public view returns(uint) { return amount.mul(this.balance).div(totalSupply); }",1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xeea8cd2150b0438555b515f0bdd1ded0d84eab8c.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x39cfd754c85023648bf003bea2dd498c5612abfa.sol,TokenBank,contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; },1
0x38ceafcff00dc2f88656a4ff3235e2124819eef6.sol,CryptojoyTokenSeller,"contract CryptojoyTokenSeller is Ownable { using SafeMath for uint; uint8 public constant decimals = 18; uint public miningSupply; uint constant MAGNITUDE = 10**6; uint constant LOG1DOT5 = 405465; uint constant THREE_SECOND= 15 * MAGNITUDE / 10; uint public a; uint public b; uint public c; uint public blockInterval; uint public startBlockNumber; address public platform; uint public lowerBoundaryETH; uint public upperBoundaryETH; uint public supplyPerInterval; uint public miningInterval; uint public tokenMint = 0; EIP20Interface public token; modifier isWithinLimits(uint _eth) { require(_eth >= lowerBoundaryETH, ); require(_eth <= upperBoundaryETH, ); _; }",1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b963f7b38980f5fbbd129fe98059eb2144076a7.sol,BLV,"contract BLV { string public name; string public symbol; uint8 public decimals = 1; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BLV( ) public { totalSupply = 1000000000; balanceOf[msg.sender] = 1000000000; name = ; symbol = ; }",1
0x05d379b48a8622ae4018309e116420db4a38a225.sol,ELYTE,"contract ELYTE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ELYTE( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5298a879e14fd5b19ebcab2104927c535cd0b90c.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5ab883cfde389e09c623c049939d7553f312ac43.sol,Core,"contract Core is Control { function random(uint256 _min, uint256 _max) public constant returns(uint256) { return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min; }",1
0x562858eaa3c5af1ae79e33c225aff4e1562f8cce.sol,AntzToken,"contract AntzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public totalSupply; uint public unitsPerTransaction; uint public tokensDistributed; uint public numDistributions; uint public numDistributionsRemaining; address public fundsWallet; address public developersWallet; uint public developersCut; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AntzToken() public { fundsWallet = 0; balances[fundsWallet] = 25000000000000000000000000; totalSupply = 25000000000000000000000000; name = ; decimals = 18; symbol = ; unitsPerTransaction = 500000000000000000000; developersWallet = 0x78061eE39Cd5eDFe1D935168234a3BEEeF9d4b5a; developersCut = safeDiv(totalSupply,10); balances[developersWallet] = safeAdd(balances[developersWallet], developersCut); Transfer(fundsWallet, developersWallet, developersCut); tokensDistributed = developersCut; numDistributionsRemaining = (totalSupply - tokensDistributed) / unitsPerTransaction; numDistributions = 1; }",1
0x6db92e635ba5d2834fff3db03b6be80d8aa28d5a.sol,TokenBaseAsset,contract TokenBaseAsset { address mOwner = msg.sender; string public mCompany; mapping(string => string) mTokens; modifier isOwner() { require(msg.sender == mOwner); _; },1
0xced350d7ef320c38cc5090c89e7475dfd2e0fff4.sol,BimuyuCoin,"contract BimuyuCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BimuyuCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x32473D19cD9009E1a9203dEb7117C89F5E359DF3] = _totalSupply; Transfer(address(0), 0x32473D19cD9009E1a9203dEb7117C89F5E359DF3, _totalSupply); }",1
0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol,FreeEth,contract FreeEth { address public Owner = msg.sender; function() public payable{},1
0x750229c6e70aa4b747b1bba2408436d74465381c.sol,CryptoCinema,"contract CryptoCinema is ERC721, Ownable { event FilmCreated(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.01 ether; mapping (uint256 => address) public filmIdToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public filmIdToApproved; mapping (uint256 => uint256) private filmIdToPrice; struct Film { string name; }",1
0xe3147bc1046fab87292e1b743c1e657b37262496.sol,AccessCrowdsale,"contract AccessCrowdsale is Whitelisted { using SafeMath for uint256; address public beneficiary; uint256 public SoftCap; uint256 public HardCap; uint256 public amountRaised; uint256 public preSaleStartdate; uint256 public preSaleDeadline; uint256 public mainSaleStartdate; uint256 public mainSaleDeadline; uint256 public price; uint256 public fundTransferred; uint256 public tokenSold; token public tokenReward; mapping(address => uint256) public balanceOf; bool crowdsaleClosed = false; bool returnFunds = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282; SoftCap = 15000 ether; HardCap = 150000 ether; preSaleStartdate = 1550102400; preSaleDeadline = 1552608000; mainSaleStartdate = 1552611600; mainSaleDeadline = 1560643200; price = 0.0004 ether; tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b); }",1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe.sol,WeaponsCore,contract WeaponsCore is Ownable { struct WeaponModel { uint id; uint weaponType; uint generation; uint price; },1
0x1f5cfb9a00b86bf9982970382bdb900b7744a559.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3632c27273a5d928d0f09407380dc0d8164a8ac5.sol,TokenShares,"contract TokenShares is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf2861ad8dd602269c21eddd4d18255903cca47c7.sol,ZethrDividendCards,"contract ZethrDividendCards is ERC721Interface { using SafeMath for uint; event Birth(uint tokenId, string name, address owner); event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint tokenId); event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner); event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner); event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner); event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner); event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId); event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId); event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId); event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId); string public constant NAME = ; string public constant SYMBOL = ; address public BANKROLL; mapping (uint => address) public divCardIndexToOwner; mapping (uint => uint) public divCardRateToIndex; mapping (address => uint) private ownershipDivCardCount; mapping (uint => address) public divCardIndexToApproved; mapping (uint => uint) private divCardIndexToPrice; mapping (address => bool) internal administrators; address public creator; bool public onSale; struct Card { string name; uint percentIncrease; }",1
0x4eea6bdcf9dfca9e5b1daa01c2f6dae3f14ecf9b.sol,TheophanesToken,"contract TheophanesToken is ERC20Interface, Owned, SafeMath { string public symbol = ; string public name = ; uint8 public decimals = 18; uint public _totalSupply = 100000000000000000000000000; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheophanesToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858] = _totalSupply; Transfer(address(0), 0x5Bd9586E9073b075eA83dFfc3c7C2FC0D2c2e858, _totalSupply); }",1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,PLAY_NOW,contract PLAY_NOW { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>=1 ether) { msg.sender.transfer(this.balance); },1
0x4cd6e70a33092e2e3aac431c39b3de364042f9f0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xcea093ff08f94ebfcd921b8cd1e6a9f18826ccab.sol,LearnX,contract LearnX is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 10000000000 * 10**8; function name() public constant returns (string) { return ; },1
0x65520a06ca242c29657ccd36665ba51d227a1d14.sol,CCD_KOHLE_13_20190411,"contract CCD_KOHLE_13_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x698674f7537ea6194caa4eb4b9129cd3c395ada8.sol,Neulaut,"contract Neulaut { uint256 public totalSupply = 7*10**27; uint256 public fee = 15*10**18; uint256 public burn = 10**19; address owner; string public name = ; uint8 public decimals = 18; string public symbol = ; mapping (address => uint256) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function Neulaut() { owner = msg.sender; balances[owner] = totalSupply; }",1
0x1ebd04228ae2900ccad55193233492ddc3b09de9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x03b6609aaceccec42ef526a35b1bd5d728874ea4.sol,PDATAToken,"contract PDATAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PDATAToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; }",1
0x068ae20c4938821442cefba1716e1f7a4696897b.sol,VOCC_I083_20181211,"contract VOCC_I083_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0073db4d9d92c22e3683058dc92c0b6e5edc639e.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2.sol,BFBtoken,"contract BFBtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0dd1326b7b80107f002ba16dad7fe2dd22f00491.sol,LetsBreakThings,contract LetsBreakThings { address public creator; address public creatorproxy; function deposit() public payable { },1
0x6b27bfd273ec79a64a62b4b3a18a89045c2389b1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,CoreContract,"contract CoreContract is Manageable { using SafeMath for uint256; bool public priceLocked = true; uint256 private constant DEFAULTPARENT = 123456789; uint256 public layerCount; mapping(uint256 => address) public getLayerFromId; mapping(uint256 => bytes32) public getLayerNameFromId; mapping(address => bool) private blacklisted; bool public blackListActive; bool public blockLockActive; mapping(address => address) public referrers; function approve(address _to, uint256 _tokenId, uint256 layerId) public isUnlocked { address layerAddr = getLayerFromId[layerId]; TokenLayer layer = TokenLayer(layerAddr); layer.approve(_to, _tokenId, msg.sender); }",1
0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555.sol,Bointt,"contract Bointt is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Bointt( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e.sol,Zamok,contract Zamok { uint256 public zamokCount; function Zamok() public { zamokCount = 0; },1
0x7440baed1503b5d103dda4893ea5bc59c4bf08d4.sol,EthProfile,contract EthProfile{ mapping(address=>string) public name; mapping(address=>string) public description; mapping(address=>string) public contact; mapping(address=>string) public imageAddress; constructor() public{ },1
0xf355164187e533b1969b4de46737c4e8bc9ae7e2.sol,MASToken,"contract MASToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MASToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc8507d914d21d50c1763288da6539f6a0f5a0916.sol,yiDaooToken,"contract yiDaooToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaooToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xf515c78ea440443021fd2abdccbf01afcaae3e65.sol,PreSignedContract,"contract PreSignedContract is Ownable { mapping (uint8 => bytes) internal _prefixPreSignedFirst; mapping (uint8 => bytes) internal _prefixPreSignedSecond; function upgradePrefixPreSignedFirst(uint8 _version, bytes _prefix) public onlyOwner { _prefixPreSignedFirst[_version] = _prefix; }",1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70aedc0621a686067fdba7fb4fdb209ea185fe73.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x8825026b162401cc50f2a614a1c2354aa59e8496.sol,AviationSecurityToken,"contract AviationSecurityToken is SupportsInterfaceWithLookup, ERC721, ERC721BasicToken, Ownable { bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63; bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; string public name_ = ; string public symbol_ = ; mapping(address => uint256[]) internal ownedTokens; mapping(uint256 => uint256) internal ownedTokensIndex; uint256[] internal allTokens; mapping(uint256 => uint256) internal allTokensIndex; mapping(uint256 => string) internal tokenURIs; struct Data{ string liscence; string URL; }",1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee278a3543afbe4c1639b430774537995c6bd995.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=36300000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0xeb86dfc14848b56955051cfd9d696bafde1d6027.sol,StoreGift,contract StoreGift is BasicAuth { struct Gift { string m_Key; uint m_Expire; uint32[] m_ItemIdxList; uint[] m_ItemNumlist; },1
0x73390087000b126be1ced616a9df4daff59d03c6.sol,CHEMCHINA_PFV_I_883,"contract CHEMCHINA_PFV_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 582396634707317000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x73c9275c3a2dd84b5741fd59aebf102c91eb033f.sol,BTRS,"contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BTRS() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); }",1
0x377dfa7bab23a798ca1fa0923bcd4d4ef2184d85.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cc24b1feb9f45f907d16159ce82fc067a7e1c43.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 3; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xeeaf418943fd5860d90676c1d739eebc6d3e28fb.sol,WankToken,"contract WankToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WankToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xB8B95D1f4D3ce2312B011AA27733bACce02D406e] = _totalSupply; Transfer(address(0), 0xB8B95D1f4D3ce2312B011AA27733bACce02D406e, _totalSupply); }",1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7.sol,GodsOfOlympus,contract GodsOfOlympus { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimStorage,"contract MonethaUsersClaimStorage is Contactable { string constant VERSION = ; mapping (address => uint256) public claimedTokens; event UpdatedClaim(address indexed _userAddress, uint256 _claimedTokens, bool _isDeleted); event DeletedClaim(address indexed _userAddress, uint256 _unclaimedTokens, bool _isDeleted); function updateUserClaim(address _userAddress, uint256 _tokens) external onlyOwner returns (bool) { claimedTokens[_userAddress] = claimedTokens[_userAddress] + _tokens; emit UpdatedClaim(_userAddress, _tokens, false); return true; }",1
0x6f3b2f2100875409c5c011bc3bb97ea6e0f671db.sol,ToknTalkToken,"contract ToknTalkToken { event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); uint private constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; address public mintSigner = msg.sender; string public constant name = ""https: string public constant symbol = ; uint public constant decimals = 0; uint public totalSupply = 0; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => uint) public mintedBy; function transfer(address to, uint amount) external returns (bool) { require(to != address(this)); require(to != 0); uint balanceOfMsgSender = balanceOf[msg.sender]; require(balanceOfMsgSender >= amount); balanceOf[msg.sender] = balanceOfMsgSender - amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; }",1
0xa5818774ffb1405d7684c92892c990ba6939828b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2118840b16aaf95a0f0027b7ac32f5986925d935.sol,TokenERC20,"contract TokenERC20 { uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",1
0x6f328f0a7cd638cda9fed876abf71423ca109fe1.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x512a4d492669e5f0746609d638796c0ad94276cd.sol,RaceCoin,"contract RaceCoin is ERC20, AccessAdmin, IRaceCoin { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; uint256 private roughSupply; uint256 public totalRaceCoinProduction; uint256 public bonusMatchFunPercent = 10; uint256 public bonusOffLinePercent = 10; uint256 constant refererPercent = 5; address[] public playerList; uint256 public totalEtherPool; uint256[] private totalRaceCoinProductionSnapshots; uint256[] private allocatedProductionSnapshots; uint256[] private allocatedRaceCoinSnapshots; uint256[] private totalRaceCoinSnapshots; uint256 public nextSnapshotTime; mapping(address => uint256) private ethBalance; mapping(address => uint256) private raceCoinBalance; mapping(address => uint256) private refererDivsBalance; mapping(address => uint256) private productionBaseValue; mapping(address => uint256) private productionMultiplier; mapping(address => uint256) private attackBaseValue; mapping(address => uint256) private attackMultiplier; mapping(address => uint256) private attackPower; mapping(address => uint256) private defendBaseValue; mapping(address => uint256) private defendMultiplier; mapping(address => uint256) private defendPower; mapping(address => uint256) private plunderBaseValue; mapping(address => uint256) private plunderMultiplier; mapping(address => uint256) private plunderPower; mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots; mapping(address => uint256) private lastRaceCoinSaveTime; mapping(address => uint256) public lastRaceCoinProductionUpdate; mapping(address => uint256) private lastProductionFundClaim; mapping(address => uint256) private lastRaceCoinFundClaim; mapping(address => uint256) private battleCooldown; mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address referal, address player, uint256 amount); event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder); mapping (address => bool) actionContracts; function setActionContract(address _actionAddr, bool _useful) external onlyAdmin { actionContracts[_actionAddr] = _useful; }",1
0x414b23b9deb0da531384c5db2ac5a99ee2e07a57.sol,TPCToken,"contract TPCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TPCToken() public { totalSupply = 900000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xda0b84a81662ec19ba06b8e902f22964dd69e13d.sol,KRT,"contract KRT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KRT( ) public { totalSupply = 288000000000000000000000000; balanceOf[msg.sender] = 288000000000000000000000000; name = ; symbol = ; }",1
0xc6720198a6f7ee5711e3491b14a5fc821174295c.sol,OPTToken,"contract OPTToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 1000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x256591374c0fb9b2782b754f6e072aa833e62278.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=3100000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf45ee2519203fe8b77c1f05de75cf5f405bf9011.sol,token,"contract token { string public standard = 'https: string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function token(uint256 initialSupply, string tokenName, string tokenSymbol) { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5513401cb13ec32809d238ee19a84405759147cc.sol,INTO_ICO,"contract INTO_ICO is Pausable { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public supply; uint256 public rate; uint256 public weiRaised; uint256 public openingTime; uint256 public closingTime; uint256 public duration; uint256 public minInvest; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public { rate = 50000; wallet = owner; token = ERC20(0x7f738ffbdE7ECAC18D31ECba1e9B6eEF5b9214b7); minInvest = 0.05 * 1 ether; duration = 176 days; openingTime = 1530446400; closingTime = openingTime + duration; }",1
0x4b44f450bc3bfb60dc1a0690cba028e1193cae4f.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x33bd43ba9c71968c132f61246a79c18f9bdf0267.sol,BouncyCoinSelfdrop,"contract BouncyCoinSelfdrop { event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount); uint256 public constant MAX_TOKENS_SOLD = 14000000000 * 10**18; uint256 public constant PRICE = 0.00000006665 * 10**18; uint256 public constant MIN_CONTRIBUTION = 0.01 ether; uint256 public constant HARD_CAP = 500 ether; uint256 oct_17 = 1539734400; uint256 oct_24 = 1540339200; uint256 oct_28 = 1540684800; uint256 public first_round_base_multiplier = 40; uint256 public second_round_base_multiplier = 20; uint256 public third_round_base_multiplier = 0; address public owner; address public wallet; uint256 public tokensSold; uint256 public totalReceived; ERC20 public bouncyCoinToken; Stages public stage; enum Stages { Deployed, Started, Ended }",1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0xd7faef6fd3d3e22037619a756221e38f7f2c9c62.sol,Blogger,contract Blogger { address public author; uint public donationCount; uint public withdrawalDate; struct Donate { address funder; uint value; },1
0x2880163d22b8742a8736b21ae9f8b7f239a22243.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken() { balanceOf[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; symbol = ; decimals = 6; }",1
0x5b8ad60798ec10ad36e52625ff881801240c491a.sol,P4,contract P4 is Ownable { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x72a73495b769682d7b09a9641fa1a95e308fbe08.sol,P4,contract P4 is Whitelist { modifier onlyTokenHolders { require(myTokens() > 0); _; },1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,PPNToken,contract PPNTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function PPNTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x1adbdb4df70c537e5052fc83099495f2ca19002f.sol,VOCC_I044_20181211,"contract VOCC_I044_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xf2bea87df174bee8a862e1395fc97084ac6e6e56.sol,Treasure,"contract Treasure is PlayerBook { uint private seed = 18; uint[3] public gameRound = [1, 1, 1]; uint[3] public maxKeys = [1200, 12000, 60000]; uint[3] public keyLimits = [100, 1000, 5000]; uint public keyPrice = 10 finney; uint public devFee = 10; uint public laffFee1 = 10; uint public laffFee2 = 1; address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5; mapping(uint => mapping(uint => RoundInfo)) public gameInfo; mapping(uint => mapping(uint => mapping(uint => uint))) public userAff; struct RoundInfo { uint module; uint rd; uint count; uint keys; uint maxKeys; uint keyLimits; uint award; address winner; bool isEnd; mapping(uint => uint) userKeys; mapping(uint => uint) userId; }",1
0x57e33c7b740fc5cad7feef358c0c117c7769204b.sol,IDToken,"contract IDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function IDToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593] = _totalSupply; Transfer(address(0), 0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593, _totalSupply); }",1
0x3ada1b57182cab7791adae804a13f9d3dce88652.sol,HeroToken,"contract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable { event Mint(address indexed owner, uint newTokenId, uint _genes); event Transfer(address indexed from, address indexed to, uint tokenId); string public constant name = ; string public constant symbol = ; Hero[] public heroes; mapping(uint => address) tokenIndexToOwner; mapping(address => uint) ownershipTokenCount; mapping(address => uint[]) public ownerTokens; function totalSupply() public view returns (uint) { return heroes.length; }",1
0x48729a6e02e62ff5780e7b0eef200420e802d174.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x7982d996cd2bf4dfa329d91ce139779c23d30fa9.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4b353a668f90025337e7f1fcd4202c41f50a22df.sol,LEToken,"contract LEToken is StandardToken, Owned { string public name = ; string public symbol = ; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 3*10**28; function LEToken(address beneficiary) public { totalSupply_ = INITIAL_SUPPLY; balances[beneficiary] = INITIAL_SUPPLY; }",1
0x504d917d0e941550e9f89df195b969e7430118ee.sol,SRDToken,"contract SRDToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SRDToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd9d42c6d1ebf9083d9514e5ae5f53cd627708c12.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4e3a095e2cad145793ec0f9fb5500e260514065.sol,FRANCE_WINS,"contract FRANCE_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 92352243954837600000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x849919acec8627dde44da59e1a9737985d022b9d.sol,ChatBitToken,"contract ChatBitToken is owned, TokenERC20 { uint256 public sellPrice = 20180418134311; uint256 public buyPrice = 1000000000000000000; uint256 public limitAMT = 0; bool public isPreSales = false; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ChatBitToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x268ec2ff9bb1c27b744f465ff25be9d578096c1e.sol,ASBTToken,"contract ASBTToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0xdae7367a4cecad9b0a37c6bde1263a9a9f7aceb3.sol,Photos,"contract Photos is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Photos() public { symbol = ; name = ; decimals = 6; _totalSupply = 1000000000000; balances[0xE15902055f380BbB907705054800c3f5Bf2Cf72B] = _totalSupply; Transfer(address(0), 0xE15902055f380BbB907705054800c3f5Bf2Cf72B, _totalSupply); }",1
0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce.sol,GUESS_AND_GET_A_PRIZE,contract GUESS_AND_GET_A_PRIZE { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xc80b47a7daedf9356bcac2c5aebb5155f5f4a8a5.sol,Bidding,contract Bidding is Pausable { uint40 public timeEnd; uint40 public lastBidTime; uint256 public highestBid; address public highestBidder; address public operatorAddress; struct Purchase { address winner; uint256 bid; },1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x44df18f1936ea129d1f87e240f099b8bcc52b602.sol,Horger,"contract Horger { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x4032a725b81cfd0cdb519933cc6084d9b22175c0.sol,SimpleDistributor,contract SimpleDistributor { address public owner; ERC20Cutted public token = ERC20Cutted(0xE2FB6529EF566a080e6d23dE0bd351311087D567); function SimpleDistributor() public { owner = msg.sender; },1
0x1e29ca8c874b4dff828297cc2e9856819eea0933.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TOURISTOKEN { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol )MyAdvancedToken(initialSupply, tokenName, tokenSymbol) public {}",1
0x4efd3bf84f40eda370e52df162eccc394cfc8834.sol,Zhoan,"contract Zhoan { string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; address private admin_add; uint private present_money=0; event Transfer(address indexed from, address indexed to, uint256 value); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowances; constructor(uint256 limit,string token_name,string token_symbol,uint8 token_decimals) public { admin_add=msg.sender; name=token_name; symbol=token_symbol; totalSupply=limit * 10 ** uint256(decimals); decimals=token_decimals; balanceOf[admin_add]=totalSupply; }",1
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb47670e40bdf1fbd34753f9ac360e613af9001f4.sol,VOCC_I029_20181211,"contract VOCC_I029_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16.sol,ClapClapToken,"contract ClapClapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ClapClapToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 18000000000000000000000000000; balances[0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864] = _totalSupply; Transfer(address(0), 0xb5D8296f8C55d5BBb51b1DCBD10d90E2d18bf864, _totalSupply); }",1
0xdd40b5a5b00d8913f3e1d6bb5cbbcd18a956b215.sol,REPOExchange,contract REPOExchange is MintableToken { uint public deal_cancel_rate = 0; struct REPODeal { address lender; address borrower; address collateral; address pledge; uint collateralAmount; uint pledgeAmount; uint interest; uint lenderFee; uint borrowerFee; uint pledgeUntil; uint collateralUntil; uint endsAt; int state; },1
0xf265b27c698f9687ed04876e2f99d8be45ecdc57.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1fd9b114da4f081361e789a2a708e9abcab7a3c4.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x5aba53f2ab792de10479cb51b809956c39a910b8.sol,SHERE_PFIV_III_883,"contract SHERE_PFIV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1827925061033140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x77fa1d1ded3f4bed737e9ae870a6f3605445df9c.sol,CryptoPokemon,contract CryptoPokemon { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address devFeeAddress; address tournamentPrizeAddress; function CryptoPokemon () public { contractCreator = msg.sender; devFeeAddress = 0xFb2D26b0caa4C331bd0e101460ec9dbE0A4783A4; tournamentPrizeAddress = 0xC6784e712229087fC91E0c77fcCb6b2F1fDE2Dc2; admins[contractCreator] = true; },1
0x4c54e5ee228b1c917980687a7e54876c340fed7f.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xf06274d668f923f472abdb67ac3dd38ac1f0bde4.sol,BOARDMYTRIP,"contract BOARDMYTRIP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 21000000000000000; balances[0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB] = _totalSupply; emit Transfer(address(0), 0x866F4f65E16C99aEd11D470dB81B5cBBf39d88eB, _totalSupply); }",1
0x1cae8c6ec705520b11f10f773b7010958363318e.sol,Hermes,contract Hermes { using MathForInterset for uint; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint public DAY_VALUE = 0; uint public DAY_LIMIT = 200 ether; uint public DEPOSIT_AMOUNT; uint public PERCENT_FOR_MARKETING = 1500000000; address[] public ADDRESSES; mapping(address => Investor) public INVESTORS; address public ADMIN_ADDR; struct Investor { uint id; uint percentCount; uint deposit; uint date; address referrer; uint reinvestID; uint actualValue; uint stage; uint startReinvestDate; uint dayLimitValue; },1
0xa22563a4b1db2cf75a53ef44118024b0f0e531fd.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x71583506d41a604bc4bf178472ef1a495131cd45.sol,GMQToken,"contract GMQToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5554e04e76533e1d14c52f05beef6c9d329e1e30.sol,Token,"contract Token { mapping (address => uint256) public balanceOf; mapping (uint256 => address) public addresses; mapping (address => bool) public addressExists; mapping (address => uint256) public addressIndex; mapping(address => mapping (address => uint256)) allowed; uint256 public numberOfAddress = 0; string public physicalString; string public cryptoString; bool public isSecured; string public name; string public symbol; uint256 public totalSupply; bool public canMintBurn; uint256 public txnTax; uint256 public holdingTax; uint256 public holdingTaxInterval; uint256 public lastHoldingTax; uint256 public holdingTaxDecimals = 2; bool public isPrivate; address public owner; function Token(string n, string a, uint256 totalSupplyToUse, bool isSecured, bool cMB, string physical, string crypto, uint256 txnTaxToUse, uint256 holdingTaxToUse, uint256 holdingTaxIntervalToUse, bool isPrivateToUse) { name = n; symbol = a; totalSupply = totalSupplyToUse; balanceOf[msg.sender] = totalSupplyToUse; isSecured = isSecured; physicalString = physical; cryptoString = crypto; canMintBurn = cMB; owner = msg.sender; txnTax = txnTaxToUse; holdingTax = holdingTaxToUse; holdingTaxInterval = holdingTaxIntervalToUse; if(holdingTaxInterval!=0) { lastHoldingTax = now; while(getHour(lastHoldingTax)!=21) { lastHoldingTax -= 1 hours; }",1
0x1802fd8f8d49b38c709345f0723de14635cf63d1.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xcd6f276334fd457d79fc04bca5f52393347c47a7.sol,ChessClubLiveChessCoin,"contract ChessClubLiveChessCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ChessClubLiveChessCoin() public { symbol = ; name = ; decimals = 64; _totalSupply = 640000000000000000000000000000000000000000000000000000000000000000; balances[0x04Ede35B1D51c0e814833887b2DdBB5D553070b6] = _totalSupply; Transfer(address(0), 0x04Ede35B1D51c0e814833887b2DdBB5D553070b6, _totalSupply); }",1
0x47709f4c5de9005cc46bf094989a67739a28ff7e.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x4488ed050cd13ccfe0b0fcf3d168216830142775.sol,NetkillerAdvancedTokenAirDrop,"contract NetkillerAdvancedTokenAirDrop { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false; bool public airdropStatus = false; uint256 public airdropTotalSupply; uint256 public airdropCurrentTotal; uint256 public airdropAmount; mapping(address => bool) public touched; event AirDrop(address indexed target, uint256 value); function NetkillerAdvancedTokenAirDrop( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; airdropAmount = 1 * 10 ** uint256(decimals); }",1
0x585a5601e2d95e988dc51a12759c0ca8309f4483.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3a7ebc138fd59ccce16b7968199c2ac7b013bbc0.sol,NewToken,contract NewToken { function NewToken() { totalSupply = 1000000000000000000; name = ; decimals = 9; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x6d06095d75784e948e0f98dd680c798bff1aabaf.sol,MALCoin,"contract MALCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MALCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6a670d25dfb62f5d24c33de9092c38e4123c3dcd.sol,LuckToken,"contract LuckToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function LuckToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x0374b22e0727302e0d8db783726c7ec4989f88ad.sol,GINI,"contract GINI is ERC20, Ownable, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 constant public decimals =18; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; event Burn(address indexed owner, uint256 value); constructor() public { name = ; symbol = ; initialSupply = 122500000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); }",1
0xd8f61d0889245c40a3555aa6386e17a5e4aafa18.sol,RCRchain,"contract RCRchain { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x5175731f308e27855337b902e667c5f36f8ce3d3.sol,MyNewToken,"contract MyNewToken is Token { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function MyNewToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = 100000; totalSupply = 100000; name = ; decimals = 0; symbol = ; }",1
0xee395235ac363725c6b895d8994706cb7050482f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6b18b3808fd9c4401af4839b6aa2971aae7a8aad.sol,ODEEPToken,"contract ODEEPToken is StandardToken , BurnableToken { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address public Bounties_Wallet = 0x70F48becd584115E8FF298eA72D5EFE199526655; address public Team_Wallet = 0xd3186A1e1ECe80F2E1811904bfBF876e6ea27A41; address public OEM_Wallet = 0x4fD0e4E8EFDf55D2C1B41d504A2977a9f8453714; address public LA_wallet = 0xA0AaFDbDD5bE0d5f1A5f980331DEf9b5e106e587; address public tokenWallet = 0x81cb9078e3c19842B201e2cCFC4B0f111d693D47; uint256 public constant INITIAL_SUPPLY = 100000000 ether; uint256 tokenRate = 560; function ODEEPToken() public { totalSupply_ = INITIAL_SUPPLY; balances[Bounties_Wallet] = INITIAL_SUPPLY.mul(5).div(100) ; balances[Team_Wallet] = INITIAL_SUPPLY.mul(8).div(100); balances[OEM_Wallet] = INITIAL_SUPPLY.mul(10).div(100) ; balances[LA_wallet] = INITIAL_SUPPLY.mul(8).div(100) ; balances[tokenWallet] = INITIAL_SUPPLY.mul(69).div(100); endDate = _endDate; emit Transfer(0x0, Bounties_Wallet, balances[Bounties_Wallet]); emit Transfer(0x0, Team_Wallet, balances[Team_Wallet]); emit Transfer(0x0, OEM_Wallet, balances[OEM_Wallet]); emit Transfer(0x0, LA_wallet, balances[LA_wallet]); emit Transfer(0x0, tokenWallet, balances[tokenWallet]); }",1
0xede4edd0c0209db3172a9a07607b47fcf57e6355.sol,EthereumUnionToken,"contract EthereumUnionToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EthereumUnionToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 12500000000000; balances[0xfb58a9af395755a4e95805d76bae231feb01a192] = _totalSupply; emit Transfer(address(0), 0xfb58a9af395755a4e95805d76bae231feb01a192, _totalSupply); }",1
0xaa8aec21ca455873f63bdd570d81674ae5bb73d5.sol,AntPetTempleToken,"contract AntPetTempleToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AntPetTempleToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xff60947022E9e3510974646C530445B51540292D] = _totalSupply; Transfer(address(0), 0xff60947022E9e3510974646C530445B51540292D, _totalSupply); }",1
0x5c62da804298d5972a323c80b539b8e7517a0dde.sol,VENJOCOIN,"contract VENJOCOIN is ERC20Interface{ string public name = ; string public symbol = ; uint public decimals = 18; uint public supply; address public founder; mapping(address => uint) public balances; event Transfer(address indexed from, address indexed to, uint tokens); constructor() public{ supply = 2000000000000000000000000000; founder = msg.sender; balances[founder] = supply; }",1
0xf2855df7f963531f689a8a3d2eb7bf4e0f532c01.sol,EtherX,contract EtherX { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x3a78b1e1fc38e61ed38f0e0e8d417cdf09f52016.sol,ERC20Token,"contract ERC20Token is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ERC20Token() public { symbol = ; name = ; decimals = 8; _totalSupply = 20000000000000000; balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xc7db6a0e78efb4d64bb06359faf83420f04cfb52.sol,play_IQUIZ,contract play_IQUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.00001 ether) { msg.sender.transfer(this.balance); question = ; },1
0xcf7097406448a6b3b109139e52e20ee909e437d2.sol,Ferrarium,"contract Ferrarium is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ferrarium() public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1dbd7059247baf317b11c9e36308fa8582867d4b.sol,EDOGE,"contract EDOGE is ERC223, SafeMath { string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 100000000000 * 10**8; address public owner; bool public unlocked = false; bool public tokenCreated = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function EDOGE() public { require(tokenCreated == false); tokenCreated = true; owner = msg.sender; balances[owner] = totalSupply; require(balances[owner] > 0); }",1
0xaa57e849341a2899110ba676a49302c069251d19.sol,EditionStorage,"contract EditionStorage is BaseStorage { uint public offset = 1000000; uint public offsetIndex = 1; uint8[3] public defaultEditionLimits = [10, 89, 200]; mapping (uint => mapping (uint8 => uint8)) public editionCounts; mapping (uint => mapping (uint8 => uint8)) public editionLimits; mapping (uint => uint) public lastEditionOf; function setOffset(uint _offset) external onlyOwner { offset = _offset; }",1
0x8993db1795b9a7b317b98ebfa4c971f225bf1248.sol,ENKToken,"contract ENKToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1500000000 * 10**18; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; function ENKToken() public { uint256 teamPoolAmount = 420 * 10**6 * 10**18; uint256 advisoryPoolAmount = 19 * 10**5 * 10**18; uint256 companyReserveAmount = 135 * 10**6 * 10**18; uint256 freePoolAmmount = totalTokenSupply - teamPoolAmount - advisoryPoolAmount; balances[teamAddress] = teamPoolAmount; balances[freePoolAddress] = freePoolAmmount; balances[advisoryPoolAddress] = advisoryPoolAmount; balances[companyReserveAddress] = companyReserveAmount; emit Transfer(address(this), teamAddress, teamPoolAmount); emit Transfer(address(this), freePoolAddress, freePoolAmmount); emit Transfer(address(this), advisoryPoolAddress, advisoryPoolAmount); emit Transfer(address(this), companyReserveAddress, companyReserveAmount); addVestingAddress(teamAddress, teamVestingTime); addVestingAddress(advisoryPoolAddress, advisoryPoolVestingTime); addVestingAddress(companyReserveAddress, companyReserveAmountVestingTime); }",1
0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xdb13025b219db5e4529f48b65ff009a26b6ae733.sol,Ubricoin,"contract Ubricoin is IERC20,Ownable,ReentrancyGuard,Haltable{ using SafeMath for uint256; string public name = ; string public symbol = ; string public version = ; uint256 public constant RATE = 1000; uint256 public constant MIN_HOLDER_TOKENS = 10 ** uint256(decimals - 1); uint8 public constant decimals = 18; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public totalSupply_; uint256 public constant TOTAL_SUPPLY = 10000000000 * decimalFactor; uint256 public constant SALES_SUPPLY = 1300000000 * decimalFactor; uint256 public AVAILABLE_FOUNDER_SUPPLY = 1500000000 * decimalFactor; uint256 public AVAILABLE_AIRDROP_SUPPLY = 2000000000 * decimalFactor; uint256 public AVAILABLE_OWNER_SUPPLY = 2000000000 * decimalFactor; uint256 public AVAILABLE_TEAMS_SUPPLY = 3000000000 * decimalFactor; uint256 public AVAILABLE_BONUS_SUPPLY = 200000000 * decimalFactor; uint256 public claimedTokens = 0; address public constant AVAILABLE_FOUNDER_SUPPLY_ADDRESS = 0xAC762012330350DDd97Cc64B133536F8E32193a8; address public constant AVAILABLE_AIRDROP_SUPPLY_ADDRESS = 0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09; address public constant AVAILABLE_OWNER_SUPPLY_ADDRESS = 0xE2d9b8259F74a46b5E3f74A30c7867be0a5f5185; address public constant AVAILABLE_BONUS_SUPPLY_ADDRESS = 0xDE59297Bf5D1D1b9d38D8F50e55A270eb9aE136e; address public constant AVAILABLE_TEAMS_SUPPLY_ADDRESS = 0x9888375f4663891770DaaaF9286d97d44FeFC82E; address[] public holders; address public icoAddress; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => bool) public airdrops; mapping (address => uint256) public holderNumber; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); event Burn(address from, uint256 value); event AirDropped ( address[] _recipient, uint256 _amount, uint256 claimedTokens); event AirDrop_many ( address[] _recipient, uint256[] _amount, uint256 claimedTokens); constructor () public { balances[AVAILABLE_FOUNDER_SUPPLY_ADDRESS] = AVAILABLE_FOUNDER_SUPPLY; holders.push(AVAILABLE_FOUNDER_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_FOUNDER_SUPPLY_ADDRESS, AVAILABLE_FOUNDER_SUPPLY); balances[AVAILABLE_AIRDROP_SUPPLY_ADDRESS] = AVAILABLE_AIRDROP_SUPPLY; holders.push(AVAILABLE_AIRDROP_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_AIRDROP_SUPPLY_ADDRESS, AVAILABLE_AIRDROP_SUPPLY); balances[AVAILABLE_OWNER_SUPPLY_ADDRESS] = AVAILABLE_OWNER_SUPPLY; holders.push(AVAILABLE_OWNER_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_OWNER_SUPPLY_ADDRESS, AVAILABLE_OWNER_SUPPLY); balances[AVAILABLE_TEAMS_SUPPLY_ADDRESS] = AVAILABLE_TEAMS_SUPPLY; holders.push(AVAILABLE_TEAMS_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_TEAMS_SUPPLY_ADDRESS, AVAILABLE_TEAMS_SUPPLY); balances[AVAILABLE_BONUS_SUPPLY_ADDRESS] = AVAILABLE_BONUS_SUPPLY; holders.push(AVAILABLE_BONUS_SUPPLY_ADDRESS); emit Transfer(0x0, AVAILABLE_BONUS_SUPPLY_ADDRESS, AVAILABLE_BONUS_SUPPLY); totalSupply_ = TOTAL_SUPPLY.sub(SALES_SUPPLY); }",1
0xf317f4acfc0d70ccc79a2f24cfbbd7ebc02cfa2e.sol,CryptoStrategiesIntelligence,contract CryptoStrategiesIntelligence is StandardToken { function () public { revert(); },1
0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae.sol,ALEX,"contract ALEX is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ALEX(){ balanceOf[msg.sender] = totalSupply; }",1
0x1db7f8171d82f9fc009f207cd80dd00a54b77560.sol,OllisCoin,"contract OllisCoin is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function OllisCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x713a7dc297156ca54a9112cba0c97c5b76c8bb30.sol,SafeMath,None,1
0xf0902adc8ebe58c4874f371066fd339519ae1d32.sol,SHERE_PFIII_III_883,"contract SHERE_PFIII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1864492808887740000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x45ca8d5458d7f3f7d2f47daae253924cafc2f331.sol,EmiratesCoin,"contract EmiratesCoin { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EmiratesCoin( ) public { totalSupply = 100000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x4c29be83d5dc0bb45faffa6af3f35a7b5862ff54.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0xc3c412b97dc3355f1bd060223e75fb047c869197.sol,HngCoin,"contract HngCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public coinunits; uint256 public ethereumWei; address public tokensWallet; address public owner; address public salesaccount; uint256 public sellPrice; uint256 public buyPrice; bool public isActive; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HngCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; coinunits = 100; tokensWallet = msg.sender; salesaccount = msg.sender; ethereumWei = 1000000000000000000; isActive = true; owner = msg.sender; }",1
0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875.sol,YCToken,"contract YCToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf3b1110c90fe991310a26742ec6c9ceebbc6bdd6.sol,ProjectJ,"contract ProjectJ is owned{ string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ProjectJ( uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter ) public { if(centralMinter != 0) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1ecef026261d7a59926dc9757a002d799fe09d14.sol,ZenswapDistribution,contract ZenswapDistribution is Ownable { token public tokenReward; constructor() public { tokenReward = token(0x0D1C63E12fDE9e5cADA3E272576183AbA9cfedA2); },1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x1b413506fc42e2f04a4e8c57710f850b234d6653.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1b55874c27c98a7b50ab9008f589f6530a48fa06.sol,CFT,"contract CFT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function CFT() public { totalSupply = 200000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0x4cfb59bdfb47396e1720f7ff1c1e37071d927112.sol,ETXToken,"contract ETXToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETXToken() public { totalSupply = 21000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5acd19b9c91e596b1f062f18e3d02da7ed8d1e50.sol,BTClite,"contract BTClite is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; uint256 public constant SUPPLY_CAP = 21000000 * (10 ** uint256(decimals)); address NULL_ADDRESS = address(0); event NoteChanged(string newNote); string public note = ; function setNote(string note_) public onlyOwner { note = note_; NoteChanged(note); }",1
0x742a56a727dac07e0889920b8887d482325f659b.sol,InfiniCoin,"contract InfiniCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 2100000; balances[0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9] = _totalSupply; emit Transfer(address(0), 0x70Fe2224D604424e7e574Dc0E0B96DB609Bb40B9, _totalSupply); }",1
0x544789c586ddaed07ffb23f41ca1334232cb1804.sol,A_TAXPHONE,"contract A_TAXPHONE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x0311dEdC05cfb1870f25de4CD80dCF9e6bF4F2e8; address internal constant partone = 0xC92Af66B0d64B2E63796Fd325f2c7ff5c70aB8B7; address internal constant parttwo = 0xbfd0Aea4b32030c985b467CF5bcc075364BD83e7; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0x69875fbeb23cfd52e7e7c23929c4f50a4fc377c3.sol,ThinSkinLarry,"contract ThinSkinLarry { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ThinSkinLarry( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c6183d10a00cd747a6dbb5f658ad514383e9419.sol,NexxusToken,contract NexxusToken is StandardToken { function () {throw;},1
0xf084d5bc3e35e3d903260267ebd545c49c6013d0.sol,DimonCoin,contract DimonCoin { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000 * 10**8; function name() constant returns (string) { return ; },1
0x74d13225bc488397212e63dc38b497f6aa7a7a69.sol,CoinStacks,"contract CoinStacks { address private admin; uint256 private constant BOTTOM_LAYER_BET = 0.005 ether; uint16 private constant INITIAL_UNLOCKED_COLUMNS = 10; uint256 private maintenanceFeePercent; uint private NUM_COINS_TO_HIT_JACKPOT = 30; uint private MIN_AVG_HEIGHT = 5; uint256 private constant JACKPOT_PRIZE = 2 * BOTTOM_LAYER_BET; mapping(uint32 => address) public coordinatesToAddresses; uint32[] public coinCoordinates; uint256 public reserveForJackpot; mapping(address => uint256) public balances; event coinPlacedEvent ( uint32 _coord, address indexed _coinOwner ); function CoinStacks() public { admin = msg.sender; maintenanceFeePercent = 1; reserveForJackpot = 0; coordinatesToAddresses[uint32(0)] = admin; coinCoordinates.push(uint32(0)); coinPlacedEvent(uint32(0),admin); }",1
0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139.sol,YOUR_CHANCE,contract YOUR_CHANCE { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x57d8b41c0f22c39ba2934cfb038f4460904e3fda.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * (10 ** 18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0xef51c9377feb29856e61625caf9390bd0b67ea18.sol,Bionic,"contract Bionic is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bionic() public { symbol = ; name = ; decimals = 8; _totalSupply = 100000000000000000; balances[0xdD2A5B646bb936CbC279CBE462E31eab2C309452] = _totalSupply; Transfer(address(0), 0xdD2A5B646bb936CbC279CBE462E31eab2C309452, _totalSupply); }",1
0x848d015af507fb3840fee1078ad3a352e0aba055.sol,PUNCToken,"contract PUNCToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PUNCToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43] = _totalSupply; Transfer(address(0), 0xF58a749AB4929b462F33b8A07f1e3b568ed8eC43, _totalSupply); }",1
0xe3d424dffecc3759fcc997f5eba2a01a58585405.sol,ERC20Standard,contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard() public { decimals = 18; symbol = ; name = ; mintable = true; owner = msg.sender; totalSupply = 300000000 * (10 ** decimals); balances[msg.sender] = totalSupply; },1
0xd4236a5b05aafadb21a3e657f6818ad9f20699ae.sol,TxFeatures,contract TxFeatures is BasicToken { struct Tx { uint timestamp; uint amount; },1
0x4d6993c02e6bbcbf6d6183c9b599b1d8c18c32d8.sol,MultiSend,"contract MultiSend { function multisend(address _tokenAddr, address[] dests, uint256[] values) returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c.sol,TokenGameHub,"contract TokenGameHub { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenGameHub( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x57e33c7b740fc5cad7feef358c0c117c7769204b.sol,IDToken,"contract IDToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function IDToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593] = _totalSupply; Transfer(address(0), 0x1Df11F47F11e2a8b9DADeAF8e77DDAa9b355A593, _totalSupply); }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,MemeCore,"contract MemeCore is Ownable { using SafeMath for uint; using ECRecovery for bytes32; mapping (address => uint) withdrawalsNonce; event Withdraw(address receiver, uint weiAmount); event WithdrawCanceled(address receiver); function() payable { require(msg.value != 0); }",1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9.sol,EtherRacingCore,"contract EtherRacingCore is Ownable, Pausable { uint64 _seed = 0; function random(uint64 upper) internal returns (uint64) { _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now)); return _seed % upper; }",1
0x7109eca95daa8f04ddeef3a941fc9bd85bd1510f.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x77d4447a3f042d3c88fae21b28d52b905d6c3dfc.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xbd0706f616b8d465d87583b727df8478ed1496fd.sol,WHOIS,"contract WHOIS is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WHOIS( ) TokenERC20(100000000, , ) public {}",1
0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37.sol,HOPE,"contract HOPE { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HOPE ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x783cf9c6754bf826f1727620b4baa19714fedf8d.sol,ETH_MIXER,contract ETH_MIXER { uint256 feePaid; uint256 creatorFee = 0.001 ether; uint256 totalTransfered; struct Transfer { uint256 timeStamp; uint256 currContractBallance; uint256 transferAmount; },1
0x1d5854e7f4dd81d9d4c09097d3cc736c7771f234.sol,vualt,contract vualt { bytes32 keyHash; address owner; bytes32 wallet_id = 0x162fb6d4a567c777d990e7b7517f9068408a67c8cca7089c7649eeeb349ee523; constructor() public { owner = msg.sender; },1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0x6c832ea5f68bdddd9f2bcba771b46821f5f51a64.sol,AAGTokenERC20,"contract AAGTokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5affe8b1f00df6c8120f7e6bc39713fce11f24ac.sol,VOCC_I049_20181211,"contract VOCC_I049_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x28e860cb89e705de876f858671cb757f650fdae2.sol,WEPAYCOIN,"contract WEPAYCOIN { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 1 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0e171f41ac484d283de20e9a02eac893d430a016.sol,EGYPT_WINS,"contract EGYPT_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1755731937980890000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd0fa079f298c120946695d5c65a15c14355943b7.sol,PODD,contract PODD { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf4dc44f1c618a5e4b6f372347e033ac5e77971a5.sol,CONTINENTAL_AG,"contract CONTINENTAL_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10651142832031200000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3106526a07ee43ca97d794ec3ba3578a47d84cfb.sol,VirMYR,"contract VirMYR { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 1000000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x06fba879216e50fbc51e5b99cc264026a0152374.sol,LUCKen,contract LUCKen is Ownable{ address[] public bebdsds; uint256 _min; uint256 _max; tokenTransfer public bebTokenTransfer; function LUCKen(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x882da60a19c67e481481bace4c0aa93080cde3d7.sol,EthTranchePricing,"contract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib { uint public constant MAX_TRANCHES = 10; mapping (address => uint) public preicoAddresses; struct Tranche { uint amount; uint price; }",1
0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965.sol,Treethereum,contract Treethereum { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xd6173e88d465c546135b71b9a8c4772e97d84552.sol,Paladin,"contract Paladin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Paladin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25dab234f1a0368656846412fa0c33a978315c07.sol,CryptoGoldStandardCoin,"contract CryptoGoldStandardCoin is MintableToken, BurnableToken { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 9; uint public INITIAL_SUPPLY = 100000000000; uint public sellPrice = 0; uint public buyPrice = 2**256-1; uint public priceExpirationBlockNumber = 0; function setPrices(uint newSellPrice, uint newBuyPrice, uint newPriceExpirationBlockNumber) onlyOwner public{ require(newPriceExpirationBlockNumber > block.number); require(newSellPrice < newBuyPrice); sellPrice = newSellPrice; buyPrice = newBuyPrice; priceExpirationBlockNumber = newPriceExpirationBlockNumber; }",1
0xc6567b2be42c208bc6875b9ae6b07d0618738c39.sol,DrunkCoin,contract DrunkCoin is IERC20 { using SafeMath for uint256; uint public _totalSupply = 0; address public owner; string public symbol; string public name; uint8 public decimals; uint256 public rate; uint256 public etherRaised; uint256 public drunkness; bool public icoRunning; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function () public payable { require(icoRunning); require(msg.value > 0); etherRaised += msg.value; uint256 tokens = msg.value.mul(rate); if(drunkness < 50 * 1 ether) { if(drunkness < 20 * 1 ether) { drunkness += msg.value * 20; if(drunkness > 20 * 1 ether) drunkness = 20 * 1 ether; },1
0x6cdccb2b249298419ab3dea261a92fbacf2223ab.sol,BountyEscrow,"contract BountyEscrow { address public admin; mapping(address => bool) public authorizations; event Bounty( address indexed sender, uint256 indexed amount ); event Payout( uint256 indexed id, bool indexed success ); function BountyEscrow() public { admin = msg.sender; }",1
0xee1f0f9731ee93736e219598e6aa441ad36ffc61.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x32cf691c1a07677e68af4b315fdb6a5fe65703ee.sol,Bitwords,contract Bitwords is Migratable { mapping(address => uint) public advertiserBalances; mapping(address => uint) public bitwordsCutOverride; address public bitwordsWithdrawlAddress; uint public bitwordsCutOutof100 = 10; struct advertiserChargeRequest { address advertiser; address publisher; uint amount; uint requestedAt; uint processAfter; },1
0x88be9be70c825b85c5ac81183a07975269b549ca.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x1db45a09efcdd8955b1c3bb855b5a8d333446bff.sol,Share,"contract Share { bool public pause; address public owner; mapping (address => uint) public holds; mapping (address => uint256) public fullfilled; mapping (address => uint256) public sellPrice; mapping (address => uint) public toSell; uint256 public watermark; event PAUSED(); event STARTED(); event SHARE_TRANSFER(address from, address to, uint amount); event INCOME(uint256); event PRICE_SET(address holder, uint shares, uint256 price, uint sell); event WITHDRAWAL(address owner, uint256 amount); event SELL_HOLDS(address from, address to, uint amount, uint256 price); event SEND_HOLDS(address from, address to, uint amount); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x836f95d2a2f5150200c76f45a0b0679542ab6bbd.sol,BANK_IV_PFII_883,"contract BANK_IV_PFII_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 426401924563853000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x1e2bbf1578d1ecd107c95ab550f8c9559a0acca6.sol,Tbyc,"contract Tbyc { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Tbyc() { owner = 0x0a09B58084554786215Dabe7Ab645cB17b1e490E; name = ; symbol = ; decimals = 18; totalSupply = 1314000000000000000000000000; balanceOf[owner] = 1314000000000000000000000000; }",1
0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af.sol,archercoin,"contract archercoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function archercoin() TokenERC20() public {}",1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0xdac7413b79394542cabbdef9d71e89d48862825d.sol,ESlotsCrowdsale,"contract ESlotsCrowdsale is Ownable, ESlotsICOTokenDeployed { using SafeMath for uint256; enum State { PrivatePreSale, PreSale, ActiveICO, ICOComplete }",1
0x6a670d25dfb62f5d24c33de9092c38e4123c3dcd.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6c29b601a00798d9f13d9959f6d156be5032168e.sol,InvestorsStorage,contract InvestorsStorage { address private owner; mapping (address => Investor) private investors; struct Investor { uint deposit; uint checkpoint; },1
0x1e188cfea3ea8fb4f5daa71ce90899cbe3806e6d.sol,WisdomWorldStandardToken,"contract WisdomWorldStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; function WisdomWorldStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xdcaf157faa03309653cd0acddd6947f3417e8dd2.sol,Aeromart,contract Aeromart is Owned { struct Note { bytes32 productID; string text; string image; },1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTToken,"contract EPTToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 64000000 * 10**18; uint256 public totalAllocatedTokens; uint256 public tokensAllocatedToCrowdFund; uint256 public foundersAllocation; address public founderMultiSigAddress; address public crowdFundAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier nonZeroAddress(address _to){ require(_to != 0x0); _; }",1
0x1848df8d1728a8ce654c7faf833b2d7296744fe4.sol,WorldToken,contract WorldToken { string public name = ; string public symbol = ; uint256 public decimals = 6; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 420000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xbb5b059f574204c344cd3096b420fe563f242890.sol,NetkillerAdvancedToken,"contract NetkillerAdvancedToken { address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function NetkillerAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = msg.sender; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x77de6b2729baff72c220115fe03017c57b57baf5.sol,Dancoin,"contract Dancoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Dancoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7] = _totalSupply; Transfer(address(0), 0xDbDF3C3Fa2ec570CbE84Fd1a181Ebc49Efca40b7, _totalSupply); }",1
0x78af82f8924f99cec0afef357105382b8a44708f.sol,EraTokens,"contract EraTokens is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x28e0d54349c00607505aadc713147140fb60ea12.sol,TheQuizGame,contract TheQuizGame { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x06badfdacd3e80e4974e8419153114f6159e4851.sol,CLOUDTOKEN,"contract CLOUDTOKEN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CLOUDTOKEN() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000; balances[0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1] = _totalSupply; Transfer(address(0), 0x37a8a9eBda1b95b788324cFA4d893bEd5c109Cd1, _totalSupply); }",1
0xd7e000213f0ffa6e20e1c953bc49867f8d318bfa.sol,voult,contract voult { bytes32 keyHash; address owner; bytes32 wallet_id = 0x4907b7baf408bca83a16ea4e780a9850c63722909d42337fb3a96414d88b6b76; constructor() public { owner = msg.sender; },1
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); address addressCrowdSale = 0xc699d90671Cb8373F21060592D41A7c92280adc4; function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply.mul(11).div(18); balanceOf[addressCrowdSale] = totalSupply.sub(balanceOf[msg.sender]); name = tokenName; symbol = tokenSymbol; }",1
0x6cc07cb2d1d354f9e2042a26697e7fe9cec4656c.sol,ERGCOIN,contract ERGCOIN is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 800000000 * 10**18; function name() public constant returns (string) { return ; },1
0x37810173b70e86b8435f8c28590e8faceff59044.sol,SatoMotive,"contract SatoMotive is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SatoMotive() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf44970e29510EDE8fFED726CF8C447F7512fb59f] = _totalSupply; Transfer(address(0), 0xf44970e29510EDE8fFED726CF8C447F7512fb59f, _totalSupply); }",1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownToken,"contract ExoTownToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public icoContract = 0x0; modifier onlyIcoContract() { require(msg.sender == icoContract); _; }",1
0x75284b2afcd520613c2da5c71be6b3847a0acbf2.sol,MyToken,contract MyToken is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; function MyToken () public { balanceOf[msg.sender] = 7998000000000000000000000000; totalSupply =7998000000000000000000000000; name = ; symbol = ; decimals = 18; },1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1c5f43710a1776b0ea7191b7ead75d4b98d69858.sol,PskERC20,"contract PskERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public lockedUntil; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PskERC20() public { uint256 initialSupply = 68072143; totalSupply = initialSupply * 10 ** uint256(decimals); name = ; symbol = ; balanceOf[address(this)] = totalSupply; emit Transfer(address(this), address(this), totalSupply); _transfer(address(this),0x8b89dc977c1D4e1B78803342487dEcee0a2Ba02c,378000000000000000000000); _transfer(address(this),0xC19c9dd81D4b8B3FaDE83eEF6f2863Ac9B76B7FB,34912500000000000000000); _transfer(address(this),0x5Ea29C0a72Ab68bE62c7942d5b3aD69d4f29d4dA,1640625000000000000000000); _transfer(address(this),0x14a926e168278cC0c00286837de51e29F814b8D3,12250000000000000000000); _transfer(address(this),0xD46d9fE2d8f991913Bd4f77536abBa4598EA29A9,131250000000000000000000); _transfer(address(this),0x0019312D39a13302Fbacedf995f702F6e071D9e8,175000000000000000000000); _transfer(address(this),0x0FBd0E32aFE5082FED52837d96df7E34a9252bC3,8750000000000000000000); _transfer(address(this),0x10E6a8f9Dbe3A6BF4aB8D07233A45125Fb411eF1,5250000000000000000000); _transfer(address(this),0x93ED3C6a78724308095C34eFD0dcdA693f515BE7,1750000000000000000000); _transfer(address(this),0xd113f63Fec7F296FFE838939Bfd3775339d79e44,3500000000000000000000); _transfer(address(this),0x83aCbBE5f22841799647De7c4aC9f0fa61691975,87500000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,1750000000000000000000); _transfer(address(this),0xEfFefF8De1C5f15FE6545a32C1Aaa372c6023d77,49000000000000000000000); _transfer(address(this),0x5239249C90D0c31C9F2A861af4da7E3393399Cb9,8750000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,28526399998250000000000); _transfer(address(this),0x55A0B2b1A705dD09F15e7120cC0c39ACb9Ea7978,35000000000000000000000); _transfer(address(this),0x8a501A75eE3d0C808b39dd2bc2760289F9785500,3500000000000000000000); _transfer(address(this),0x752452F7759E58C50A7817F616B5317275924F78,272144811750000000000); _transfer(address(this),0x639631fc10eA37DF5540E3A6FAf1Bd12Ab02A02c,28000000000000000000000); _transfer(address(this),0x8A0Dea5F511b21a58aC9b2E348eB80E19B7126ab,98000000000000000000000); _transfer(address(this),0x231A9614c5726df24BB385F4A1720d6408302fde,42000000000000000000000); _transfer(address(this),0xCE2daE844a2f473Cb10e72eA5B5cd82ce1C86c76,207900000000000000000); _transfer(address(this),0x9829D08FE48a402fF1A3e9faD0407023ffd947e7,1890000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,5670000000000000000000); _transfer(address(this),0x7C31755f9374c238248aD19EABf648c79FF3A5eD,945000000000000000000); _transfer(address(this),0x9Ce1B1B62344ADdca64Aac6338da369f395367DE,5670000000000000000000); _transfer(address(this),0x81a1Ff97AE6DB89f5FD1B0Fb559Bd7C61e4BA960,189000000000000000000); _transfer(address(this),0xd4E6c27B8e5805318295f3586F59c34B60495992,1890000000000000000000); _transfer(address(this),0xc458F28FC72bA8dFEE6021763eCAAF21033839e8,3780000000000000000000); _transfer(address(this),0x2188f6212CE37dCbfeC7e0167D68d9e5E5F07e3a,1890000000000000000000); _transfer(address(this),0xd1EfE47c8610678DE2192F03B8dA49b25Be746fb,5670000000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,473185571040000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,463050000000000000000); _transfer(address(this),0x5BFd06c00CCf7c25984D1Fb4D153Abfdb999984c,189000000000000000000); _transfer(address(this),0xAAA0779B11BC0b03f00F82427f4C14F9C2dBB6aB,2835000000000000000000); _transfer(address(this),0x4DE5BA1869Dfd12eE429eE227EAEa33b295AE7C9,378000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,623700000000000000000); _transfer(address(this),0xbA6F61ca597510E8dc86c7f3e4fe1d251e8C5B89,642600000000000000000); _transfer(address(this),0x1a08bac3FA02C1aC7e12F8b961e3B2ed6CE31E00,18879909300000000000000); _transfer(address(this),0x4745b5130aC32Ed0c541442440C37284d475a166,2627100000000000000000); _transfer(address(this),0xd00266409A2fd099FEcbFd0340F7A965CeeceCF2,378000000000000000000); _transfer(address(this),0x26C0E0772EA9ABd416667ee5FFf978cb1F54720A,1890000000000000000000); _transfer(address(this),0x2874E22Bb3a2E378cabaa1058Aa09a23087829d0,283500000000000000000); _transfer(address(this),0x19682FE3B7BB4D0Baba4c53fa1C697c9Ba2Fce02,75600000000000000000000); _transfer(address(this),0xA4C8ed0dB08a9EfCc502f390E5E75c51851B870A,1341900000000000000000); _transfer(address(this),0x9ED09BD3c7BB325cCb84D793Ad9ce42a068D7Ef1,3780000000000000000000); _transfer(address(this),0x0b72805FFa5CB6E1187223e8EEF97dA6a6a0950c,5670000000000000000000); _transfer(address(this),0xe19938a75140d8e16aF4bf5F08D97B4cd8C62317,3780000000000000000000); _transfer(address(this),0xEf4a2C6b92024E359e107Aa6Acd17F6391855B5a,618030000000000000000); _transfer(address(this),0x7967149ed2FBaA14D1E74D26505573C803c0D698,563846285520000000000); _transfer(address(this),0x446471EAc3Ac288b9bECb3ca814daefEB867Bbc8,472500000000000000000); _transfer(address(this),0xd89F659402245781daC5c11CBaBB86B79484E696,94500000000000000000000); _transfer(address(this),0x8252e834763933124f80177b08e6F60A90DA0919,1890000000000000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,2800000000000000000000); _transfer(address(this),0x664f129b55a6948900577bad77D9b6a792b50743,140000000000000000000); _transfer(address(this),0x8166AD8690A3E7BFb2D6B45006eBB5d111628a59,663452885200000000000); _transfer(address(this),0x4997DF0Ef9f05A5c136f991b5ee088BBF5526f42,423906000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,554483286000000000000); _transfer(address(this),0x7CDE9cD90afaEc5a40480DDA05C8Cf4ec39cF643,140000000000000000000); _transfer(address(this),0x0f929995C0c8a00E212dF802f57b5f63D7640FE7,8400000000000000000000); _transfer(address(this),0x1e7D081e2Bf261F99918d02366ed8F3B524e39EC,840000000000000000000); _transfer(address(this),0x0354dEd5058c5AB4aa42F8260c2Cc08904e7eE09,329000000000000000000); _transfer(address(this),0x73b3166784F4C878E6eea15665F6F35651141984,294000000000000000000); _transfer(address(this),0x6133c06Be78f1D2AB67b4cd8f854C90167dBd066,680000000000000000000000); _transfer(address(this),0xFf342491cC946B8Cd9d7B48484306a0C18B814Dd,416666666666667000000000); _transfer(address(this),0x4fd60c47bf9437954557d0Ec46C68B63858B2862,3900000000000000000000); _transfer(address(this),0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26,3024002711476670000000000); _transfer(address(this),0x820baEBb0f077C746DaF57af4DCD38bEACeE22ed,100000000000000000000); _transfer(address(this),0x13A7b665c91259873dFF9D685811Bc916b5E403c,100000000000000000000); _transfer(address(this),0xBa122378B1b5A5D73B2778Aa6C724c4D43ebf966,100000000000000000000); _transfer(address(this),0xd495826cABB093e7dCA498D1a98e4dc55e0C29Db,100000000000000000000); _transfer(address(this),0x3dC21E7Eca79C7b9890dF4AFbe2E0ba2f17512C3,100000000000000000000); _transfer(address(this),0xA823648A8251B44b09873723A32831f2f206acD5,100000000000000000000); _transfer(address(this),0x68b1951F36e77324924170cAE9Ca2aa03dc1e0AC,100000000000000000000); _transfer(address(this),0x1CE853FC613D900FD9eB004d2D7837E97D40a23C,100000000000000000000); _transfer(address(this),0x0AeEe2337F2Cc88AB7cadc619205b22C7Ee2f05A,100000000000000000000); _transfer(address(this),0x4C844FEf1014bE0862167925842c4835354Dc4B6,100000000000000000000); _transfer(address(this),0x24f56B8e6b0bc478c00a8055600BA076777c5cFa,100000000000000000000); _transfer(address(this),0xDe29bB2E66F1731B187919bB34f4Dd793CebbE86,100000000000000000000); _transfer(address(this),0xE792690B3783c08823049b1DCe5CC916001e92Cd,340000000000000000000000); _transfer(address(this),0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8,340000000000000000000000); _transfer(address(this),0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7,340000000000000000000000); _transfer(address(this),0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4,650000000000000000000000); _transfer(address(this),0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F,750000000000000000000000); _transfer(address(this),0xa537E2887B9887Cb72bDd381C9E21DA4856bb60d,382000000000000000000000); _transfer(address(this),0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c,510500000000000000000000); _transfer(address(this),0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E,397500000000000000000000); _transfer(address(this),0xf2944172b735609b2EcEeadb00179AC88f6aA431,630000000000000000000000); _transfer(address(this),0x3e6330A1a05a170b16Dabfb2ECe7E44453CD5A36,2333333333333320000000000); _transfer(address(this),0x21028AAeb61f39c68380928e7d6297C47d09CdD9,3466666666666660000000000); _transfer(address(this),0x98Dc9E2b1AA2A29D71eec988e45022Ad774f6bF6,2000000000000000000000000); _transfer(address(this),0xdc3603FB59BDb00A527c9D8143Cda58d3A1Ade8d,1866666666666670000000000); _transfer(address(this),0xE85D25FA06b045396C2Ce811F461d3e408DcD267,2666666666666660000000000); _transfer(address(this),0x79A69503eC313cAf56A83Ff05A9C5a7798504eD4,1000000000000000000000000); _transfer(address(this),0x0B4Db8D4e13EeB6aac5D2e7fB770Ac118bDE8dc6,1666666666666670000000000); _transfer(address(this),0xD6d957139941af45B452b69783A19C77a6883ea8,1733333333333330000000000); _transfer(address(this),0x237Abf82405C542A803642DbbbFA9639Df9cA33D,2933333333333320000000000); _transfer(address(this),0x78961633419f69032D874c27D1d789E243c2B8Ed,333333333333332000000000); _transfer(address(this),0xB62FD8775e4938A352cb20E632654CC2f5e76829,564202334630000000000); _transfer(address(this),0x1449dEb2db6dFD95299776E3F77aCe0ffFFD0198,225225225230000000000); _transfer(address(this),0xa77694c0C0d0e81Ca1a21c8A6498bb2c0A1329f2,1922178988330000000000); _transfer(address(this),0xD996263209B2dfbA4Bbba5D7F37705DdE265116E,10000000000000000000000); _transfer(address(this),0xa854fF673bf41Cf79c2E4C799Af94d5f275D8D5e,333333333330000000000); _transfer(address(this),0x3353bfCA0DF0C585E94b2eE2338572f46c8986Dd,1000000000000000000000); _transfer(address(this),0x72417A054Efa81d50252cC5ceCc58716cdD99Ac7,149880000000000000000000); _transfer(address(this),0xB16e325f3458d8A6658b5f69e7986686428Ecf58,1426866000000000000000000); _transfer(address(this),0xd1eFcC88EFBEAe11FF3F2dF5A49B24D519cdBbf2,857144000000000000000000); _transfer(address(this),0x6517f439AD90ecAc307EC543404D998C0Ec965B6,2000000000000000000000000); _transfer(address(this),0x87a4E93f1acCf6dcf536107d9786d3b344D2ec05,1666667000000000000000000); _transfer(address(this),0xbDba9C3E780FB6AF27FD964e2c861b35deE0c318,3000000000000000000000000); _transfer(address(this),0xaBeEa80693B860ae2C47F824A8fDAD402AEbE100,2500000000000000000000000); _transfer(address(this),0xB83dB1E8E14A7A40BB62F2A8EBce5BBD07EA3F62,1666666666666660000000000); _transfer(address(this),0x51f96736Bbc6348cbF33A224C3Cc5231A87a1e43,2000000000000000000000000); _transfer(address(this),0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e,5000000000000000000000000); _transfer(address(this),0xF062193f4f34Ac4A13BAdd1bB8e7E4132637C1E7,3500000907170760000000000); _transfer(address(this),0x4ed9001076B69e19b397aC719D235F4f0786D7C5,4079000000000000000000000); _transfer(address(this),0x7A52a16f34576CBc028c1840825cDa9323DA4890,2268334000000000000000000); _transfer(address(this),0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90,2268334000000000000000000); _transfer(address(this),0x7518d5cB06891C62621871b1aC3bdE500BD533a0,2268334000000000000000000); _transfer(address(this),0xA3f3f84844A67c618DE06441d2970321e70bdCe7,700000000000000000000000); _transfer(address(this),0xBEc13832bb518629501fe7d07caAB099E85e1c50,700000000000000000000000); _transfer(address(this),0xF6F209C6C031b1560D073d5E82b380C40cD02469,300000000000000000000000); _transfer(address(this),0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c,55500000000000000000000); _transfer(address(this),0x9b818b7B401908671CbE2bf677F7F3361653Fdb5,35000000000000000000000); _transfer(address(this),0xd5C56952e1Aad42f20075666b123F42334969297,30000000000000000000000); _transfer(address(this),0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da,45000000000000000000000); _transfer(address(this),0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9,40000000000000000000000); lockedUntil[0xD384C81eFEF96CB32Ae8Ad52cC85630eABC75E26]=1554508800; lockedUntil[0xE792690B3783c08823049b1DCe5CC916001e92Cd]=1570320000; lockedUntil[0x08a62f6DFd9f4334478B5CC038d0584fEACe9ac8]=1570320000; lockedUntil[0xd987728d110e0A270dc4B6E75e558E0F29E0c2c7]=1570320000; lockedUntil[0x25A8178d085a600Eb535e51D3bCD4Fea773E81e4]=1554508800; lockedUntil[0xE9cB39c9AfCf84C73FB3e8E8a3353d0bfD2Baa0F]=1554508800; lockedUntil[0x1d4Aa2b232Af68599864efE1C0Fbf4F4b5E6112c]=1554508800; lockedUntil[0xCbEde66A699C3a5efF63c5E234D7b8149f353c4E]=1570320000; lockedUntil[0xf2944172b735609b2EcEeadb00179AC88f6aA431]=1554508800; lockedUntil[0x2FBE4cdb2f46dc12d86A1289323a7D0545Fe2b5e]=1554508800; lockedUntil[0x7A52a16f34576CBc028c1840825cDa9323DA4890]=1601942400; lockedUntil[0x5AA37C6176b6E0612151BE56A8a0372C9DB7DE90]=1601942400; lockedUntil[0x7518d5cB06891C62621871b1aC3bdE500BD533a0]=1601942400; lockedUntil[0xA3f3f84844A67c618DE06441d2970321e70bdCe7]=1554508800; lockedUntil[0xBEc13832bb518629501fe7d07caAB099E85e1c50]=1554508800; lockedUntil[0xF6F209C6C031b1560D073d5E82b380C40cD02469]=1570320000; lockedUntil[0xf0586C3e0CAe135E90dDe857b5f53C8B29Ebc77c]=1570320000; lockedUntil[0x9b818b7B401908671CbE2bf677F7F3361653Fdb5]=1554508800; lockedUntil[0xd5C56952e1Aad42f20075666b123F42334969297]=1554508800; lockedUntil[0xB6ceCEAbfBd07ac0440972C0c0c4129249de29Da]=1554508800; lockedUntil[0x0eaa51bef06694e1e0C99f413dcd7d3beE110Fb9]=1554508800; }",1
0x06779e2a75cc5b7ad2c14cf98d88cf2cfcfcc6f1.sol,lucky9io,"contract lucky9io { uint public house_edge = 0; uint public jackpot = 0; uint public total_wins_wei = 0; uint public total_wins_count = 0; uint public total_tickets = 0; bool private game_alive = true; address private owner = 0x5Bf066c70C2B5e02F1C6723E72e82478Fec41201; address[] private entries_addresses; bytes32[] private entries_blockhash; uint private entries_count = 0; modifier onlyOwner() { require(msg.sender == owner, ); _; }",1
0x4c3a22fc1f2f3307a01f71d266e01a06d86fb0f1.sol,Hold,"contract Hold is Ownable { uint public deadline = 1546230000; uint public amountRaised; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function () payable public { uint amount = msg.value; amountRaised += amount; }",1
0x4027c7262554ba72ccc3e346c6b71794299d3b99.sol,CWT,"contract CWT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CWT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x693e3857aa48bb2902fd12f724dc095622e61afc.sol,DopeToken,"contract DopeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DopeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000; balances[0xe2f54E82B8E413537B95e739C2e80d99dE40C67B] = _totalSupply; Transfer(address(0), 0xe2f54E82B8E413537B95e739C2e80d99dE40C67B, _totalSupply); }",1
0x560431a917c5bf4f5831935a199d6516472bcff1.sol,POFOMO,contract POFOMO { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x32cd77627ddb1dd8bda46e35c6e68aadfe916066.sol,RedlineFinancialLabCoin,"contract RedlineFinancialLabCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RedlineFinancialLabCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x116312c3471C2e7C34C52782D0399eBE601f3F30] = _totalSupply; Transfer(address(0), 0x116312c3471C2e7C34C52782D0399eBE601f3F30, _totalSupply); }",1
0xedbe509e65f7425016265a049941311497c0099c.sol,LuckyYouContract,contract LuckyYouContract is Pausable { using SafeMath for uint256; LuckyYouTokenInterface public luckyYouToken = LuckyYouTokenInterface(0x6D7efEB3DF42e6075fa7Cf04E278d2D69e26a623); bool public airDrop = true; function setAirDrop(bool _airDrop) public onlyOwner { airDrop = _airDrop; },1
0x1b7da22f43059858f045ffb1362630712d5d2f0c.sol,VOTOToken,"contract VOTOToken { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xee8c1500e3b5d8463980f8cfd8f2d58b692c4980.sol,ElementsToken,"contract ElementsToken is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.002 ether; uint256 private constant PROMO_CREATION_LIMIT = 5000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0x5bcff9bf8cdaa9df4fec7fb1bd9a51cf99ac57ac.sol,Eps,contract Eps { uint timeout; mapping (address => address) inviter; function bytesToAddr (bytes b) constant returns (address) { uint result = 0; for (uint i = b.length-1; i+1 > 0; i--) { uint c = uint(b[i]); uint to_inc = c * ( 16 ** ((b.length - i-1) * 2)); result += to_inc; },1
0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6.sol,Dividend,contract Dividend { struct Record { uint balance; uint shares; uint index; },1
0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939.sol,ARXpresale,"contract ARXpresale is owned, safeMath { address public admin = owner; ERC20Interface public tokenReward; address public foundationWallet; address public beneficiaryWallet; uint256 public tokensPerEthPrice; uint256 public amountRaisedInWei; uint256 public fundingMinCapInWei; uint256 public fundingMaxCapInWei; uint256 public fundingRemainingAvailableInEth; string public currentStatus = ; uint256 public fundingStartBlock; uint256 public fundingEndBlock; bool public isPresaleClosed = false; bool public isPresaleSetup = false; event Buy(address indexed _sender, uint256 _eth, uint256 _ARX); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Refund(address indexed _refunder, uint256 _value); event Burn(address _from, uint256 _value); mapping(address => uint256) balances; mapping(address => uint256) fundValue; function ARXpresale() onlyOwner { admin = msg.sender; currentStatus = ; }",1
0x70538834e68efe5061a11c4999fc050e55ae2b68.sol,AYA,"contract AYA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 8000000000000000000000000; balances[0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b] = _totalSupply; emit Transfer(address(0), 0x7fa7f2ec928cd9b8cf2fed0de18d6a519a9ffb4b, _totalSupply); }",1
0x260cd379410a753cb602c76ae59bfba68246e789.sol,AdvancedToken365,"contract AdvancedToken365 is owned, Token365 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function AdvancedToken365( uint256 initialSupply, string tokenName, string tokenSymbol ) Token365(initialSupply, tokenName, tokenSymbol) public {}",1
0x5833dbb0749887174b254ba4a5df747ff523a905.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7220e734c524e8938a1553ae18e3c68aec8bf955.sol,SmsCertifier,contract SmsCertifier is Ownable { event Confirmed(address indexed who); event Revoked(address indexed who); modifier only_certified(address _who) { require(certs[_who].active); _; },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,HelloGoldSale,"contract HelloGoldSale is Pausable, SafeMath { uint256 public decimals = 8; uint256 public startDate = 1503892800; uint256 public endDate = 1504497600; uint256 tranchePeriod = 1 weeks; HelloGoldToken token; uint256 constant MaxCoinsR1 = 80 * 10**6 * 10**8; uint256 public coinsRemaining = 80 * 10**6 * 10**8; uint256 coinsPerTier = 16 * 10**6 * 10**8; uint256 public coinsLeftInTier = 16 * 10**6 * 10**8; uint256 public minimumCap = 0; uint256 numTiers = 5; uint16 public tierNo; uint256 public preallocCoins; uint256 public purchasedCoins; uint256 public ethRaised; uint256 public personalMax = 10 ether; uint256 public contributors; address public cs; address public multiSig; address public HGT_Reserve; struct csAction { bool passedKYC; bool blocked; }",1
0x377748ddc51b3075b84500a6ed95d260a102d85f.sol,TuneToken,"contract TuneToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TuneToken() public { totalSupply = 3e9 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x52a5e1a56a124dce84e548ff96122246e46d599f.sol,MultiGamesToken,"contract MultiGamesToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MultiGamesToken( ) TokenERC20(10000000, , ) public {}",1
0xf02904cbf8e5134aeaf45626e96b782ed233fe04.sol,BWCToken,contract BWCToken is Ownable{ uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 4; uint constant start = 1517418000; uint constant period = 87; uint256 public constant hardcap = 25 * 1000000 * (10 ** uint256(decimals)); bool public transferAllowed = true; bool public mintingFinished = false; modifier whenTransferAllowed() { if(msg.sender != owner){ require(transferAllowed); },1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,Storage,"contract Storage is SafeMath, StringMover { function Storage() public { controllerAddress = msg.sender; }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint256 value; bytes data; bytes4 sig; },1
0x36efee477f68c136139abeb219be6c2254711d0a.sol,FLiK,"contract FLiK is owned { string public standard = ; string public name; string public symbol; uint8 public decimals = 14; uint256 public totalSupply; bool public locked; uint256 public icoSince; uint256 public icoTill; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event IcoFinished(); uint256 public buyPrice = 1; function FLiK( uint256 initialSupply, string tokenName, string tokenSymbol, uint256 _icoSince, uint256 _icoTill ) { totalSupply = initialSupply; balanceOf[this] = totalSupply / 100 * 90; name = tokenName; symbol = tokenSymbol; balanceOf[msg.sender] = totalSupply / 100 * 10; Transfer(this, msg.sender, balanceOf[msg.sender]); if(_icoSince == 0 && _icoTill == 0) { icoSince = 1503187200; icoTill = 1505865600; }",1
0xbd04617f9bee584c0c45923a2d7971a64cea9297.sol,ADSToken,contract ADSToken { string public name = ; string public symbol = ; uint256 public decimals = 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1e27; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6ba0841cd866e2d914d38f4af0643b7a982b3b51.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x041fe8df8b4aaa868941eb877952f17babe57da5.sol,SafeMath,None,1
0x53c2159fa4690ccaa773086a137fb1cd17f65f35.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b.sol,FTWCoin,contract FTWCoin is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function FTWCoin() public { balances[msg.sender] = 250000000000000000000000000; totalSupply = 250000000000000000000000000; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 10000; fundsWallet = msg.sender; },1
0x5292eb1d4f669e697ad14e55d151013969485711.sol,WorkValley,"contract WorkValley { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WorkValley( ) public { totalSupply = 1000000000 * 10 ** 8; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1.sol,SAFE_GIFT,contract SAFE_GIFT { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x945d886e3859cc683c368ee3390b1c2c332dde46.sol,MultiTransfer,"contract MultiTransfer { event Transacted( address msgSender, address toAddress, uint value ); function multiTransfer( address _from, address[] _to, uint[] _amount ) public payable { require(msg.sender == _from); require(_to.length == _amount.length); uint256 ui; uint256 amountSum = 0; for (ui = 0; ui < _to.length; ui++) { require(_to[ui] != address(0)); amountSum = amountSum + _amount[ui]; }",1
0xc7df14a8289efe7a2d3399387302fdf86e7adc4e.sol,IXToken,contract IXToken { string public name = ; string public symbol = ; uint256 public decimals = 4; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 200000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x190e2028060fa49adefa5e1f47c8d7be0cbe5063.sol,TRONIXGOLD,"contract TRONIXGOLD is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TRONIXGOLD() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x95a96a9fab04Fdf71f37807246408973b30d29e1] = _totalSupply; Transfer(address(0), 0x95a96a9fab04Fdf71f37807246408973b30d29e1, _totalSupply); }",1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0xc81068cd335889736fc485592e4d73a82403d44b.sol,Factories,contract Factories { GooToken constant goo = GooToken(0xdf0960778c6e6597f197ed9a25f12f5d971da86c); Units units = Units(0x0); Inventory inventory = Inventory(0x0); mapping(address => uint256[]) private playerFactories; mapping(uint256 => mapping(uint256 => uint32[8])) public tileBonuses; mapping(address => bool) operator; address owner; uint256 public constant MAX_SIZE = 40; constructor() public { owner = msg.sender; },1
0xe0c3f2deaa356fea4b6a1355674a766cb5821589.sol,MineableToken,"contract MineableToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public supplyCap; mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; event Approval( address indexed owner, address indexed spender, uint value ); event Transfer( address indexed from, address indexed to, uint256 value ); event Burn( address indexed from, uint256 value ); function MineableToken() public { decimals = uint8(18); supplyCap = 833333333 * 10**uint256(decimals); name = ; symbol = ; }",1
0x41e50bb0dfd21cd201b16a3d2f945920675a4408.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 1000000; },1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x282ee54f8ecda53d6bb77df4a4134738375a0664.sol,XToken,"contract XToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function XToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xf0552ae7f174e43479159f87a66417cca31eb54b.sol,VOCC_I054_20181211,"contract VOCC_I054_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xed678608de045609da5a7a459c5416fe25bc5532.sol,BLPZ,"contract BLPZ is NFTokenMetadata, NFTokenEnumerable { function mint(address _to, uint256 _tokenId)external { super._mint(_to, _tokenId); }",1
0xda908dcf358351d79e5051a7118c9318f67fcfc9.sol,Troo,"contract Troo is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function Troo ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x888934de736b7f5244f006a655f3bcd71ef0979d.sol,Oryx,"contract Oryx is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Oryx() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000; balances[0x439d5924500Aa4E2F0cD5A0d84fdd9c8Cb983418] = _totalSupply; Transfer(address(0), 0x439d5924500Aa4E2F0cD5A0d84fdd9c8Cb983418, _totalSupply); }",1
0xaf860eb1d70ffc3842c6a1004ce89a7ade043f25.sol,BurgerKapija,"contract BurgerKapija is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BurgerKapija() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000000; balances[0x6c50ad33f6b4414b7be304cc69725d212ebf138a] = _totalSupply; Transfer(address(0), 0x6c50ad33f6b4414b7be304cc69725d212ebf138a, _totalSupply); }",1
0x12b470a5c9055d312e1af0259b65976dce608e5d.sol,Lighthouse,"contract Lighthouse { address public auth = msg.sender; Searcher seeker; uint value; uint maxAge; modifier onlyAuth { require(auth == msg.sender, ); _; }",1
0x7045c5c158aecd68eed18671cc8775fc7f7d6e70.sol,DHCToken,contract DHCToken is StandardToken { string public name = ; string public symbol = ; address owner; uint public decimals = 18; uint public INITIAL_SUPPLY = 40000000*10**18; constructor(address _owner) public { owner = _owner; totalSupply = INITIAL_SUPPLY; balances[_owner] = INITIAL_SUPPLY; },1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x1b2ced22e089d752d2c27e90d95599a7a9699774.sol,DappsGallery,contract DappsGallery is ERC721Token { string[] public dns; mapping (string=>Redirect) redirects; struct Redirect { string uri; bool registered; },1
0x5be7d692a8adc3dff8296f5f316a736b02dcef24.sol,ECTCOIN,"contract ECTCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 18000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x07b2f3fbfda96208704e14068a50144f2ec6a37c.sol,Evocoin,contract Evocoin{ string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint public constant totalSupply = 7500000000*10**5; uint userIndex = 0; address public constant owner = 0x34A4933de38bF3830C7848aBb182d553F5a5D523; struct user{ address _adress; uint _value; },1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0xee8d31fb0c278de147e621c6cee5905c1a5d4323.sol,YBCLiveToken,"contract YBCLiveToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YBCLiveToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x6f9064180354a6773db5af7226a40614c8dbce39.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; for (i = 0; i < dests.length; i++) { ERC20(_tokenAddr).transfer(dests[i], values[i]); }",1
0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b.sol,Fibonzi,contract Fibonzi{ address owner; uint8 public poolCount = 0; uint8 public playersCount = 0; uint8 public transactionsCount = 0; uint8 public fibonacciIndex = 0; uint8 public fibokenCreatedCount = 0; uint8 public fibokenUsedCount = 0; uint fibonacciMax = 18; uint public poolsToCreate = 0; address[] public playersList; struct Player{ address wallet; uint balance; },1
0xed51040da497901107870ece117f9ed8df4f4e52.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9.sol,CustodyStorage,contract CustodyStorage { BBODServiceRegistry public bbodServiceRegistry; mapping(address => bool) public custodiesMap; uint public custodyCounter = 0; address[] public custodiesArray; event CustodyRemoved(address indexed custody); constructor(address _serviceRegistryAddress) public { bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress); },1
0x5b463c4e19358b4eaf010cf24244bf140541a63e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; event FrozenFunds(address target, bool frozen); mapping (address => bool) public frozenAccount; function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd628af3abb55fc8a5e6095fbcf95e508b7bc6724.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0x17c68823b18d0b6397757dcd90e0758406365f81.sol,ERC20Standard,contract ERC20Standard { uint public totalSupply; string public name; uint8 public decimals; string public symbol; string public version; mapping (address => uint256) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; },1
0xaa88e4e83055f144a9f265a217d5727c8b0df57a.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => uint) public lockAmount; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdb8ea10793899f6323ecd6b2cd510c005f14b116.sol,ENYCOIN,"contract ENYCOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function ENYCOIN() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = 500000000 * (10 ** uint256(decimals)); name = ; symbol = ; }",1
0x0cf55facee33ed2827d78ad2d113efe0aa80a92b.sol,SafeMath,None,1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,RGEToken,contract RGEToken is EIP20 { string public name = ; string public symbol = ; uint8 public decimals = 8; address owner; address public crowdsale; uint public endTGE; string public version = ; uint256 public totalSupply = 1000000000 * 10**uint(decimals); uint256 public reserveY1 = 300000000 * 10**uint(decimals); uint256 public reserveY2 = 200000000 * 10**uint(decimals); modifier onlyBy(address _account) { require(msg.sender == _account); _; },1
0xeb41d9b0326b787a7c767478cfc4d060c6aa9dbd.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0x83ff9580519f9746bc73a1d8048a2f8a8c8c4ca8.sol,ERC20,"contract ERC20Interface{ string public name; string public symbol; uint8 public decimals; uint public totalSupply; function transfer(address _to,uint256 _value) returns(bool success); function transferFrom(address _from,address _to,uint256 _value) returns(bool success); function approve(address _spender,uint256 _value) returns(bool success); function allowance(address _owner,address _spender) view returns(uint256 remaining); event Transfer(address indexed _from,address indexed _to,uint256 _value); event Approval(address indexed _owner,address indexed _spender,uint256 _value); }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x1eeeaffe28d463dcf2c1898d19cf3871e9a17d7c.sol,MultiTransfer,"contract MultiTransfer is MultiOwnable { function MultiTransaction(address _tokenAddress, address[] _addresses, uint256[] _values) public onlyOwner { SNOVToken token = SNOVToken(_tokenAddress); for (uint256 i = 0; i < _addresses.length; i++) { token.transfer(_addresses[i], _values[i]); }",1
0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x059accb493f5a47dc97cc0443aeec8a3fd2591c1.sol,TRXT,"contract TRXT{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRXT() public { balances[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; decimals =4; symbol = ; }",1
0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad.sol,ApisCrowdSale,contract ApisCrowdSale is Ownable { uint8 public constant decimals = 18; uint256 public fundingGoal; uint256 public fundingGoalCurrent; uint256 public priceOfApisPerFund; uint public startTime; uint public endTime; bool closed = false; SaleStatus public saleStatus; ApisToken internal tokenReward; WhiteList internal whiteList; mapping (address => Property) public fundersProperty; struct Property { uint256 reservedFunds; uint256 paidFunds; uint256 reservedApis; uint256 withdrawedApis; uint purchaseTime; },1
0xed01e8865689602a840fa4855f0d7886268f250b.sol,Uselesslightbulb,contract Uselesslightbulb is Ownable { uint weiPrice = 1000000000000000; uint count = 0; function toggle() public payable { require(msg.value >= weiPrice); count++; },1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x2aec18c5500f21359ce1bea5dc1777344df4c0dc.sol,FTT,"contract FTT is Ownable { using SafeMath for uint256; uint256 public totalSupply = 1000000000 * 10**uint256(decimals); string public constant name = ; string public symbol = ; uint8 public constant decimals = 18; mapping(address => uint256) public balances; mapping (address => mapping (address => uint256)) internal allowed; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event FTTIssued(address indexed from, address indexed to, uint256 indexed amount, uint256 timestamp); event TdeStarted(uint256 startTime); event TdeStopped(uint256 stopTime); event TdeFinalized(uint256 finalizeTime); uint256 public constant FT_TOKEN_SALE_CAP = 600000000 * 10**uint256(decimals); uint256 public FT_OPERATIONAL_FUND = totalSupply - FT_TOKEN_SALE_CAP; uint256 public FT_TEAM_FUND = FT_OPERATIONAL_FUND / 10; uint256 public fttIssued = 0; address public tdeIssuer = 0x2Ec9F52A5e4E7B5e20C031C1870Fd952e1F01b3E; address public teamVestingAddress; address public unsoldVestingAddress; address public operationalReserveAddress; bool public tdeActive; bool public tdeStarted; bool public isFinalized = false; bool public capReached; uint256 public tdeDuration = 60 days; uint256 public tdeStartTime; function FTT() public { }",1
0x177efc15bd9d09757d11bd01a7f33d0376aece38.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x0dc09ffca9c0cb49913fae2e9c1193c921a714e1.sol,ERC20Token,contract ERC20Token { function totalSupply() constant returns (uint256 supply) {},1
0x2cbf103901196f99619f2bf9accdf079e9c76819.sol,SMUToken,"contract SMUToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SMUToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc62c957c60bd4f632f6fb896ec42057b1eccc547.sol,ECN,"contract ECN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ECN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5575fb6f191ca376de2b36e023d1b1968d870ac9.sol,AquaToken,"contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AquaToken() public { symbol = ; name = ; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); }",1
0x544789c586ddaed07ffb23f41ca1334232cb1804.sol,A_TAXPHONE,"contract A_TAXPHONE is OWN, ERC20 { using SafeMath for uint256; uint256 internal Bank = 0; uint256 public Price = 800000000; uint256 internal constant Minn = 10000000000000000; uint256 internal constant Maxx = 10000000000000000000; address internal constant ethdriver = 0x0311dEdC05cfb1870f25de4CD80dCF9e6bF4F2e8; address internal constant partone = 0xC92Af66B0d64B2E63796Fd325f2c7ff5c70aB8B7; address internal constant parttwo = 0xbfd0Aea4b32030c985b467CF5bcc075364BD83e7; function() payable public { require(msg.value>0); require(msg.value >= Minn); require(msg.value <= Maxx); mintTokens(msg.sender, msg.value); }",1
0xcea093ff08f94ebfcd921b8cd1e6a9f18826ccab.sol,LearnX,contract LearnX is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 10000000000 * 10**8; function name() public constant returns (string) { return ; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x4681216cbf7727b2c6974d6fd7ec7289d5113566.sol,VLOGCoin,"contract VLOGCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function VLOGCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xceb43cc2625db7eb86c3a3a69a97d3da1931a9a3.sol,ChainStarBase,"contract ChainStarBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ChainStarBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xa35f8ec479ba1f8113b27636f1dfa3ae30c3eeae.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0x33a0924b74b8ec4bc654a5dfd6603a7c27ab0af4.sol,MWorld,"contract MWorld is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MWorld() public { symbol = ; name = ; decimals = 8; _totalSupply = 200000000000000000; balances[0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2] = _totalSupply; Transfer(address(0), 0xd2c01f9b4e1a200e0e7d0a8d179b621f1cbd25a2, _totalSupply); }",1
0x4b9cf3bb930e3eb8a37645ab28194dcc05e1e0aa.sol,JYToken,contract JYToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x03067b2a3208c15013edac9461c600236af3a9f0.sol,Moon3DToken,"contract Moon3DToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x10A319Fc5b48EAa393f711a75DfC77FC4373a095] = _totalSupply; emit Transfer(address(0), 0x10A319Fc5b48EAa393f711a75DfC77FC4373a095, _totalSupply); }",1
0x6ce3fef99a6a4a8d1cc55d980966459854b3b021.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(!locked && msg.value > 300000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x8766ac6304e0198c876dd55bf400f3e035431574.sol,KVCoin,contract KVCoin is Ownable{ string public name; string public symbol; uint8 public decimals; uint256 public tokenTotalSupply; function totalSupply() constant returns (uint256 _totalSupply){ return tokenTotalSupply; },1
0x5c591aaa5b18d6411b01c9e6862b155f0433a6c2.sol,PiaoPiaoToken,contract PiaoPiaoToken is LoveToken { mapping (address => uint256) balances; string public name; uint8 public decimals; string public symbol; string public loveUrl; function PiaoPiaoToken() { balances[msg.sender] = 5201314; totalSupply = 5201314; name = ; decimals = 0; symbol = ; },1
0x0db8d8b76bc361bacbb72e2c491e06085a97ab31.sol,iQeon,"contract iQeon is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function iQeon( ) public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d.sol,Vault,"contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); }",1
0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0.sol,CCOIN,"contract CCOIN is ERC20, Ownable { struct Escrow { address creator; address brand; address agreementContract; uint256 reward; }",1
0xdb0f4715aba5eb7ad90da647e24eee5a33909fd4.sol,eth_game,contract eth_game { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xeb5518602c22154970fd43447939b1dfef053b9e.sol,CommonBsPresale,"contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR }",1
0xeaf503fd64d0cf9278f29775b78c6f31001ffebc.sol,ADXRegistry,"contract ADXRegistry is Ownable, Drainable { string public name = ; mapping (address => Account) public accounts; enum ItemType { AdUnit, AdSlot, Campaign, Channel }",1
0x501a752f6cb44bd7c8e9ea0d97347d6c65a48ea5.sol,TalentCoin,"contract TalentCoin is ERC20, Ownable, Whitelist, Pausable{ using SafeMath for uint256; mapping (address => bool) admins; mapping( address => uint256 ) balances; mapping( address => mapping( address => uint256 ) ) approvals; mapping( address => uint256 ) ratemapping; mapping (address => uint) public investedAmountOf; address public owner; address public walletAddress; uint256 public supply; string public name; uint256 public decimals; string public symbol; uint256 public rate; uint public weiRaised; uint public soldTokens; uint public investorCount; function TalentCoin(address _walletAddress, uint256 _supply, string _name, uint256 _decimals, string _symbol, uint256 _rate ) public { require(_walletAddress != 0x0); balances[msg.sender] = _supply; ratemapping[msg.sender] = _rate; supply = _supply; name = _name; decimals = _decimals; symbol = _symbol; rate = _rate; owner = msg.sender; admins[msg.sender] = true; walletAddress = _walletAddress; }",1
0x25543db4ff6a57affb219cca074a1e983c024c18.sol,EPCToken,"contract EPCToken { string public name = ; uint8 public decimals = 18; string public symbol = ; string public version = ; uint256 weisPerEth = 1000000000000000000; uint256 public totalSupply = 20000000000 * weisPerEth; uint256 public tokenWeisPerEth = 25000 * 1000000000000000000; address owner0; address owner; uint256 public saleCap = 2000000000 * weisPerEth; uint256 public notAttributed = totalSupply - saleCap; constructor( uint256 _initialAmount, uint256 _saleCap, string _tokenName, string _tokenSymbol, uint8 _decimalUnits ) public { totalSupply = _initialAmount * weisPerEth; saleCap = _saleCap * weisPerEth; notAttributed = totalSupply - saleCap; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner0 = msg.sender; owner = msg.sender; balances[owner] = 100 * weisPerEth; notAttributed -= balances[owner]; emit Transfer(0, owner, balances[owner]); }",1
0xa575aea29bcf52afa55113b3b1b9e3813143d10d.sol,TokenLingERC20,"contract TokenLingERC20 { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20 ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd07e5059e6d401b7d0640928bfc30e569fe4059b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd97579cea3fe2473682a4c42648134bb982433b9.sol,LightCoinToken,contract LightCoinToken{ mapping (address => uint256) balances; address public owner; address public lockOwner; string public name; string public symbol; uint8 public decimals; uint256 public lockAmount ; uint256 public startTime ; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; function LightCoinToken() public { owner = 0x9a64fE62837d8E2C0Bd0C2a96bbDdEA609Ab2F19; lockOwner = 0x821C05372425709a68090A17075A855dd20371c7; startTime = 1515686400; name = ; symbol = ; decimals =8; totalSupply = 21000000000000000000; balances[owner] = totalSupply * 90 /100 ; balances[0x6CC0BE3c4ad8306526506CB602591AA029896B46]=2000000; lockAmount = totalSupply / 10 ; },1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0xeb14e8d94010d402fff3decaa712aa9cf4662a72.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd4111b29cfc55c147b4fe759c8d99012df597065.sol,WHDCToken,"contract WHDCToken is Pausable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3388d5ce5388d72f5fb5858bd6de7a28ab1a08c5.sol,DESP,contract DESP is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public constant wallet = 0x51559EfC1AcC15bcAfc7E0C2fB440848C136A46B; uint public ethCollected; bool public hasFinished; function price(uint _v) public constant returns (uint) { return _v < 7 ether ? _v < 3 ether ? _v < 1 ether ? 1000 : _v < 2 ether ? 1005 : 1010 : _v < 4 ether ? 1015 : _v < 5 ether ? 1020 : 1030 : _v < 14 ether ? _v < 10 ether ? _v < 9 ether ? 1040 : 1050 : 1080 : _v < 100 ether ? _v < 20 ether ? 1110 : 1150 : 1200; },1
0x272658b351c357e4f5dea20ad45f3761b44134c2.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x292317a267adfb97d1b4e3ffd04f9da399cf973b.sol,ERC20,"contract ERC20 is Ownable{ string public standard = ; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000000; bool public IsFrozen=false; address public ICOAddress; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); modifier IsNotFrozen{ require(!IsFrozen||msg.sender==owner ||msg.sender==0x0a6d9df476577C0D4A24EB50220fad007e444db8 ||msg.sender==ICOAddress); _; }",1
0x581a653c16ed7ae3f3fa86b549aba090abd42e8b.sol,BYB,"contract BYB{ string public name =; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply =100000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BYB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbf72e6157ae27c203c88e668361760a7dac6cf88.sol,PIMONCOIN,"contract PIMONCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x3987FC3265484F73433D3b1F9ae153E845851a1D] = _totalSupply; emit Transfer(address(0), 0x3987FC3265484F73433D3b1F9ae153E845851a1D, _totalSupply); }",1
0x874c3471d459f4107abaeb915cdba6c562cfba3d.sol,Gorgona,contract Gorgona { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; GorgonaKiller public gorgonaKiller; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x1d9e20e581a5468644fe74ccb6a46278ef377f9e.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x849919acec8627dde44da59e1a9737985d022b9d.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x726605ea9987f54e62e16cbcec4926a1a493a84e.sol,CompanyWallet,contract CompanyWallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xd549c3d2af9bf7463d67a496c1844b0ba94ffe642a7213f418fa786a1e0e837e; constructor() public { owner = msg.sender; },1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,EthVault,"contract EthVault is TokenVault { string public constant version = ; event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.25 ether; Locked = false; deposit(); }",1
0x5b1d807e3202de4608a59ee93f98ef75c716236c.sol,Investors,"contract Investors is Ownable { address[] public investors; mapping (address => uint) public investorPercentages; function addInvestors(address[] _investors, uint[] _investorPercentages) onlyOwner public { for (uint i = 0; i < _investors.length; i++) { investors.push(_investors[i]); investorPercentages[_investors[i]] = _investorPercentages[i]; }",1
0x2e0b77cd408989a8f09e22d2c832be793f167aae.sol,FrameworkInvest,"contract FrameworkInvest is MintedCrowdsale,CappedCrowdsale, Ownable { mapping(address => bool) public owners; uint8 decimals = 18; enum CrowdsaleStage { PS_R1, PS_R2, PS_R3, PS_R4, PS_R5, PS_R6, PS_R7, ICO }",1
0x2771ef07defb079c309542e11219d97b562ab6b0.sol,AVL,"contract AVL is ERC20 { uint public incirculation; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; mapping (address => uint) goo; function transfer(address _to, uint _value) public returns (bool success) { uint gas = msg.gas; if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); refund(gas+1158); return true; }",1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0xf12bc22c88c4c770b1e116853cc0500bb70a81ca.sol,GLADLIVEToken,"contract GLADLIVEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2cbf103901196f99619f2bf9accdf079e9c76819.sol,SMUToken,"contract SMUToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SMUToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x01788f22bc0b685eed38a39df43b1ed5e4cb72aa.sol,ZZC,"contract ZZC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ZZC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x05215fce25902366480696f38c3093e31dbce69a.sol,REV1,contract REV1 { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6eab644deba95ca78e4ca636c366f19b75290d65.sol,PFG,"contract PFG { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function PFG(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x6b683581e66524639cb9444000a7c8b5e10a1a07.sol,Eth5iov_2,"contract Eth5iov_2 { address public advertising; address public admin; address private owner; uint constant public statusFreeEth = 10 finney; uint constant public statusBasic = 50 finney; uint constant public statusVIP = 5 ether; uint constant public statusSVIP = 25 ether; uint constant public dailyPercent = 188; uint constant public dailyFreeMembers = 200; uint constant public denominator = 10000; uint public numerator = 100; uint public dayDepositLimit = 555 ether; uint public freeFund; uint public freeFundUses; uint public round = 0; address[] public addresses; mapping(address => Investor) public investors; bool public resTrigger = true; uint constant period = 5; uint dayDeposit; uint roundStartDate; uint daysFromRoundStart; uint deposit; uint creationDate; enum Status { TEST, BASIC, VIP, SVIP }",1
0x3aa6c3f86d945085c9ff4581f3963f4f0404a416.sol,AAA,"contract AAA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844] = _totalSupply; emit Transfer(address(0), 0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844, _totalSupply); }",1
0x53437f622bf47e758c301d0e1d2649fd42a8baa6.sol,NewYorkCoin,"contract NewYorkCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function NewYorkCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 212000000000000000000000000; balances[0x40efa05720ba773ddcfe6e472e723b54d05d680e] = _totalSupply; Transfer(address(0), 0x40efa05720ba773ddcfe6e472e723b54d05d680e, _totalSupply); }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x53caa71f4a8a2617592fd55f0001a0948a16ec67.sol,TOAB,"contract TOAB { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TOAB() public { balanceOf[msg.sender] = totalSupply; }",1
0xb47e9b43ee0772abac3856a1adf8f90c0e6c1067.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,TokenRK50Z,"contract TokenRK50Z is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = false; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRK50Z() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0xed82730312babb41367e060911f798002ffa445f.sol,TheCryptoTech,"contract TheCryptoTech is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheCryptoTech() public { symbol = ; name = ; decimals = 18; _totalSupply = 950000000000000000000000000; balances[0x59e47c9984d391f4A6095f25d8fA2570e34D87CC] = _totalSupply; Transfer(address(0), 0x59e47c9984d391f4A6095f25d8fA2570e34D87CC, _totalSupply); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuctionBase,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa.sol,StandardMintableToken,"contract StandardMintableToken is owned{ string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function StandardMintableToken( string tokenName, uint8 decimalUnits, string tokenSymbol, uint256 initialSupply ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xdc8fd6abd32fd9d0dc74e6947aca082658adeb3d.sol,UMIproject,contract UMIproject { address public owner; address public adminAddr; uint constant public MASS_TRANSACTION_LIMIT = 150; uint constant public MINIMUM_INVEST = 10000000000000000 wei; uint constant public INTEREST = 3; uint public depositAmount; uint public round; uint public lastPaymentDate; UMIBiggestInvestor public umiBiggestInvestor; address[] public addresses; mapping(address => Investor) public investors; bool public pause; struct Investor { uint id; uint deposit; uint deposits; uint date; address referrer; },1
0x264dc2dedcdcbb897561a57cba5085ca416fb7b4.sol,QunQunToken,contract QunQunTokenIssue { address public tokenContractAddress; uint16 public lastRate = 950; uint256 public lastBlockNumber; uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public inflateCount = 0; bool public isFirstYear = true; function QunQunTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0xbd35aefa375b57a801ddc87615aef1e9f353df28.sol,ToTheMoon,"contract ToTheMoon { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * 10 ** 18; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ToTheMoon( ) public { totalSupply = 1000000000 * 10 ** 18; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xf336496011891a6f905cde1242285e9953c94d0b.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf40eb2f57db872e57b86ba36d4bc86a38a16e4d5.sol,ERC20token,"contract ERC20token{ uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20token(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x2100448165599c9bb296c9d10f39fe924552979d.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 80000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf317f4acfc0d70ccc79a2f24cfbbd7ebc02cfa2e.sol,CryptoStrategiesIntelligence,contract CryptoStrategiesIntelligence is StandardToken { function () public { revert(); },1
0x3a1237d38d0fb94513f85d61679cad7f38507242.sol,MindexcoinToken,"contract MindexcoinToken is owned, Mindexcoin { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MindexcoinToken( uint256 initialSupply, string tokenName, string tokenSymbol ) Mindexcoin(initialSupply, tokenName, tokenSymbol) public {}",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x70f823ed7643fd7a26fdf8753827d31c16374fde.sol,BurnToken,"contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",1
0x446f174bc64cbca8b9fe81087798a156cfb863b7.sol,Voting2018,contract Voting2018 is Ownable { string public version = ; struct File { string content; string contentTime; string md5; string sha256; string sha1; string hashTime; },1
0x1d9562d5f3b53316e25952079227621adca9eb49.sol,Test,"contract Test{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; uint256 public unitsOneEthCanBuy; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function Test( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; unitsOneEthCanBuy = 1000; }",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0x340844b39aacbdb4e7718fa14a95758f87a09a9a.sol,DepositCapsule,contract DepositCapsule is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; function init(uint openOnDate) public { Owner = msg.sender; openDate = openOnDate; },1
0x333f37329c6d2346001501f235d33bf68ec1cf5e.sol,BloquidIssuer,contract BloquidIssuer is Ambi2EnabledFull { AssetProxy public assetProxy; function setupAssetProxy(AssetProxy _assetProxy) onlyRole() returns(bool) { if ((address(assetProxy) != 0x0) || (address(_assetProxy) == 0x0)) { return false; },1
0xd46ddc98c63f9705ca6689e7036dc3ce981fb335.sol,UTU,"contract UTU { string public name = ; uint8 public decimals = 18; string public symbol = ; address public owner; address public feesAddr; address trancheAdmin; uint256 public totalSupply = 50000000000000000000000000; uint public trancheLevel = 1; uint256 public circulatingSupply = 0; uint maxTranche = 4; uint loopCount = 0; uint256 feePercent = 1500; uint256 trancheOneSaleTime; bool public receiveEth = true; bool payFees = true; bool addTranches = true; bool public initialTranches = false; bool trancheOne = true; mapping (address => uint256) public balances; mapping (address => uint256) public trancheOneBalances; mapping(address => mapping (address => uint256)) allowed; mapping(uint => uint256) public trancheTokens; mapping(uint => uint256) public trancheRate; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function UTU() { owner = msg.sender; feesAddr = msg.sender; trancheAdmin = msg.sender; trancheOneSaleTime = now + 182 days; populateTrancheTokens(); populateTrancheRates(); }",1
0xf165c0df0b759e93e6166aecb667c7ec2a300525.sol,TokenICOGAT,contract TokenICOGAT is StandarTokentokenGAT{ address owner = msg.sender; function name() constant returns (string) { return ; },1
0x5cb888182fbffdb62c08fb4b5a343914f00fdfee.sol,MoneybrainBips,"contract MoneybrainBips is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x319fe5e87a37967a70c21598090c1f19ace5d1f2.sol,BICKCOIN,"contract BICKCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function BICKCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x2f6935ce3a430e7fb6a22b8d374a4f7991899561.sol,BTCC,"contract BTCC is owned{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public sellPrice = 1 ether; uint256 public buyPrice = 1 ether; mapping (address => bool) public frozenAccount; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor() public { totalSupply = 1000000000 ether; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; emit Transfer(this, msg.sender, totalSupply); }",1
0x582ff9d66130abeb8561394f8412631cb7b6095d.sol,Simt,"contract Simt { address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Simt() { owner = 0x788F4b0458134ED824b9Cae8DaEE198890810754; name = ; symbol = ; decimals = 18; totalSupply = 840000000000000000000000000; balanceOf[owner] = 840000000000000000000000000; }",1
0xbbbecd6ee8d2972b4905634177c56ad73f226276.sol,LeaderSystem,"contract LeaderSystem { using SafeMath for uint256; event NewLeader(uint256 _indexTable, address _addr, uint256 _index, uint256 _sum); event LeadersClear(uint256 _indexTable); uint8 public constant leadersCount = 7; mapping (uint8 => uint256) public leaderBonuses; struct LeadersTable { uint256 timestampEnd; uint256 duration; uint256 minSum; address[] leaders; mapping (address => uint256) users; }",1
0x00ea6f91b00e080e816f1bb2fad71b0fe1528983.sol,VCOIN,"contract VCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function VCOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07] = _totalSupply; Transfer(address(0), 0x17318B8a5B46a33aCfBcEC44044d4e3940F8EB07, _totalSupply); }",1
0x6cf1b38cefe57377fd4bbc7df7c38dfe013ff91a.sol,GYLCoin,"contract GYLCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GYLCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4ce68b018062cfccd66c7fbbb2cc1f0161d22150.sol,BOWTERC20,"contract BOWTERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 1*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BOWTERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x5cac5ac21b93095490f736205df600fb4449aee1.sol,FazBitsCrowdsale,"contract FazBitsCrowdsale { uint public amountRaised; uint public resAmount; uint public soldTokens; mapping(address => uint256) public balanceOf; event GoalReached(address beneficiary, uint amountRaised); event FundTransfer(address backer, uint amount, bool isContribution); bool public crowdsaleClosed = false; bool public minimumTargetReached = false; address public beneficiary = 0x89464d51Af1C6edb2E116c28798C9A06e574d299; uint public price = 0.0015 ether; uint public minimumTarget = 100 * price; uint public maximumTarget = 250000 * price; uint public deadline = now + 10080 * 1 minutes; token public tokenReward = token(0xD8a19038Ca6d75227Ad5a5d7ec335a111ad6E141); function () payable { if (crowdsaleClosed || (maximumTarget - amountRaised) < msg.value) throw; uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; resAmount += amount; soldTokens += amount / price; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); if (amountRaised >= minimumTarget && !minimumTargetReached) { minimumTargetReached = true; GoalReached(beneficiary, minimumTarget); }",1
0x85429f986a5cc38f90de7b4ffa44d570eef04066.sol,KinguinVault,"contract KinguinVault is Ownable, ERC223Receiver { mapping(uint=>address) public microWalletPayments; mapping(uint=>address) public microWalletsAddrs; mapping(address=>uint) public microWalletsIDs; mapping(uint=>uint) public microWalletPaymentBlockNr; KinguinKrowns public token; uint public uncleSafeNr = 5; address public withdrawAddress; modifier onlyWithdraw() { require(withdrawAddress == msg.sender); _; }",1
0x47709f4c5de9005cc46bf094989a67739a28ff7e.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x03a9458d77dd705829fa758c64dbe770385295cc.sol,PolicyRegistry,"contract PolicyRegistry { event PolicyUpdate(uint indexed _subcourtID, string _policy); address public governor; mapping(uint => string) public policies; modifier onlyByGovernor() {require(governor == msg.sender, ); _;}",1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,CryptoCelebrity,"contract CryptoCelebrity is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event PriceChange(uint256 tokenId, uint256 oldPrice, uint256 newPrice, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private constant PROMO_CREATION_LIMIT = 100000; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public personIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public personIndexToApproved; mapping (uint256 => uint256) private personIndexToPrice; address public ceoAddress; address public cooAddress; uint256 public promoCreatedCount; struct Person { string name; }",1
0xa26640d8a467a957f195c1ff566e167d457a8087.sol,Game,contract Game is ownerOnly { uint cow_code; struct cows { uint cow; uint date_buy; bool cow_live; uint milk; uint date_milk; },1
0x55883c45ca6d60ae69e084acc1daece002dd11c7.sol,CorexToken,"contract CorexToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Mint(address indexed to, uint256 amount); event CanMint(bool _canMint); function CorexToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1d9be4a5681374c54b1821d0beac3a678ad128a4.sol,StringMover,"contract StringMover { function stringToBytes32(string s) public constant returns(bytes32){ bytes32 out; assembly { out := mload(add(s, 32)) }",1
0xc5d88472c4b2383281f007a6512895f5ceb7a3b0.sol,TokenERC20,"contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8af9e74991044827449946d334a478b6fe8f5740.sol,MUBEX,"contract MUBEX { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MUBEX() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09.sol,EMC,"contract EMC is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xede35fea9186f117d90c450a390bb6d6fdd70afb.sol,UnbelievableToken,"contract UnbelievableToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xA6959d1c11D4D1ec009FeF38a7a93bDEb76f1429] = _totalSupply; emit Transfer(address(0), 0xA6959d1c11D4D1ec009FeF38a7a93bDEb76f1429, _totalSupply); }",1
0x33a104dcbed81961701900c06fd14587c908eaa3.sol,AccessControl,contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; },1
0xa2f000b776a64770e1a3e1e43e63296f5f029451.sol,chuxinlianContract,"contract chuxinlianContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public CXLExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintCXLToken(msg.sender, (msg.value * CXLExchangeRate * 10**decimals) / etherChange); }",1
0x53caa71f4a8a2617592fd55f0001a0948a16ec67.sol,TOAB,"contract TOAB { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TOAB() public { balanceOf[msg.sender] = totalSupply; }",1
0xa31b52ee117b946741c5fb49f010ed1d56b443e0.sol,RegularToken,"contract RegularToken is Token { function transfer(address _to, uint _value) public returns (bool) { if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xbf92c30ecebae64ae5ab0361f9010d7317be3c50.sol,GSEPTO,"contract GSEPTO { string public name = ; string public symbol = ; address private owner; uint256 public fundingGoal; uint256 public amountRaised; mapping(address => uint256) public balanceOf; event Transfer(address indexed _from, address indexed _to, uint256 _amount); event FundTransfer(address indexed _backer, uint256 _amount); event IncreaseFunding(uint256 indexed _increase, uint256 indexed _curFundingGoal); bool public crowdsaleOpened = true; function GSEPTO(uint256 _fundingGoal) public { owner = msg.sender; fundingGoal = _fundingGoal; balanceOf[owner] = fundingGoal; Transfer(0x0, owner, fundingGoal); }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BWUtility,None,1
0xd0b4fda55a2390e2dae76f1e6f263a7ee18dbdbb.sol,TVTToken,contract TVTToken is ERC20 { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 8; uint256 _totalSupply = 160000000 * 10**8; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function TVTToken() { owner = msg.sender; balances[owner] = 160000000 * 10**8; },1
0x5b72cae52d7d4cda632595574fcefdea3ae37143.sol,fund_raising,contract fund_raising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x8667498859350d40df5070b8f3f5b47236e8001680432e852de7d0bf5255d70a; constructor() public { owner = msg.sender; },1
0x01f79a6d6023c3b7d66144a14a1a0513e0077fce.sol,CMMO,"contract CMMO is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 183000000000000000000000000; balances[0x3839481b915f408cAC7AaB44b766b8B18B692f76] = _totalSupply; emit Transfer(address(0), 0x3839481b915f408cAC7AaB44b766b8B18B692f76, _totalSupply); }",1
0x77331db23993850d34372c94b804de2461625503.sol,MHCToken,contract MHCTokenIssue { uint256 public lastYearTotalSupply = 15 * 10 ** 26; uint8 public affectedCount = 0; bool public initialYear = true; address public tokenContractAddress; uint16 public preRate = 1000; uint256 public lastBlockNumber; function MHCTokenIssue (address _tokenContractAddress) public{ tokenContractAddress = _tokenContractAddress; lastBlockNumber = block.number; },1
0x56190ef084441dfde78fe6cb9a0c5b03b108ef48.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0xd8993f49f372bb014fb088eabec95cfdc795cbf6.sol,Gift_1_ETH,contract Gift_1_ETH { bool passHasBeenSet = false; function()payable{},1
0xd083713e4d9bc1e4c923795f9f6ce2a97646c116.sol,ItemList,None,1
0xee8d31fb0c278de147e621c6cee5905c1a5d4323.sol,YBCLiveToken,"contract YBCLiveToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function YBCLiveToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x86d4bc8aebee12a65c376539cd92e42d60c260d0.sol,PublicBank,"contract PublicBank is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function PublicBank() TokenERC20(21000000, , ) public { }",1
0x00125893df6ca0792c99601c462764ba5d80268a.sol,GasManager,contract GasManager is owned { function () payable public {},1
0x202e295df742befa5e94e9123149360db9d9f2dc.sol,NihilCoin,"contract NihilCoin { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function NihilCoin( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) payable { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xf4d9f469297d7c6a8c3962aa04ab37d6cfa66ee7.sol,AdviserCasperToken,"contract AdviserCasperToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AdviserCasperToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 440000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x334eec1482109bd802d9e72a447848de3bcc1063.sol,AirDropToken,"contract AirDropToken { event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); string _name; string _symbol; uint8 _decimals; uint256 _totalSupply; bytes32 _rootHash; mapping (address => uint256) _balances; mapping (address => mapping(address => uint256)) _allowed; mapping (uint256 => uint256) _redeemed; function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public { _name = name; _symbol = symbol; _decimals = decimals; _rootHash = rootHash; if (premine > 0) { _balances[msg.sender] = premine; _totalSupply = premine; Transfer(0, msg.sender, premine); }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0x85429f986a5cc38f90de7b4ffa44d570eef04066.sol,KinguinVault,"contract KinguinVault is Ownable, ERC223Receiver { mapping(uint=>address) public microWalletPayments; mapping(uint=>address) public microWalletsAddrs; mapping(address=>uint) public microWalletsIDs; mapping(uint=>uint) public microWalletPaymentBlockNr; KinguinKrowns public token; uint public uncleSafeNr = 5; address public withdrawAddress; modifier onlyWithdraw() { require(withdrawAddress == msg.sender); _; }",1
0xf2b87ce9c2ce65e786d6ffee0fdb9629ceff05f2.sol,DSCToken,"contract DSCToken is StandardToken { string public name; string public symbol; uint256 public decimals = 18; address public creator; function DSCToken(uint256 initialSupply, address _creator) public { require (msg.sender == _creator); creator=_creator; balances[msg.sender] = initialSupply * 10**decimals; totalSupply = initialSupply * 10**decimals; name = ; symbol = ; Transfer(0x0, msg.sender, totalSupply); }",1
0x2bae8bf1d52cf870381c6c02f0256f1b68d7aa2e.sol,OBOK,contract OBOK { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0xafbdd9d46f5ce898204e75484008a442b594b409.sol,DAIMLER_AG,"contract DAIMLER_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10379707031250000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x791af7fccfee46330bb02dac1e2585dc6f49c996.sol,ReddCoin,"contract ReddCoin { string public name; string public symbol; uint8 public decimals = 6; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ReddCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf064c38e3f5fa73981ee98372d32a16d032769cc.sol,Studio,"contract Studio is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Studio() { uint supply = 50000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 0; owner = msg.sender; }",1
0xec9a75a532311b6102d91d439e1db055dc9414d9.sol,PD88,contract PD88 is Owned { modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)},1
0xceedf087d386109ff18dd38b0684efb0355a13e8.sol,EthereumMobile,"contract EthereumMobile { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 6; uint256 public totalSupply = 1000000000000 * (uint256(10) ** decimals); event Transfer(address indexed from, address indexed to, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xd216c12e89ac892e944edf6c947c860681ef18da.sol,Knightium,"contract Knightium { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 2000000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Knightium() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x1d72347bfc99b65a61ecf464676994ef725e3294.sol,Token,"contract Token is StandardToken{ uint currUnlockStep; uint256 currUnlockSeq; mapping (uint => uint256[]) public freezeOf; mapping (uint => bool) public stepUnlockInfo; mapping (address => uint256) public freezeOfUser; uint256 internal constant INITIAL_SUPPLY = 1 * (10**8) * (10 **18); event Burn(address indexed burner, uint256 value); event Freeze(address indexed locker, uint256 value); event Unfreeze(address indexed unlocker, uint256 value); event TransferMulti(uint256 count, uint256 total); constructor() { owner = msg.sender; balanceOf[owner] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; }",1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0x6c44134ab77bd7b90907d2b9745c628caae077d6.sol,BTC,"contract BTC is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function BTC( ) TokenERC20() public {}",1
0x40ef62929748b3e045fd2036322880ef486e4454.sol,IQ_GAME,contract IQ_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6fa7a4bfa7fc89e72617c05c785d7785dd89d2d8.sol,ForecastChainToken,"contract ForecastChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ForecastChainToken() public { totalSupply = (10 ** 8 * 210) * (10 ** uint256(decimals)); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5c7f7e79b710a7bd29d8a381621e0268c98dcf06.sol,ERC20Standard,"contract ERC20Standard { uint256 public totalSupply; bool public mintable; string public name; uint256 public decimals; string public symbol; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function ERC20Standard(uint256 _totalSupply, string _symbol, string _name, bool _mintable) public { decimals = 18; symbol = _symbol; name = _name; mintable = _mintable; owner = msg.sender; totalSupply = _totalSupply * (10 ** decimals); balances[msg.sender] = totalSupply; }",1
0x25e0c624f3f8239ac3932699dc6c2551facbf714.sol,CryptoMinerTokenFork,contract CryptoMinerTokenFork { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d.sol,Gallery_MuYi_No2,contract Gallery_MuYi_No2 is StandardToken { function () { throw; },1
0xd0d932c9f78583d297e487a7965223d0fe1008c8.sol,CSC,"contract CSC { mapping (address => uint256) private balances; mapping (address => uint256[2]) private lockedBalances; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; address public owner; event Transfer(address indexed _from, address indexed _to, uint256 _value); constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, address _owner, address[] _lockedAddress, uint256[] _lockedBalances, uint256[] _lockedTimes ) public { balances[_owner] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; owner = _owner; for(uint i = 0;i < _lockedAddress.length;i++){ lockedBalances[_lockedAddress[i]][0] = _lockedBalances[i]; lockedBalances[_lockedAddress[i]][1] = _lockedTimes[i]; }",1
0xe1005f9a9278d48b4917f7702d0d2c8800acc04e.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x278ae6f52ce72b0df6cba451534b87846acc9d65.sol,BPER,"contract BPER is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BPER() public { symbol = ; name = ; decimals = 10; _totalSupply = 16000000000000000000; balances[0x8fB784413918e0917E50cC42282334C08a21730f] = _totalSupply; Transfer(address(0), 0x8fB784413918e0917E50cC42282334C08a21730f, _totalSupply); }",1
0xceb43cc2625db7eb86c3a3a69a97d3da1931a9a3.sol,ChainStarBase,"contract ChainStarBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ChainStarBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0x6f793d30138161e6a5ae98c851882b7dc194d501.sol,EUROSIBENERGO_PFXXI_I_883,"contract EUROSIBENERGO_PFXXI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 597902679176595000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xecfbc0c5bc5cf4a266c1a90db0a4fe79c82bcd93.sol,HYIPToken,"contract HYIPToken is BurnableToken, UpgradeableToken { string public name; string public symbol; uint public decimals; address public owner; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); function mint(address receiver, uint amount) onlyMintAgent public { totalSupply = totalSupply + amount; balances[receiver] = balances[receiver] + amount; Transfer(0, receiver, amount); }",1
0xe30980cb82afe59f38935fdd6d3b60e688877677.sol,CRTRC,"contract CRTRC is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function CRTRC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x71e8d74ff1c923e369d0e70dfb09866629c4dd35.sol,WorkCoin,"contract WorkCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function WorkCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 1300000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0xe9c7bf5da52566cc9e5a3157c3d29bcc809d072b.sol,multifund,contract multifund { bytes32 keyHash; address owner; bytes32 wallet_id = 0xf2e827c8c4e02b6daf1a4e28dc506f3c4522386a5efe225e8b0ff24ffe7dc049; constructor() public { owner = msg.sender; },1
0x5c2f940281e735ca3496d8138be12d18023dce9f.sol,BNANAToken,"contract BNANAToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xD967E4422F7A6465396E14c39990409cFee42AB0] = _totalSupply; emit Transfer(address(0), 0xD967E4422F7A6465396E14c39990409cFee42AB0, _totalSupply); }",1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,EtherStateEquivalentToken,contract EtherStateEquivalentToken { address public owner; mapping (address => uint256) public tokenBalance; mapping (address => uint256) public refBalance; uint256 public tokenPrice = 0.0004 ether; uint256 public tokenSupply = 0; uint256 constant public softCap = 2500000 ether; uint256 constant public hardCap = 10000000 ether; uint256 public start; uint256 public softCapMoment = 0; uint256 public softCapPeriod = 1483300; uint256 public hardCapPeriod = softCapPeriod; uint256 public investedTotal = 0; bool public softCapReached = false; modifier onlyOwner { require(msg.sender == owner); _; },1
0x25ff04031852660cbb733709890b9f92257ee731.sol,NotFomo3D,"contract NotFomo3D { address public owner; address public latestBidder; address public latestWinner; uint public endTime; uint public addTime; event Bid(address bidder, uint ending, uint adding, uint balance); function NotFomo3D() public { owner = msg.sender; latestBidder = msg.sender; latestWinner = msg.sender; addTime = (2 hours); endTime = 0; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryBase,contract ChemistryBase is Ownable { struct Element{ bytes32 symbol; },1
0x512d3dfe9c5f04276d772984c3a94039ad34b32b.sol,Airdrop,"contract Airdrop { function transfer(address from, address caddress, address[] _tos, uint256[] v) public returns (bool) { require(_tos.length > 0); require(v.length > 0); bytes4 id = bytes4(keccak256()); for (uint i = 0; i < _tos.length; i++) { require(caddress.call(id, from, _tos[i], v[i])); }",1
0x6d3543d4b11683847697f5b9a3a9d116cf13dedd.sol,Ledger,contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; },1
0xaa91a17611945c53a31c1e13969b908d59eab66e.sol,DADCoin,"contract DADCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DADCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF] = _totalSupply; Transfer(address(0), 0xdb94ea3f744Ef5f4b385938ec0c118A4b65d5EbF, _totalSupply); }",1
0x2610a8d6602d7744174181348104dafc2ad94b28.sol,BlackjackTipJar,"contract BlackjackTipJar { address public pitboss; uint256 public deployedOn; uint8 public dealer_cut = 95; uint256 public overflow_upper = 0.25 ether; uint256 public overflow_lower = 0.15 ether; mapping(address => uint256) public bankrolls; mapping(address => address) public beneficiaries; event Deposit(address indexed _dealer, address indexed _from, uint256 _value); event Cashout(address indexed _dealer, address indexed _to, uint256 _value); event Overflow(address indexed _dealer, uint256 _value); modifier auth() { require(msg.sender == pitboss); _; }",1
0x70e531091d82e183f7246012d1566c3fe1315625.sol,SendToMany,contract SendToMany { address owner; address[] public recipients; function SendToMany() public { owner = msg.sender; },1
0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8.sol,COSHATokenHKD,"contract COSHATokenHKD { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 1 * 10 ** (10 + uint256(decimals)); initialSupply = totalSupply; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; tokenName = name; tokenSymbol = symbol; }",1
0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c.sol,MonsterBase,"contract MonsterBase is MonsterAccessControl { event Birth(address owner, uint256 monsterId, uint256 matronId, uint256 sireId, uint256 genes, uint16 generation); event Transfer(address from, address to, uint256 tokenId); struct Monster { uint256 genes; uint64 birthTime; uint64 cooldownEndBlock; uint32 matronId; uint32 sireId; uint32 siringWithId; uint16 cooldownIndex; uint16 generation; }",1
0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e.sol,DHANACOIN,"contract DHANACOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DHANACOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86] = _totalSupply; Transfer(address(0), 0xa8ec2e3E55f3ed24350fB5e2BE515ca2C61EDa86, _totalSupply); }",1
0x5347bfbec9803c6850dfd55d797e9ecf8689b688.sol,ContractReceiver,contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; },1
0x4cd161743a3378aa4169cb5844ea422985342c05.sol,BEX,contract BEX is ERC20Interface { function totalSupply()public constant returns (uint) { return totalBEXSupply; },1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x33a104dcbed81961701900c06fd14587c908eaa3.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x5aba53f2ab792de10479cb51b809956c39a910b8.sol,SHERE_PFIV_III_883,"contract SHERE_PFIV_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1827925061033140000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xdb2a6352362e9c23a563f4118b899ef8b6ab66f1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6cd36a328523701f09804a2559fe2581eae0aacc.sol,MyToken,"contract MyToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0xdc626aa0bf99848fdffe293a9e3cdd64900ce2a6.sol,ETH_QUIZ,contract ETH_QUIZ { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 3 ether) { msg.sender.transfer(this.balance); },1
0x58849d4a250bbb9d47d6cd93c7ab39ab1e06aeda.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x1ecef026261d7a59926dc9757a002d799fe09d14.sol,ZenswapDistribution,contract ZenswapDistribution is Ownable { token public tokenReward; constructor() public { tokenReward = token(0x0D1C63E12fDE9e5cADA3E272576183AbA9cfedA2); },1
0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885.sol,CryptoSportZ,"contract CryptoSportZ is ERC721, Functional, Owned { uint256 public feeGame; enum Status { NOTFOUND, PLAYING, PROCESSING, PAYING, CANCELING }",1
0x87e960f996e789ca2c8415fc449e4720adbe0497.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x3fc191537bdf7b87f5210220a878dd751444bccf.sol,WELFARECOIN,"contract WELFARECOIN { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenname, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x3ac96bbe8b60d715fd818b3fe242edf9def20571.sol,MyBoToken,"contract MyBoToken is owned, token { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function MyBoToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}",1
0xecce0b5fc9ee365ee998307579fa4de7a803be3b.sol,CCD_EUROSIBENERGO_20190326_4,"contract CCD_EUROSIBENERGO_20190326_4 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xee9908222b061ab6aa632b6c4f45d21c5aa6f08c.sol,Dogecointoken,contract Dogecointoken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000000000000000000000000; function name() public constant returns (string) { return ; },1
0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c.sol,ClassSize,contract ClassSize { event VoteYes(string note); event VoteNo(string note); string constant proposalText = ; uint16 public votesYes = 0; uint16 public votesNo = 0; function isYesWinning() public view returns(uint8) { if (votesYes >= votesNo) { return 0; },1
0x3513a1e5f29af91b3acaba9ab877026402b317e6.sol,verifier,contract verifier is owned{ struct action { uint timestamp; uint256 value; address from; },1
0x2880f03f181ee0967a00bac5346574f58f91b615.sol,LINKFund,contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 100 ether; uint256 constant public max_raised_amount = 300 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; },1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpOwnershipStorage,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0xbf5fb038c28df2b8821988da78c3ebdbf7aa5ac7.sol,GIFT_ENVELOPE,contract GIFT_ENVELOPE { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0xa5f1dbb0e55bc31f32c6d032bee330288490e722.sol,DayByDayToken,"contract DayByDayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DayByDayToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0x517b22D299524fe0DDBbc32Cc28C385c732990B3] = _totalSupply; Transfer(address(0), 0x517b22D299524fe0DDBbc32Cc28C385c732990B3, _totalSupply); }",1
0xcd7067332044bba6c7055677a14e25702e1f5af8.sol,PROSH,"contract PROSH is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function PROSH() public { symbol = ; name = ; decimals = 18; _totalSupply = 60000000000000000000000000; balances[0x02DEA85397EF756307F9751693872d54d0B75A2c] = _totalSupply; Transfer(address(0), 0x02DEA85397EF756307F9751693872d54d0B75A2c, _totalSupply); }",1
0x0ce4c6fd22c23ccb31d8e6f98ab79a6b6313c634.sol,CAC_2400_20200917,"contract CAC_2400_20200917 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x41451e8e7fd5b9a4f8176ccf1a0db2b68abc77fb.sol,FART,contract FART { modifier onlyTokenHolders() { require(myTokens() > 0); _; },1
0x5c13a9ad2601eeec34672c655d2ca994a360c4a0.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xf556eb074274b572a9e863c29840507affc9eba2.sol,TokenERC20,"contract TokenERC20 { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=20000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d7b14967d103df9dbc16d408616da18c4ae83eb.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf208c7a5682d3835a58dadce8e249453ebd0ec0b.sol,FOIN,"contract FOIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); uint256 initialSupply = 100000; string tokenName = ; string tokenSymbol = ; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70bb80b39a361aba7695420157792d59791ce24d.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xef7e7984a6e9a77a32eaf6153135526f09f3c794.sol,YtChainToken,"contract YtChainToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor ( ) TokenERC20(30000000000, , ) public {}",1
0xee045942b043b92cca0c454a553649eaa80873ea.sol,TokenERC20,"contract TokenERC20 is SafeM{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 90000000* 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x2676d51e7a2e532f8e944e6ea5ca1cd07048ab08.sol,AHS,contract AHS { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x2672880d7be2b687b3a7f874fc4bf2eab7ab7074.sol,FundingWallet,contract FundingWallet{ bytes32 keyHash; address owner; bytes32 wallet_id = 0x65e40f866a57923fb46b18549dba76f1c748d751aa0d4b8b45a37297b734dc28; constructor() public { owner = msg.sender; },1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTToken,"contract EPTToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 64000000 * 10**18; uint256 public totalAllocatedTokens; uint256 public tokensAllocatedToCrowdFund; uint256 public foundersAllocation; address public founderMultiSigAddress; address public crowdFundAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier nonZeroAddress(address _to){ require(_to != 0x0); _; }",1
0x1d1cf6cd3fe91fe4d1533ba3e0b7758dfb59aa1f.sol,Dragon,"contract Dragon is ERC20 { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping( address => uint256) public balanceOf; mapping( uint => address) public accountIndex; uint accountCount; mapping(address => mapping(address => uint256)) public allowance; address public burner; bool public burnerSet; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint value); event Message ( address a, uint256 amount ); event Burn(address indexed from, uint256 value); function Dragon() { uint supply = 50000000000000000; appendTokenHolders( msg.sender ); balanceOf[msg.sender] = supply; totalSupply = supply; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x03ab65aa0a900e4df97ed8f3b316a261cef5affc.sol,ICT,"contract ICT { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ICT( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0xd0fa079f298c120946695d5c65a15c14355943b7.sol,PODD,contract PODD { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x5b614e4f17a1938da6248d116cc32f4f17c35f99.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => string) public keys; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Register (address user, string key); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x4523f19c7618cdbfc564f445ec92f8b8d1723c62.sol,UltimateCoin,"contract UltimateCoin is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UltimateCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x5046e860ff274fb8c66106b0ffb8155849fb0787.sol,JavaScriptToken,contract JavaScriptToken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 7991996 * 10**8; function name() public constant returns (string) { return ; },1
0x287d2215c5f73fb53badc102f4ae0ca37b1d3d22.sol,Bitzex,contract Bitzex is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function Bitzex() { balances[msg.sender] = 20762827198238982674857634; totalSupply = 20762827198238982674857634; name = ; decimals = 18; symbol = ; unitsOneEthCanBuy = 1000000; fundsWallet = msg.sender; },1
0x5562acc7749ed48ca4692a8d9d3cc25c3d8f9b2f.sol,TokenLayer,"contract TokenLayer is ERC721, Manageable { using SafeMath for uint256; event TokenCreated(uint256 tokenId, bytes32 name, uint256 parentId, address owner); event TokenDeleted(uint256 tokenId); event TokenSold( uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name, uint256 parentId ); event PriceChanged(uint256 tokenId, uint256 oldPrice, uint256 newPrice); event ParentChanged(uint256 tokenId, uint256 oldParentId, uint256 newParentId); event NameChanged(uint256 tokenId, bytes32 oldName, bytes32 newName); event MetaDataChanged(uint256 tokenId, bytes32 oldMeta, bytes32 newMeta); uint256 private constant DEFAULTPARENT = 123456789; mapping (uint256 => Token) private tokenIndexToToken; mapping (address => uint256) private ownershipTokenCount; address public gameAddress; address public parentAddr; uint256 private totalTokens; uint256 public devFee = 50; uint256 public ownerFee = 200; uint256[10] private chainFees = [10]; struct Token { bool exists; address approved; address owner; bytes32 metadata; bytes32 name; uint256 lastBlock; uint256 parentId; uint256 price; }",1
0xa1d38ef843553322a338cdd7d6134565ffba97ab.sol,LEVT,"contract LEVT is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public Claimed; string public constant name = ; string public constant symbol = ; uint public constant decimals = 8; uint256 public totalSupply = 22222222222e8; uint256 public totalDistributed; uint256 public constant requestMinimum = 1 ether / 100; uint256 public tokensPerEth = 11111111e8; uint256 public totalDonation; uint public target0drop = 400000; uint public progress0drop = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Airdrop(address indexed _owner, uint _amount, uint _balance); event TokensPerEthUpdated(uint _tokensPerEth); event Burn(address indexed burner, uint256 value); event Add(uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; }",1
0x2880163d22b8742a8736b21ae9f8b7f239a22243.sol,MyToken,"contract MyToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyToken() { balanceOf[msg.sender] = 1000000000000; totalSupply = 1000000000000; name = ; symbol = ; decimals = 6; }",1
0xb3ccb987036d9e93ea895aa78378e137f72a5e84.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd4c435f5b09f855c3317c8524cb1f586e42795fa.sol,MiniMeTokenFactory,"contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) returns (MiniMeToken) { MiniMeToken newToken = new MiniMeToken( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; }",1
0xedde8f9b753ae899794f09756e11999cf54c82c5.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x454a5244556e044ad6ecfcf3f59290fae47484e8.sol,MintableToken,"contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event Burn(address indexed burner, uint value); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; }",1
0x74c5ab4757fcdbf8732230ca154498ea0c538239.sol,TheIlluminati,contract TheIlluminati { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xb49c61b2da035bf198815a0d43f108530a834cce.sol,SafeMath,None,1
0x6bff83c6d87b1adff6679c75abac82fe7c38d7cf.sol,EasyInvestTurbo,contract EasyInvestTurbo { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; function () external payable { if (invested[msg.sender] != 0) { uint256 amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900; msg.sender.transfer(amount); },1
0x1dd72a0d3357901d51e791ba65476e101cb2c6a5.sol,TokenERC20,"contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { totalSupply = initialSupply * 10 ** uint256(decimalUnits); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; owner = msg.sender; }",1
0x20832ef3de12cc21c6411220e81dd906e038ce0d.sol,WeAPOWH,contract WeAPOWH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff.sol,BTYCEC,contract BTYCEC is ERC20Interface { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint public sysusermoney; uint public sysoutmoney; uint public sellPrice; uint public buyPrice; uint public btycbuyPrice; uint public btycsellPrice; uint public sysPer; uint public sysPrice1; uint public sysPer1; uint public systime1; uint public sysPrice2; uint public sysPer2; uint public systime2; uint public transper; bool public actived; uint public onceAddTime; uint public upper1; uint public upper2; uint public teamper1; uint public teamper2; uint public outper1; uint public outper2; uint public sellper; uint public sysday; uint public sysminteth; uint public hasoutmony; uint public hasbuymoney; uint public hassellmoney; uint public hasbuyeth; uint public hasselleth; uint public hasbtycbuymoney; uint public hasbtycsellmoney; mapping(address => uint) balances; mapping(address => uint) myeth; mapping(address => uint) froeth; mapping(address => mapping(address => uint)) allowed; mapping(address => bool) public frozenAccount; mapping(address => address) public fromaddr; mapping(address => uint) public crontime; mapping(address => uint) public mintnum; uint[] public permans; mapping(address => uint) public teamget; struct sunsdata{ uint n1; uint n2; uint getmoney; },1
0x0ec03c088cbfffdd0c2ba8c1cfa35f655a9ce078.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x789109d185f5f4205d58c533eb831fdefb0d10b8.sol,BlockchainofBeautifulandHealthyEcosystem,"contract BlockchainofBeautifulandHealthyEcosystem { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BlockchainofBeautifulandHealthyEcosystem( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x270c27a8e5b19f04cbf079797bbf2aaa931a22c6.sol,PET,"contract PET { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xedd4941d09bb0fafd230100c86ffbbd7907b6fed.sol,SafeMath,None,1
0x2a8cef60776d931eb1200aa2a9877eb091cb34a7.sol,TTC,"contract TTC { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address admin; mapping (address => bool) admin_list; function TTC( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { admin = msg.sender; admin_list[admin] = true; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x1eab19e6623e8cbcafc252e275f5b51c27656faf.sol,Spank,"contract Spank is ERC20, Owned { using SafeMath for uint256; string public name; string public symbol; uint256 public decimals; uint256 public initialSupply; uint256 public totalSupply; uint256 multiplier; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) revert(); _; }",1
0x33259c14a28c89af457c9dbac9743f3efb651f09.sol,PODH,contract PODH { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x70838403ecc194b73e50b70a177b2ef413a2f421.sol,bzxcoin,"contract bzxcoin is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 10**25; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function bzxcoin(){ balanceOf[msg.sender] = totalSupply; }",1
0x0db8d8b76bc361bacbb72e2c491e06085a97ab31.sol,iQeon,"contract iQeon is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function iQeon( ) public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xef8a2c1bc94e630463293f71bf5414d13e80f62d.sol,SupplySchedule,contract SupplySchedule is Owned { using SafeMath for uint; using SafeDecimalMath for uint; struct ScheduleData { uint totalSupply; uint startPeriod; uint endPeriod; uint totalSupplyMinted; },1
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,HFCoin,"contract HFCoin { string public name; string public symbol; address public owner; uint256 public prizeAmount = 0; bool public gameStarted = false; bool public prizeWon = false; mapping (address => uint256) public balanceOf; event Burn(address indexed from, uint256 value); event Redemption(address indexed from, uint256 value); event TokenRequest(address indexed from, uint256 value); event Winner(address indexed from); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xbd791314f50c8854866ce4db764b3031d7a9a68e.sol,KycContract,contract KycContract is Owned { mapping (address => bool) verifiedAddresses; function isAddressVerified(address _address) public view returns (bool) { return verifiedAddresses[_address]; },1
0xbca5b3524e2d52c38fd6ca6dd10233575baa8533.sol,VOCC_I098_20181211,"contract VOCC_I098_20181211 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x6cf2de9eabbcbb45d12294acbdbd8cd6f23e8a7f.sol,AFCoin,"contract AFCoin { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AFCoin(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf35470b6182cbd9a0f0c01d8f491b18445707c7d.sol,ERC827Caller,"contract ERC827Caller { function makeCall(address _target, bytes _data) external payable returns (bool) { return _target.call.value(msg.value)(_data); }",1
0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x4c4bcb4ffa0d7eab9287d1df294c8391e3b8096f.sol,PDVBO,"contract PDVBO { bytes32 public name; bytes6 public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PDVBO( ) public { totalSupply = 1000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xede79a28fe8e2edb3efb629e7396034f76c22cc3.sol,FreeMoney,contract FreeMoney { uint public remaining; function FreeMoney() public payable { remaining += msg.value; },1
0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57.sol,ERC23Token,contract ERC23Token is ERC23 { mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; },1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xee8c282901c523d1933478d223f28d2a25c4b63a.sol,POOL,contract POOL { bytes32 keyHash; address owner; bytes32 wallet_id = 0xad2f7721e166f8f6df08fe098755259c399a8437944ad54b97ac73c77ffd43c4; constructor() public { owner = msg.sender; },1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x74a31dc20802cb1e41201af055ce7dfcd31d291d.sol,m10fanclub,"contract m10fanclub is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function m10fanclub() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 12 weeks; endDate = now + 52 weeks; }",1
0x2868f8e9425a7f5cfe989026b6cabb19a01d51d6.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 0; uint256 public totalSupply; mapping (address => uint256) public balanceOf; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x471407f224b99bb3347de2609bc117dad367f889.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }",1
0x4bb0f20cf2e4cd470ed9537b1b69aa7a2c53707d.sol,_List_Glory_,contract _List_Glory_{ string public info_Name; string public info_Symbol; address public info_OwnerOfContract; string[] private listTINAmotley; uint256 private listTINAmotleyTotalSupply; mapping (uint => address) private listTINAmotleyIndexToAddress; mapping(address => uint256) private listTINAmotleyBalanceOf; struct forSaleInfo { bool isForSale; uint256 tokenIndex; address seller; uint256 minValue; address onlySellTo; },1
0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00.sol,MSCE,"contract MSCE is Ownable, StandardToken, BurnableToken{ using SafeMath for uint256; uint8 public constant TOKEN_DECIMALS = 18; string public name = ; string public symbol = ; uint8 public decimals = TOKEN_DECIMALS; uint256 public totalSupply = 500000000 *(10**uint256(TOKEN_DECIMALS)); uint256 public soldSupply = 0; uint256 public sellSupply = 0; uint256 public buySupply = 0; bool public stopSell = true; bool public stopBuy = false; uint256 public crowdsaleStartTime = block.timestamp; uint256 public crowdsaleEndTime = 1526831999; uint256 public crowdsaleTotal = 2000*40000*(10**18); uint256 public buyExchangeRate = 40000; uint256 public sellExchangeRate = 100000; address public ethFundDeposit; bool public allowTransfers = true; mapping (address => bool) public frozenAccount; bool public enableInternalLock = true; uint256 unitCount = 100; uint256 unitTime = 1 days; uint256 lockTime = unitCount * unitTime; mapping (address => bool) public internalLockAccount; mapping (address => uint256) public releaseLockAccount; mapping (address => uint256) public lockAmount; mapping (address => uint256) public lockStartTime; mapping (address => uint256) public lockReleaseTime; event LockAmount(address _from, address _to, uint256 amount, uint256 releaseTime); event FrozenFunds(address target, bool frozen); event IncreaseSoldSaleSupply(uint256 _value); event DecreaseSoldSaleSupply(uint256 _value); function MSCE() public { balances[msg.sender] = totalSupply; ethFundDeposit = msg.sender; allowTransfers = true; }",1
0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d.sol,Transaction,contract Transaction is Ownable { struct TransactionNeoPlace { uint id; address seller; address buyer; bytes16 itemId; bytes8 typeItem; string location; string pictureHash; bytes16 receiptHash; string comment; bytes8 status; uint256 _price; },1
0x788ca5935759c06ea223d0e2cf5ea5729d669c18.sol,BancorConverter,"contract BancorConverter is ITokenConverter, SmartTokenController, Managed { uint32 private constant MAX_WEIGHT = 1000000; uint32 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x5870a119fccc91a46426ed1d4f12f8384f372e93.sol,TEG,"contract TEG{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TEG() public { balances[msg.sender] = 1600000000000; totalSupply = 1600000000000; name = ; decimals =4; symbol = ; }",1
0x7909209a3d78a66f6d71885f10b6ea7c6c58177b.sol,Try_Me,contract Try_Me { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 2 ether) { msg.sender.transfer(this.balance); },1
0x412c003380e08921be3ee7ee5830d3a00dd7e589.sol,AeternumLibertarianFoundationToken,"contract AeternumLibertarianFoundationToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AeternumLibertarianFoundationToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xb41ae4f3a164145629602468ecffcf0eb59e559c.sol,ECRecovery,None,1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0xf297a0806f24dbc96794af54c8c3691874c430f4.sol,ForestEcosphere,"contract ForestEcosphere { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x92251fd0e744f7c5aac55c60c98ddafc48e97e18.sol,GCCTTOKEN,"contract GCCTTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GCCTTOKEN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94.sol,Token,"contract Token { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6576963107077cce5ec879978c03ec6bb300cc89.sol,SafeMath,None,1
0x849919acec8627dde44da59e1a9737985d022b9d.sol,ChatBitToken,"contract ChatBitToken is owned, TokenERC20 { uint256 public sellPrice = 20180418134311; uint256 public buyPrice = 1000000000000000000; uint256 public limitAMT = 0; bool public isPreSales = false; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function ChatBitToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x8815df7e7e92b9b038658f0870e062548136e8cd.sol,LDC,"contract LDC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",1
0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20() public { totalSupply = 36000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x37aa63c4cbd06a57f1ea35bceee4e46f0a7ce924.sol,SafeMath,None,1
0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc.sol,CoinwareToken,"contract CoinwareToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CoinwareToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 260000000000000000000000000; balances[0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F] = _totalSupply; Transfer(address(0), 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F , _totalSupply); }",1
0x880016750db7d4b040a0d9b15aad966fa47cfea4.sol,CCD_KOHLE_7_20190411,"contract CCD_KOHLE_7_20190411 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x71f2ea939984349838578fbd20fd25e649c1d6a3.sol,RecoverEosKey,"contract RecoverEosKey { mapping (address => string) public keys; event LogRegister (address user, string key); function register(string key) public { assert(bytes(key).length <= 64); keys[msg.sender] = key; emit LogRegister(msg.sender, key); }",1
0xa211db1867e4fa5dc0dd4d8f51f177a51d054d94.sol,ZTKGamers,"contract ZTKGamers is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 5000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 962; uint256 public totalZTKCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; event ZTKCheckIssue(string chequeIndex); struct ZTKCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x1e5cbdf415dc6a762ad4ded7743aa9fe0837ff9e.sol,HKIN,"contract HKIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HKIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0eb113e6a8b14c539c7bd7ed5f52678b1a47a7ed.sol,Busters,"contract Busters is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 5000000000000; balances[0xe70881f038163Ad674857A43313304ca25099F2A] = _totalSupply; emit Transfer(address(0), 0xe70881f038163Ad674857A43313304ca25099F2A, _totalSupply); }",1
0x01a922de9af2c1158dd947ea5b794f0dd995c7df.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xbfb3b6972a814e2f6ed6d6fb9f9e47cd0b13720a.sol,SafeDivs,"contract SafeDivs { using SafeMath for *; address public devAddr_ = address(0xe6CE2a354a0BF26B5b383015B7E61701F6adb39C); address public affiAddr_ = address(0x08F521636a2B117B554d04dc9E54fa4061161859); address public partnerAddr_ = address(0x08962cDCe053e2cE92daE22F3dE7538F40dAEFC2); bool public activated_ = false; modifier isActivated() { require(activated_ == true, ); _; }",1
0x4b9cf3bb930e3eb8a37645ab28194dcc05e1e0aa.sol,JYToken,contract JYToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x73b0ebea28f76be1368d578d13657354330472a9.sol,CryptoArtsToken,"contract CryptoArtsToken is AccessControl, DetailedERC721 { using SafeMath for uint256; event TokenCreated(uint256 tokenId, string name, uint256 price, address owner); event TokenSold(uint256 indexed tokenId, string name, uint256 sellingPrice, uint256 newPrice, address indexed oldOwner, address indexed newOwner); mapping (uint256 => address) private tokenIdToOwner; mapping (uint256 => uint256) private tokenIdToPrice; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public tokenIdToApproved; struct Art { string name; }",1
0xf46f049967ed63b864a7f6cdf91d6dac9ea23b2c.sol,WhaleKiller,contract WhaleKiller { address WhaleAddr; uint constant interest = 5; uint constant whalefee = 1; uint constant maxRoi = 150; uint256 amount = 0; mapping (address => uint256) invested; mapping (address => uint256) timeInvest; mapping (address => uint256) rewards; constructor() public { WhaleAddr = msg.sender; },1
0x50f37df80a4e804a03275b21f83ebf5d5a668d39.sol,AuctionPotato,"contract AuctionPotato is Ownable { using SafeMath for uint256; string name; uint public startTime; uint public endTime; uint auctionDuration; uint public potato; uint oldPotato; uint oldHighestBindingBid; bool public canceled; uint public highestBindingBid; address public highestBidder; bool blockerPay; bool blockerWithdraw; mapping(address => uint256) public fundsByBidder; bool ownerHasWithdrawn; event LogBid(address bidder, address highestBidder, uint oldHighestBindingBid, uint highestBindingBid); event LogWithdrawal(address withdrawer, address withdrawalAccount, uint amount); event LogCanceled(); event Withdraw(address owner, uint amount); constructor() public { blockerWithdraw = false; blockerPay = false; highestBindingBid = 3000000000000000; potato = 0; auctionDuration = 3 hours; startTime = 1546794000; endTime = startTime + auctionDuration; name = ; }",1
0xdf195c2101959f6f39f583ffa5a2aeae71c0f503.sol,SCOIN,"contract SCOIN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SCOIN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf2d3bee00851fdf205f4fe825fe89d2abff88231.sol,WOB,"contract WOB { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function WOB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol,Snip3D,contract Snip3D is Owned { using SafeMath for uint; uint public _totalSupply; mapping(address => uint256)public balances; mapping(address => uint256)public bullets; mapping(uint256 => address)public formation; uint256 public nextFormation; mapping(address => uint256)public lastMove; mapping(uint256 => address) public RefundWaitingLine; uint256 public NextInLine; uint256 public NextAtLineEnd; uint256 public Refundpot; uint256 public blocksBeforeSemiRandomShoot = 200; uint256 public blocksBeforeTargetShoot = 800; event death(address indexed player); event semiShot(address indexed player); event targetShot(address indexed player); constructor() public { },1
0x20900587e569e3d0b2609bca6fb3469765ed0920.sol,Bitpoint,"contract Bitpoint is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Bitpoint() public { symbol = ; name = ; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8] = _totalSupply; Transfer(address(0), 0x70D45684E72d382F7DF7276fa06Cf6E7F95A5dd8, _totalSupply); }",1
0xcec0922b39cf101c892f9f6aa80488d3cbdd771a.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x778608c4ac424522180a43329ff5145400b9d409.sol,ChainclubToken,contract ChainclubToken is StandardToken { string public name; uint8 public decimals; string public symbol; function ChainclubToken() { balances[msg.sender] = 0.21 ether; totalSupply = 0.21 ether; name = ; decimals = 8; symbol = ; },1
0xdae7367a4cecad9b0a37c6bde1263a9a9f7aceb3.sol,Photos,"contract Photos is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Photos() public { symbol = ; name = ; decimals = 6; _totalSupply = 1000000000000; balances[0xE15902055f380BbB907705054800c3f5Bf2Cf72B] = _totalSupply; Transfer(address(0), 0xE15902055f380BbB907705054800c3f5Bf2Cf72B, _totalSupply); }",1
0xed01e8865689602a840fa4855f0d7886268f250b.sol,Uselesslightbulb,contract Uselesslightbulb is Ownable { uint weiPrice = 1000000000000000; uint count = 0; function toggle() public payable { require(msg.value >= weiPrice); count++; },1
0xdcb6622cb14e44213092a986d5654ad599e7ebfe.sol,NOWToken,"contract NOWToken is Z_StandardToken, Z_Ownable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18); uint256 internal constant WEI_PER_ETHER= 1000000000000000000; uint256 internal constant NUM_OF_SALE_STAGES= 5; enum Sale_Status { Initialized_STATUS, Stage0_Sale_Started_STATUS, Stage0_Sale_Stopped_STATUS, Stage1_Sale_Started_STATUS, Stage1_Sale_Stopped_STATUS, Stage2_Sale_Started_STATUS, Stage2_Sale_Stopped_STATUS, Stage3_Sale_Started_STATUS, Stage3_Sale_Stopped_STATUS, Stage4_Sale_Started_STATUS, Stage4_Sale_Stopped_STATUS, Public_Allowed_To_Trade_STATUS, Stage0_Allowed_To_Trade_STATUS, Closed_STATUS }",1
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x5ab6aad76a702591724b7788b0fbea6292638561.sol,CIC,"contract CIC is owned { address public deployer; string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public { if(centralMinter != 0 ) owner = centralMinter; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; deployer = msg.sender; }",1
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x17c3b17843a7dd182ba35d21a88a71d6c4af216a.sol,vault,contract vault { bytes32 keyHash; address owner; bytes32 wallet_id = 0x3af0ca95df423181d4a5af13676ad1e6576c9d8d21d0c4fec0c1f42af389fa86; constructor() public { owner = msg.sender; },1
0xda6245b3355e15cb38f65701700876de75ef4bef.sol,HOT,"contract HOT { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function HOT() public { totalSupply = 500000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0xf0902adc8ebe58c4874f371066fd339519ae1d32.sol,SHERE_PFIII_III_883,"contract SHERE_PFIII_III_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1864492808887740000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x3ff283f4b333f0c046dea47938a413a2bae56bf5.sol,FantasySportsCoin,"contract FantasySportsCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FantasySportsCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0] = _totalSupply; Transfer(address(0), 0xE5F40f8f8EFe44bDf3585e2779bc855d2Ce214c0, _totalSupply); }",1
0x279fd66b7621468ca14f60eaa205dae94c484dbf.sol,OfflineSecret,"contract OfflineSecret { modifier validSecret(address to, string secret, bytes32 hashed) { require(checkSecret(to, secret, hashed)); _; }",1
0x3fdd90ccdb7a430dac92580170a47f278322a9a0.sol,MDIVToken,"contract MDIVToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MDIVToken() public { symbol = ; name = ; decimals = 10; _totalSupply = 1000000000000000000; balances[0xa149a7230cACE190905E9B50954471825C261021] = _totalSupply; emit Transfer(address(0), 0xa149a7230cACE190905E9B50954471825C261021, _totalSupply); }",1
0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71.sol,CRYPTOBUX,"contract CRYPTOBUX is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CRYPTOBUX() public { symbol = ; name = ; decimals = 18; _totalSupply = 890000000000000000000000000; balances[0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B] = _totalSupply; Transfer(address(0), 0xC37F4f21172F0C5a461b46Ce1Ac4e6c25B5F303B, _totalSupply); }",1
0x86c6a7ee4ec24d25456580d81f7e8f486186ec91.sol,Coin,"contract Coin { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint256 public _totalSupply = 0; uint256 public _maxSupply = 33000000000000000000000; uint256 public price = 2000; bool private workingState = true; bool private transferAllowed = true; bool private generationState = true; address public owner; address private cur_coin; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) private etherClients; event FundsGot(address indexed _sender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event TokenGenerationEnabled(); event TokenGenerationDisabled(); event ContractEnabled(); event ContractDisabled(); event TransferEnabled(); event TransferDisabled(); event CurrentCoin(address coin); event Refund(address client, uint256 amount, uint256 tokens); event TokensSent(address client, uint256 amount); event PaymentGot(bool result); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x2e87fbbf2f222e8dc16ae29441a47ffc07503063.sol,SuNFT,"contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces { mapping (uint256 => address) internal tokenApprovals; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { address owner = _tokenOwnerWithSubstitutions[_tokenId]; require(msg.sender == owner); _; }",1
0x0e16923571c50a48b4f9b3b8319606ef8d6106ae.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x597f180157564555ffd96235806415573a02ecb0e9af129d1ddc24e53fe00c96; constructor() public { owner = msg.sender; },1
0xd59b961d5be7ae59486cf4431cbd5534c9ef4f0d.sol,TTCoin,"contract TTCoin is SafeMath,owned{ string public name; string public symbol; uint8 public decimals=8; uint256 public totalSupply; uint256 public soldToken; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function TTCoin( ) { totalSupply = 10000000000 *10**uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; soldToken=0; }",1
0x53877b7c93c80c9631c73c5feda1e421d836a39c.sol,CryptaurDepository,"contract CryptaurDepository is owned, AddressBook { enum UnlimitedMode {UNLIMITED,LIMITED}",1
0x560431a917c5bf4f5831935a199d6516472bcff1.sol,POFOMO,contract POFOMO { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x472eb1a4c31e4c6557feb00e90987e564ca412af.sol,MogoToken,"contract MogoToken is TokenERC20{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 200000000 * 10 ** uint256(decimals); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor() public{ balanceOf[msg.sender] = totalSupply; }",1
0x028ff933bd86bd4d699b1643477f858626482d35.sol,LUCKER,contract LUCKER is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; uint256 opentime=now+3600; uint256 opensome; uint256 _opensome; uint256 BEBMAX; uint256 BEBtime; uint256 Numberofairdrops; address ownersto; struct luckuser{ uint256 _time; uint256 _eth; uint256 _beb; uint256 _bz; uint256 _romd; uint256 Bond; uint256 sumeth; uint256 sumbeb; },1
0x8c28350a9449397f6ccbc61dd724601193a5dea0.sol,MGTToken,contract MGTToken { string public name = ; string public symbol = ; uint256 public decimals = 8; string public constant PRICE_PRESALE = ; address public adminWallet; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint public constant TOKEN_SUPPLY_TOTAL = 20000000000000000; uint public tokensIssuedIco = 14000000000000000; uint256 constant valueFounder = TOKEN_SUPPLY_TOTAL; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; },1
0x2fb23f5b0b18e947186c9cc848b86d550c81711c.sol,AndhraToken,"contract AndhraToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AndhraToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000000; balances[0x3878c8700b65afcc237f0cf29dc7eae7fa236192] = _totalSupply; Transfer(address(0), 0x3878c8700b65afcc237f0cf29dc7eae7fa236192, _totalSupply); }",1
0x920231a0e58d685f29ca3838777093fad88f665f.sol,Moongang,contract Moongang { modifier onlyOwner { require(msg.sender == owner); _; },1
0xd1b4fdf2fdeb790df015bf0b74bf43253b9ac2da.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x3fe53debe8720a61a3e40f85da8611e810fe1fa0.sol,MyTokenEVC,"contract MyTokenEVC is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MyTokenEVC() public { totalSupply = 0 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xf3eb09a1fd5a3e133a669074de1231d7a673744b.sol,ExoTownToken,"contract ExoTownToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; address public icoContract = 0x0; modifier onlyIcoContract() { require(msg.sender == icoContract); _; }",1
0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0xc592c63a86d03d1ac2aad4a0a2d5cd1eb724ddba.sol,SafeMath,None,1
0x3a8a6d2bc23fb68a245250ad34019a65cf057418.sol,DiscountPercentToken,"contract DiscountPercentToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function DiscountPercentToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1d90a6825550feac7406fbc7714b67f329a8d3f1.sol,Airdropper,"contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x3a57137eb81e70fe3975f8121a913d5d033f81b3.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x64e65d352f6a2949463b3a7595911b61bbafc63e.sol,KIPToken,"contract KIPToken{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 10000000000; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x873467738b5053f155639208b7495318fced5262.sol,StreamNetworkToken,"contract StreamNetworkToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StreamNetworkToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 7632819325000000000000000000; balances[0xcfb1E02D3687B7Eedea33E8acA96Bc34869fE17b] = _totalSupply; Transfer(address(0), 0xcfb1E02D3687B7Eedea33E8acA96Bc34869fE17b, _totalSupply); }",1
0x5548003c0610a9be74eecd469db94e947601209a.sol,MylittleProgram,contract MylittleProgram { using SafeMath for uint256; mapping (address => bool) private admins; mapping (uint => uint256) public levels; mapping (uint => bool) private lock; address contractCreator; address winnerAddress; uint256 prize; function MylittleProgram () public { contractCreator = msg.sender; admins[contractCreator] = true; },1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,SmartBillions,contract SmartBillions is StandardToken { string public constant name = ; string public constant symbol = ; uint public constant decimals = 0; struct Wallet { uint208 balance; uint16 lastDividendPeriod; uint32 nextWithdrawBlock; },1
0xdb2fb534e111e57e1a97adae7fdb83d92062e3c1.sol,EAB,"contract EAB { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EAB( ) public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = 500000000000000000000000000; name = ; symbol = ; }",1
0xa2dfd314cb3fcf821300a2e518469b6544ad6a84.sol,threeZZZToken,"contract threeZZZToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function threeZZZToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xf42455BDBA7584b614A2F4E8A5e687ffF31fd896] = _totalSupply; Transfer(address(0), 0xf42455BDBA7584b614A2F4E8A5e687ffF31fd896, _totalSupply); }",1
0xbd80161e3c4d7d18ec8f86002da2529f1e4b034b.sol,GameConfig,"contract GameConfig { using SafeMath for SafeMath; address public owner; event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction); event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity); event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase); struct Card { uint256 cardId; uint256 baseCoinCost; uint256 coinCostIncreaseHalf; uint256 ethCost; uint256 baseCoinProduction; bool unitSellable; }",1
0x4d50c99294daa84d8de9b2a5b9b6a6d9a8d88aa3.sol,SERBIA_WINS,"contract SERBIA_WINS { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 1174363746596490000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x546e955456867a5822bb9532973f7380f1bf55a1.sol,VIRALTOKEN,contract VIRALTOKEN is VRTStandardToken { uint256 constant public decimals = 18; uint256 public totalSupply = 25 * (10**6) * 10**18 ; string constant public name = ; string constant public symbol = ; string constant public version = ; function VIRALTOKEN(){ balances[msg.sender] = totalSupply; },1
0xc59cb23295e2deeb66bd090acb6b02be8d30a11f.sol,Utils,contract Utils { function Utils() { },1
0x3763fc61bc1b54d97dfdbd1501a3ff476bd99c36.sol,MworldElectronicsportscoin,"contract MworldElectronicsportscoin { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xbfc70f2151b471794422fd06480933192f3da674.sol,SIE_DE_301202,"contract SIE_DE_301202 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10972781423493000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xcd856a8d411f43392c21d89271dd0bf565128080.sol,Fundraising,contract Fundraising { bytes32 keyHash; address owner; bytes32 wallet_id = 0x9285ec36936b38aaf7f00c9d18ea89687d857f5d728b4df9a8b995b1e7b60d85; constructor() public { owner = msg.sender; },1
0x1d935f49c1574d4b109dd7f5ff660de3adeb5a0f.sol,COCOIN,"contract COCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 2000000000000000000000000000; balances[0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5] = _totalSupply; emit Transfer(address(0), 0x36a05d957B68d2400bc77cDb11A048e4B56ca3f5, _totalSupply); }",1
0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee.sol,TryToPlay,contract TryToPlay { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x1dacefe4f8eedef2524fa729f563a86695b8888e.sol,CCECOIN,"contract CCECOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CCECOIN() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xeE0fE0037C11685025d07864781338fbbb2e3159] = _totalSupply; Transfer(address(0), 0xeE0fE0037C11685025d07864781338fbbb2e3159, _totalSupply); }",1
0x5b202f04786e6e9c0a689b1506af229f095d2d0e.sol,BenziToken,"contract BenziToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BenziToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 1000000000e18; balances[0x743fd6d924ae32ccddb377f11d43129cdd0d0d00] = _totalSupply; Transfer(address(0), 0x743fd6d924ae32ccddb377f11d43129cdd0d0d00, _totalSupply); }",1
0x366efd14d20302ab592ffff7bfa4ccb244c19ad9.sol,LCoin,"contract LCoin { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; string public name; string public symbol; uint8 public decimals; constructor(uint _totalSupply,string tokenName,string tokenSymbol,uint8 decimalUnits) public{ balanceOf[msg.sender] = _totalSupply; totalSupply = _totalSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x5ac8359a7d38afedf7ed0d4abb283cd2654d126a.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0xd082e9e4f9b39bad6103c330292a7b219bf3b740.sol,BIBToken,"contract BIBToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function BIBToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xef09dd7bc772d135778e58f0696132ce7610ab34.sol,Voting,"contract Voting{ address owner; event Voting(uint256 videoNum, uint256 totalVoting); event ChangeOwner(address owner); mapping (uint256=>uint256) totalVoting; constructor(){ owner = msg.sender; }",1
0xd4111b29cfc55c147b4fe759c8d99012df597065.sol,WHDCToken,"contract WHDCToken is Pausable{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xd35be56e4ed6818d09e6f95b9c744c4607fda453.sol,ProofOfBitConnect,contract ProofOfBitConnect { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x842d6da3097b5efde5a81535144f947ab482b6ee.sol,WhoTheEth,"contract WhoTheEth { address owner; uint public numberOfNames; mapping(address => string) public names; mapping(address => uint) public bank; event AddedName( address indexed _address, string _name, uint _time, address indexed _referrer, uint _value ); function WhoTheEth() public { owner = msg.sender; }",1
0xa226aa0c9039808f72f3ef62205b7be58da12fef.sol,Etheradium,"contract Etheradium is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Etheradium() public { symbol = ; name = ; decimals = 18; _totalSupply = 1500000000000000000000000000; balances[0xa35514a419D9807905778300b8F547C2b2E8C4AE] = _totalSupply; Transfer(address(0), 0xa35514a419D9807905778300b8F547C2b2E8C4AE, _totalSupply); }",1
0xa5b1685b23db36859611cac03e0c68daf0e3c0a1.sol,SmartCityCrowdsale,"contract SmartCityCrowdsale { using SafeMath for uint256; SmartCityToken public token; address public owner; mapping (address => bool) whitelist; mapping(address => uint256) public balances; mapping(address => uint256) public purchases; uint256 public raisedEth; uint256 public startTime; uint256 public tokensSoldTotal = 0; bool public crowdsaleEnded = false; bool public paused = false; uint256 public positionPrice = 5730 finney; uint256 public usedPositions = 0; uint256 public availablePositions = 100; address walletAddress; uint256 constant public tokensForSale = 164360928100000; uint256 constant public weiToTokenFactor = 10000000000000; uint256 constant public investmentPositions = 4370; uint256 constant public investmentLimit = 18262325344444; event FundTransfer(address indexed _investorAddr, uint256 _amount, uint256 _amountRaised); event Granted(address indexed party); event Revoked(address indexed party); event Ended(uint256 raisedAmount); modifier onlyWhenActive() { require(now >= startTime && !crowdsaleEnded && !paused); _; }",1
0x65832facdc1eefbcfaf50f570228ba886f745681.sol,SmartToken,"contract SmartToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function SmartToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xb7710726f14E238aAfb93aDc00A0A7B5755109c1] = _totalSupply; Transfer(address(0), 0xb7710726f14E238aAfb93aDc00A0A7B5755109c1, _totalSupply); }",1
0x40eb7549cb14d3ed0b165ade56dcfdb6352b4fdd.sol,SendLove,"contract SendLove is Ownable { function multisend(address _tokenAddr, address[] _to, uint256[] _value) returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 150); for (uint8 i = 0; i < _to.length; i++) { assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true); }",1
0x92f6096a93a6ebb6bc439831a7f30f1e6020f184.sol,ROPE,"contract ROPE{ string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000; bool public transferrable = true; address public contract2Address; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ROPE( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c66bb904ceaa80aa224193728d459b109115ec2.sol,TBC,"contract TBC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() { totalSupply = 5000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x5510f1996e210659e135b05d6bf48d6682af23a7.sol,EthereumPrivate,"contract EthereumPrivate { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1c3a7bafd90133756ac63fee437844c47f707420.sol,ZenswapDistribution,contract ZenswapDistribution is Ownable { token public tokenReward; constructor() public { tokenReward = token(0x4fa000dF40C06FC8c7D9179661535846B7Cd4f87); },1
0x0e9186d1d0c7aa2212e3f42405eda1bc35d826a9.sol,DailyDraw,contract DailyDraw is Owned{ bytes32 public number; uint public timeLimit; uint public ticketsSold; struct Ticket { address addr; uint time; },1
0x71529cea068e3785efd4f18aaf59a6cb82b7e5cb.sol,BBXCoin,"contract BBXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BBXCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 19999999000000000000000000; balances[0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515] = _totalSupply; Transfer(address(0), 0xEF871E2F799bbF939964E9b707Cb2805EB4Bd515, _totalSupply); }",1
0x841941debf6a89f673d174d6bbf71b96e69cacb7.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,Reputation,contract Reputation { address owner; mapping(address => bool) whitelist; mapping(address => int) ratings; constructor () public { owner = msg.sender; },1
0x6fa8b7532cae4e8feedadfb4a757a43ae5243165.sol,BING,"contract BING is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function BING( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol,TokenRHT,"contract TokenRHT is ERC20, SafeMath { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; bool public SC_locked = true; bool public tokenCreated = false; uint public DateCreateToken; mapping(address => uint256) balances; mapping(address => bool) public frozenAccount; mapping(address => bool) public SmartContract_Allowed; function TokenRHT() public { require(tokenCreated == false); owner = msg.sender; name = ; symbol = ; decimals = 5; totalSupply = 500000000 * 10 ** uint256(decimals); balances[owner] = totalSupply; emit Transfer(owner, owner, totalSupply); tokenCreated = true; require(balances[owner] > 0); DateCreateToken = now; }",1
0x72907f5d1417404d9e4963d53107ddd4237aa10d.sol,ecothereum,"contract ecothereum is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ecothereum ( ) public { totalSupply = 41000000 * 10e17; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x3375d3d9df8c67b3d7ebce220c3dda4be03dce31.sol,SantimentWhiteList,contract SantimentWhiteList { string constant public VERSION = ; function () { throw; },1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0x06fba879216e50fbc51e5b99cc264026a0152374.sol,LUCKen,contract LUCKen is Ownable{ address[] public bebdsds; uint256 _min; uint256 _max; tokenTransfer public bebTokenTransfer; function LUCKen(address _tokenAddress){ bebTokenTransfer = tokenTransfer(_tokenAddress); },1
0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26.sol,ELHeroToken,"contract ELHeroToken is ERC721,AccessAdmin{ struct Card { uint16 protoId; uint16 hero; uint16 quality; uint16 feature; uint16 level; uint16 attrExt1; uint16 attrExt2; }",1
0x1e05efba2fd19cc48a123a9e38afa6a9ffc18f41.sol,TwentyOneMillionToken,contract TwentyOneMillionToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; },1
0xf528d0e1e11edee40ca3724bd9fd923bb0235cc3.sol,TGCToken,"contract TGCToken is StandardToken { string public constant NAME = ; string public constant SYMBOL = ; uint public constant DECIMALS = 18; uint8[10] public bonusPercentages = [ 20, 10, 0 ]; uint public constant NUM_OF_PHASE = 3; uint16 public constant BLOCKS_PER_PHASE = 29000; address public target; uint public firstblock = 0; bool public unsoldTokenIssued = false; uint256 public constant GOAL = 3000 ether; uint256 public constant HARD_CAP = 4500 ether; uint256 public constant BASE_RATE = 10000; uint public totalEthReceived = 0; uint public issueIndex = 0; event SaleStarted(); event SaleEnded(); event InvalidCaller(address caller); event InvalidState(bytes msg); event Issue(uint issueIndex, address addr, uint ethAmount, uint tokenAmount); event SaleSucceeded(); event SaleFailed(); modifier onlyOwner { if (target == msg.sender) { _; }",1
0x2919336f7a427de135dc515fc5004b083d171ba4.sol,CryptoPokerMarket,"contract CryptoPokerMarket is CryptoPokerBase { event fallbackTrigged(bytes data); event saleCardEvent(address _address,uint256 price); event createSaleCardEvent(address _address); function() public payable { emit fallbackTrigged(msg.data); }",1
0x519e5585540ac8d5770cfcd8175bbbd2a6430367.sol,Ethereum_Nika_Database_Service,contract Ethereum_Nika_Database_Service { NikaToken public token; struct VariableAmounts { bool isset; address blank_address; uint256 large_amount; uint256 large_amount2; string string1; string string2; string string3; string string4; string string5; string string6; string string7; string string8; },1
0x1cc2a863c070340f21f441648bbceed77656a137.sol,KeytonToken,"contract KeytonToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function KeytonToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000000; balances[0x6360E136A401D4373B3AB084F46Ea9550d088302] = _totalSupply; Transfer(address(0), 0x6360E136A401D4373B3AB084F46Ea9550d088302, _totalSupply); }",1
0x584a0ec8a7a3fcfed27db5c234a9062863883778.sol,StandardToken,"contract StandardToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function StandardToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x0352e1aaeeaa975b3aadfe1f5fc9ee2bf702ffd1.sol,ERC20Store,contract ERC20Store is ERC20ImplUpgradeable { uint256 public totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public { totalSupply = 0; },1
0xcd74d15b488ed7ef7874819e8cb6daa75a759dc3.sol,OPTPRG_EURRUB_20190423_1,"contract OPTPRG_EURRUB_20190423_1 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14400000000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x69baeddcf90c95a4d81002de6a669c7b993139d4.sol,ZenswapContributeTest,contract ZenswapContributeTest is Ownable { address public beneficiary; uint256 public amountTokensPerEth = 200000000; uint256 public amountEthRaised = 0; uint256 public availableTokens; token public tokenReward; mapping(address => uint256) public balanceOf; constructor() public { beneficiary = msg.sender; tokenReward = token(0xbaD16E6bACaF330D3615539dbf3884836071f279); },1
0x205969440ffcf5493df62a974ad8a30ec96527ea.sol,NDD_DBX_I_883,"contract NDD_DBX_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 505773630192928000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xe35ff61bbec1c56f5aa304de7bf173d29970d0ac.sol,lindyhanCoin,"contract lindyhanCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function lindyhanCoin() public { symbol = ; name = ; decimals = 0; _totalSupply = 1000000; balances[0x4427bC64b0f00C29393e5b03C164cc9629fF83E8] = _totalSupply; Transfer(address(0), 0x4427bC64b0f00C29393e5b03C164cc9629fF83E8, _totalSupply); }",1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x33bd43ba9c71968c132f61246a79c18f9bdf0267.sol,BouncyCoinSelfdrop,"contract BouncyCoinSelfdrop { event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount); uint256 public constant MAX_TOKENS_SOLD = 14000000000 * 10**18; uint256 public constant PRICE = 0.00000006665 * 10**18; uint256 public constant MIN_CONTRIBUTION = 0.01 ether; uint256 public constant HARD_CAP = 500 ether; uint256 oct_17 = 1539734400; uint256 oct_24 = 1540339200; uint256 oct_28 = 1540684800; uint256 public first_round_base_multiplier = 40; uint256 public second_round_base_multiplier = 20; uint256 public third_round_base_multiplier = 0; address public owner; address public wallet; uint256 public tokensSold; uint256 public totalReceived; ERC20 public bouncyCoinToken; Stages public stage; enum Stages { Deployed, Started, Ended }",1
0x715ea4b194e90e2c6861192be7883fe481bf8be4.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0xf45c4e30e9a4d8107d7dbd0556065baedf03838d.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,ProperProposal,"contract ProperProposal is ProposalInterface, TokenRescue { struct Argument { address source; uint8 position; uint256 count; }",1
0x778e763c4a09c74b2de221b4d3c92d8c7f27a038.sol,TokenERC20,contract TokenERC20 is Ownable { using SafeMath for uint256; token public tokenReward1; token public tokenReward2; token public tokenReward3; token public tokenReward4; token public tokenReward5; token public tokenReward6; token public tokenReward7; token public tokenReward8; token public tokenReward9; token public tokenReward10; string public constant name = ; string public constant symbol = ; uint32 public constant decimals = 18; uint256 public totalSupply; struct Userinfo { bool recommendtrue; uint256 locksnumber; uint256 lockstime; uint256 grade; uint64 commission; uint64 round; uint64 roundaff; address onerecommender; address tworecommender; bool locksstatus; },1
0x71fbecb11e291f824fd5dc9e760f56a5239e4702.sol,HodlDAO,contract HodlDAO { string public version = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => withdrawalRequest) public withdrawalRequests; struct withdrawalRequest { uint sinceTime; uint256 amount; },1
0x8bbb3375d2401da181711032f658c52252b03275.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0x02df890024de6658a5a323c9ea33e8cd492bd3906a19c9977574634af4215a98; constructor() public { owner = msg.sender; },1
0xb41e96d68e9016f03480d98663caf02ba15958cc.sol,Silvereum,"contract Silvereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Silvereum() public { symbol = ; name = ; decimals = 7; _totalSupply = 230000000000000000; balances[0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D] = _totalSupply; Transfer(address(0), 0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D, _totalSupply); }",1
0x5b1d807e3202de4608a59ee93f98ef75c716236c.sol,Investors,"contract Investors is Ownable { address[] public investors; mapping (address => uint) public investorPercentages; function addInvestors(address[] _investors, uint[] _investorPercentages) onlyOwner public { for (uint i = 0; i < _investors.length; i++) { investors.push(_investors[i]); investorPercentages[_investors[i]] = _investorPercentages[i]; }",1
0x0f690a76ad438222ce694d84b2902b0ee2270e69.sol,Secure,"contract Secure { enum Algorithm { sha, keccak }",1
0x544a1abc3c932847fd1049ee55e0d0e1eeb3dc80.sol,online_wallet,contract online_wallet { bytes32 keyHash; address owner; bytes32 wallet_id = 0xc5fdada86ba48ae58214a1d6bac3c0207862ffd0302738847798a4843e4cc242; constructor() public { owner = msg.sender; },1
0x6da5380105a57abf2f42ef4afe01d4d888fc9282.sol,EthStar,"contract EthStar { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xaaabd58b6d94b21859f9fc2b4e829f532283cf69.sol,UCoinToken,"contract UCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UCoinToken( ) TokenERC20(5000000000, , ) public {}",1
0x3632c27273a5d928d0f09407380dc0d8164a8ac5.sol,TokenShares,"contract TokenShares is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0xda7c27c04f66842faf20644814b644e25e1766ea.sol,OptionsCalculator,"contract OptionsCalculator is Ownable, Destructable, Math, ESOPTypes { uint public cliffPeriod; uint public vestingPeriod; uint public maxFadeoutPromille; function residualAmountPromille() public constant returns(uint) { return FP_SCALE - maxFadeoutPromille; }",1
0xd091eb3a1cbb2182d1b98435be25bbaf89746540.sol,TokenERC20,"contract TokenERC20 { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 10*1000*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x84cc06eddb26575a7f0afd7ec2e3e98d31321397.sol,DiamondDividendMain,contract DiamondDividendMain { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0xd6ed0e5d7f854b64b5e467a240a6c155c17cc6a2.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x312d25cafdd6822c7b5dcdc8c7434e72f6e39c19.sol,FixedSupplyToken,"contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function FixedSupplyToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 300 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,SeedCrowdsaleContract,"contract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned { struct ContributorData { uint contributionAmount; }",1
0xdda784ce15449948520580cacb229717cd7ad261.sol,Laker_Show,contract Laker_Show { bytes32 keyHash; address owner; bytes32 wallet_id = 0x1dec6cf84a749ef01bf72a1d415c650393afbd3b11bf92e1e22e0c2372c0df4b; constructor() public { owner = msg.sender; },1
0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95.sol,LaiBiToken,"contract LaiBiToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LaiBiToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xc4fd6c87218a2c0f2f7cfed260e1778d62020688.sol,TestingCoin,contract TestingCoin { string constant public name = ; string constant public symbol = ; uint256 constant scaleFactor = 0x10000000000000000; uint8 constant limitedFirstBuyers = 4; uint256 constant firstBuyerLimit = 0.5 ether; uint8 constant public decimals = 18; mapping(address => uint256) public stakeBalance; mapping(address => int256) public payouts; uint256 public totalSupply; uint256 public contractBalance; int256 totalPayouts; uint256 earningsPerStake; uint8 initialFunds; address creator; uint256 numStakes = 0; uint256 balance = 0; modifier isAdmin() { require(msg.sender == creator ); _; },1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchase,contract StarbaseEarlyPurchase { string public constant PURCHASE_AMOUNT_UNIT = ; string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http: uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; uint256 amount; uint256 purchasedAt; },1
0x0111e8a755a4212e6e1f13e75b1eaba8f837a213.sol,FundEIF,"contract FundEIF { mapping(address => uint256) public receivedFunds; uint256 public totalSent; uint256 public totalOtherReceived; uint256 public totalInterestReinvested; address public EIF; address public PoEIF; event INCOMING(address indexed sender, uint amount, uint256 timestamp); event OUTGOING(address indexed sender, uint amount, uint256 timestamp); constructor() public { EIF = 0x35027a992A3c232Dd7A350bb75004aD8567561B2; PoEIF = 0xFfB8ccA6D55762dF595F21E78f21CD8DfeadF1C8; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x3a580a0d295d3f5a8137a91448b03f2bdc22aa2c.sol,EtherSmarts,contract EtherSmarts { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint techSupportPercent = 2; address defaultReferrer = 0x6366303f11bD1176DA860FD6571C5983F707854F; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 1e22) { return 50; },1
0x3775b1b9781cfe7196a91c00ce44507440a51e20.sol,Airdrop,"contract Airdrop is Ownable { function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender, dests[i], values[i] * (10 ** 9)); i += 1; }",1
0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2.sol,BFBtoken,"contract BFBtoken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d5854e7f4dd81d9d4c09097d3cc736c7771f234.sol,vualt,contract vualt { bytes32 keyHash; address owner; bytes32 wallet_id = 0x162fb6d4a567c777d990e7b7517f9068408a67c8cca7089c7649eeeb349ee523; constructor() public { owner = msg.sender; },1
0xf4be3da9df0c12e69115bb5614334786fbaf5ace.sol,MiBoodleToken,"contract MiBoodleToken is ERC20,SafeMath,Haltable { bool public isMiBoodleToken = false; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => mapping (address => uint256)) allowedToBurn; mapping (address => uint256) investment; address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; bool public upgradeAgentStatus = false; uint256 public start; uint256 public end; uint256 public preFundingStart; uint256 public preFundingtokens; uint256 public fundingTokens; uint256 public maxTokenSupply = 600000000 ether; uint256 public maxTokenSale = 200000000 ether; uint256 public maxTokenForPreSale = 100000000 ether; address public multisig; address public vault; bool public isCrowdSaleFinalized = false; uint256 minInvest = 1 ether; uint256 maxInvest = 50 ether; bool public isTransferEnable = false; bool public isReleasedOnce = false; event Allocate(address _address,uint256 _value); event Burn(address owner,uint256 _value); event ApproveBurner(address owner, address canBurn, uint256 value); event BurnFrom(address _from,uint256 _value); event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); event Deposit(address _investor,uint256 _value); function MiBoodleToken(uint256 _preFundingtokens,uint256 _fundingTokens,uint256 _preFundingStart,uint256 _start,uint256 _end) public { upgradeMaster = msg.sender; isMiBoodleToken = true; preFundingtokens = _preFundingtokens; fundingTokens = _fundingTokens; preFundingStart = safeAdd(now, _preFundingStart); start = safeAdd(now, _start); end = safeAdd(now, _end); }",1
0x70bf9df6967dc96156e76cc43b928a7ef02e159a.sol,X_GAME,contract X_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x01628c3308f798362f89886bdac1506e0b33a045.sol,CBC,"contract CBC is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000 * 10 ** uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0xaaabd58b6d94b21859f9fc2b4e829f532283cf69.sol,UCoinToken,"contract UCoinToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function UCoinToken( ) TokenERC20(5000000000, , ) public {}",1
0x418b47c62af92e2ab2c105279c50d4e93b77c725.sol,MIC,"contract MIC { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MIC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x64fac631db32d70d77e0b759f9a27e1f6b9e9f6f.sol,TON,"contract TON { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 1000000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TON() public { balanceOf[msg.sender] = totalSupply; }",1
0x1f31d1168efe4bd22d00d31fc425e5bcb54c75e7.sol,STeX_WL,"contract STeX_WL is owned { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public ethRaised; uint256 public soldSupply; uint256 public curPrice; uint256 public minBuyPrice; uint256 public maxBuyPrice; uint256 public wlStartBlock; uint256 public wlStopBlock; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function STeX_WL() public { totalSupply = 1000000000000000; balanceOf[this] = totalSupply; soldSupply = 0; decimals = 8; name = ; symbol = ; minBuyPrice = 20500000; maxBuyPrice = 24900000; curPrice = minBuyPrice; wlStartBlock = 5071809; wlStopBlock = wlStartBlock + 287000; }",1
0x27ce49590684308d22fe7adcb8b80976701774d3.sol,TheEthGameTrophy,"contract TheEthGameTrophy { string public name; string public description; string public message; address public creator; address public owner; address public winner; uint public rank; bool private isAwarded = false; event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner); event Transfer (address indexed _from, address indexed _to); constructor () public { name = ; description = ; rank = 1; creator = msg.sender; }",1
0x30d5f039375a1c6977b32225ad8c9a409d5dd31f.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0xc56a477ceb26c50ecdf00863c2a0c8b4399c8828.sol,Bitparadise,"contract Bitparadise is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 8; _totalSupply = 50000000000000000; balances[0x9b89e4a13c186E22588941eaD7B3b706B474E885] = _totalSupply; emit Transfer(address(0), 0x9b89e4a13c186E22588941eaD7B3b706B474E885, _totalSupply); }",1
0x86b300ef935284a99fa5d148a9a6ccc5103b21a8.sol,CryptoDashtoken,"contract CryptoDashtoken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 25000000000000000000000000000; balances[0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761] = _totalSupply; emit Transfer(address(0), 0xFAa81d8b3e7F609Ecf0cF825cC786c2efaB8e761, _totalSupply); }",1
0x2803ade692943fff909a20ee3109efb78282cab1.sol,HTHP,"contract HTHP is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function HTHP() public { symbol = ; name = ; decimals = 8; _totalSupply = 12000000000000000; balances[0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2] = _totalSupply; Transfer(address(0), 0x6100388A3e83A9EF1500Cb76D08048cB5ebaAEc2, _totalSupply); }",1
0x6cd3cbfa29ebb63e84132ad7b1a10407aba30acd.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x518049c81352636b34d82f0a3fad8cfe3571f35a.sol,TICKET,"contract TICKET { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TICKET( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x70aa0247de23fdd3b8558be98747a8c286affd54.sol,Digital_1,"contract Digital_1 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xf4985070ce32b6b1994329df787d1acc9a2dd9e2.sol,AxieClockAuction,"contract AxieClockAuction is HasNoEther, Pausable { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x5064ec168fac380a866e8061b422d75b73470ad9.sol,ElectricCoin,"contract ElectricCoin { string public version = ; string public name; string public symbol; uint8 public decimals; address public owner; uint256 public _totalSupply; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowances; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ElectricCoin() public { balances[msg.sender] = 30000000000000000; _totalSupply = 30000000000000000; name = ; symbol = ; decimals = 8; owner = msg.sender; }",1
0x4c4757b23526ba13876f8ef3efe973618266e3e8.sol,UZMINI_KO,contract UZMINI_KO { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x8b7d609e51f22acaf0dcf935a147945caabf2457.sol,LTC,"contract LTC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LTC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0x297fbad9810ab3d52abc4f1720bc24cac8b22c56.sol,VAULT,contract VAULT { bytes32 keyHash; address owner; bytes32 wallet_id = 0xe346313e6971755e249e10726c10717c735e9e54eb5ca3c4aff9ff9eb628150c; constructor() public { owner = msg.sender; },1
0x532975d56cf18f597480e2521246b273ad9ae348.sol,LiabilityFactory,"contract LiabilityFactory { constructor( address _robot_liability_lib, address _lighthouse_lib, XRT _xrt ) public { robotLiabilityLib = _robot_liability_lib; lighthouseLib = _lighthouse_lib; xrt = _xrt; }",1
0xef0b91addd85c4cb5ddc622778f9ab8f29cb939d.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x1fbf025ad94dde79f88732f79966a9a435f2772f.sol,BLITZQUIZ,contract BLITZQUIZ { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x0e41c976f456ccb29c04e62ba70094d174f2b503.sol,NoahDividend,contract NoahDividend is Ownable { NoahToken public noahToken; function NoahDividend(address noahTokenAddress) public { noahToken = NoahToken(noahTokenAddress); },1
0x411be588940376ae23e58274ad4fe175f85e5ca1.sol,FLICoin,"contract FLICoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 4; _totalSupply = 10000000000; balances[0xe03766D5219C40970126a6f139aae20dDA81Dcf5] = _totalSupply; emit Transfer(address(0), 0xe03766D5219C40970126a6f139aae20dDA81Dcf5, _totalSupply); }",1
0x4cc29dd2b01a3e0ed005c6e2deb5b3666e4c240c.sol,SafeMath,None,1
0x28b3381c0bf4658a2fa66fbcf6f31dcda1a7b596.sol,SHERE_PFI_I_883,"contract SHERE_PFI_I_883 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 760409854824080000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,Controllable,contract Controllable is Ownable { mapping(address => uint256) private contractIndices; address[] private contracts; modifier onlyActiveContracts() { require(contractIndices[msg.sender] != 0); _; },1
0xf502275121deeaddbd7807bdbf533f48747ac17b.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xf29e2bcde0ed59252df2f4b4f3867599dd06b687.sol,SenbitTokenSBIT,"contract SenbitTokenSBIT{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function SenbitTokenSBIT() public{ balanceOf[msg.sender] = 300000000 * (10**18); totalSupply = 300000000 * (10**18); name = ; symbol = ; decimals = 18; }",1
0x00125893df6ca0792c99601c462764ba5d80268a.sol,GasManager,contract GasManager is owned { function () payable public {},1
0x41f9a3392cc695b8a12c6b5ede0e04a1bef12d05.sol,Ether2x,"contract Ether2x is StandardToken, owned, allowMonthly { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; bool public initialDrop; uint256 public inititalSupply = 10000000 * (10 ** uint256(decimals)); uint256 public totalSupply; address NULL_ADDRESS = address(0); uint public nonce = 0; event NonceTick(uint _nonce); function incNonce() public { nonce += 1; if(nonce > 100) { nonce = 0; }",1
0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3.sol,queue,contract queue { Queue public q; struct BuyTicket { address account; uint amount; uint time; },1
0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219.sol,CrowdsaleToken,"contract CrowdsaleToken is MintableToken { uint256 public totalTokens = uint256(300000000).mul(1e4); uint256 public crowdSaleCap = uint256(210000000).mul(1e4); uint256 public hardCap = uint256(12000).mul(1 ether); uint256 public softCap = uint256(1000).mul(1 ether); uint256 public weiRaised; uint256 public basePrice = 330000000000000; uint256 public refundPercent = 90; uint256 public preIcoStartDate = 1534291200; uint256 public preIcoEndDate = 1537919999; uint256 public icoStartDate = 1539561600; uint256 public icoEndDate = 1543622399; uint256 public refundEndDate = 1543881599; uint256 public bonusPeriod = 432000; uint256 public bonusLimit1 = uint256(45000).mul(1e4); uint256 public bonusLimit2 = uint256(30000).mul(1e4); uint256 public bonusLimit3 = uint256(10000).mul(1e4); uint256 public bonusLimit4 = uint256(3000).mul(1e4); uint256 public bonusLimit5 = uint256(25).mul(1e4); address public newOwner = 0x67f00b9B121ab98CF102c5892c14A5e696eA2CC0; address public wallet = 0x3840428703BaA6C614E85CaE6167c59d8922C0FE; mapping(address => uint256) contribution; constructor() public { owner = newOwner; uint256 teamTokens = totalTokens.sub(crowdSaleCap); balances[owner] = teamTokens; totalSupply_ = teamTokens; emit Transfer(address(this), owner, teamTokens); }",1
0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87.sol,IPFSV,"contract IPFSV { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x3617081dd9294a785780a4fcde3dcb8f0a2c69e8.sol,MofasAirdrop,"contract MofasAirdrop is Ownable { function multisend(address[] to, uint256[] value) onlyOwner returns (uint256) { address tokenAddr = 0x1d18f44256A27862d886E27191d55AB4029172C1; uint256 i = 0; while (i < to.length) { ERC20(tokenAddr).transfer(to[i], value[i] * ( 10 ** 18 )); i++; }",1
0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x52ab2ef83426ad1fa5d3e402947e38dce2894903.sol,Vegan,"contract Vegan is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Vegan() public { symbol = ; name = ; decimals = 18; _totalSupply = 300000000000000000000000000; startDate = now; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,Data,contract Data is Ownable { mapping (address => address) private parent; mapping (address => uint8) public statuses; mapping (address => uint) public referralDeposits; mapping(address => uint256) private balances; mapping(address => uint256) private investorBalances; function parentOf(address _addr) public constant returns (address) { return parent[_addr]; },1
0x345fd80105d95fd8845d0e717b9590499b5756d0.sol,CPPGToken,"contract CPPGToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function CPPGToken() public { symbol = ; name = ; decimals = 0; _totalSupply = 100000000000; balances[0x8A1221947555321795f29eE63B47cC43Bd252A7A] = _totalSupply; Transfer(address(0), 0x8A1221947555321795f29eE63B47cC43Bd252A7A, _totalSupply); }",1
0x3a5f32732d6be576d5dec48354b2377e14675eca.sol,BCTToken,"contract BCTToken is PausableToken { string public name = ; string public symbol = ; uint8 public decimals = 18; constructor() public { totalSupply_ = 21000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); }",1
0x6e6f819299e7809ce744f37fae9f84fe38d95f1c.sol,CompanyFundsWallet,contract CompanyFundsWallet { bytes32 keyHash; address owner; constructor() public { owner = msg.sender; },1
0x2668afe75c5b0b726c2b4388658edae365eda4e2.sol,B2ANDcoin,"contract B2ANDcoin is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function B2ANDcoin( ) public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xafbdd9d46f5ce898204e75484008a442b594b409.sol,DAIMLER_AG,"contract DAIMLER_AG { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 10379707031250000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x5aebcc44588feabb4a87076d17f3aa8c950a28e1.sol,SafeOpt,None,1
0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol,EnjinBuyer,contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; },1
0x46940639ff7122539b71e836eccb08e53b08045d.sol,MyToken,"contract MyToken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); }",1
0xf0f9569413d99964ec01bd900126e90c70edda6a.sol,Rollercoaster,contract Rollercoaster { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x7157cf5f3f57ee59d74b905175134b8a7763b065.sol,PeaceChainToken,"contract PeaceChainToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function PeaceChainToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x066771118888b07539988963e29ffe99d6e62fd1.sol,TokenERC20,"contract TokenERC20 is Owner{ string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply=10000000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { balanceOf[msg.sender] = totalSupply; }",1
0x573db28be1fce18fb46fbc49d23204daf7e7589c.sol,SafeMath,None,1
0xc07c972ac722eb36f5911fdf89dfe978ef36988c.sol,SafeMath,None,1
0x409694d12ab1ee7cf7f45245aec9197644660683.sol,BNB,"contract BNB is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BNB() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 5 weeks; }",1
0x52a5e1a56a124dce84e548ff96122246e46d599f.sol,TokenERC20,"contract TokenERC20 { string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply ; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x25ea302afd1e9ca629ebb2ea97146152ee9fab96.sol,EtherTots,"contract EtherTots is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); string public constant NAME = ; string public constant SYMBOL = ; uint256 private startingPrice = 0.001 ether; uint256 private firstStepLimit = 0.053613 ether; uint256 private secondStepLimit = 0.564957 ether; mapping (uint256 => address) public totIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public totIndexToApproved; mapping (uint256 => uint256) private totIndexToPrice; address public ceoAddress; address public cooAddress; struct Tot { string name; }",1
0xb3aac808b10eb65b74b59deb4f1998b52327bd1a.sol,InsightsNetwork1,contract InsightsNetwork1 { address public owner; address public successor; mapping (address => uint) public balances; mapping (address => uint) public unlockTimes; bool public active; uint256 _totalSupply; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 0; function InsightsNetwork1() { owner = msg.sender; active = true; },1
0x6fc619aa9889a2822167065146650acf7a2f1127.sol,WPHCoin,"contract WPHCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 5000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7.sol,Manageable,"contract ManageableInterface { function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool); modifier onlyAllowedManager(string _permissionName) { require(isManagerAllowed(msg.sender, _permissionName) == true); _; }",1
0xef828938155cabfe83affbe726b55d188b4f45c0.sol,APPToken,"contract APPToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public appFundDeposit; bool public isFinalized; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public constant appFund = 3000 * (10**3) * 10**decimals; function tokenRate() constant returns(uint) { if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 360; if (block.number>=fundingStartBlock && block.number<fundingStartBlock+23333) return 300; return 250; }",1
0x44c82d8d516a4e500e7dba17df1368e2ec5e4212.sol,TrueSmart,contract TrueSmart { mapping (address => uint256) public invested; mapping (address => uint256) public atBlock; address techSupport = 0xb893dEb7F5Dd2D6d8FFD2f31F99c9E2Cf2CB3Fff; uint techSupportPercent = 1; address advertising = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint advertisingPercent = 5; address defaultReferrer = 0x1393409B9e811C96B557aDb8B0bed3A6589377C0; uint refPercent = 2; uint refBack = 2; function calculateProfitPercent(uint bal) private pure returns (uint) { if (bal >= 4e20) { return 50; },1
0x53148bb4551707edf51a1e8d7a93698d18931225.sol,Peculium,"contract Peculium is BurnableToken,Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; string public name = ; string public symbol = ; uint256 public decimals = 8; uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8; uint256 public dateStartContract; mapping(address => bool) public balancesCanSell; uint256 public dateDefrost; event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); function Peculium() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; balancesCanSell[owner] = true; dateStartContract=now; dateDefrost = dateStartContract + 85 days; }",1
0x6d2e76213615925c5fc436565b5ee788ee0e86dc.sol,SafeMath,"contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; }",1
0x8b7d609e51f22acaf0dcf935a147945caabf2457.sol,LTC,"contract LTC { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LTC( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x21aec0a028d7adec228595b24439c7eb969edd5f.sol,Sudokoin,"contract Sudokoin { uint supply = 203462379904501283815424; uint public boards = 0; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 12; mapping (address => mapping (address => uint)) allowances; mapping (address => uint) balances; mapping (uint => bool) public claimedBoards; event Approval(address indexed _owner, address indexed _spender, uint _value); event BoardClaimed(uint _board, uint _no, address _by); event Burn(address indexed _from, uint _value); event Transfer(address indexed _from, address indexed _to, uint _value); function allowance(address _owner, address _spender) constant returns (uint remaining) { remaining = allowances[_owner][_spender]; }",1
0x4b9cf3bb930e3eb8a37645ab28194dcc05e1e0aa.sol,JYToken,contract JYToken { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9.sol,Distribute,contract Distribute is owned { token public tokenReward; constructor() public { tokenReward = token(0x8432A5A61Cf1CC5ca5Bc5aB919d0665427fb513c); },1
0x2021526a4a62a70f52c0340b0f67740a08b94e01.sol,Bcxss,"contract Bcxss { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0x3485b9566097ad656c70d6ebbd1cd044e2e72d05.sol,PinkyToken,"contract PinkyToken is owned { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public totalSupply = 10000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PinkyToken(){ balanceOf[msg.sender] = totalSupply; }",1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,GIFT_1_ETH,contract GIFT_1_ETH { function GetGift(bytes pass) external payable { if(hashPass == keccak256(pass) && now>giftTime) { msg.sender.transfer(this.balance); },1
0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc.sol,SUPERBRAAI,"contract SUPERBRAAI { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 initialSupply=120000000; string tokenName = ; string tokenSymbol = ; constructor( ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x37aa63c4cbd06a57f1ea35bceee4e46f0a7ce924.sol,SafeMath,None,1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5129bdff6b065ce57cc7e7349ba681a0ac1d00cd.sol,BNCXToken,"contract BNCXToken { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 50000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x0d2a65ef3e4c3509f00a3576495bd237f5817520.sol,ENIGMA,contract ENIGMA { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value > 0.5 ether) { msg.sender.transfer(this.balance); },1
0x0485d2be00eda257b6e7868950616ad2a8cc44b6.sol,BaseToken,"contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ArtworkBase,"contract ArtworkBase is ArtworkAccessControl { event Birth(address owner, uint256 artworkId, string name, string author, uint32 series); event Transfer(address from, address to, uint256 tokenId); struct Artwork { uint64 birthTime; string name; string author; uint32 series; }",1
0x838b653d5877f92d0d9ecaea0073b479513b3326.sol,COINEIUM,"contract COINEIUM { string public name=; string public symbol=; uint8 public decimals = 18; uint256 public totalSupply = 777000000000000000000000000; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function COINEIUM() public { totalSupply = 777000000000000000000000000; balanceOf[msg.sender] = totalSupply; name = ; symbol = ; }",1
0x1767856bc75cf070de5e6ba3d0c718440f008c66.sol,TimeCapsuleEvent,"contract TimeCapsuleEvent is Ownable { address public Owner; mapping (address=>uint) public deposits; uint public openDate; event Initialized(address indexed owner, uint openOn); function initCapsule(uint open) { Owner = msg.sender; openDate = open; Initialized(Owner, openDate); }",1
0x6e10e8f202ced220791043df74aa84615caec537.sol,KittyToken,"contract KittyToken is AccessAdmin, ERC721 { using SafeMath for SafeMath; event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); struct Kitty { uint32 kittyId; }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0xc64500dd7b0f1794807e67802f8abbf5f8ffb054.sol,LocusToken,contract LocusToken { address public tokenOwner; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint public totalSupply; uint internal constant initialSupply = 7000000000 * (10 ** uint(decimals)); mapping(address => uint) public balanceOf; mapping(address => mapping(address => uint)) internal allowed; function balanceOfToken(address _owner) public view returns(uint) { return balanceOf[_owner]; },1
0x4d6993c02e6bbcbf6d6183c9b599b1d8c18c32d8.sol,MultiSend,"contract MultiSend { function multisend(address _tokenAddr, address[] dests, uint256[] values) returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; }",1
0x3aa6c3f86d945085c9ff4581f3963f4f0404a416.sol,AAA,"contract AAA is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844] = _totalSupply; emit Transfer(address(0), 0x3Aba8AA182c4Dd034332aD71110D5B262DBFD844, _totalSupply); }",1
0x32e2150b69072fc331f7e4dff202d5bc4cb7156f.sol,CCD_BDX_BOO_20190329_1,"contract CCD_BDX_BOO_20190329_1 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 19800000000000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0xb8c6107f66152fa908111e2963878ad04c89b125.sol,EENX,"contract EENX is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; function EENX( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0xd6d62024d82b5bf4fe4a9e214991743d543f1673.sol,SafeMath,None,1
0xd90cd0492bbb7405a8bba2e49556dbd74ef3b00c.sol,BEC700,"contract BEC700 is ERC20Interface, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BEC700() public { symbol = ; name = ; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC] = _totalSupply; Transfer(address(0), 0xd05374067CEd8EE9e2eF8bba184B1CC051C094FC, _totalSupply); }",1
0xeddbe73b7ed6d6d2887ba7349e411a5b7dcf0e16.sol,MindCoin,"contract MindCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MindCoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x324d65aa829a9b976fe661b03a7d4cd0d66ff843.sol,BCE,"contract BCE { using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; uint256 public supplyLeftAtOrigin = 21000000 * 10 ** uint256(decimals); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); uint256 public constant RATE = 500; function BCE( address sendTo, uint256 initialSupply, string tokenName, string tokenSymbol ) public { owner = sendTo; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x652c7e43e82e6b45fc6265c02174cf1a91339b5b.sol,MB,"contract MB { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MB( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; totalSupply = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; }",1
0x5422b8e108c1e361863d9aabdaa72f945c213422.sol,HBCM,"contract HBCM is Owned { string public name=; string public symbol=; uint8 public decimals=18; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; uint minBalanceForAccounts; mapping (address => uint256) public balanceOf; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); function HBCM() public { totalSupply = 500000000000000000000000000; balanceOf[msg.sender] = totalSupply; }",1
0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2.sol,Lotthereum,"contract Lotthereum is Mortal, SafeMath { Game[] private games; mapping (address => uint) private balances; struct Game { uint id; uint pointer; uint maxNumberOfBets; uint minAmountByBet; uint prize; uint currentRound; Round[] rounds; }",1
0xb41e96d68e9016f03480d98663caf02ba15958cc.sol,Silvereum,"contract Silvereum is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Silvereum() public { symbol = ; name = ; decimals = 7; _totalSupply = 230000000000000000; balances[0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D] = _totalSupply; Transfer(address(0), 0xe5371c7cb3FB6322F4C8A936baDaC8A7Ef888B3D, _totalSupply); }",1
0xf4985070ce32b6b1994329df787d1acc9a2dd9e2.sol,AxieClockAuction,"contract AxieClockAuction is HasNoEther, Pausable { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xe3eec4b1a59dd6b42a98c2f7ad64b56fee15337d.sol,Ticket2Crypto,contract Ticket2Crypto { struct player_ent{ address player; address ref; },1
0xa1506902f8ca82dace3176575e740c78aa29fc02.sol,Storage,"contract Storage { bytes32[] public data; bool readOnly; function uploadData(bytes _data) public { require(readOnly != true); uint index = data.length; for(uint i = 0; i < _data.length / 32; i++) { bytes32 word; assembly { word:= mload(add(_data, add(32, mul(i, 32)))) }",1
0x899850f5b7f34d213a01802c727e7a59a88487a1.sol,MessageToken,"contract MessageToken { string public standard = ; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function MessageToken() { balanceOf[msg.sender] = 10000; totalSupply = 10000; name = ; symbol = ; decimals = 0; }",1
0x1eebb0f896a8995aa95954a0870dc520eedc891f.sol,CNYTokenPlus,contract CNYTokenPlus is StandardToken { function () { throw; },1
0x190e569be071f40c704e15825f285481cb74b6cc.sol,FAMEToken,contract FAMEToken is ERC20Standard { function FAMEToken() { totalSupply = 2100000 szabo; name = ; decimals = 12; symbol = ; version = ; balances[msg.sender] = totalSupply; },1
0x0e9f8e7e84fa6bb04287c0c002e92d779c5e7ae4.sol,m00n,contract m00n { mapping (address => uint) public invested; mapping (address => uint) public atBlock; uint public investorsCount = 0; function () external payable { if(msg.value > 0) { require(msg.value >= 10 finney); uint fee = msg.value * 10 / 100; address(0x6C221dea36d48512947BDe8aEb58811DB50dbf6F).transfer(fee); if (invested[msg.sender] == 0) ++investorsCount; },1
0x5c88e93b5feae72f0fbe787c7f1b96ce3f29ee6a.sol,BWW_ERC20,"contract BWW_ERC20 is owned { using SafeMath for uint; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 100000000000; uint256 public TokenPerKRWBuy = 4; mapping(bytes32 => bool) transactionHashes; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); constructor () public { balanceOf[owner] = totalSupply; }",1
0xef0b91addd85c4cb5ddc622778f9ab8f29cb939d.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x410804f20daf6498ec564a20132985b8da401c2e.sol,MultiSend,"contract MultiSend { event Multisended(uint256 total, address tokenAddress); function multiSend(address _token, address[] addresses, uint[] counts) public { uint total; ERC20 token = ERC20(_token); for(uint i = 0; i < addresses.length; i++) { require(token.transferFrom(msg.sender, addresses[i], counts[i])); total += counts[i]; }",1
0xeb41d9b0326b787a7c767478cfc4d060c6aa9dbd.sol,VirtualGift,"contract VirtualGift is ERC721 { string public name = ; uint8 public decimals = 0; string public symbol = ; string public version = ; address private defaultGiftOwner; mapping(address => bool) allowPermission; ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d); event Creation(address indexed _owner, uint256 indexed tokenId); GiftToken[] giftStorageArry; GiftTemplateToken[] giftTemplateStorageArry; mapping(address => uint256) private balances; mapping(uint256 => address) private giftIndexToOwners; mapping(uint256 => bool) private giftExists; mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds; mapping(uint256 => uint256[]) private giftTemplateIdToGiftids; mapping(uint256 => uint256) private giftTypeToGiftLimit; mapping(uint256 => uint256) private giftTypeToSelledSum; struct GiftTemplateToken { uint256 giftPrice; uint256 giftLimit; string giftImgUrl; string giftName; }",1
0x74004a7227615fb52b82d17ffabfa376907d8a4d.sol,AVMToken,"contract AVMToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function AVMToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 24000000000000000000000000; balances[0x6804eb5708eD497D69c31e541A9d2C6b920e28D3] = _totalSupply; Transfer(address(0), 0x6804eb5708eD497D69c31e541A9d2C6b920e28D3, _totalSupply); }",1
0x70b7c2015e1e01541ca220fa36c733fc03c687c5.sol,DBXContract,"contract DBXContract { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xede4edd0c0209db3172a9a07607b47fcf57e6355.sol,EthereumUnionToken,"contract EthereumUnionToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function EthereumUnionToken() public { symbol = ; name = ; decimals = 5; _totalSupply = 12500000000000; balances[0xfb58a9af395755a4e95805d76bae231feb01a192] = _totalSupply; emit Transfer(address(0), 0xfb58a9af395755a4e95805d76bae231feb01a192, _totalSupply); }",1
0x77e00640a6343152a35542027ba76407bdde0bb6.sol,quiz_please,contract quiz_please { function Try(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); },1
0x6cbadb622d30a8c998c907911a9b160e735348fc.sol,BitEspritCoin,"contract BitEspritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) _balances; mapping(address => mapping(address => uint)) allowed; function BitEspritCoin() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; _balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); }",1
0xf0b9dd890257c20bb2c733db38d5cd5c8df522cf.sol,Medianizer,"contract Medianizer is DSValue { mapping (bytes12 => address) public values; mapping (address => bytes12) public indexes; bytes12 public next = 0x1; uint96 public min = 0x1; function set(address wat) auth { bytes12 nextId = bytes12(uint96(next) + 1); assert(nextId != 0x0); set(next, wat); next = nextId; }",1
0x6b3add2227ac41403c93674185b32ff9e8bc3a43.sol,QianChengMeng,"contract QianChengMeng { mapping(address => uint256) public balances; mapping(address => mapping (address => uint256)) public allowed; using SafeMath for uint256; address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 private constant MAX_UINT256 = 2**256 -1 ; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); bool lock = false; constructor( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { owner = msg.sender; balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; }",1
0x6c5607c25121c8a1070311c85ae5f474b0d5f642.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x01d706ed109e2038ae3261e30a1ed1af207a9d2c.sol,ETHERECASHTOKEN,"contract ETHERECASHTOKEN { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETHERECASHTOKEN( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a.sol,BiddingCustom,contract BiddingCustom is BiddingBase { struct Auction { uint128 highestBid; address highestBidder; uint40 timeEnd; uint40 lastBidTime; uint40 timeStart; },1
0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b.sol,OROCoin,"contract OROCoin { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x5192a95f79c83e1581574b90f75a28af79c871ff.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x7475e268b2f72f7974cac38d45011c277daf5d90.sol,UbetCoins,"contract UbetCoins is Ownable, StandardToken { string public name = ; string public symbol = ; uint public decimals = 18; uint256 public totalSupply = 4000000000 * (10**decimals); uint256 public tokenSupplyFromCheck = 0; uint256 public ratePerOneEther = 135; uint256 public totalUBetCheckAmounts = 0; uint64 public issueIndex = 0; event Issue(uint64 issueIndex, address addr, uint256 tokenAmount); address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953; string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = ""https: string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = ; event UBetCheckIssue(string chequeIndex); struct UBetCheck { string accountId; string accountNumber; string fullName; string routingNumber; string institution; uint256 amount; uint256 tokens; string checkFilePath; string digitalCheckFingerPrint; }",1
0x5c4e3dbca1dea91d26ace342dbe9e3ad7e5d3ccf.sol,SmartPayment,"contract SmartPayment is owned, TokenERC20 { uint256 public sellPrice = 1; uint256 public buyPrice = 1000000000000000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function SmartPayment() TokenERC20(6000000, , ) public {}",1
0x262e1acb79822bfd711f04aa80d08b629ecdb299.sol,StopLoss,"contract StopLoss is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function StopLoss() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x0667F1b5000fca448C3E3FdebA796616797c4DC9] = _totalSupply; Transfer(address(0), 0x0667F1b5000fca448C3E3FdebA796616797c4DC9, _totalSupply); }",1
0x71880d9f448c995ec5a7c9d68f2b0e256ef510d2.sol,ValueTokenBase,"contract ValueTokenBase is ERC20 { string public name; string public symbol; uint8 public decimals = 18; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; event Burn(address indexed from, uint256 value); function ValueTokenBase(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public { name = _tokenName; symbol = _tokenSymbol; decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; }",1
0xd46d0505f73f26f4cc7c8df65e562ac3f28ffc10.sol,ProtectEarth,contract ProtectEarth{using SafeMath for*;using NameFilter for*;struct Player{address addr;bytes32 name;uint8 level;uint256 recCount;uint256 laffID;uint256 commanderID;uint256 captainID;uint256 win;uint256 enableVault;uint256 affVault;uint256 achievement;uint256 keys;},1
0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1.sol,MyAdvancedToken,"contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",1
0x54345d405d4f459c22954b1a233cd42bfd3a9262.sol,ERC23PayableToken,"contract ERC23PayableToken is BasicToken, ERC23{ function transfer(address to, uint value, bytes data){ transferAndPay(to, value, data); }",1
0x52553a82adbc45eda6af687f9b5246fc51863b50.sol,GlobalCashChain,"contract GlobalCashChain { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5.sol,WilliamJones,"contract WilliamJones is owned, PiToken { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function WilliamJones( uint256 initialSupply, string tokenName, string tokenSymbol ) PiToken(initialSupply, tokenName, tokenSymbol) public {}",1
0xf140a9bd2a35b71006fb71e4229eaf8754bc95ed.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498.sol,BeeBitGold,"contract BeeBitGold is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function BeeBitGold() public { symbol = ; name = ; decimals = 18; _totalSupply = 50000000000000000000000000000; balances[0x6F6609ee9212477B6Ea9A39D12fab6f80589F084] = _totalSupply; Transfer(address(0), 0x6F6609ee9212477B6Ea9A39D12fab6f80589F084, _totalSupply); }",1
0xee284b58871645ce2656e309e238c5e2eace771a.sol,PornTokenV2,"contract PornTokenV2 { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PornTokenV2( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x5a9633b76eedb38ab04733682f1f422b4ce219b5.sol,Multiownable,"contract Multiownable { uint256 public ownersGeneration; uint256 public howManyOwnersDecide; address[] public owners; bytes32[] public allOperations; address internal insideCallSender; uint256 internal insideCallCount; mapping(address => uint) public ownersIndices; mapping(bytes32 => uint) public allOperationsIndicies; mapping(bytes32 => uint256) public votesMaskByOperation; mapping(bytes32 => uint256) public votesCountByOperation; event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide); event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer); event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter); event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer); event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount, address downvoter); event OperationCancelled(bytes32 operation, address lastCanceller); function isOwner(address wallet) public constant returns(bool) { return ownersIndices[wallet] > 0; }",1
0x1f9033b3fdf74e1d7619447bc491d73a36967d71.sol,BasicToken,"contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x256591374c0fb9b2782b754f6e072aa833e62278.sol,PDAToken,"contract PDAToken { string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 private initialSupply=3100000000; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf3620846825ba198be14cdbc5f2b41bbff788d67.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x548d32216d01617452892ea360bfce9ce8dc9729.sol,ChemistryBase,contract ChemistryBase is Ownable { struct Element{ bytes32 symbol; },1
0x1782829b659575b18bb6f8d146ec3405ae5a4bba.sol,ZeroChainToken,"contract ZeroChainToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ZeroChainToken() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 2 weeks; endDate = now + 6 weeks; }",1
0x542a900357c9638ad6e944a57072c5d01f1c1ea7.sol,Love,"contract Love { mapping (address => address) private propose; mapping (address => address) private partner; mapping (uint256 => string[]) private partnerMessages; mapping (uint256 => bool) private isHiddenMessages; uint public proposeCount; uint public partnerCount; event Propose(address indexed from, address indexed to); event CancelPropose(address indexed from, address indexed to); event Partner(address indexed from, address indexed to); event Farewell(address indexed from, address indexed to); event Message(address indexed addressOne, address indexed addressTwo, string message, uint index); event HiddenMessages(address indexed addressOne, address indexed addressTwo, bool flag); function proposeTo(address to) public { require(to != address(0)); require(msg.sender != to); require(partner[msg.sender] != to); address alreadyPropose = propose[to]; if (alreadyPropose == msg.sender) { propose[to] = address(0); if (propose[msg.sender] != address(0)) { propose[msg.sender] = address(0); proposeCount -= 2; }",1
0x1c307a39511c16f74783fcd0091a921ec29a0b51.sol,EthVerifyCore,contract EthVerifyCore{ address public ceoAddress; mapping(address=>bool) public admins; mapping(address=>bool) public approvedContracts; mapping (address => bool) public verifiedUsers; modifier onlyCEO() { require(msg.sender == ceoAddress); _; },1
0x9c3b979e2d9cb9d851fc29869ab4bdb1851b4d48.sol,StartupAcceleratorCoin,"contract StartupAcceleratorCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 18; _totalSupply = 745122014000000000000000000; balances[0x06203D2308102af31cFdd0317601943285F74086] = _totalSupply; emit Transfer(address(0),0x06203D2308102af31cFdd0317601943285F74086, _totalSupply); }",1
0x360abb53840302d4b4b119d2004a856f1151366b.sol,BaseContract,"contract BaseContract is AssemblyBase, ERC721 { using SafeMath for uint; address wallet1; address wallet2; address wallet3; address wallet4; address wallet5; string public constant name = ; string public constant symbol = ; uint[] dHead; uint[] dHousing; uint[] dLeftHand; uint[] dRightHand; uint[] dPelvic; uint[] dLeftLeg; uint[] dRightLeg; uint randNonce = 0; function BaseContract() public { Detail memory _detail = Detail(0, 0, 0); details.push(_detail); Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0); assemblys.push(_ass); }",1
0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66.sol,ARMtest,"contract ARMtest is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ARMtest() public { symbol = ; name = ; decimals = 18; bonusEnds = now + 4 weeks; endDate = now + 8 weeks; }",1
0x5b0fa053297f0ff35954531292d439a252f58919.sol,TRCERC20,"contract TRCERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x332124f226e80c3afdbb59271f550881b20604a1.sol,TokenERC20,"contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xddd151f4d9ed27aa18defefe4e0b2ef02f865d59.sol,EthToCoins,"contract EthToCoins is Token { function transfer(address _to, uint256 _value) returns (bool success) { require( balances[msg.sender] >= _value && _value > 0 ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0xd0d916322b02b7a8095af4bb69bea0e9d93cf3b1.sol,WTI_10_20210916,"contract WTI_10_20210916 { mapping (address => uint256) public balanceOf; string public name = ; string public symbol = ; uint8 public decimals = 18 ; uint256 public totalSupply = 14693280768000000000000000 ; event Transfer(address indexed from, address indexed to, uint256 value); function SimpleERC20Token() public { balanceOf[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); }",1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,BnsPresale,"contract BnsPresale { string public constant VERSION = ; uint public constant PRESALE_START = 4465500; uint public constant PRESALE_END = 4466550; uint public constant WITHDRAWAL_END = 4469000; address public constant OWNER = 0xcEAfe38b8d3802789A2A2cc45EA5d08bE8EA3b49; uint public constant MIN_TOTAL_AMOUNT_TO_RECEIVE_ETH = 0; uint public constant MAX_TOTAL_AMOUNT_TO_RECEIVE_ETH = 1; uint public constant MIN_ACCEPTED_AMOUNT_FINNEY = 1; string[5] private stateNames = [, , , , ]; enum State { BEFORE_START, PRESALE_RUNNING, WITHDRAWAL_RUNNING, REFUND_RUNNING, CLOSED }",1
0x6e10e8f202ced220791043df74aa84615caec537.sol,KittyToken,"contract KittyToken is AccessAdmin, ERC721 { using SafeMath for SafeMath; event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); struct Kitty { uint32 kittyId; }",1
0xd6310735586f09cf1cb6485f234b3534579706af.sol,BitMaxProToken,"contract BitMaxProToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = ; name = ; decimals = 2; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); }",1
0x137099bdc97fa0c487612466333d2b28bf0c2aa4.sol,Rocket,contract Rocket { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x6f86aeae8dd4f56a566a0d462ec7c254a2213916.sol,MetronomeToken,"contract MetronomeToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MetronomeToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0xaf892edC9515Ba62151d44219eA2149A86B86F93] = _totalSupply; Transfer(address(0), 0xaf892edC9515Ba62151d44219eA2149A86B86F93, _totalSupply); }",1
0x0de197dc289d680e734ccab866d529505b2638db.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 MINIMUM_LIMIT_SELL = 5000000; uint256 randNonce = 0; mapping(uint256 => MinerData) private minerData; uint256 private numberOfMiners; mapping(address => PlayerData) private players; uint256 private numberOfBoosts; mapping(uint256 => BoostData) private boostData; uint256 private numberOfOrders; mapping(uint256 => BuyOrderData) private buyOrderData; mapping(uint256 => SellOrderData) private sellOrderData; uint256 private numberOfRank; address[21] rankList; address public sponsor; uint256 public sponsorLevel; address public administrator; struct PlayerData { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; uint256 referral_count; uint256 noQuest; },1
0x1fd1f34a7476fa7d7b2187c8bd255e39e78271e6.sol,TokenERC20,"contract TokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; bool public send_allowed = false; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55.sol,OrganicumOrders,contract OrganicumOrders { struct order { uint256 balance; uint256 tokens; },1
0x40a835f8573c4b75e962e435591ea2200b74a714.sol,MyEtherTeller,contract MyEtherTeller { address public owner; struct EscrowStruct { address buyer; address seller; address escrow_agent; uint escrow_fee; uint amount; bool escrow_intervention; bool release_approval; bool refund_approval; bytes32 notes; },1
0x2728361ad889146544c48786b3a549f8b550c5d7.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x7038c15f76ad2667837c438c8819fd969899cdbe.sol,Airdrop,"contract Airdrop { function drop(ERC20 token, address[] recipients, uint256[] values) public { for (uint256 i = 0; i < recipients.length; i++) { token.transfer(recipients[i], values[i]); }",1
0x41c1bc7738ef9c259f100a5fd655185496fb5a47.sol,Kcoin,"contract Kcoin is IERC20{ using SafeMath for uint256; uint public initialSupply = 150000000000e18; string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 18; uint public totalSupply = 1500000000000e18; uint256 public constant Rate1 = 5000; uint256 public constant Rate2 = 5000; uint256 public constant Rate3 = 4500; uint256 public constant Rate4 = 4000; uint256 public constant Rate5 = 3500; uint256 public constant Rate6 = 3000; uint256 public constant Rate7 = 2500; uint256 public constant Rate8 = 2000; uint256 public constant Rate9 = 1500; uint256 public constant Rate10= 1000; uint256 public constant Start1 = 1519862400; uint256 public constant Start2 = 1522540800; uint256 public constant Start3 = 1525132800; uint256 public constant Start4 = 1527811200; uint256 public constant Start5 = 1530403200; uint256 public constant Start6 = 1533081600; uint256 public constant Start7 = 1535760000; uint256 public constant Start8 = 1538352000; uint256 public constant Start9 = 1541030400; uint256 public constant Start10= 1543622400; uint256 public constant End1 = 1522540799; uint256 public constant End2 = 1525132799; uint256 public constant End3 = 1527811199; uint256 public constant End4 = 1530403199; uint256 public constant End5 = 1533081599; uint256 public constant End6 = 1535759999; uint256 public constant End7 = 1538351940; uint256 public constant End8 = 1540943940; uint256 public constant End9 = 1543622340; uint256 public constant End10= 1546300740; address public owner; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; event Burn(address indexed from, uint256 value); function() public payable { buyTokens(); }",1
0x011a94df7ccf7eb28409cefc9d825f24c75b3c74.sol,SalaryInfo,contract SalaryInfo { struct User { string name; },1
0x743bba828949fce4557bad9a52db488ce6fdff8d.sol,ZHSH,"contract ZHSH{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ZHSH() public { balances[msg.sender] = 1300000000000; totalSupply = 1300000000000; name = ; decimals =4; symbol = ; }",1
0xc8507d914d21d50c1763288da6539f6a0f5a0916.sol,yiDaooToken,"contract yiDaooToken { string public name = ; string public symbol = ; uint256 public decimals = 18; uint256 public totalSupply = 200*1000*1000*10**decimals; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function yiDaooToken( ) public { balanceOf[msg.sender] = totalSupply; }",1
0x403f614ea176bdd865ab0377831f487987179cea.sol,GIFT_CARD,"contract GIFT_CARD { function Put(bytes32 _hash, uint _unlockTime) public payable { if(this.balance==0 || msg.value > 1000000000000000000) { unlockTime = now+_unlockTime; hashPass = _hash; }",1
0x571df5a0b5571a3cc7dcbd8185b200426376845f.sol,EBRK,"contract EBRK { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function EBRK( ) public { totalSupply = 100000000000000000000000000; balanceOf[msg.sender] = 100000000000000000000000000; name = ; symbol = ; }",1
0xb3d5cb3487ab2ce24172e2f4791d5c638324fce7.sol,FakeVote,"contract FakeVote { mapping (address => uint256) public voteCount; mapping (address => uint256) public alreadyUsedVotes; uint256 public maxNumVotesPerAccount = 10; function voteFor(address participant, uint256 numVotes) public { require (voteCount[participant] < voteCount[participant] + numVotes); require(participant != msg.sender); require(alreadyUsedVotes[msg.sender] + numVotes <= maxNumVotesPerAccount); alreadyUsedVotes[msg.sender] += numVotes; voteCount[participant] += numVotes; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0xa2f000b776a64770e1a3e1e43e63296f5f029451.sol,chuxinlianContract,"contract chuxinlianContract is ERC20Token, Owned{ string public constant standard = ; string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 6; uint256 private constant etherChange = 10**18; uint256 public totalSupply; uint256 public totalRemainSupply; uint256 public CXLExchangeRate; bool public crowdsaleIsOpen; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; address public multisigAddress; event mintToken(address indexed _to, uint256 _value); event burnToken(address indexed _from, uint256 _value); function () payable public { require (crowdsaleIsOpen == true); require(msg.value != 0); mintCXLToken(msg.sender, (msg.value * CXLExchangeRate * 10**decimals) / etherChange); }",1
0x268f03c41d3f33a697eed9c7f0632053556fae9e.sol,BountyClaims,"contract BountyClaims is Ownable { using SafeMath for uint256; ERC20 public token; address public wallet; mapping(address => uint256) bountyTokens; event Claim( address indexed beneficiary, uint256 amount ); function BountyClaims( ERC20 _token, address _wallet) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; }",1
0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8.sol,DragonLifeChain,"contract DragonLifeChain is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; }",1
0xf093b8cc623ca76d2743f47ac1da6eeda24b040a.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0x85924fdcccb75c47c3d2155ae0a519018164cac0.sol,StandardToken,"contract StandardToken is TelomereCoin { function transfer(address _to, uint256 _value) returns (bool success) { require(allowTransfer); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,SafeMath,None,1
0xdeec3ec3d942a50f77d9e4d6912a008a2bede2b3.sol,StandardToken,contract StandardToken is Token { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; },1
0x39e743fee400a5d9b36f1167b70c10e8f06440e5.sol,TNCGroupToken,"contract TNCGroupToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string memory tokenName, string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0x543e9c99addfc7c6fa158359019fd8f530334396.sol,EPCToken,"contract EPCToken is ERC20, Math, owned { string public name; string public symbol; uint8 public decimals = 18; string public version; event Reward(address indexed _to, uint256 _value); event MintToken(address indexed _to, uint256 _value); event Burn(address indexed _to, uint256 _value); function EPCToken( string _name, string _symbol, string _version ) public { name = _name; symbol = _symbol; version = _version; }",1
0xa42c5aa9735eca0db714f02de9dc2a56e405dae7.sol,BCT,contract BCT is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 minBalanceForAccounts; bool public usersCanTrade; bool public usersCanUnfreeze; bool public ico = true; mapping (address => bool) public admin; modifier notICO { require(admin[msg.sender] || !ico); _; },1
0x1cbd39b61919b41e22b1eb8bc564e67cae7376b9.sol,AirdropContract,contract AirdropContract { address public owner; FrescoToken token; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xb3a9d2e554c653b7712753c0e8616cca20b14c56.sol,HaiWang,"contract HaiWang { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HaiWang(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",1
0xee9908222b061ab6aa632b6c4f45d21c5aa6f08c.sol,Dogecointoken,contract Dogecointoken is ERC20 { address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply = 100000000000000000000000000000; function name() public constant returns (string) { return ; },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,SafeMath,"contract SafeMath { uint constant DAY_IN_SECONDS = 86400; uint constant BASE = 1000000000000000000; uint constant preIcoPrice = 4101; uint constant icoPrice = 2255; function mul(uint256 a, uint256 b) constant internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; }",1
0x07b2f3fbfda96208704e14068a50144f2ec6a37c.sol,Evocoin,contract Evocoin{ string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 5; uint public constant totalSupply = 7500000000*10**5; uint userIndex = 0; address public constant owner = 0x34A4933de38bF3830C7848aBb182d553F5a5D523; struct user{ address _adress; uint _value; },1
0x0838524d3ba16e7f9433ab7f914847f1d38b53e8.sol,RTDAirDrop,"contract RTDAirDrop is owned { address public token_address; string public detail; string public website; event AirDropCoin(address target, uint256 amount); constructor() public { owner = msg.sender; }",1
0x2aaefbac989f8951436c36474c304af7bf31bb26.sol,Broker,"contract Broker is Administration { event BrokerRegistered(uint indexed brokerId, address indexed broker); event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker); event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId); event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share); event BrokerFeeClaim(address indexed broker, uint indexed fee); mapping (uint => address[]) BrokerIdToBrokers; mapping (uint => uint) BrokerIdToSpots; mapping (address => uint) BrokerIncoming; mapping (address => bool) UserToIfBroker; uint public vipBrokerFee = 5 ether; uint public brokerFee = 1.5 ether; uint public vipBrokerNum = 1000; uint public subBrokerNum = 5; function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal { address vipBroker = getBrokerAddress(_brokerId, 0); address broker = getBrokerAddress(_brokerId, _subBrokerId); require(vipBroker != address(0) && broker != address(0)); uint totalShare = _price*rewardPercent[_type]/100; BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100; BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100; emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100); }",1
0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5.sol,DYLC_ERC20Token,"contract DYLC_ERC20Token { address public owner; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public totalSupply = 5000000000 * (10**18); uint256 public currentSupply = 0; uint256 public angelTime = 1522395000; uint256 public privateTime = 1523777400; uint256 public firstTime = 1525073400; uint256 public secondTime = 1526369400; uint256 public thirdTime = 1527665400; uint256 public endTime = 1529047800; uint256 public constant earlyExchangeRate = 83054; uint256 public constant baseExchangeRate = 55369; uint8 public constant rewardAngel = 20; uint8 public constant rewardPrivate = 20; uint8 public constant rewardOne = 15; uint8 public constant rewardTwo = 10; uint8 public constant rewardThree = 5; uint256 public constant CROWD_SUPPLY = 550000000 * (10**18); uint256 public constant DEVELOPER_RESERVED = 4450000000 * (10**18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x6f945c83f9ddc4ebd9cad21e7c08cc3c82a21c90.sol,MidnightRun,contract MidnightRun is Ownable { using SafeMath for uint; modifier isHuman() { uint32 size; address investor = msg.sender; assembly { size: = extcodesize(investor) },1
0x72a2384d0920b6c46f97ebe4c23c092acce485ac.sol,EIP20,"contract EIP20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); }",1
0xed2192afa8c062dfd6883759380b7f2d1dc6c0c0.sol,WedIndex,contract WedIndex is Owned { string public wedaddress; string public partnernames; uint public indexdate; uint public weddingdate; uint public displaymultisig; IndexArray[] public indexarray; struct IndexArray { uint indexdate; string wedaddress; string partnernames; uint weddingdate; uint displaymultisig; },1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTToken,"contract EPTToken is BasicToken { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 18; uint256 public initialSupply = 64000000 * 10**18; uint256 public totalAllocatedTokens; uint256 public tokensAllocatedToCrowdFund; uint256 public foundersAllocation; address public founderMultiSigAddress; address public crowdFundAddress; event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier nonZeroAddress(address _to){ require(_to != 0x0); _; }",1
0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1.sol,Crowdsale,"contract Crowdsale is owned { address public beneficiary; uint256 public preICOLimit; uint256 public totalLimit; uint256 public pricePreICO; uint256 public priceICO; bool preICOClosed = false; bool ICOClosed = false; bool preICOWithdrawn = false; bool ICOWithdrawn = false; bool public preICOActive = false; bool public ICOActive = false; uint256 public preICORaised; uint256 public ICORaised; uint256 public totalRaised; token public tokenReward; event FundTransfer(address backer, uint256 amount, bool isContribution); mapping(address => uint256) public balanceOf; function Crowdsale() { preICOLimit = 5000000 * 1 ether; totalLimit = 45000000 * 1 ether; pricePreICO = 375; priceICO = 250; }",1
0x0ed2cefc445825dcdf2fddf3c7f06f64783b6f60.sol,StandardToken,"contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; }",1
0x405b17cc0f4e6e30648637a8e052d9a8c35def89.sol,BlueOceanCompetitionContract,"contract BlueOceanCompetitionContract is ERC20 { using SafeMath for uint256; address owner1 = msg.sender; address owner2; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) times; mapping (address => mapping (uint256 => uint256)) dorpnum; mapping (address => mapping (uint256 => uint256)) dorptime; mapping (address => mapping (uint256 => uint256)) freeday; mapping (address => bool) public frozenAccount; mapping (address => bool) public airlist; string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 _Rate = 10 ** decimals; uint256 public totalSupply = 2000000000 * _Rate; uint256 public totalDistributed = 0; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 200 * _Rate; uint256 public _per = 1; bool public distributionClosed = true; bool key; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event FrozenFunds(address target, bool frozen); event Distr(address indexed to, uint256 amount); event DistrClosed(bool Closed); modifier onlyOwner() { require(msg.sender == owner1 || msg.sender == owner2); _; }",1
0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c.sol,DiscToken,"contract DiscToken is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function DiscToken() public { symbol = ; name = ; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x385C03042276635b92a347D666d7A2e19862Bb98] = _totalSupply; Transfer(address(0), 0x385C03042276635b92a347D666d7A2e19862Bb98, _totalSupply); }",1
0x2a062a343b53bb8fcee929d50f14ce4b418f455b.sol,StandardToken,"contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; }",1
